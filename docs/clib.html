<head>
<title> Open Watcom 1.9 C Library Reference </title>
</head>
<body>
<h1 id="Index_of_Topics"> Index of Topics </h1>
<dl>
<dt>- A -
<dd><a href="#abort">abort</a>
<br><a href="#The_abort_Function">The abort Function</a>
<br><a href="#abort_handler_s">abort_handler_s</a>
<br><a href="#abs">abs</a>
<br><a href="#access">access, _access, _waccess</a>
<br><a href="#acos">acos</a>
<br><a href="#acosh">acosh</a>
<br><a href="#alloca">alloca</a>
<br><a href="#Allocating_Zero_Memory">Allocating Zero Memory</a>
<br><a href="#Analyze_Functions">Analyze Functions</a>
<br><a href="#_arc">_arc, _arc_w, _arc_wxy</a>
<br><a href="#asctime">asctime Functions</a>
<br><a href="#asctime_s">asctime_s, _wasctime_s</a>
<br><a href="#asin">asin</a>
<br><a href="#asinh">asinh</a>
<br><a href="#assert">assert</a>
<br><a href="#atan">atan</a>
<br><a href="#atan2">atan2</a>
<br><a href="#atanh">atanh</a>
<br><a href="#atexit">atexit</a>
<br><a href="#The_atexit_Function">The atexit Function</a>
<br><a href="#atof">atof, _wtof</a>
<br><a href="#atoi">atoi, _wtoi</a>
<br><a href="#atol">atol, _wtol</a>
<br><a href="#atoll">atoll, _wtoll</a>
<br><a href="#_atouni">_atouni</a>
<br><a href="#Attribute_Functions">Attribute Functions</a>
<dt><br>- B -
<dd><a href="#basename">basename</a>
<br><a href="#bcmp">bcmp</a>
<br><a href="#bcopy">bcopy</a>
<br><a href="#bdos">bdos</a>
<br><a href="#_beginthread">_beginthread, _beginthreadex</a>
<br><a href="#bessel">bessel Functions</a>
<br><a href="#_bfreeseg">_bfreeseg</a>
<br><a href="#_bgetcmd">_bgetcmd</a>
<br><a href="#_bheapseg">_bheapseg</a>
<br><a href="#BIOS_Functions">BIOS Functions</a>
<br><a href="#_bios_disk">_bios_disk</a>
<br><a href="#_bios_equiplist">_bios_equiplist</a>
<br><a href="#_bios_keybrd">_bios_keybrd</a>
<br><a href="#_bios_memsize">_bios_memsize</a>
<br><a href="#_bios_printer">_bios_printer</a>
<br><a href="#_bios_serialcom">_bios_serialcom</a>
<br><a href="#_bios_timeofday">_bios_timeofday</a>
<br><a href="#_bprintf">_bprintf, _bwprintf</a>
<br><a href="#break___">break...&nbsp; Functions</a>
<br><a href="#bsearch">bsearch</a>
<br><a href="#bsearch_s">bsearch_s</a>
<br><a href="#btowc">btowc</a>
<br><a href="#bzero">bzero</a>
<dt><br>- C -
<dd><a href="#C_Library_Overview">C Library Overview</a>
<br><a href="#cabs">cabs</a>
<br><a href="#calloc">calloc Functions</a>
<br><a href="#ceil">ceil</a>
<br><a href="#cgets">cgets</a>
<br><a href="#_chain_intr">_chain_intr</a>
<br><a href="#Character_Manipulation_Functions">Character Manipulation Functions</a>
<br><a href="#Character_Testing">Character Testing</a>
<br><a href="#chdir">chdir, _chdir, _wchdir</a>
<br><a href="#_chdrive">_chdrive</a>
<br><a href="#chmod">chmod, _chmod, _wchmod</a>
<br><a href="#chsize">chsize, _chsize</a>
<br><a href="#Classes_of_Functions">Classes of Functions</a>
<br><a href="#Classes_of_Graphics_Functions">Classes of Graphics Functions</a>
<br><a href="#_clear87">_clear87</a>
<br><a href="#clearenv">clearenv</a>
<br><a href="#clearerr">clearerr</a>
<br><a href="#_clearscreen">_clearscreen</a>
<br><a href="#clock">clock</a>
<br><a href="#The_clock_Function">The clock Function</a>
<br><a href="#close">close, _close</a>
<br><a href="#closedir">closedir, _wclosedir</a>
<br><a href="#_cmdname">_cmdname</a>
<br><a href="#_commit">_commit</a>
<br><a href="#Console_IDO_Functions">Console I/O Functions</a>
<br><a href="#_control87">_control87</a>
<br><a href="#_controlfp">_controlfp</a>
<br><a href="#Conversion_Functions">Conversion Functions</a>
<br><a href="#Coordinate_System_Functions">Coordinate System Functions</a>
<br><a href="#cos">cos</a>
<br><a href="#cosh">cosh</a>
<br><a href="#cprintf">cprintf</a>
<br><a href="#cputs">cputs</a>
<br><a href="#creat">creat, _creat, _wcreat</a>
<br><a href="#cscanf">cscanf</a>
<br><a href="#ctime">ctime Functions</a>
<br><a href="#ctime_s">ctime_s, _wctime_s</a>
<br><a href="#cwait">cwait</a>
<dt><br>- D -
<dd><a href="#Default_Signals">Default Signals</a>
<br><a href="#Default_Windowing_Functions">Default Windowing Functions</a>
<br><a href="#delay">delay</a>
<br><a href="#Deleting_Open_Files">Deleting Open Files</a>
<br><a href="#Diagnostic_Printed_by_the_assert_Function">Diagnostic Printed by the assert Function</a>
<br><a href="#_dieeetomsbin">_dieeetomsbin</a>
<br><a href="#difftime">difftime</a>
<br><a href="#Directory_Functions">Directory Functions</a>
<br><a href="#dirname">dirname</a>
<br><a href="#_disable">_disable</a>
<br><a href="#Display_Functions">Display Functions</a>
<br><a href="#_displaycursor">_displaycursor</a>
<br><a href="#div">div</a>
<br><a href="#_dmsbintoieee">_dmsbintoieee</a>
<br><a href="#Domain_Errors">Domain Errors</a>
<br><a href="#DOS_Commands">DOS Commands</a>
<br><a href="#DOS_Considerations">DOS Considerations</a>
<br><a href="#DOS_Devices">DOS Devices</a>
<br><a href="#DOS_Directories">DOS Directories</a>
<br><a href="#DOS_File_Names">DOS File Names</a>
<br><a href="#DOS_Files">DOS Files</a>
<br><a href="#DOS_Interrupts">DOS Interrupts</a>
<br><a href="#DOS_LFN_aware_Functions">DOS LFN aware Functions</a>
<br><a href="#DOS_Processes">DOS Processes</a>
<br><a href="#DOSMSpecific_Functions">DOS-Specific Functions</a>
<br><a href="#_dos_allocmem">_dos_allocmem</a>
<br><a href="#_dos_close">_dos_close</a>
<br><a href="#_dos_commit">_dos_commit</a>
<br><a href="#_dos_creat">_dos_creat</a>
<br><a href="#_dos_creatnew">_dos_creatnew</a>
<br><a href="#_dos_find___">_dos_find...&nbsp; Functions</a>
<br><a href="#_dos_freemem">_dos_freemem</a>
<br><a href="#_dos_getdate">_dos_getdate</a>
<br><a href="#_dos_getdiskfree">_dos_getdiskfree</a>
<br><a href="#_dos_getdrive">_dos_getdrive</a>
<br><a href="#_dos_getfileattr">_dos_getfileattr</a>
<br><a href="#_dos_getftime">_dos_getftime</a>
<br><a href="#_dos_gettime">_dos_gettime</a>
<br><a href="#_dos_getvect">_dos_getvect</a>
<br><a href="#_dos_keep">_dos_keep</a>
<br><a href="#_dos_open">_dos_open</a>
<br><a href="#_dos_read">_dos_read</a>
<br><a href="#_dos_setblock">_dos_setblock</a>
<br><a href="#_dos_setdate">_dos_setdate</a>
<br><a href="#_dos_setdrive">_dos_setdrive</a>
<br><a href="#_dos_setfileattr">_dos_setfileattr</a>
<br><a href="#_dos_setftime">_dos_setftime</a>
<br><a href="#_dos_settime">_dos_settime</a>
<br><a href="#_dos_setvect">_dos_setvect</a>
<br><a href="#_dos_write">_dos_write</a>
<br><a href="#dosexterr">dosexterr</a>
<br><a href="#Drawing_Functions">Drawing Functions</a>
<br><a href="#dup">dup, _dup</a>
<br><a href="#dup2">dup2, _dup2</a>
<br><a href="#_dwDeleteOnClose">_dwDeleteOnClose</a>
<br><a href="#_dwSetAboutDlg">_dwSetAboutDlg</a>
<br><a href="#_dwSetAppTitle">_dwSetAppTitle</a>
<br><a href="#_dwSetConTitle">_dwSetConTitle</a>
<br><a href="#_dwShutDown">_dwShutDown</a>
<br><a href="#_dwYield">_dwYield</a>
<dt><br>- E -
<dd><a href="#ecvt">ecvt, _ecvt, _wecvt</a>
<br><a href="#_ellipse">_ellipse, _ellipse_w, _ellipse_wxy</a>
<br><a href="#_enable">_enable</a>
<br><a href="#_endthread">_endthread, _endthreadex</a>
<br><a href="#Environment_Functions">Environment Functions</a>
<br><a href="#Environment_Names">Environment Names</a>
<br><a href="#eof">eof, _eof</a>
<br><a href="#exec___">exec...&nbsp; Functions</a>
<br><a href="#exit">exit</a>
<br><a href="#_exit">_exit, _Exit</a>
<br><a href="#exp">exp</a>
<br><a href="#_expand">_expand Functions</a>
<dt><br>- F -
<dd><a href="#fabs">fabs</a>
<br><a href="#fclose">fclose</a>
<br><a href="#fcloseall">fcloseall</a>
<br><a href="#fcvt">fcvt, _fcvt, _wfcvt</a>
<br><a href="#fdopen">fdopen, _fdopen, _wfdopen</a>
<br><a href="#feclearexcept">feclearexcept</a>
<br><a href="#__fedisableexcept">__fedisableexcept</a>
<br><a href="#__feenableexcept">__feenableexcept</a>
<br><a href="#fegetenv">fegetenv</a>
<br><a href="#fegetexceptflag">fegetexceptflag</a>
<br><a href="#fegetround">fegetround</a>
<br><a href="#feholdexcept">feholdexcept</a>
<br><a href="#feof">feof</a>
<br><a href="#feraiseexcept">feraiseexcept</a>
<br><a href="#ferror">ferror</a>
<br><a href="#fesetenv">fesetenv</a>
<br><a href="#fesetexceptflag">fesetexceptflag</a>
<br><a href="#fesetround">fesetround</a>
<br><a href="#fetestexcept">fetestexcept</a>
<br><a href="#feupdateenv">feupdateenv</a>
<br><a href="#fflush">fflush</a>
<br><a href="#ffs">ffs</a>
<br><a href="#fgetc">fgetc, fgetwc</a>
<br><a href="#fgetchar">fgetchar, _fgetchar, _fgetwchar</a>
<br><a href="#fgetpos">fgetpos</a>
<br><a href="#fgets">fgets, fgetws</a>
<br><a href="#_fieeetomsbin">_fieeetomsbin</a>
<br><a href="#File_Access_Limits">File Access Limits</a>
<br><a href="#File_Buffering">File Buffering</a>
<br><a href="#File_Manipulation_Functions">File Manipulation Functions</a>
<br><a href="#File_Names">File Names</a>
<br><a href="#File_Position_Errors">File Position Errors</a>
<br><a href="#File_Position_in_Append_Mode">File Position in Append Mode</a>
<br><a href="#filelength">filelength, _filelength, _filelengthi64</a>
<br><a href="#FILENAME_MAX">FILENAME_MAX</a>
<br><a href="#fileno">fileno</a>
<br><a href="#_findclose">_findclose</a>
<br><a href="#_findfirst">_findfirst, _findfirsti64, _wfindfirst, _wfindfirsti64</a>
<br><a href="#_findnext">_findnext, _findnexti64, _wfindnext, _wfindnexti64</a>
<br><a href="#_finite">_finite</a>
<br><a href="#_floodfill">_floodfill, _floodfill_w</a>
<br><a href="#floor">floor</a>
<br><a href="#flushall">flushall</a>
<br><a href="#fmod">fmod</a>
<br><a href="#The_fmod_Function">The fmod Function</a>
<br><a href="#_fmsbintoieee">_fmsbintoieee</a>
<br><a href="#fnmatch">fnmatch</a>
<br><a href="#Font_Manipulation_Functions">Font Manipulation Functions</a>
<br><a href="#fopen">fopen, _wfopen</a>
<br><a href="#fopen_s">fopen_s, _wfopen_s</a>
<br><a href="#FP_OFF">FP_OFF</a>
<br><a href="#FP_SEG">FP_SEG</a>
<br><a href="#fpclassify">fpclassify</a>
<br><a href="#_fpreset">_fpreset</a>
<br><a href="#fprintf">fprintf, fwprintf</a>
<br><a href="#fprintf_s">fprintf_s, fwprintf_s</a>
<br><a href="#fputc">fputc, fputwc</a>
<br><a href="#fputchar">fputchar, _fputchar, _fputwchar</a>
<br><a href="#fputs">fputs, fputws</a>
<br><a href="#fread">fread</a>
<br><a href="#free">free Functions</a>
<br><a href="#_freect">_freect</a>
<br><a href="#freopen">freopen, _wfreopen</a>
<br><a href="#freopen_s">freopen_s, _wfreopen_s</a>
<br><a href="#frexp">frexp</a>
<br><a href="#fscanf">fscanf, fwscanf</a>
<br><a href="#fscanf_s">fscanf_s, fwscanf_s</a>
<br><a href="#fseek">fseek</a>
<br><a href="#fsetpos">fsetpos</a>
<br><a href="#_fsopen">_fsopen, _wfsopen</a>
<br><a href="#fstat">fstat, _fstat, _fstati64, _wfstat, _wfstati64</a>
<br><a href="#fsync">fsync</a>
<br><a href="#ftell">ftell</a>
<br><a href="#ftime">ftime</a>
<br><a href="#_fullpath">_fullpath, _wfullpath</a>
<br><a href="#fwide">fwide</a>
<br><a href="#fwrite">fwrite</a>
<dt><br>- G -
<dd><a href="#gcvt">gcvt, _gcvt, _wgcvt</a>
<br><a href="#_get_osfhandle">_get_osfhandle</a>
<br><a href="#_getactivepage">_getactivepage</a>
<br><a href="#_getarcinfo">_getarcinfo</a>
<br><a href="#_getbkcolor">_getbkcolor</a>
<br><a href="#getc">getc, getwc</a>
<br><a href="#getch">getch</a>
<br><a href="#getchar">getchar, getwchar</a>
<br><a href="#getche">getche</a>
<br><a href="#_getcliprgn">_getcliprgn</a>
<br><a href="#getcmd">getcmd</a>
<br><a href="#_getcolor">_getcolor</a>
<br><a href="#_getcurrentposition">_getcurrentposition, _getcurrentposition_w</a>
<br><a href="#getcwd">getcwd, _wgetcwd</a>
<br><a href="#_getdcwd">_getdcwd, _wgetdcwd</a>
<br><a href="#_getdiskfree">_getdiskfree</a>
<br><a href="#_getdrive">_getdrive</a>
<br><a href="#getenv">getenv, _wgetenv</a>
<br><a href="#getenv_s">getenv_s</a>
<br><a href="#_getfillmask">_getfillmask</a>
<br><a href="#_getfontinfo">_getfontinfo</a>
<br><a href="#_getgtextextent">_getgtextextent</a>
<br><a href="#_getgtextvector">_getgtextvector</a>
<br><a href="#_getimage">_getimage, _getimage_w, _getimage_wxy</a>
<br><a href="#_getlinestyle">_getlinestyle</a>
<br><a href="#_getmbcp">_getmbcp</a>
<br><a href="#getopt">getopt</a>
<br><a href="#_getphyscoord">_getphyscoord</a>
<br><a href="#getpid">getpid</a>
<br><a href="#_getpixel">_getpixel, _getpixel_w</a>
<br><a href="#_getplotaction">_getplotaction</a>
<br><a href="#gets">gets, _getws</a>
<br><a href="#gets_s">gets_s</a>
<br><a href="#_gettextcolor">_gettextcolor</a>
<br><a href="#_gettextcursor">_gettextcursor</a>
<br><a href="#_gettextextent">_gettextextent</a>
<br><a href="#_gettextposition">_gettextposition</a>
<br><a href="#_gettextsettings">_gettextsettings</a>
<br><a href="#_gettextwindow">_gettextwindow</a>
<br><a href="#_getvideoconfig">_getvideoconfig</a>
<br><a href="#_getviewcoord">_getviewcoord, _getviewcoord_w, _getviewcoord_wxy</a>
<br><a href="#_getvisualpage">_getvisualpage</a>
<br><a href="#_getw">_getw</a>
<br><a href="#_getwindowcoord">_getwindowcoord</a>
<br><a href="#Global_Data">Global Data</a>
<br><a href="#gmtime">gmtime Functions</a>
<br><a href="#gmtime_s">gmtime_s</a>
<br><a href="#Graphics_Adapters">Graphics Adapters</a>
<br><a href="#Graphics_Functions">Graphics Functions</a>
<br><a href="#Graphics_Header_Files">Graphics Header Files</a>
<br><a href="#Graphics_Library">Graphics Library</a>
<br><a href="#Graphics_Text_Functions">Graphics Text Functions</a>
<br><a href="#_grow_handles">_grow_handles</a>
<br><a href="#_grstatus">_grstatus</a>
<br><a href="#_grtext">_grtext, _grtext_w</a>
<dt><br>- H -
<dd><a href="#halloc">halloc</a>
<br><a href="#_harderr">_harderr, _hardresume, _hardretn</a>
<br><a href="#_hdopen">_hdopen</a>
<br><a href="#Header_Files">Header Files</a>
<br><a href="#Header_Files_in_DwatcomDh">Header Files in /watcom/h</a>
<br><a href="#Header_Files_in_DwatcomDhDsys">Header Files in /watcom/h/sys</a>
<br><a href="#Heap_Functions">Heap Functions</a>
<br><a href="#_heapchk">_heapchk Functions</a>
<br><a href="#_heapenable">_heapenable</a>
<br><a href="#_heapgrow">_heapgrow Functions</a>
<br><a href="#_heapmin">_heapmin Functions</a>
<br><a href="#_heapset">_heapset Functions</a>
<br><a href="#_heapshrink">_heapshrink Functions</a>
<br><a href="#_heapwalk">_heapwalk Functions</a>
<br><a href="#hfree">hfree</a>
<br><a href="#hypot">hypot</a>
<dt><br>- I -
<dd><a href="#ignore_handler_s">ignore_handler_s</a>
<br><a href="#Image_Manipulation_Functions">Image Manipulation Functions</a>
<br><a href="#_imagesize">_imagesize, _imagesize_w, _imagesize_wxy</a>
<br><a href="#imaxabs">imaxabs</a>
<br><a href="#imaxdiv">imaxdiv</a>
<br><a href="#ImplementationMDefined_Behavior_of_the_C_Library">Implementation-Defined Behavior of the C Library</a>
<br><a href="#inp">inp</a>
<br><a href="#inpd">inpd</a>
<br><a href="#inpw">inpw</a>
<br><a href="#int386">int386</a>
<br><a href="#int386x">int386x</a>
<br><a href="#int86">int86</a>
<br><a href="#int86x">int86x</a>
<br><a href="#intdos">intdos</a>
<br><a href="#intdosx">intdosx</a>
<br><a href="#Intel_80x86_ArchitectureMSpecific_Functions">Intel 80x86 Architecture-Specific Functions</a>
<br><a href="#Intel_Pentium_Multimedia_Extension_Functions">Intel Pentium Multimedia Extension Functions</a>
<br><a href="#intr">intr</a>
<br><a href="#isalnum">isalnum, iswalnum</a>
<br><a href="#isalpha">isalpha, iswalpha</a>
<br><a href="#isascii">isascii, __isascii, iswascii</a>
<br><a href="#isatty">isatty, _isatty</a>
<br><a href="#isblank">isblank, iswblank</a>
<br><a href="#iscntrl">iscntrl, iswcntrl</a>
<br><a href="#iscsym">iscsym, __iscsym, __iswcsym</a>
<br><a href="#iscsymf">iscsymf, __iscsymf, __iswcsymf</a>
<br><a href="#isdigit">isdigit, iswdigit</a>
<br><a href="#isfinite">isfinite</a>
<br><a href="#isgraph">isgraph, iswgraph</a>
<br><a href="#isinf">isinf</a>
<br><a href="#isleadbyte">isleadbyte</a>
<br><a href="#islower">islower, iswlower</a>
<br><a href="#_ismbbalnum">_ismbbalnum</a>
<br><a href="#_ismbbalpha">_ismbbalpha</a>
<br><a href="#_ismbbgraph">_ismbbgraph</a>
<br><a href="#_ismbbkalnum">_ismbbkalnum</a>
<br><a href="#_ismbbkalpha">_ismbbkalpha</a>
<br><a href="#_ismbbkana">_ismbbkana</a>
<br><a href="#_ismbbkprint">_ismbbkprint</a>
<br><a href="#_ismbbkpunct">_ismbbkpunct</a>
<br><a href="#_ismbblead">_ismbblead</a>
<br><a href="#_ismbbprint">_ismbbprint</a>
<br><a href="#_ismbbpunct">_ismbbpunct</a>
<br><a href="#_ismbbtrail">_ismbbtrail</a>
<br><a href="#_ismbcalnum">_ismbcalnum</a>
<br><a href="#_ismbcalpha">_ismbcalpha</a>
<br><a href="#_ismbccntrl">_ismbccntrl</a>
<br><a href="#_ismbcdigit">_ismbcdigit</a>
<br><a href="#_ismbcgraph">_ismbcgraph</a>
<br><a href="#_ismbchira">_ismbchira</a>
<br><a href="#_ismbckata">_ismbckata</a>
<br><a href="#_ismbcl0">_ismbcl0</a>
<br><a href="#_ismbcl1">_ismbcl1</a>
<br><a href="#_ismbcl2">_ismbcl2</a>
<br><a href="#_ismbclegal">_ismbclegal</a>
<br><a href="#_ismbclower">_ismbclower</a>
<br><a href="#_ismbcprint">_ismbcprint</a>
<br><a href="#_ismbcpunct">_ismbcpunct</a>
<br><a href="#_ismbcspace">_ismbcspace</a>
<br><a href="#_ismbcsymbol">_ismbcsymbol</a>
<br><a href="#_ismbcupper">_ismbcupper</a>
<br><a href="#_ismbcxdigit">_ismbcxdigit</a>
<br><a href="#isnan">isnan</a>
<br><a href="#isnormal">isnormal</a>
<br><a href="#isprint">isprint, iswprint</a>
<br><a href="#ispunct">ispunct, iswpunct</a>
<br><a href="#isspace">isspace, iswspace</a>
<br><a href="#isupper">isupper, iswupper</a>
<br><a href="#iswctype">iswctype</a>
<br><a href="#isxdigit">isxdigit, iswxdigit</a>
<br><a href="#itoa">itoa, _itoa, _itow</a>
<dt><br>- K -
<dd><a href="#kbhit">kbhit, _kbhit</a>
<dt><br>- L -
<dd><a href="#labs">labs</a>
<br><a href="#ldexp">ldexp</a>
<br><a href="#ldiv">ldiv</a>
<br><a href="#lfind">lfind</a>
<br><a href="#Library_Functions_and_Macros">Library Functions and Macros</a>
<br><a href="#_lineto">_lineto, _lineto_w</a>
<br><a href="#llabs">llabs</a>
<br><a href="#lldiv">lldiv</a>
<br><a href="#lltoa">lltoa, _lltoa, _lltow</a>
<br><a href="#localeconv">localeconv</a>
<br><a href="#localtime">localtime Functions</a>
<br><a href="#localtime_s">localtime_s</a>
<br><a href="#lock">lock</a>
<br><a href="#locking">locking, _locking</a>
<br><a href="#log">log</a>
<br><a href="#log10">log10</a>
<br><a href="#log2">log2</a>
<br><a href="#longjmp">longjmp</a>
<br><a href="#_lrotl">_lrotl</a>
<br><a href="#_lrotr">_lrotr</a>
<br><a href="#lsearch">lsearch</a>
<br><a href="#lseek">lseek, _lseek, _lseeki64</a>
<br><a href="#ltoa">ltoa, _ltoa, _ltow</a>
<dt><br>- M -
<dd><a href="#_m_empty">_m_empty</a>
<br><a href="#_m_from_int">_m_from_int</a>
<br><a href="#_m_packssdw">_m_packssdw</a>
<br><a href="#_m_packsswb">_m_packsswb</a>
<br><a href="#_m_packuswb">_m_packuswb</a>
<br><a href="#_m_paddb">_m_paddb</a>
<br><a href="#_m_paddd">_m_paddd</a>
<br><a href="#_m_paddsb">_m_paddsb</a>
<br><a href="#_m_paddsw">_m_paddsw</a>
<br><a href="#_m_paddusb">_m_paddusb</a>
<br><a href="#_m_paddusw">_m_paddusw</a>
<br><a href="#_m_paddw">_m_paddw</a>
<br><a href="#_m_pand">_m_pand</a>
<br><a href="#_m_pandn">_m_pandn</a>
<br><a href="#_m_pcmpeqb">_m_pcmpeqb</a>
<br><a href="#_m_pcmpeqd">_m_pcmpeqd</a>
<br><a href="#_m_pcmpeqw">_m_pcmpeqw</a>
<br><a href="#_m_pcmpgtb">_m_pcmpgtb</a>
<br><a href="#_m_pcmpgtd">_m_pcmpgtd</a>
<br><a href="#_m_pcmpgtw">_m_pcmpgtw</a>
<br><a href="#_m_pmaddwd">_m_pmaddwd</a>
<br><a href="#_m_pmulhw">_m_pmulhw</a>
<br><a href="#_m_pmullw">_m_pmullw</a>
<br><a href="#_m_por">_m_por</a>
<br><a href="#_m_pslld">_m_pslld</a>
<br><a href="#_m_pslldi">_m_pslldi</a>
<br><a href="#_m_psllq">_m_psllq</a>
<br><a href="#_m_psllqi">_m_psllqi</a>
<br><a href="#_m_psllw">_m_psllw</a>
<br><a href="#_m_psllwi">_m_psllwi</a>
<br><a href="#_m_psrad">_m_psrad</a>
<br><a href="#_m_psradi">_m_psradi</a>
<br><a href="#_m_psraw">_m_psraw</a>
<br><a href="#_m_psrawi">_m_psrawi</a>
<br><a href="#_m_psrld">_m_psrld</a>
<br><a href="#_m_psrldi">_m_psrldi</a>
<br><a href="#_m_psrlq">_m_psrlq</a>
<br><a href="#_m_psrlqi">_m_psrlqi</a>
<br><a href="#_m_psrlw">_m_psrlw</a>
<br><a href="#_m_psrlwi">_m_psrlwi</a>
<br><a href="#_m_psubb">_m_psubb</a>
<br><a href="#_m_psubd">_m_psubd</a>
<br><a href="#_m_psubsb">_m_psubsb</a>
<br><a href="#_m_psubsw">_m_psubsw</a>
<br><a href="#_m_psubusb">_m_psubusb</a>
<br><a href="#_m_psubusw">_m_psubusw</a>
<br><a href="#_m_psubw">_m_psubw</a>
<br><a href="#_m_punpckhbw">_m_punpckhbw</a>
<br><a href="#_m_punpckhdq">_m_punpckhdq</a>
<br><a href="#_m_punpckhwd">_m_punpckhwd</a>
<br><a href="#_m_punpcklbw">_m_punpcklbw</a>
<br><a href="#_m_punpckldq">_m_punpckldq</a>
<br><a href="#_m_punpcklwd">_m_punpcklwd</a>
<br><a href="#_m_pxor">_m_pxor</a>
<br><a href="#_m_to_int">_m_to_int</a>
<br><a href="#main">main, wmain, WinMain, wWinMain</a>
<br><a href="#_makepath">_makepath, _wmakepath</a>
<br><a href="#malloc">malloc Functions</a>
<br><a href="#Math_Functions">Math Functions</a>
<br><a href="#matherr">matherr</a>
<br><a href="#max">max</a>
<br><a href="#_mbbtombc">_mbbtombc</a>
<br><a href="#_mbbtype">_mbbtype</a>
<br><a href="#_mbccmp">_mbccmp, _fmbccmp</a>
<br><a href="#_mbccpy">_mbccpy, _fmbccpy</a>
<br><a href="#_mbcicmp">_mbcicmp, _fmbcicmp</a>
<br><a href="#_mbcjistojms">_mbcjistojms</a>
<br><a href="#_mbcjmstojis">_mbcjmstojis</a>
<br><a href="#_mbclen">_mbclen, _fmbclen</a>
<br><a href="#_mbctohira">_mbctohira</a>
<br><a href="#_mbctokata">_mbctokata</a>
<br><a href="#_mbctolower">_mbctolower</a>
<br><a href="#_mbctombb">_mbctombb</a>
<br><a href="#_mbctoupper">_mbctoupper</a>
<br><a href="#_mbgetcode">_mbgetcode, _fmbgetcode</a>
<br><a href="#mblen">mblen, _fmblen</a>
<br><a href="#_mbputchar">_mbputchar, _fmbputchar</a>
<br><a href="#mbrlen">mbrlen, _fmbrlen</a>
<br><a href="#mbrtowc">mbrtowc, _fmbrtowc</a>
<br><a href="#_mbsbtype">_mbsbtype, _fmbsbtype</a>
<br><a href="#mbsinit">mbsinit, sisinit</a>
<br><a href="#_mbsnbcat">_mbsnbcat, _fmbsnbcat</a>
<br><a href="#_mbsnbcmp">_mbsnbcmp, _fmbsnbcmp</a>
<br><a href="#_mbsnbcnt">_mbsnbcnt, _fmbsnbcnt, _strncnt, _wcsncnt</a>
<br><a href="#_mbsnbcpy">_mbsnbcpy, _fmbsnbcpy</a>
<br><a href="#_mbsnbicmp">_mbsnbicmp, _fmbsnbicmp</a>
<br><a href="#_mbsnbset">_mbsnbset, _fmbsnbset</a>
<br><a href="#_mbsnccnt">_mbsnccnt, _fmbsnccnt, _strncnt, _wcsncnt</a>
<br><a href="#_mbsnextc">_mbsnextc, _fmbsnextc, _strnextc, _wcsnextc</a>
<br><a href="#mbsrtowcs">mbsrtowcs, _fmbsrtowcs</a>
<br><a href="#mbsrtowcs_s">mbsrtowcs_s, _fmbsrtowcs_s</a>
<br><a href="#mbstowcs">mbstowcs, _fmbstowcs</a>
<br><a href="#mbstowcs_s">mbstowcs_s, _fmbstowcs_s</a>
<br><a href="#_mbterm">_mbterm, _fmbterm</a>
<br><a href="#mbtowc">mbtowc, _fmbtowc</a>
<br><a href="#_mbvtop">_mbvtop, _fmbvtop</a>
<br><a href="#_memavl">_memavl</a>
<br><a href="#memccpy">memccpy, _fmemccpy</a>
<br><a href="#memchr">memchr, _fmemchr, wmemchr</a>
<br><a href="#memcmp">memcmp, _fmemcmp, wmemcmp</a>
<br><a href="#memcpy">memcpy, _fmemcpy, wmemcpy</a>
<br><a href="#memcpy_s">memcpy_s, wmemcpy_s</a>
<br><a href="#memicmp">memicmp, _memicmp, _fmemicmp</a>
<br><a href="#_memmax">_memmax</a>
<br><a href="#memmove">memmove, _fmemmove, wmemmove</a>
<br><a href="#memmove_s">memmove_s, wmemmove_s</a>
<br><a href="#Memory_Allocation_Functions">Memory Allocation Functions</a>
<br><a href="#Memory_Manipulation_Functions">Memory Manipulation Functions</a>
<br><a href="#memset">memset, _fmemset, wmemset</a>
<br><a href="#Messages_Generated_by_the_perror_Function">Messages Generated by the perror Function</a>
<br><a href="#min">min</a>
<br><a href="#Miscellaneous_Functions">Miscellaneous Functions</a>
<br><a href="#MK_FP">MK_FP</a>
<br><a href="#mkdir">mkdir, _mkdir, _wmkdir</a>
<br><a href="#mkstemp">mkstemp</a>
<br><a href="#_mktemp">_mktemp, _wmktemp</a>
<br><a href="#mktime">mktime</a>
<br><a href="#modf">modf</a>
<br><a href="#movedata">movedata</a>
<br><a href="#_moveto">_moveto, _moveto_w</a>
<br><a href="#_msize">_msize Functions</a>
<br><a href="#Multibyte_Character_Manipulation_Functions">Multibyte Character Manipulation Functions</a>
<br><a href="#Multibyte_String_Manipulation_Functions">Multibyte String Manipulation Functions</a>
<dt><br>- N -
<dd><a href="#nosound">nosound</a>
<br><a href="#Null_Characters">Null Characters</a>
<br><a href="#NULL_Macro">NULL Macro</a>
<dt><br>- O -
<dd><a href="#offsetof">offsetof</a>
<br><a href="#onexit">onexit</a>
<br><a href="#open">open, _open, _wopen</a>
<br><a href="#_open_osfhandle">_open_osfhandle</a>
<br><a href="#opendir">opendir, _wopendir</a>
<br><a href="#Operating_System_IDO_Functions">Operating System I/O Functions</a>
<br><a href="#The_OSD2_TZ_Environment_Variable">The OS/2 TZ Environment Variable</a>
<br><a href="#_os_handle">_os_handle</a>
<br><a href="#_outgtext">_outgtext</a>
<br><a href="#_outmem">_outmem</a>
<br><a href="#outp">outp</a>
<br><a href="#outpd">outpd</a>
<br><a href="#outpw">outpw</a>
<br><a href="#_outtext">_outtext</a>
<dt><br>- P -
<dd><a href="#_pclose">_pclose</a>
<br><a href="#perror">perror, _wperror</a>
<br><a href="#_pg_analyzechart">_pg_analyzechart, _pg_analyzechartms</a>
<br><a href="#_pg_analyzepie">_pg_analyzepie</a>
<br><a href="#_pg_analyzescatter">_pg_analyzescatter, _pg_analyzescatterms</a>
<br><a href="#_pg_chart">_pg_chart, _pg_chartms</a>
<br><a href="#_pg_chartpie">_pg_chartpie</a>
<br><a href="#_pg_chartscatter">_pg_chartscatter, _pg_chartscatterms</a>
<br><a href="#_pg_defaultchart">_pg_defaultchart</a>
<br><a href="#_pg_getchardef">_pg_getchardef</a>
<br><a href="#_pg_getpalette">_pg_getpalette</a>
<br><a href="#_pg_getstyleset">_pg_getstyleset</a>
<br><a href="#_pg_hlabelchart">_pg_hlabelchart</a>
<br><a href="#_pg_initchart">_pg_initchart</a>
<br><a href="#_pg_resetpalette">_pg_resetpalette</a>
<br><a href="#_pg_resetstyleset">_pg_resetstyleset</a>
<br><a href="#_pg_setchardef">_pg_setchardef</a>
<br><a href="#_pg_setpalette">_pg_setpalette</a>
<br><a href="#_pg_setstyleset">_pg_setstyleset</a>
<br><a href="#_pg_vlabelchart">_pg_vlabelchart</a>
<br><a href="#_pie">_pie, _pie_w, _pie_wxy</a>
<br><a href="#_pipe">_pipe</a>
<br><a href="#_polygon">_polygon, _polygon_w, _polygon_wxy</a>
<br><a href="#_popen">_popen, _wpopen</a>
<br><a href="#pow">pow</a>
<br><a href="#Presentation_Graphics_Functions">Presentation Graphics Functions</a>
<br><a href="#printf">printf, wprintf</a>
<br><a href="#printf_s">printf_s, wprintf_s</a>
<br><a href="#Printing_Pointer_Values">Printing Pointer Values</a>
<br><a href="#Process_Environment">Process Environment</a>
<br><a href="#Process_Primitive_Functions">Process Primitive Functions</a>
<br><a href="#putc">putc, putwc</a>
<br><a href="#putch">putch</a>
<br><a href="#putchar">putchar, putwchar</a>
<br><a href="#putenv">putenv, _putenv, _wputenv</a>
<br><a href="#_putimage">_putimage, _putimage_w</a>
<br><a href="#puts">puts, _putws</a>
<br><a href="#_putw">_putw</a>
<dt><br>- Q -
<dd><a href="#qsort">qsort</a>
<br><a href="#qsort_s">qsort_s</a>
<dt><br>- R -
<dd><a href="#raise">raise</a>
<br><a href="#rand">rand</a>
<br><a href="#ReMentrant_Functions">Re-entrant Functions</a>
<br><a href="#read">read, _read</a>
<br><a href="#readdir">readdir, _wreaddir</a>
<br><a href="#Reading_Pointer_Values">Reading Pointer Values</a>
<br><a href="#Reading_Ranges">Reading Ranges</a>
<br><a href="#realloc">realloc Functions</a>
<br><a href="#_rectangle">_rectangle, _rectangle_w, _rectangle_wxy</a>
<br><a href="#_registerfonts">_registerfonts</a>
<br><a href="#_remapallpalette">_remapallpalette</a>
<br><a href="#_remappalette">_remappalette</a>
<br><a href="#remove">remove, _wremove</a>
<br><a href="#rename">rename, _wrename</a>
<br><a href="#Renaming_with_a_Name_that_Exists">Renaming with a Name that Exists</a>
<br><a href="#rewind">rewind</a>
<br><a href="#rewinddir">rewinddir, _wrewinddir</a>
<br><a href="#rmdir">rmdir, _rmdir, _wrmdir</a>
<br><a href="#_rotl">_rotl</a>
<br><a href="#_rotr">_rotr</a>
<dt><br>- S -
<dd><a href="#sbrk">sbrk</a>
<br><a href="#scanf">scanf, wscanf</a>
<br><a href="#scanf_s">scanf_s, wscanf_s</a>
<br><a href="#_scrolltextwindow">_scrolltextwindow</a>
<br><a href="#_searchenv">_searchenv, _wsearchenv</a>
<br><a href="#Searching_Functions">Searching Functions</a>
<br><a href="#segread">segread</a>
<br><a href="#_selectpalette">_selectpalette</a>
<br><a href="#set_constraint_handler_s">set_constraint_handler_s</a>
<br><a href="#_set_matherr">_set_matherr</a>
<br><a href="#set_new_handler">set_new_handler, _set_new_handler</a>
<br><a href="#_setactivepage">_setactivepage</a>
<br><a href="#_setbkcolor">_setbkcolor</a>
<br><a href="#setbuf">setbuf</a>
<br><a href="#_setcharsize">_setcharsize, _setcharsize_w</a>
<br><a href="#_setcharspacing">_setcharspacing, _setcharspacing_w</a>
<br><a href="#_setcliprgn">_setcliprgn</a>
<br><a href="#_setcolor">_setcolor</a>
<br><a href="#setenv">setenv, _setenv, _wsetenv</a>
<br><a href="#_setfillmask">_setfillmask</a>
<br><a href="#_setfont">_setfont</a>
<br><a href="#_setgtextvector">_setgtextvector</a>
<br><a href="#setjmp">setjmp</a>
<br><a href="#_setlinestyle">_setlinestyle</a>
<br><a href="#setlocale">setlocale, _wsetlocale</a>
<br><a href="#_setmbcp">_setmbcp</a>
<br><a href="#setmode">setmode, _setmode</a>
<br><a href="#_setpixel">_setpixel, _setpixel_w</a>
<br><a href="#_setplotaction">_setplotaction</a>
<br><a href="#_settextalign">_settextalign</a>
<br><a href="#_settextcolor">_settextcolor</a>
<br><a href="#_settextcursor">_settextcursor</a>
<br><a href="#_settextorient">_settextorient</a>
<br><a href="#_settextpath">_settextpath</a>
<br><a href="#_settextposition">_settextposition</a>
<br><a href="#_settextrows">_settextrows</a>
<br><a href="#_settextwindow">_settextwindow</a>
<br><a href="#setvbuf">setvbuf</a>
<br><a href="#_setvideomode">_setvideomode</a>
<br><a href="#_setvideomoderows">_setvideomoderows</a>
<br><a href="#_setvieworg">_setvieworg</a>
<br><a href="#_setviewport">_setviewport</a>
<br><a href="#_setvisualpage">_setvisualpage</a>
<br><a href="#_setwindow">_setwindow</a>
<br><a href="#The_SIGILL_Signal">The SIGILL Signal</a>
<br><a href="#signal">signal</a>
<br><a href="#The_signal_Function">The signal Function</a>
<br><a href="#signbit">signbit</a>
<br><a href="#sin">sin</a>
<br><a href="#sinh">sinh</a>
<br><a href="#sleep">sleep</a>
<br><a href="#_snprintf">_snprintf, _snwprintf</a>
<br><a href="#snprintf">snprintf, snwprintf</a>
<br><a href="#snprintf_s">snprintf_s, snwprintf_s</a>
<br><a href="#sopen">sopen, _sopen, _wsopen</a>
<br><a href="#sound">sound</a>
<br><a href="#Space_Characters">Space Characters</a>
<br><a href="#spawn___">spawn...&nbsp; Functions</a>
<br><a href="#_splitpath">_splitpath, _wsplitpath</a>
<br><a href="#_splitpath2">_splitpath2, _wsplitpath2</a>
<br><a href="#sprintf">sprintf, swprintf</a>
<br><a href="#sprintf_s">sprintf_s, swprintf_s</a>
<br><a href="#sqrt">sqrt</a>
<br><a href="#srand">srand</a>
<br><a href="#sscanf">sscanf, swscanf</a>
<br><a href="#sscanf_s">sscanf_s, swscanf_s</a>
<br><a href="#stackavail">stackavail, _stackavail</a>
<br><a href="#stat">stat, _stat, _stati64, _wstat, _wstati64, lstat</a>
<br><a href="#_status87">_status87</a>
<br><a href="#strcasecmp">strcasecmp</a>
<br><a href="#strcat">strcat, _fstrcat, wcscat, _mbscat, _fmbscat</a>
<br><a href="#strcat_s">strcat_s, wcscat_s</a>
<br><a href="#strchr">strchr, _fstrchr, wcschr, _mbschr, _fmbschr</a>
<br><a href="#strcmp">strcmp, _fstrcmp, wcscmp, _mbscmp, _fmbscmp</a>
<br><a href="#strcmpi">strcmpi, wcscmpi</a>
<br><a href="#strcoll">strcoll, wcscoll, _mbscoll</a>
<br><a href="#strcpy">strcpy, _fstrcpy, wcscpy, _mbscpy, _fmbscpy</a>
<br><a href="#strcpy_s">strcpy_s, wcscpy_s</a>
<br><a href="#strcspn">strcspn, _fstrcspn, wcscspn, _mbscspn, _fmbscspn</a>
<br><a href="#_strdate">_strdate, _wstrdate</a>
<br><a href="#_strdec">_strdec, _wcsdec, _mbsdec, _fmbsdec</a>
<br><a href="#strdup">strdup, _strdup, _fstrdup, _wcsdup, _mbsdup, _fmbsdup</a>
<br><a href="#Stream_IDO_Functions">Stream I/O Functions</a>
<br><a href="#The_strerror_Function">The strerror Function</a>
<br><a href="#strerror">strerror, wcserror</a>
<br><a href="#strerror_s">strerror_s, wcserror_s</a>
<br><a href="#strerrorlen_s">strerrorlen_s, wcserrorlen_s</a>
<br><a href="#strftime">strftime, wcsftime, _wstrftime_ms</a>
<br><a href="#stricmp">stricmp, _stricmp, _fstricmp, _wcsicmp, _mbsicmp, _fmbsicmp</a>
<br><a href="#_stricoll">_stricoll, _wcsicoll, _mbsicoll</a>
<br><a href="#_strinc">_strinc, _wcsinc, _mbsinc, _fmbsinc</a>
<br><a href="#String_Manipulation_Functions">String Manipulation Functions</a>
<br><a href="#strlcat">strlcat, wcslcat</a>
<br><a href="#strlcpy">strlcpy, wcslcpy</a>
<br><a href="#strlen">strlen, _fstrlen, wcslen, _mbslen, _fmbslen</a>
<br><a href="#strlwr">strlwr, _strlwr, _fstrlwr, _wcslwr, _mbslwr, _fmbslwr</a>
<br><a href="#strncasecmp">strncasecmp</a>
<br><a href="#strncat">strncat, _fstrncat, wcsncat, _mbsncat, _fmbsncat</a>
<br><a href="#strncat_s">strncat_s, wcsncat_s</a>
<br><a href="#strncmp">strncmp, _fstrncmp, wcsncmp, _mbsncmp, _fmbsncmp</a>
<br><a href="#_strncoll">_strncoll, _wcsncoll, _mbsncoll</a>
<br><a href="#strncpy">strncpy, _fstrncpy, wcsncpy, _mbsncpy, _fmbsncpy</a>
<br><a href="#strncpy_s">strncpy_s, wcsncpy_s</a>
<br><a href="#strnicmp">strnicmp, _strnicmp, _fstrnicmp, _wcsnicmp, _mbsnicmp, _fmbsnicmp</a>
<br><a href="#_strnicoll">_strnicoll, _wcsnicoll, _mbsnicoll</a>
<br><a href="#_strninc">_strninc, _wcsninc, _mbsninc, _fmbsninc</a>
<br><a href="#strnlen_s">strnlen_s, wcsnlen_s</a>
<br><a href="#strnset">strnset, _strnset, _fstrnset, _wcsnset, _mbsnset, _fmbsnset</a>
<br><a href="#strpbrk">strpbrk, _fstrpbrk, wcspbrk, _mbspbrk, _fmbspbrk</a>
<br><a href="#strrchr">strrchr, _fstrrchr, wcsrchr, _mbsrchr, _fmbsrchr</a>
<br><a href="#strrev">strrev, _strrev, _fstrrev, _wcsrev, _mbsrev, _fmbsrev</a>
<br><a href="#strset">strset, _strset, _fstrset, _wcsset, _mbsset, _fmbsset</a>
<br><a href="#strspn">strspn, _fstrspn, wcsspn, _mbsspn, _fmbsspn</a>
<br><a href="#strspnp">strspnp, _strspnp, _fstrspnp, _wcsspnp, _mbsspnp, _fmbsspnp</a>
<br><a href="#strstr">strstr, _fstrstr, wcsstr, _mbsstr, _fmbsstr</a>
<br><a href="#_strtime">_strtime, _wstrtime</a>
<br><a href="#strtod">strtod, wcstod</a>
<br><a href="#strtoimax">strtoimax, wcstoimax</a>
<br><a href="#strtok">strtok, _fstrtok, wcstok, _mbstok, _fmbstok</a>
<br><a href="#strtok_s">strtok_s, wcstok_s</a>
<br><a href="#strtol">strtol, wcstol</a>
<br><a href="#strtoll">strtoll, wcstoll</a>
<br><a href="#strtoul">strtoul, wcstoul</a>
<br><a href="#strtoull">strtoull, wcstoull</a>
<br><a href="#strtoumax">strtoumax, wcstoumax</a>
<br><a href="#strupr">strupr, _strupr, _fstrupr, _wcsupr, _mbsupr, _fmbsupr</a>
<br><a href="#strxfrm">strxfrm, wcsxfrm</a>
<br><a href="#swab">swab</a>
<br><a href="#The_system_Function">The system Function</a>
<br><a href="#system">system, _wsystem</a>
<dt><br>- T -
<dd><a href="#tan">tan</a>
<br><a href="#tanh">tanh</a>
<br><a href="#tell">tell, _tell, _telli64</a>
<br><a href="#_tempnam">_tempnam, _wtempnam</a>
<br><a href="#Terminating_Newline_Characters">Terminating Newline Characters</a>
<br><a href="#Text_Functions">Text Functions</a>
<br><a href="#time">time</a>
<br><a href="#Time_Functions">Time Functions</a>
<br><a href="#The_Time_Zone">The Time Zone</a>
<br><a href="#tmpfile">tmpfile</a>
<br><a href="#tmpfile_s">tmpfile_s</a>
<br><a href="#tmpnam">tmpnam, _wtmpnam</a>
<br><a href="#tmpnam_s">tmpnam_s, _wtmpnam_s</a>
<br><a href="#tolower">tolower, _tolower, towlower</a>
<br><a href="#toupper">toupper, _toupper, towupper</a>
<br><a href="#towctrans">towctrans</a>
<br><a href="#Truncation_of_Text_Files">Truncation of Text Files</a>
<br><a href="#The_TZ_Environment_Variable">The TZ Environment Variable</a>
<br><a href="#tzset">tzset</a>
<dt><br>- U -
<dd><a href="#ulltoa">ulltoa, _ulltoa, _ulltow</a>
<br><a href="#ultoa">ultoa, _ultoa, _ultow</a>
<br><a href="#umask">umask, _umask</a>
<br><a href="#Underflow_of_FloatingMPoint_Values">Underflow of Floating-Point Values</a>
<br><a href="#ungetc">ungetc, ungetwc</a>
<br><a href="#ungetch">ungetch</a>
<br><a href="#unlink">unlink, _unlink, _wunlink</a>
<br><a href="#unlock">unlock</a>
<br><a href="#_unregisterfonts">_unregisterfonts</a>
<br><a href="#Utility_Functions">Utility Functions</a>
<br><a href="#utime">utime, _utime, _wutime</a>
<br><a href="#utoa">utoa, _utoa, _utow</a>
<dt><br>- V -
<dd><a href="#va_arg">va_arg</a>
<br><a href="#va_end">va_end</a>
<br><a href="#va_start">va_start</a>
<br><a href="#VariableMlength_Argument_Lists">Variable-length Argument Lists</a>
<br><a href="#_vbprintf">_vbprintf, _vbwprintf</a>
<br><a href="#vcprintf">vcprintf</a>
<br><a href="#vcscanf">vcscanf</a>
<br><a href="#vfprintf">vfprintf, vfwprintf</a>
<br><a href="#vfprintf_s">vfprintf_s, vfwprintf_s</a>
<br><a href="#vfscanf">vfscanf, vfwscanf</a>
<br><a href="#vfscanf_s">vfscanf_s, vfwscanf_s</a>
<br><a href="#vprintf">vprintf, vwprintf</a>
<br><a href="#vprintf_s">vprintf_s, vwprintf_s</a>
<br><a href="#vscanf">vscanf, vwscanf</a>
<br><a href="#vscanf_s">vscanf_s, vwscanf_s</a>
<br><a href="#_vsnprintf">_vsnprintf, _vsnwprintf</a>
<br><a href="#vsnprintf">vsnprintf, vsnwprintf</a>
<br><a href="#vsnprintf_s">vsnprintf_s, vsnwprintf_s</a>
<br><a href="#vsprintf">vsprintf, vswprintf</a>
<br><a href="#vsprintf_s">vsprintf_s, vswprintf_s</a>
<br><a href="#vsscanf">vsscanf, vswscanf</a>
<br><a href="#vsscanf_s">vsscanf_s, vswscanf_s</a>
<dt><br>- W -
<dd><a href="#wait">wait</a>
<br><a href="#wcrtomb">wcrtomb, _fwcrtomb</a>
<br><a href="#wcrtomb_s">wcrtomb_s, _fwcrtomb_s</a>
<br><a href="#wcsrtombs">wcsrtombs, _fwcsrtombs</a>
<br><a href="#wcsrtombs_s">wcsrtombs_s, _fwcsrtombs_s</a>
<br><a href="#wcstombs">wcstombs, _fwcstombs</a>
<br><a href="#wcstombs_s">wcstombs_s, _fwcstombs_s</a>
<br><a href="#wctob">wctob</a>
<br><a href="#wctomb">wctomb, _fwctomb</a>
<br><a href="#wctomb_s">wctomb_s, _fwctomb_s</a>
<br><a href="#wctrans">wctrans</a>
<br><a href="#wctype">wctype</a>
<br><a href="#Wide_Character_Manipulation_Functions">Wide Character Manipulation Functions</a>
<br><a href="#Wide_Character_Stream_IDO_Functions">Wide Character Stream I/O Functions</a>
<br><a href="#Wide_String_Manipulation_Functions">Wide String Manipulation Functions</a>
<br><a href="#_wrapon">_wrapon</a>
<br><a href="#write">write, _write</a>
<dt><br>- Z -
<dd><a href="#ZeroMLength_Files">Zero-Length Files</a>
</dl>
<h1 id="C_Library_Overview"> C Library Overview </h1>
<br>The C library provides much of the power usually associated with the C language.&nbsp; This chapter introduces the individual
 functions (and macros) that comprise the Watcom C library.&nbsp; The chapter<b> Library Functions and Macros</b> describes
 each function and macro in complete detail.
<br><br>Library functions are called as if they had been defined within the program.&nbsp; When the program is linked, the
 code for these routines is incorporated into the program by the linker.
<br><br>Strictly speaking, it is not necessary to declare most library functions since they return<tt> int</tt> values for
 the most part.&nbsp; It is preferred, however, to declare all functions by including the header files found in the synopsis
 section with each function.&nbsp; Not only does this declare the return value, but also the type expected for each of the
 arguments as well as the number of arguments.&nbsp; This enables the Watcom C and C++ compilers to check the arguments coded
 with each function call.
<h2 id="Classes_of_Functions"> Classes of Functions </h2>
<br>The functions in the Watcom C library can be organized into a number of classes:
<dl>
<dt>Character Manipulation Functions
<dd>
<br>These functions deal with single characters.
<dt><br>Wide Character Manipulation Functions
<dd>
<br>These functions deal with wide characters.
<dt><br>Multibyte Character Manipulation Functions
<dd>
<br>These functions deal with multibyte characters.
<dt><br>Memory Manipulation Functions
<dd>
<br>These functions manipulate blocks of memory.
<dt><br>String Manipulation Functions
<dd>
<br>These functions manipulate strings of characters.&nbsp; A character string is an array of zero or more adjacent characters
 followed by a null character<tt> ('\0')</tt> which marks the end of the string.
<dt><br>Wide String Manipulation Functions
<dd>
<br>These functions manipulate strings of wide characters.&nbsp; A wide character string is an array of zero or more adjacent
 wide characters followed by a null wide character<tt> (L'\0')</tt> which marks the end of the wide string.
<dt><br>Multibyte String Manipulation Functions
<dd>
<br>These functions manipulate strings of multibyte characters.&nbsp; A multibyte character is either a single-byte or double-byte
 character.&nbsp; The Chinese, Japanese and Korean character sets are examples of character sets containing both single-byte
 and double-byte characters.
<br>What determines whether a character is a single-byte or double-byte character is the value of the lead byte in the sequence.
&nbsp; For example, in the Japanese DBCS (double-byte character set), double-byte characters are those in which the first
 byte falls in the range 0x81 - 0x9F or 0xE0 - 0xFC and the second byte falls in the range 0x40 - 0x7E or 0x80 - 0xFC.&nbsp;
 A string of multibyte characters must be scanned from the first byte (index 0) to the last byte (index n) in sequence in
 order to determine if a particular byte is part of a double-byte character.&nbsp; For example, suppose that a multibyte character
 string contains the following byte values.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x31 0x40 0x41 0x81 0x41 // &quot;1@A..&quot; where .. is a DB char</tt>
<br><br>Among other characters, it contains the letter &quot;A&quot; (the first 0x41) and a double-byte character (0x81 0x41).
&nbsp; The second 0x41 is not the letter &quot;A&quot; and that could only be determined by scanning from left to right starting
 with the first byte (0x31).
<dt><br>Conversion Functions
<dd>
<br>These functions convert values from one representation to another.&nbsp; Numeric values, for example, can be converted
 to strings.
<dt><br>Memory Allocation Functions
<dd>
<br>These functions are concerned with allocating and deallocating memory.
<dt><br>Heap Functions
<dd>
<br>These functions provide the ability to shrink and grow the heap, as well as, find heap related problems.
<dt><br>Math Functions
<dd>
<br>The mathematical functions perform mathematical computations such as the common trigonometric calculations.&nbsp; These
 functions operate on<tt> double</tt> values, also known as floating-point values.
<dt><br>Searching Functions
<dd>
<br>These functions provide searching and sorting capabilities.
<dt><br>Time Functions
<dd>
<br>These functions provide facilities to obtain and manipulate times and dates.
<dt><br>Variable-length Argument Lists
<dd>
<br>These functions provide the capability to process a variable number of arguments to a function.
<dt><br>Stream I/O Functions
<dd>
<br>These functions provide the &quot;standard&quot; functions to read and write files.&nbsp; Data can be transmitted as characters,
 strings, blocks of memory or under format control.
<dt><br>Wide Character Stream I/O Functions
<dd>
<br>These functions provide the &quot;standard&quot; functions to read and write files of wide characters.&nbsp; Data can
 be transmitted as wide characters, wide character strings, blocks of memory or under format control.
<dt><br>Process Primitive Functions
<dd>
<br>These functions deal with process creation, execution and termination, signal handling, and timer operations.
<dt><br>Process Environment
<dd>
<br>These functions deal with process identification, user identification, process groups, system identification, system time
 and process time, environment variables, terminal identification, and configurable system variables.
<dt><br>Directory Functions
<dd>
<br>These functions provide directory services.
<dt><br>Operating System I/O Functions
<dd>
<br>These &quot;non-standard&quot; file operations are more primitive than the &quot;standard&quot; functions in that they
 are directly interfaced to the operating system.&nbsp; They are included to provide compatibility with other C implementations
 and to provide the capability to directly use operating-system file operations.
<dt><br>File Manipulation Functions
<dd>
<br>These functions operate directly on files, providing facilities such as deletion of files.
<dt><br>Console I/O Functions
<dd>
<br>These functions provide the capability to directly read and write characters from the console.
<dt><br>Default Windowing Functions
<dd>
<br>These functions provide the capability to manipulate various dialog boxes in Watcom's default windowing system.
<dt><br>BIOS Functions
<dd>
<br>This set of functions allows access to services provided by the BIOS.
<dt><br>DOS-Specific Functions
<dd>
<br>This set of functions allows access to DOS-specific functions.
<dt><br>Intel 80x86 Architecture-Specific Functions
<dd>
<br>This set of functions allows access to Intel 80x86 processor-related functions.
<dt><br>Intel Pentium Multimedia Extension Functions
<dd>
<br>This set of functions allows access to Intel Architecture Multimedia Extensions (MMX).
<dt><br>Miscellaneous Functions
<dd>
<br>This collection consists of the remaining functions.
<dt><br>DOS LFN aware Functions
<dd>
<br>These functions are DOS LFN capable.
</dl>
<br>The following subsections describe these function classes in more detail.&nbsp; Each function in the class is noted with
 a brief description of its purpose.&nbsp; The chapter<b> Library Functions and Macros</b> provides a complete description
 of each function and macro.
<h3 id="Character_Manipulation_Functions"> Character Manipulation Functions </h3>
<br>These functions operate upon single characters of type<tt> char.</tt>&nbsp; The functions test characters in various ways
 and convert them between upper and lowercase.&nbsp; The following functions are defined:
<dl>
<dt><a href="#isalnum">isalnum</a>
<dd>test for letter or digit
<dt><br><a href="#isalpha">isalpha</a>
<dd>test for letter
<dt><br><a href="#isascii">isascii</a>
<dd>test for ASCII character
<dt><br><a href="#isblank">isblank</a>
<dd>test for blank character
<dt><br><a href="#iscntrl">iscntrl</a>
<dd>test for control character
<dt><br>__iscsym (see <a href="#iscsym">iscsym</a>)
<dd>test for letter, underscore or digit
<dt><br>__iscsymf (see <a href="#iscsymf">iscsymf</a>)
<dd>test for letter or underscore
<dt><br><a href="#isdigit">isdigit</a>
<dd>test for digit
<dt><br><a href="#isgraph">isgraph</a>
<dd>test for printable character, except space
<dt><br><a href="#islower">islower</a>
<dd>test for letter in lowercase
<dt><br><a href="#isprint">isprint</a>
<dd>test for printable character, including space
<dt><br><a href="#ispunct">ispunct</a>
<dd>test for punctuation characters
<dt><br><a href="#isspace">isspace</a>
<dd>test for &quot;white space&quot; characters
<dt><br><a href="#isupper">isupper</a>
<dd>test for letter in uppercase
<dt><br><a href="#isxdigit">isxdigit</a>
<dd>test for hexadecimal digit
<dt><br><a href="#tolower">tolower</a>
<dd>convert character to lowercase
<dt><br><a href="#toupper">toupper</a>
<dd>convert character to uppercase
</dl>
<h3 id="Wide_Character_Manipulation_Functions"> Wide Character Manipulation Functions </h3>
<br>These functions operate upon wide characters of type<tt> wchar_t.</tt>&nbsp; The functions test wide characters in various
 ways and convert them between upper and lowercase.&nbsp; The following functions are defined:
<dl>
<dt>iswalnum (see <a href="#isalnum">isalnum</a>)
<dd>test for letter or digit
<dt><br>iswalpha (see <a href="#isalpha">isalpha</a>)
<dd>test for letter
<dt><br>iswascii (see <a href="#isascii">isascii</a>)
<dd>test for ASCII character
<dt><br>iswblank (see <a href="#isblank">isblank</a>)
<dd>test for blank character
<dt><br>iswcntrl (see <a href="#iscntrl">iscntrl</a>)
<dd>test for control character
<dt><br>__iswcsym (see <a href="#iscsym">iscsym</a>)
<dd>test for letter, underscore or digit
<dt><br>__iswcsymf (see <a href="#iscsymf">iscsymf</a>)
<dd>test for letter or underscore
<dt><br>iswdigit (see <a href="#isdigit">isdigit</a>)
<dd>test for digit
<dt><br>iswgraph (see <a href="#isgraph">isgraph</a>)
<dd>test for printable character, except space
<dt><br>iswlower (see <a href="#islower">islower</a>)
<dd>test for letter in lowercase
<dt><br>iswprint (see <a href="#isprint">isprint</a>)
<dd>test for printable character, including space
<dt><br>iswpunct (see <a href="#ispunct">ispunct</a>)
<dd>test for punctuation characters
<dt><br>iswspace (see <a href="#isspace">isspace</a>)
<dd>test for &quot;white space&quot; characters
<dt><br>iswupper (see <a href="#isupper">isupper</a>)
<dd>test for letter in uppercase
<dt><br>iswxdigit (see <a href="#isxdigit">isxdigit</a>)
<dd>test for hexadecimal digit
<dt><br><a href="#wctype">wctype</a>
<dd>construct a property value for a given &quot;property&quot;
<dt><br><a href="#iswctype">iswctype</a>
<dd>test a character for a specific property
<dt><br>towlower (see <a href="#tolower">tolower</a>)
<dd>convert character to lowercase
<dt><br>towupper (see <a href="#toupper">toupper</a>)
<dd>convert character to uppercase
<dt><br><a href="#wctrans">wctrans</a>
<dd>construct mapping value for a given &quot;property&quot;
<dt><br><a href="#towctrans">towctrans</a>
<dd>convert a character based on a specific property
</dl>
<h3 id="Multibyte_Character_Manipulation_Functions"> Multibyte Character Manipulation Functions </h3>
<br>These functions operate upon multibyte characters.&nbsp; The functions test wide characters in various ways and convert
 them between upper and lowercase.&nbsp; The following functions are defined:
<dl>
<dt>_fmbccmp (see <a href="#_mbccmp">_mbccmp</a>)
<dd>compare one multibyte character with another
<dt><br>_fmbccpy (see <a href="#_mbccpy">_mbccpy</a>)
<dd>copy one multibyte character from one string to another
<dt><br>_fmbcicmp (see <a href="#_mbcicmp">_mbcicmp</a>)
<dd>compare one multibyte character with another (case insensitive)
<dt><br>_fmbclen (see <a href="#_mbclen">_mbclen</a>)
<dd>return number of bytes comprising multibyte character
<dt><br>_fmblen (see <a href="#mblen">mblen</a>)
<dd>determine length of next multibyte character
<dt><br>_fmbgetcode (see <a href="#_mbgetcode">_mbgetcode</a>)
<dd>get next single-byte or double-byte character from far string
<dt><br>_fmbputchar (see <a href="#_mbputchar">_mbputchar</a>)
<dd>store single-byte or double-byte character into far string
<dt><br>_fmbrlen (see <a href="#mbrlen">mbrlen</a>)
<dd>determine length of next multibyte character
<dt><br>_fmbrtowc (see <a href="#mbrtowc">mbrtowc</a>)
<dd>convert far multibyte character to wide character
<dt><br>_fmbsbtype (see <a href="#_mbsbtype">_mbsbtype</a>)
<dd>return type of byte in multibyte character string
<dt><br>_fmbtowc (see <a href="#mbtowc">mbtowc</a>)
<dd>convert far multibyte character to wide character
<dt><br><a href="#_ismbbalnum">_ismbbalnum</a>
<dd>test for isalnum or _ismbbkalnum
<dt><br><a href="#_ismbbalpha">_ismbbalpha</a>
<dd>test for isalpha or _ismbbkalpha
<dt><br><a href="#_ismbbgraph">_ismbbgraph</a>
<dd>test for isgraph or _ismbbkprint
<dt><br><a href="#_ismbbkalnum">_ismbbkalnum</a>
<dd>test for non-ASCII text symbol other than punctuation
<dt><br><a href="#_ismbbkana">_ismbbkana</a>
<dd>test for single-byte Katakana character
<dt><br><a href="#_ismbbkalpha">_ismbbkalpha</a>
<dd>test for non-ASCII text symbol other than digits or punctuation
<dt><br><a href="#_ismbbkprint">_ismbbkprint</a>
<dd>test for non-ASCII text or non-ASCII punctuation symbol
<dt><br><a href="#_ismbbkpunct">_ismbbkpunct</a>
<dd>test for non-ASCII punctuation character
<dt><br><a href="#_ismbblead">_ismbblead</a>
<dd>test for valid first byte of multibyte character
<dt><br><a href="#_ismbbprint">_ismbbprint</a>
<dd>test for isprint or _ismbbkprint
<dt><br><a href="#_ismbbpunct">_ismbbpunct</a>
<dd>test for ispunct or _ismbbkpunct
<dt><br><a href="#_ismbbtrail">_ismbbtrail</a>
<dd>test for valid second byte of multibyte character
<dt><br><a href="#_ismbcalnum">_ismbcalnum</a>
<dd>test for _ismbcalpha or _ismbcdigit
<dt><br><a href="#_ismbcalpha">_ismbcalpha</a>
<dd>test for a multibyte alphabetic character
<dt><br><a href="#_ismbccntrl">_ismbccntrl</a>
<dd>test for a multibyte control character
<dt><br><a href="#_ismbcdigit">_ismbcdigit</a>
<dd>test for a multibyte decimal-digit character '0' through '9'
<dt><br><a href="#_ismbcgraph">_ismbcgraph</a>
<dd>test for a printable multibyte character except space
<dt><br><a href="#_ismbchira">_ismbchira</a>
<dd>test for a double-byte Hiragana character
<dt><br><a href="#_ismbckata">_ismbckata</a>
<dd>test for a double-byte Katakana character
<dt><br><a href="#_ismbcl0">_ismbcl0</a>
<dd>test for a double-byte non-Kanji character
<dt><br><a href="#_ismbcl1">_ismbcl1</a>
<dd>test for a JIS level 1 double-byte character
<dt><br><a href="#_ismbcl2">_ismbcl2</a>
<dd>test for a JIS level 2 double-byte character
<dt><br><a href="#_ismbclegal">_ismbclegal</a>
<dd>test for a valid multibyte character
<dt><br><a href="#_ismbclower">_ismbclower</a>
<dd>test for a valid lowercase multibyte character
<dt><br><a href="#_ismbcprint">_ismbcprint</a>
<dd>test for a printable multibyte character including space
<dt><br><a href="#_ismbcpunct">_ismbcpunct</a>
<dd>test for any multibyte punctuation character
<dt><br><a href="#_ismbcspace">_ismbcspace</a>
<dd>test for any multibyte space character
<dt><br><a href="#_ismbcsymbol">_ismbcsymbol</a>
<dd>test for valid multibyte symbol (punctuation and other special graphics)
<dt><br><a href="#_ismbcupper">_ismbcupper</a>
<dd>test for valid uppercase multibyte character
<dt><br><a href="#_ismbcxdigit">_ismbcxdigit</a>
<dd>test for any multibyte hexadecimal-digit character
<dt><br><a href="#_mbbtombc">_mbbtombc</a>
<dd>return double-byte equivalent to single-byte character
<dt><br><a href="#_mbbtype">_mbbtype</a>
<dd>determine type of byte in multibyte character
<dt><br><a href="#_mbccmp">_mbccmp</a>
<dd>compare one multibyte character with another
<dt><br><a href="#_mbccpy">_mbccpy</a>
<dd>copy one multibyte character from one string to another
<dt><br><a href="#_mbcicmp">_mbcicmp</a>
<dd>compare one multibyte character with another (case insensitive)
<dt><br><a href="#_mbcjistojms">_mbcjistojms</a>
<dd>convert JIS code to shift-JIS code
<dt><br><a href="#_mbcjmstojis">_mbcjmstojis</a>
<dd>convert shift-JIS code to JIS code
<dt><br><a href="#_mbclen">_mbclen</a>
<dd>return number of bytes comprising multibyte character
<dt><br><a href="#_mbctolower">_mbctolower</a>
<dd>convert double-byte uppercase character to double-byte lowercase character
<dt><br><a href="#_mbctoupper">_mbctoupper</a>
<dd>convert double-byte lowercase character to double-byte uppercase character
<dt><br><a href="#_mbctohira">_mbctohira</a>
<dd>convert double-byte Katakana character to Hiragana character
<dt><br><a href="#_mbctokata">_mbctokata</a>
<dd>convert double-byte Hiragana character to Katakana character
<dt><br><a href="#_mbctombb">_mbctombb</a>
<dd>return single-byte equivalent to double-byte character
<dt><br><a href="#_mbgetcode">_mbgetcode</a>
<dd>get next single-byte or double-byte character from string
<dt><br><a href="#mblen">mblen</a>
<dd>determine length of next multibyte character
<dt><br><a href="#_mbputchar">_mbputchar</a>
<dd>store single-byte or double-byte character into string
<dt><br><a href="#mbrlen">mbrlen</a>
<dd>determine length of next multibyte character
<dt><br><a href="#mbrtowc">mbrtowc</a>
<dd>convert multibyte character to wide character
<dt><br><a href="#_mbsbtype">_mbsbtype</a>
<dd>return type of byte in multibyte character string
<dt><br><a href="#mbsinit">mbsinit</a>
<dd>determine if mbstate_t object describes an initial conversion state
<dt><br><a href="#mbtowc">mbtowc</a>
<dd>convert multibyte character to wide character
</dl>
<h3 id="Memory_Manipulation_Functions"> Memory Manipulation Functions </h3>
<br>These functions manipulate blocks of memory.&nbsp; In each case, the address of the memory block and its size is passed
 to the function.&nbsp; The functions that begin with &quot;_f&quot; accept<tt> far</tt> pointers as their arguments allowing
 manipulation of any memory location regardless of which memory model your program has been compiled for.&nbsp; The following
 functions are defined:
<dl>
<dt>_fmemccpy (see <a href="#memccpy">memccpy</a>)
<dd>copy far memory block up to a certain character
<dt><br>_fmemchr (see <a href="#memchr">memchr</a>)
<dd>search far memory block for a character value
<dt><br>_fmemcmp (see <a href="#memcmp">memcmp</a>)
<dd>compare any two memory blocks (near or far)
<dt><br>_fmemcpy (see <a href="#memcpy">memcpy</a>)
<dd>copy far memory block, overlap not allowed
<dt><br>_fmemicmp (see <a href="#memicmp">memicmp</a>)
<dd>compare far memory, case insensitive
<dt><br>_fmemmove (see <a href="#memmove">memmove</a>)
<dd>copy far memory block, overlap allowed
<dt><br>_fmemset (see <a href="#memset">memset</a>)
<dd>set any memory block (near of far) to a character
<dt><br><a href="#memccpy">memccpy</a>
<dd>copy memory block up to a certain character
<dt><br><a href="#memchr">memchr</a>
<dd>search memory block for a character value
<dt><br><a href="#memcmp">memcmp</a>
<dd>compare memory blocks
<dt><br><a href="#memcpy">memcpy</a>
<dd>copy memory block, overlap not allowed
<dt><br><a href="#memicmp">memicmp</a>
<dd>compare memory, case insensitive
<dt><br><a href="#memmove">memmove</a>
<dd>copy memory block, overlap allowed
<dt><br><a href="#memset">memset</a>
<dd>set memory block to a character
<dt><br><a href="#movedata">movedata</a>
<dd>copy memory block, with segment information
<dt><br><a href="#swab">swab</a>
<dd>swap bytes of a memory block
<dt><br>wmemchr (see <a href="#memchr">memchr</a>)
<dd>search memory block for a wide character value
<dt><br>wmemcmp (see <a href="#memcmp">memcmp</a>)
<dd>compare memory blocks
<dt><br>wmemcpy (see <a href="#memcpy">memcpy</a>)
<dd>copy memory block, overlap not allowed
<dt><br>wmemmove (see <a href="#memmove">memmove</a>)
<dd>copy memory block, overlap allowed
<dt><br>wmemset (see <a href="#memset">memset</a>)
<dd>set memory block to a wide character
</dl>
<br>See the section<b> &quot;String Manipulation Functions&quot;</b> for descriptions of functions that manipulate strings
 of data.&nbsp; See the section<b> &quot;Wide String Manipulation Functions&quot;</b> for descriptions of functions that manipulate
 wide strings of data.
<h3 id="String_Manipulation_Functions"> String Manipulation Functions </h3>
<br>A<b> string</b> is an array of characters (with type<tt> char</tt>) that is terminated with an extra null character<tt>
 ('\0').</tt>&nbsp; Functions are passed only the address of the string since the size can be determined by searching for
 the terminating character.&nbsp; The functions that begin with &quot;_f&quot; accept<tt> far</tt> pointers as their arguments
 allowing manipulation of any memory location regardless of which memory model your program has been compiled for.&nbsp; The
 following functions are defined:
<dl>
<dt><a href="#bcmp">bcmp</a>
<dd>compare two byte strings
<dt><br><a href="#bcopy">bcopy</a>
<dd>copy a byte string
<dt><br><a href="#_bprintf">_bprintf</a>
<dd>formatted transmission to fixed-length string
<dt><br><a href="#bzero">bzero</a>
<dd>zero a byte string
<dt><br>_fstrcat (see <a href="#strcat">strcat</a>)
<dd>concatenate two far strings
<dt><br>_fstrchr (see <a href="#strchr">strchr</a>)
<dd>locate character in far string
<dt><br>_fstrcmp (see <a href="#strcmp">strcmp</a>)
<dd>compare two far strings
<dt><br>_fstrcpy (see <a href="#strcpy">strcpy</a>)
<dd>copy far string
<dt><br>_fstrcspn (see <a href="#strcspn">strcspn</a>)
<dd>get number of string characters not from a set of characters
<dt><br>_fstricmp (see <a href="#stricmp">stricmp</a>)
<dd>compare two far strings with case insensitivity
<dt><br>_fstrlen (see <a href="#strlen">strlen</a>)
<dd>length of a far string
<dt><br>_fstrlwr (see <a href="#strlwr">strlwr</a>)
<dd>convert far string to lowercase
<dt><br>_fstrncat (see <a href="#strncat">strncat</a>)
<dd>concatenate two far strings, up to a maximum length
<dt><br>_fstrncmp (see <a href="#strncmp">strncmp</a>)
<dd>compare two far strings up to maximum length
<dt><br>_fstrncpy (see <a href="#strncpy">strncpy</a>)
<dd>copy a far string, up to a maximum length
<dt><br>_fstrnicmp (see <a href="#strnicmp">strnicmp</a>)
<dd>compare two far strings with case insensitivity up to a maximum length
<dt><br>_fstrnset (see <a href="#strnset">strnset</a>)
<dd>fill far string with character to a maximum length
<dt><br>_fstrpbrk (see <a href="#strpbrk">strpbrk</a>)
<dd>locate occurrence of a string within a second string
<dt><br>_fstrrchr (see <a href="#strrchr">strrchr</a>)
<dd>locate last occurrence of character from a character set
<dt><br>_fstrrev (see <a href="#strrev">strrev</a>)
<dd>reverse a far string in place
<dt><br>_fstrset (see <a href="#strset">strset</a>)
<dd>fill far string with a character
<dt><br>_fstrspn (see <a href="#strspn">strspn</a>)
<dd>find number of characters at start of string which are also in a second string
<dt><br>_fstrstr (see <a href="#strstr">strstr</a>)
<dd>find first occurrence of string in second string
<dt><br>_fstrtok (see <a href="#strtok">strtok</a>)
<dd>get next token from a far string
<dt><br>_fstrupr (see <a href="#strupr">strupr</a>)
<dd>convert far string to uppercase
<dt><br><a href="#sprintf">sprintf</a>
<dd>formatted transmission to string
<dt><br><a href="#sscanf">sscanf</a>
<dd>scan from string under format control
<dt><br><a href="#strcat">strcat</a>
<dd>concatenate string
<dt><br><a href="#strchr">strchr</a>
<dd>locate character in string
<dt><br><a href="#strcmp">strcmp</a>
<dd>compare two strings
<dt><br><a href="#strcmpi">strcmpi</a>
<dd>compare two strings with case insensitivity
<dt><br><a href="#strcoll">strcoll</a>
<dd>compare two strings using &quot;locale&quot; collating sequence
<dt><br><a href="#strcpy">strcpy</a>
<dd>copy a string
<dt><br><a href="#strcspn">strcspn</a>
<dd>get number of string characters not from a set of characters
<dt><br><a href="#_strdec">_strdec</a>
<dd>returns pointer to the previous character in string
<dt><br>_strdup (see <a href="#strdup">strdup</a>)
<dd>allocate and duplicate a string
<dt><br><a href="#strerror">strerror</a>
<dd>get error message as string
<dt><br>_stricmp (see <a href="#stricmp">stricmp</a>)
<dd>compare two strings with case insensitivity
<dt><br><a href="#_strinc">_strinc</a>
<dd>return pointer to next character in string
<dt><br><a href="#strlcat">strlcat</a>
<dd>concatenate string into a bounded buffer
<dt><br><a href="#strlcpy">strlcpy</a>
<dd>copy string into a bounded buffer
<dt><br><a href="#strlen">strlen</a>
<dd>string length
<dt><br>_strlwr (see <a href="#strlwr">strlwr</a>)
<dd>convert string to lowercase
<dt><br><a href="#strncat">strncat</a>
<dd>concatenate two strings, up to a maximum length
<dt><br><a href="#strncmp">strncmp</a>
<dd>compare two strings up to maximum length
<dt><br>_strncnt (see <a href="#_mbsnbcnt">_mbsnbcnt</a>)
<dd>count the number of characters in the first &quot;n&quot; bytes
<dt><br><a href="#strncpy">strncpy</a>
<dd>copy a string, up to a maximum length
<dt><br>_strnextc (see <a href="#_mbsnextc">_mbsnextc</a>)
<dd>return integer value of the next character in string
<dt><br>_strnicmp (see <a href="#strnicmp">strnicmp</a>)
<dd>compare two strings with case insensitivity up to a maximum length
<dt><br><a href="#_strninc">_strninc</a>
<dd>increment character pointer by &quot;n&quot; characters
<dt><br>_strnset (see <a href="#strnset">strnset</a>)
<dd>fill string with character to a maximum length
<dt><br><a href="#strpbrk">strpbrk</a>
<dd>locate occurrence of a string within a second string
<dt><br><a href="#strrchr">strrchr</a>
<dd>locate last occurrence of character from a character set
<dt><br>_strrev (see <a href="#strrev">strrev</a>)
<dd>reverse a string in place
<dt><br>_strset (see <a href="#strset">strset</a>)
<dd>fill string with a character
<dt><br><a href="#strspn">strspn</a>
<dd>find number of characters at start of string which are also in a second string
<dt><br>_strspnp (see <a href="#strspnp">strspnp</a>)
<dd>return pointer to first character of string not in set
<dt><br><a href="#strstr">strstr</a>
<dd>find first occurrence of string in second string
<dt><br><a href="#strtok">strtok</a>
<dd>get next token from string
<dt><br>_strupr (see <a href="#strupr">strupr</a>)
<dd>convert string to uppercase
<dt><br><a href="#strxfrm">strxfrm</a>
<dd>transform string to locale's collating sequence
<dt><br><a href="#_vbprintf">_vbprintf</a>
<dd>same as &quot;_bprintf&quot; but with variable arguments
<dt><br><a href="#vsscanf">vsscanf</a>
<dd>same as &quot;sscanf&quot; but with variable arguments
</dl>
<br>For related functions see the sections<b> Conversion Functions</b> (conversions to and from strings),<b> Time Functions</b>
 (formatting of dates and times), and<b> Memory Manipulation Functions</b> (operate on arrays without terminating null character).
<h3 id="Wide_String_Manipulation_Functions"> Wide String Manipulation Functions </h3>
<br>A<b> wide string</b> is an array of wide characters (with type<tt> wchar_t</tt>) that is terminated with an extra null
 wide character<tt> (L'\0').</tt>&nbsp; Functions are passed only the address of the string since the size can be determined
 by searching for the terminating character.&nbsp; The functions that begin with &quot;_f&quot; accept<tt> far</tt> pointers
 as their arguments allowing manipulation of any memory location regardless of which memory model your program has been compiled
 for.&nbsp; The following functions are defined:
<dl>
<dt>_bwprintf (see <a href="#_bprintf">_bprintf</a>)
<dd>formatted wide character transmission to fixed-length wcsing
<dt><br>swprintf (see <a href="#sprintf">sprintf</a>)
<dd>formatted wide character transmission to string
<dt><br>swscanf (see <a href="#sscanf">sscanf</a>)
<dd>scan from wide character string under format control
<dt><br>_vbwprintf (see <a href="#_vbprintf">_vbprintf</a>)
<dd>same as &quot;_bwprintf&quot; but with variable arguments
<dt><br>vswscanf (see <a href="#vsscanf">vsscanf</a>)
<dd>same as &quot;swscanf&quot; but with variable arguments
<dt><br>wcscat (see <a href="#strcat">strcat</a>)
<dd>concatenate string
<dt><br>wcschr (see <a href="#strchr">strchr</a>)
<dd>locate character in string
<dt><br>wcscmp (see <a href="#strcmp">strcmp</a>)
<dd>compare two strings
<dt><br>wcscmpi (see <a href="#strcmpi">strcmpi</a>)
<dd>compare two strings with case insensitivity
<dt><br>wcscoll (see <a href="#strcoll">strcoll</a>)
<dd>compare two strings using &quot;locale&quot; collating sequence
<dt><br>wcscpy (see <a href="#strcpy">strcpy</a>)
<dd>copy a string
<dt><br>wcscspn (see <a href="#strcspn">strcspn</a>)
<dd>get number of string characters not from a set of characters
<dt><br>_wcsdec (see <a href="#_strdec">_strdec</a>)
<dd>returns pointer to the previous character in string
<dt><br>_wcsdup (see <a href="#strdup">strdup</a>)
<dd>allocate and duplicate a string
<dt><br>wcserror (see <a href="#strerror">strerror</a>)
<dd>get error message as string
<dt><br>_wcsicmp (see <a href="#stricmp">stricmp</a>)
<dd>compare two strings with case insensitivity
<dt><br>_wcsinc (see <a href="#_strinc">_strinc</a>)
<dd>return pointer to next character in string
<dt><br>wcslcat (see <a href="#strlcat">strlcat</a>)
<dd>concatenate string into a bounded buffer
<dt><br>wcslcpy (see <a href="#strlcpy">strlcpy</a>)
<dd>copy string into a bounded buffer
<dt><br>wcslen (see <a href="#strlen">strlen</a>)
<dd>string length
<dt><br>_wcslwr (see <a href="#strlwr">strlwr</a>)
<dd>convert string to lowercase
<dt><br>wcsncat (see <a href="#strncat">strncat</a>)
<dd>concatenate two strings, up to a maximum length
<dt><br>wcsncmp (see <a href="#strncmp">strncmp</a>)
<dd>compare two strings up to maximum length
<dt><br>_wcsncnt (see <a href="#_mbsnbcnt">_mbsnbcnt</a>)
<dd>count the number of characters in the first &quot;n&quot; bytes
<dt><br>wcsncpy (see <a href="#strncpy">strncpy</a>)
<dd>copy a string, up to a maximum length
<dt><br>_wcsnextc (see <a href="#_mbsnextc">_mbsnextc</a>)
<dd>return integer value of the next multibyte-character in string
<dt><br>_wcsnicmp (see <a href="#strnicmp">strnicmp</a>)
<dd>compare two strings with case insensitivity up to a maximum length
<dt><br>_wcsninc (see <a href="#_strninc">_strninc</a>)
<dd>increment wide character pointer by &quot;n&quot; characters
<dt><br>_wcsnset (see <a href="#strnset">strnset</a>)
<dd>fill string with character to a maximum length
<dt><br>wcspbrk (see <a href="#strpbrk">strpbrk</a>)
<dd>locate occurrence of a string within a second string
<dt><br>wcsrchr (see <a href="#strrchr">strrchr</a>)
<dd>locate last occurrence of character from a character set
<dt><br>_wcsrev (see <a href="#strrev">strrev</a>)
<dd>reverse a string in place
<dt><br>_wcsset (see <a href="#strset">strset</a>)
<dd>fill string with a character
<dt><br>wcsspn (see <a href="#strspn">strspn</a>)
<dd>find number of characters at start of string which are also in a second string
<dt><br>_wcsspnp (see <a href="#strspnp">strspnp</a>)
<dd>return pointer to first character of string not in set
<dt><br>wcsstr (see <a href="#strstr">strstr</a>)
<dd>find first occurrence of string in second string
<dt><br>wcstok (see <a href="#strtok">strtok</a>)
<dd>get next token from string
<dt><br>_wcsupr (see <a href="#strupr">strupr</a>)
<dd>convert string to uppercase
<dt><br>wcsxfrm (see <a href="#strxfrm">strxfrm</a>)
<dd>transform string to locale's collating sequence
</dl>
<br>For related functions see the sections<b> Conversion Functions</b> (conversions to and from strings),<b> Time Functions</b>
 (formatting of dates and times), and<b> Memory Manipulation Functions</b> (operate on arrays without terminating null character).
<h3 id="Multibyte_String_Manipulation_Functions"> Multibyte String Manipulation Functions </h3>
<br>A<b> wide string</b> is an array of wide characters (with type<tt> wchar_t</tt>) that is terminated with an extra null
 wide character<tt> (L'\0').</tt>&nbsp; Functions are passed only the address of the wide string since the size can be determined
 by searching for the terminating character.&nbsp; The functions that begin with &quot;_f&quot; accept<tt> far</tt> pointers
 as their arguments allowing manipulation of any memory location regardless of which memory model your program has been compiled
 for.&nbsp; The following functions are defined:
<dl>
<dt><a href="#btowc">btowc</a>
<dd>return wide-character version of single-byte character
<dt><br>_fmbscat (see <a href="#strcat">strcat</a>)
<dd>concatenate two far strings
<dt><br>_fmbschr (see <a href="#strchr">strchr</a>)
<dd>locate character in far string
<dt><br>_fmbscmp (see <a href="#strcmp">strcmp</a>)
<dd>compare two far strings
<dt><br>_fmbscpy (see <a href="#strcpy">strcpy</a>)
<dd>copy far string
<dt><br>_fmbscspn (see <a href="#strcspn">strcspn</a>)
<dd>get number of string characters not from a set of characters
<dt><br>_fmbsdec (see <a href="#_strdec">_strdec</a>)
<dd>returns far pointer to the previous character in far string
<dt><br>_fmbsdup (see <a href="#strdup">strdup</a>)
<dd>allocate and duplicate a far string
<dt><br>_fmbsicmp (see <a href="#stricmp">stricmp</a>)
<dd>compare two far strings with case insensitivity
<dt><br>_fmbsinc (see <a href="#_strinc">_strinc</a>)
<dd>return far pointer to next character in far string
<dt><br>_fmbslen (see <a href="#strlen">strlen</a>)
<dd>length of a far string
<dt><br>_fmbslwr (see <a href="#strlwr">strlwr</a>)
<dd>convert far string to lowercase
<dt><br>_fmbsnbcat (see <a href="#_mbsnbcat">_mbsnbcat</a>)
<dd>append up to &quot;n&quot; bytes of string to another string
<dt><br>_fmbsnbcmp (see <a href="#_mbsnbcmp">_mbsnbcmp</a>)
<dd>compare up to &quot;n&quot; bytes in two strings
<dt><br>_fmbsnbcnt (see <a href="#_mbsnbcnt">_mbsnbcnt</a>)
<dd>count the number of characters in the first &quot;n&quot; bytes
<dt><br>_fmbsnbcpy (see <a href="#_mbsnbcpy">_mbsnbcpy</a>)
<dd>copy up to &quot;n&quot; bytes of a string
<dt><br>_fmbsnbicmp (see <a href="#_mbsnbicmp">_mbsnbicmp</a>)
<dd>compare up to &quot;n&quot; bytes in two strings with case insensitivity
<dt><br>_fmbsnbset (see <a href="#_mbsnbset">_mbsnbset</a>)
<dd>fill string with up to &quot;n&quot; bytes
<dt><br>_fmbsncat (see <a href="#strncat">strncat</a>)
<dd>concatenate two far strings, up to a maximum length
<dt><br>_fmbsnccnt (see <a href="#_mbsnccnt">_mbsnccnt</a>)
<dd>count the number of characters in the first &quot;n&quot; bytes
<dt><br>_fmbsncmp (see <a href="#strncmp">strncmp</a>)
<dd>compare two far strings up to maximum length
<dt><br>_fmbsncpy (see <a href="#strncpy">strncpy</a>)
<dd>copy a far string, up to a maximum length
<dt><br>_fmbsnextc (see <a href="#_mbsnextc">_mbsnextc</a>)
<dd>return integer value of the next multibyte-character in far string
<dt><br>_fmbsnicmp (see <a href="#strnicmp">strnicmp</a>)
<dd>compare two far strings with case insensitivity up to a maximum length
<dt><br>_fmbsninc (see <a href="#_strninc">_strninc</a>)
<dd>increment wide character far pointer by &quot;n&quot; characters
<dt><br>_fmbsnset (see <a href="#strnset">strnset</a>)
<dd>fill far string with character to a maximum length
<dt><br>_fmbspbrk (see <a href="#strpbrk">strpbrk</a>)
<dd>locate occurrence of a string within a second string
<dt><br>_fmbsrchr (see <a href="#strrchr">strrchr</a>)
<dd>locate last occurrence of character from a character set
<dt><br>_fmbsrev (see <a href="#strrev">strrev</a>)
<dd>reverse a far string in place
<dt><br>_fmbsrtowcs (see <a href="#mbsrtowcs">mbsrtowcs</a>)
<dd>convert multibyte character string to wide character string
<dt><br>_fmbsset (see <a href="#strset">strset</a>)
<dd>fill far string with a character
<dt><br>_fmbsspn (see <a href="#strspn">strspn</a>)
<dd>find number of characters at start of string which are also in a second string
<dt><br>_fmbsspnp (see <a href="#strspnp">strspnp</a>)
<dd>return far pointer to first character of far string not in set
<dt><br>_fmbsstr (see <a href="#strstr">strstr</a>)
<dd>find first occurrence of string in second string
<dt><br>_fmbstok (see <a href="#strtok">strtok</a>)
<dd>get next token from a far string
<dt><br>_fmbstowcs (see <a href="#mbstowcs">mbstowcs</a>)
<dd>convert multibyte character string to wide character string
<dt><br>_fmbsupr (see <a href="#strupr">strupr</a>)
<dd>convert far string to uppercase
<dt><br>_fmbterm (see <a href="#_mbterm">_mbterm</a>)
<dd>determine if next multibyte character in string is null
<dt><br>_fmbvtop (see <a href="#_mbvtop">_mbvtop</a>)
<dd>store multibyte character into far string
<dt><br>_fwcrtomb (see <a href="#wcrtomb">wcrtomb</a>)
<dd>convert wide character to multibyte character and store
<dt><br>_fwcsrtombs (see <a href="#wcsrtombs">wcsrtombs</a>)
<dd>convert far wide character string to far multibyte character string
<dt><br>_fwcstombs (see <a href="#wcstombs">wcstombs</a>)
<dd>convert far wide character string to far multibyte character string
<dt><br>_fwctomb (see <a href="#wctomb">wctomb</a>)
<dd>convert wide character to multibyte character
<dt><br>_mbscat (see <a href="#strcat">strcat</a>)
<dd>concatenate string
<dt><br>_mbschr (see <a href="#strchr">strchr</a>)
<dd>locate character in string
<dt><br>_mbscmp (see <a href="#strcmp">strcmp</a>)
<dd>compare two strings
<dt><br>_mbscoll (see <a href="#strcoll">strcoll</a>)
<dd>compare two strings using &quot;locale&quot; collating sequence
<dt><br>_mbscpy (see <a href="#strcpy">strcpy</a>)
<dd>copy a string
<dt><br>_mbscspn (see <a href="#strcspn">strcspn</a>)
<dd>get number of string characters not from a set of characters
<dt><br>_mbsdec (see <a href="#_strdec">_strdec</a>)
<dd>returns pointer to the previous character in string
<dt><br>_mbsdup (see <a href="#strdup">strdup</a>)
<dd>allocate and duplicate a string
<dt><br>_mbsicmp (see <a href="#stricmp">stricmp</a>)
<dd>compare two strings with case insensitivity
<dt><br>_mbsinc (see <a href="#_strinc">_strinc</a>)
<dd>return pointer to next character in string
<dt><br><a href="#mbsinit">mbsinit</a>
<dd>determine if mbstate_t object describes an initial conversion state
<dt><br>_mbslen (see <a href="#strlen">strlen</a>)
<dd>string length
<dt><br>_mbslwr (see <a href="#strlwr">strlwr</a>)
<dd>convert string to lowercase
<dt><br><a href="#_mbsnbcat">_mbsnbcat</a>
<dd>append up to &quot;n&quot; bytes of string to another string
<dt><br><a href="#_mbsnbcmp">_mbsnbcmp</a>
<dd>compare up to &quot;n&quot; bytes in two strings
<dt><br><a href="#_mbsnbcnt">_mbsnbcnt</a>
<dd>count the number of characters in the first &quot;n&quot; bytes
<dt><br><a href="#_mbsnbcpy">_mbsnbcpy</a>
<dd>copy up to &quot;n&quot; bytes of a string
<dt><br><a href="#_mbsnbicmp">_mbsnbicmp</a>
<dd>compare up to &quot;n&quot; bytes in two strings with case insensitivity
<dt><br><a href="#_mbsnbset">_mbsnbset</a>
<dd>fill string with up to &quot;n&quot; bytes
<dt><br>_mbsncat (see <a href="#strncat">strncat</a>)
<dd>concatenate two strings, up to a maximum length
<dt><br><a href="#_mbsnccnt">_mbsnccnt</a>
<dd>count the number of characters in the first &quot;n&quot; bytes
<dt><br>_mbsncmp (see <a href="#strncmp">strncmp</a>)
<dd>compare two strings up to maximum length
<dt><br>_mbsncpy (see <a href="#strncpy">strncpy</a>)
<dd>copy a string, up to a maximum length
<dt><br><a href="#_mbsnextc">_mbsnextc</a>
<dd>return integer value of the next multibyte-character in string
<dt><br>_mbsnicmp (see <a href="#strnicmp">strnicmp</a>)
<dd>compare two strings with case insensitivity up to a maximum length
<dt><br>_mbsninc (see <a href="#_strninc">_strninc</a>)
<dd>increment wide character pointer by &quot;n&quot; characters
<dt><br>_mbsnset (see <a href="#strnset">strnset</a>)
<dd>fill string with up to &quot;n&quot; multibyte characters
<dt><br>_mbspbrk (see <a href="#strpbrk">strpbrk</a>)
<dd>locate occurrence of a string within a second string
<dt><br>_mbsrchr (see <a href="#strrchr">strrchr</a>)
<dd>locate last occurrence of character from a character set
<dt><br>_mbsrev (see <a href="#strrev">strrev</a>)
<dd>reverse a string in place
<dt><br><a href="#mbsrtowcs">mbsrtowcs</a>
<dd>convert multibyte character string to wide character string
<dt><br>_mbsset (see <a href="#strset">strset</a>)
<dd>fill string with a character
<dt><br>_mbsspn (see <a href="#strspn">strspn</a>)
<dd>find number of characters at start of string which are also in a second string
<dt><br>_mbsspnp (see <a href="#strspnp">strspnp</a>)
<dd>return pointer to first character of string not in set
<dt><br>_mbsstr (see <a href="#strstr">strstr</a>)
<dd>find first occurrence of string in second string
<dt><br>_mbstok (see <a href="#strtok">strtok</a>)
<dd>get next token from string
<dt><br><a href="#mbstowcs">mbstowcs</a>
<dd>convert multibyte character string to wide character string
<dt><br>_mbsupr (see <a href="#strupr">strupr</a>)
<dd>convert string to uppercase
<dt><br><a href="#_mbterm">_mbterm</a>
<dd>determine if next multibyte character in string is null
<dt><br><a href="#_mbvtop">_mbvtop</a>
<dd>store multibyte character into string
<dt><br><a href="#wcrtomb">wcrtomb</a>
<dd>convert wide character to multibyte character and store
<dt><br><a href="#wcsrtombs">wcsrtombs</a>
<dd>convert wide character string to multibyte character string
<dt><br><a href="#wcstombs">wcstombs</a>
<dd>convert wide character string to multibyte character string
<dt><br><a href="#wctob">wctob</a>
<dd>return single-byte character version of wide character
<dt><br><a href="#wctomb">wctomb</a>
<dd>convert wide character to multibyte character
</dl>
<br>For related functions see the sections<b> Conversion Functions</b> (conversions to and from strings),<b> Time Functions</b>
 (formatting of dates and times), and<b> Memory Manipulation Functions</b> (operate on arrays without terminating null character).
<h3 id="Conversion_Functions"> Conversion Functions </h3>
<br>These functions perform conversions between objects of various types and strings.&nbsp; The following functions are defined:
<dl>
<dt><a href="#atof">atof</a>
<dd>string to &quot;double&quot;
<dt><br><a href="#atoi">atoi</a>
<dd>string to &quot;int&quot;
<dt><br><a href="#atol">atol</a>
<dd>string to &quot;long int&quot;
<dt><br><a href="#atoll">atoll</a>
<dd>string to &quot;long long int&quot;
<dt><br><a href="#ecvt">ecvt</a>
<dd>&quot;double&quot; to E-format string
<dt><br><a href="#fcvt">fcvt</a>
<dd>&quot;double&quot; to F-format string
<dt><br><a href="#gcvt">gcvt</a>
<dd>&quot;double&quot; to string
<dt><br><a href="#itoa">itoa</a>
<dd>&quot;int&quot; to string
<dt><br><a href="#lltoa">lltoa</a>
<dd>&quot;long long int&quot; to string
<dt><br><a href="#ltoa">ltoa</a>
<dd>&quot;long int&quot; to string
<dt><br><a href="#strtod">strtod</a>
<dd>string to &quot;double&quot;
<dt><br><a href="#strtol">strtol</a>
<dd>string to &quot;long int&quot;
<dt><br><a href="#strtoll">strtoll</a>
<dd>string to &quot;long long int&quot;
<dt><br><a href="#strtoul">strtoul</a>
<dd>string to &quot;unsigned long int&quot;
<dt><br><a href="#strtoull">strtoull</a>
<dd>string to &quot;unsigned long long int&quot;
<dt><br><a href="#ulltoa">ulltoa</a>
<dd>&quot;unsigned long long int&quot; to string
<dt><br><a href="#ultoa">ultoa</a>
<dd>&quot;unsigned long int&quot; to string
<dt><br><a href="#utoa">utoa</a>
<dd>&quot;unsigned int&quot; to string
</dl>
<br>These functions perform conversions between objects of various types and wide character strings.&nbsp; The following functions
 are defined:
<dl>
<dt>_itow (see <a href="#itoa">itoa</a>)
<dd>&quot;int&quot; to wide character string
<dt><br>_lltow (see <a href="#lltoa">lltoa</a>)
<dd>&quot;long long int&quot; to wide character string
<dt><br>_ltow (see <a href="#ltoa">ltoa</a>)
<dd>&quot;long int&quot; to wide character string
<dt><br>_ulltow (see <a href="#ulltoa">ulltoa</a>)
<dd>&quot;unsigned long long int&quot; to wide character string
<dt><br>_ultow (see <a href="#ultoa">ultoa</a>)
<dd>&quot;unsigned long int&quot; to wide character string
<dt><br>_utow (see <a href="#utoa">utoa</a>)
<dd>&quot;unsigned int&quot; to wide character string
<dt><br>wcstod (see <a href="#strtod">strtod</a>)
<dd>wide character string to &quot;double&quot;
<dt><br>wcstol (see <a href="#strtol">strtol</a>)
<dd>wide character string to &quot;long int&quot;
<dt><br>wcstoll (see <a href="#strtoll">strtoll</a>)
<dd>wide character string to &quot;long long int&quot;
<dt><br>wcstoul (see <a href="#strtoul">strtoul</a>)
<dd>wide character string to &quot;unsigned long int&quot;
<dt><br>wcstoull (see <a href="#strtoull">strtoull</a>)
<dd>wide character string to &quot;unsigned long long int&quot;
<dt><br>_wtof (see <a href="#atof">atof</a>)
<dd>wide character string to &quot;double&quot;
<dt><br>_wtoi (see <a href="#atoi">atoi</a>)
<dd>wide character string to &quot;int&quot;
<dt><br>_wtol (see <a href="#atol">atol</a>)
<dd>wide character string to &quot;long int&quot;
<dt><br>_wtoll (see <a href="#atoll">atoll</a>)
<dd>wide character string to &quot;long long int&quot;
</dl>
<br>See also <tt> tolower</tt>, <tt> towlower</tt>, <tt> _mbctolower</tt>, <tt> toupper</tt>, <tt> towupper</tt>, <tt> _mbctoupper</tt>,
 <tt> strlwr</tt>, <tt> _wcslwr</tt>, <tt> _mbslwr</tt>, <tt> strupr</tt>, <tt> _wcsupr</tt> and <tt> _mbsupr</tt> which convert
 the cases of characters and strings.
<h3 id="Memory_Allocation_Functions"> Memory Allocation Functions </h3>
<br>These functions allocate and de-allocate blocks of memory.
<br><br>Unless you are running your program in 32-bit protect mode, where segments have a limit of 4 gigabytes, the default
 data segment has a maximum size of 64K bytes.&nbsp; It may be less in a machine with insufficient memory or when other programs
 in the computer already occupy some of the memory.&nbsp; The <tt> _nmalloc</tt> function allocates space within this area
 while the <tt> _fmalloc</tt> function allocates space outside the area (if it is available).
<br><br>In a small data model, the <tt> malloc</tt>, <tt> calloc</tt> and <tt> realloc</tt> functions use the <tt> _nmalloc</tt>
 function to acquire memory; in a large data model, the <tt> _fmalloc</tt> function is used.
<br><br>It is also possible to allocate memory from a based heap using <tt> _bmalloc</tt>.&nbsp; Based heaps are similar to
 far heaps in that they are located outside the normal data segment.&nbsp; Based pointers only store the offset portion of
 the full address, so they behave much like near pointers.&nbsp; The selector portion of the full address specifies which
 based heap a based pointer belongs to, and must be passed to the various based heap functions.
<br><br>It is important to use the appropriate memory-deallocation function to free memory blocks.&nbsp; The <tt> _nfree</tt>
 function should be used to free space acquired by the <tt> _ncalloc</tt>, <tt> _nmalloc</tt>, or <tt> _nrealloc</tt> functions.
&nbsp; The <tt> _ffree</tt> function should be used to free space acquired by the <tt> _fcalloc</tt>, <tt> _fmalloc</tt>,
 or <tt> _frealloc</tt> functions.&nbsp; The <tt> _bfree</tt> function should be used to free space acquired by the <tt> _bcalloc</tt>,
 <tt> _bmalloc</tt>, or <tt> _brealloc</tt> functions.
<br><br>The <tt> free</tt> function will use the <tt> _nfree</tt> function when the small data memory model is used; it will
 use the <tt> _ffree</tt> function when the large data memory model is being used.
<br><br>It should be noted that the <tt> _fmalloc</tt> and <tt> _nmalloc</tt> functions can both be used in either data memory
 model.&nbsp; The following functions are defined:
<dl>
<dt><a href="#alloca">alloca</a>
<dd>allocate auto storage from stack
<dt><br>_bcalloc (see <a href="#calloc">calloc</a>)
<dd>allocate and zero memory from a based heap
<dt><br>_bexpand (see <a href="#_expand">_expand</a>)
<dd>expand a block of memory in a based heap
<dt><br>_bfree (see <a href="#free">free</a>)
<dd>free a block of memory in a based heap
<dt><br><a href="#_bfreeseg">_bfreeseg</a>
<dd>free a based heap
<dt><br><a href="#_bheapseg">_bheapseg</a>
<dd>allocate a based heap
<dt><br>_bmalloc (see <a href="#malloc">malloc</a>)
<dd>allocate a memory block from a based heap
<dt><br>_bmsize (see <a href="#_msize">_msize</a>)
<dd>return the size of a memory block
<dt><br>_brealloc (see <a href="#realloc">realloc</a>)
<dd>re-allocate a memory block in a based heap
<dt><br><a href="#calloc">calloc</a>
<dd>allocate and zero memory
<dt><br><a href="#_expand">_expand</a>
<dd>expand a block of memory
<dt><br>_fcalloc (see <a href="#calloc">calloc</a>)
<dd>allocate and zero a memory block (outside default data segment)
<dt><br>_fexpand (see <a href="#_expand">_expand</a>)
<dd>expand a block of memory (outside default data segment)
<dt><br>_ffree (see <a href="#free">free</a>)
<dd>free a block allocated using &quot;_fmalloc&quot;
<dt><br>_fmalloc (see <a href="#malloc">malloc</a>)
<dd>allocate a memory block (outside default data segment)
<dt><br>_fmsize (see <a href="#_msize">_msize</a>)
<dd>return the size of a memory block
<dt><br>_frealloc (see <a href="#realloc">realloc</a>)
<dd>re-allocate a memory block (outside default data segment)
<dt><br><a href="#free">free</a>
<dd>free a block allocated using &quot;malloc&quot;, &quot;calloc&quot; or &quot;realloc&quot;
<dt><br><a href="#_freect">_freect</a>
<dd>return number of objects that can be allocated
<dt><br><a href="#halloc">halloc</a>
<dd>allocate huge array
<dt><br><a href="#hfree">hfree</a>
<dd>free huge array
<dt><br><a href="#malloc">malloc</a>
<dd>allocate a memory block (using current memory model)
<dt><br><a href="#_memavl">_memavl</a>
<dd>return amount of available memory
<dt><br><a href="#_memmax">_memmax</a>
<dd>return largest block of memory available
<dt><br><a href="#_msize">_msize</a>
<dd>return the size of a memory block
<dt><br>_ncalloc (see <a href="#calloc">calloc</a>)
<dd>allocate and zero a memory block (inside default data segment)
<dt><br>_nexpand (see <a href="#_expand">_expand</a>)
<dd>expand a block of memory (inside default data segment)
<dt><br>_nfree (see <a href="#free">free</a>)
<dd>free a block allocated using &quot;_nmalloc&quot;
<dt><br>_nmalloc (see <a href="#malloc">malloc</a>)
<dd>allocate a memory block (inside default data segment)
<dt><br>_nmsize (see <a href="#_msize">_msize</a>)
<dd>return the size of a memory block
<dt><br>_nrealloc (see <a href="#realloc">realloc</a>)
<dd>re-allocate a memory block (inside default data segment)
<dt><br><a href="#realloc">realloc</a>
<dd>re-allocate a block of memory
<dt><br><a href="#sbrk">sbrk</a>
<dd>set allocation &quot;break&quot; position
<dt><br><a href="#stackavail">stackavail</a>
<dd>determine available amount of stack space
</dl>
<h3 id="Heap_Functions"> Heap Functions </h3>
<br>These functions provide the ability to shrink and grow the heap, as well as, find heap related problems.&nbsp; The following
 functions are defined:
<dl>
<dt><a href="#_heapchk">_heapchk</a>
<dd>perform consistency check on the heap
<dt><br>_bheapchk (see <a href="#_heapchk">_heapchk</a>)
<dd>perform consistency check on a based heap
<dt><br>_fheapchk (see <a href="#_heapchk">_heapchk</a>)
<dd>perform consistency check on the far heap
<dt><br>_nheapchk (see <a href="#_heapchk">_heapchk</a>)
<dd>perform consistency check on the near heap
<dt><br><a href="#_heapgrow">_heapgrow</a>
<dd>grow the heap
<dt><br>_fheapgrow (see <a href="#_heapgrow">_heapgrow</a>)
<dd>grow the far heap
<dt><br>_nheapgrow (see <a href="#_heapgrow">_heapgrow</a>)
<dd>grow the near heap up to its limit of 64K
<dt><br><a href="#_heapmin">_heapmin</a>
<dd>shrink the heap as small as possible
<dt><br>_bheapmin (see <a href="#_heapmin">_heapmin</a>)
<dd>shrink a based heap as small as possible
<dt><br>_fheapmin (see <a href="#_heapmin">_heapmin</a>)
<dd>shrink the far heap as small as possible
<dt><br>_nheapmin (see <a href="#_heapmin">_heapmin</a>)
<dd>shrink the near heap as small as possible
<dt><br><a href="#_heapset">_heapset</a>
<dd>fill unallocated sections of heap with pattern
<dt><br>_bheapset (see <a href="#_heapset">_heapset</a>)
<dd>fill unallocated sections of based heap with pattern
<dt><br>_fheapset (see <a href="#_heapset">_heapset</a>)
<dd>fill unallocated sections of far heap with pattern
<dt><br>_nheapset (see <a href="#_heapset">_heapset</a>)
<dd>fill unallocated sections of near heap with pattern
<dt><br><a href="#_heapshrink">_heapshrink</a>
<dd>shrink the heap as small as possible
<dt><br>_fheapshrink (see <a href="#_heapshrink">_heapshrink</a>)
<dd>shrink the far heap as small as possible
<dt><br>_bheapshrink (see <a href="#_heapshrink">_heapshrink</a>)
<dd>shrink a based heap as small as possible
<dt><br>_nheapshrink (see <a href="#_heapshrink">_heapshrink</a>)
<dd>shrink the near heap as small as possible
<dt><br><a href="#_heapwalk">_heapwalk</a>
<dd>walk through each entry in the heap
<dt><br>_bheapwalk (see <a href="#_heapwalk">_heapwalk</a>)
<dd>walk through each entry in a based heap
<dt><br>_fheapwalk (see <a href="#_heapwalk">_heapwalk</a>)
<dd>walk through each entry in the far heap
<dt><br>_nheapwalk (see <a href="#_heapwalk">_heapwalk</a>)
<dd>walk through each entry in the near heap
</dl>
<h3 id="Math_Functions"> Math Functions </h3>
<br>These functions operate with objects of type<tt> double,</tt> also known as floating-point numbers.&nbsp; The Intel 8087
 processor (and its successor chips) is commonly used to implement floating-point operations on personal computers.&nbsp;
 Functions ending in &quot;87&quot; pertain to this specific hardware and should be isolated in programs when portability
 is a consideration.&nbsp; The following functions are defined:
<dl>
<dt><a href="#abs">abs</a>
<dd>absolute value of an object of type &quot;int&quot;
<dt><br><a href="#acos">acos</a>
<dd>arccosine
<dt><br><a href="#acosh">acosh</a>
<dd>inverse hyperbolic cosine
<dt><br><a href="#asin">asin</a>
<dd>arcsine
<dt><br><a href="#asinh">asinh</a>
<dd>inverse hyperbolic sine
<dt><br><a href="#atan">atan</a>
<dd>arctangent of one argument
<dt><br><a href="#atan2">atan2</a>
<dd>arctangent of two arguments
<dt><br><a href="#atanh">atanh</a>
<dd>inverse hyperbolic tangent
<dt><br><a href="#bessel">bessel</a>
<dd>bessel functions j0, j1, jn, y0, y1, and yn
<dt><br><a href="#cabs">cabs</a>
<dd>absolute value of complex number
<dt><br><a href="#ceil">ceil</a>
<dd>ceiling function
<dt><br><a href="#_clear87">_clear87</a>
<dd>clears floating-point status
<dt><br><a href="#_control87">_control87</a>
<dd>sets new floating-point control word
<dt><br><a href="#cos">cos</a>
<dd>cosine
<dt><br><a href="#cosh">cosh</a>
<dd>hyperbolic cosine
<dt><br><a href="#div">div</a>
<dd>compute quotient, remainder from division of an &quot;int&quot; object
<dt><br><a href="#exp">exp</a>
<dd>exponential function
<dt><br><a href="#fabs">fabs</a>
<dd>absolute value of &quot;double&quot;
<dt><br><a href="#_finite">_finite</a>
<dd>determines whether floating-point value is valid
<dt><br><a href="#floor">floor</a>
<dd>floor function
<dt><br><a href="#fmod">fmod</a>
<dd>modulus function
<dt><br><a href="#_fpreset">_fpreset</a>
<dd>initializes for floating-point operations
<dt><br><a href="#frexp">frexp</a>
<dd>fractional exponent
<dt><br><a href="#hypot">hypot</a>
<dd>compute hypotenuse
<dt><br><a href="#imaxabs">imaxabs</a>
<dd>get quotient, remainder from division of object of maximum-size integer type
<dt><br><a href="#imaxdiv">imaxdiv</a>
<dd>absolute value of an object of maximum-size integer type
<dt><br>j0 (see <a href="#bessel">bessel</a>)
<dd>return Bessel functions of the first kind (described under &quot;bessel Functions&quot;)
<dt><br>j1 (see <a href="#bessel">bessel</a>)
<dd>return Bessel functions of the first kind (described under &quot;bessel Functions&quot;)
<dt><br>jn (see <a href="#bessel">bessel</a>)
<dd>return Bessel functions of the first kind (described under &quot;bessel Functions&quot;)
<dt><br><a href="#labs">labs</a>
<dd>absolute value of an object of type &quot;long int&quot;
<dt><br><a href="#ldexp">ldexp</a>
<dd>multiply by a power of two
<dt><br><a href="#ldiv">ldiv</a>
<dd>get quotient, remainder from division of object of type &quot;long int&quot;
<dt><br><a href="#log">log</a>
<dd>natural logarithm
<dt><br><a href="#log10">log10</a>
<dd>logarithm, base 10
<dt><br><a href="#log2">log2</a>
<dd>logarithm, base 2
<dt><br><a href="#matherr">matherr</a>
<dd>handles error from math functions
<dt><br><a href="#max">max</a>
<dd>return maximum of two arguments
<dt><br><a href="#min">min</a>
<dd>return minimum of two arguments
<dt><br><a href="#modf">modf</a>
<dd>get integral, fractional parts of &quot;double&quot;
<dt><br><a href="#pow">pow</a>
<dd>raise to power
<dt><br><a href="#rand">rand</a>
<dd>random integer
<dt><br><a href="#_set_matherr">_set_matherr</a>
<dd>specify a math error handler
<dt><br><a href="#sin">sin</a>
<dd>sine
<dt><br><a href="#sinh">sinh</a>
<dd>hyperbolic sine
<dt><br><a href="#sqrt">sqrt</a>
<dd>square root
<dt><br><a href="#srand">srand</a>
<dd>set starting point for generation of random numbers using &quot;rand&quot; function
<dt><br><a href="#_status87">_status87</a>
<dd>gets floating-point status
<dt><br><a href="#tan">tan</a>
<dd>tangent
<dt><br><a href="#tanh">tanh</a>
<dd>hyperbolic tangent
<dt><br>y0 (see <a href="#bessel">bessel</a>)
<dd>return Bessel functions of the second kind (described under &quot;bessel&quot;)
<dt><br>y1 (see <a href="#bessel">bessel</a>)
<dd>return Bessel functions of the second kind (described under &quot;bessel&quot;)
<dt><br>yn (see <a href="#bessel">bessel</a>)
<dd>return Bessel functions of the second kind (described under &quot;bessel&quot;)
</dl>
<h3 id="Searching_Functions"> Searching Functions </h3>
<br>These functions provide searching and sorting capabilities.&nbsp; The following functions are defined:
<dl>
<dt><a href="#bsearch">bsearch</a>
<dd>find a data item in an array using binary search
<dt><br><a href="#lfind">lfind</a>
<dd>find a data item in an array using linear search
<dt><br><a href="#lsearch">lsearch</a>
<dd>linear search array, add item if not found
<dt><br><a href="#qsort">qsort</a>
<dd>sort an array
</dl>
<h3 id="Time_Functions"> Time Functions </h3>
<br>These functions are concerned with dates and times.&nbsp; The following functions are defined:
<dl>
<dt><a href="#asctime">asctime</a>
<dd>makes time string from time structure
<dt><br>_asctime (see <a href="#asctime">asctime</a>)
<dd>makes time string from time structure
<dt><br>_wasctime (see <a href="#asctime">asctime</a>)
<dd>makes time string from time structure
<dt><br>__wasctime (see <a href="#asctime">asctime</a>)
<dd>makes time string from time structure
<dt><br><a href="#clock">clock</a>
<dd>gets time since program start
<dt><br><a href="#ctime">ctime</a>
<dd>gets calendar time string
<dt><br>_ctime (see <a href="#ctime">ctime</a>)
<dd>gets calendar time string
<dt><br>_wctime (see <a href="#ctime">ctime</a>)
<dd>gets calendar time string
<dt><br>__wctime (see <a href="#ctime">ctime</a>)
<dd>gets calendar time string
<dt><br><a href="#difftime">difftime</a>
<dd>calculate difference between two times
<dt><br><a href="#ftime">ftime</a>
<dd>returns the current time in a &quot;timeb&quot; structure
<dt><br><a href="#gmtime">gmtime</a>
<dd>convert calendar time to Coordinated Universal Time (UTC)
<dt><br>_gmtime (see <a href="#gmtime">gmtime</a>)
<dd>convert calendar time to Coordinated Universal Time (UTC)
<dt><br><a href="#localtime">localtime</a>
<dd>convert calendar time to local time
<dt><br>_localtime (see <a href="#localtime">localtime</a>)
<dd>convert calendar time to local time
<dt><br><a href="#mktime">mktime</a>
<dd>make calendar time from local time
<dt><br><a href="#_strdate">_strdate</a>
<dd>return date in buffer
<dt><br><a href="#strftime">strftime</a>
<dd>format date and time
<dt><br>wcsftime (see <a href="#strftime">strftime</a>)
<dd>format date and time
<dt><br>_wstrftime_ms (see <a href="#strftime">strftime</a>)
<dd>format date and time
<dt><br><a href="#_strtime">_strtime</a>
<dd>return time in buffer
<dt><br>_wstrtime (see <a href="#_strtime">_strtime</a>)
<dd>return time in buffer
<dt><br><a href="#time">time</a>
<dd>get current calendar time
<dt><br><a href="#tzset">tzset</a>
<dd>set global variables to reflect the local time zone
<dt><br>_wstrdate (see <a href="#_strdate">_strdate</a>)
<dd>return date in buffer
</dl>
<h3 id="VariableMlength_Argument_Lists"> Variable-length Argument Lists </h3>
<br>Variable-length argument lists are used when a function does not have a fixed number of arguments.&nbsp; These macros
 provide the capability to access these arguments.&nbsp; The following functions are defined:
<dl>
<dt><a href="#va_arg">va_arg</a>
<dd>get next variable argument
<dt><br><a href="#va_end">va_end</a>
<dd>complete access of variable arguments
<dt><br><a href="#va_start">va_start</a>
<dd>start access of variable arguments
</dl>
<h3 id="Stream_IDO_Functions"> Stream I/O Functions </h3>
<br>A<b> stream</b> is the name given to a file or device which has been opened for data transmission.&nbsp; When a stream
 is opened, a pointer to a <tt> FILE</tt> structure is returned.&nbsp; This pointer is used to reference the stream when other
 functions are subsequently invoked.
<br><br>There are two modes by which data can be transmitted:
<dl>
<dt>binary
<dd>Data is transmitted unchanged.
<dt><br>text
<dd>On input, carriage-return characters are removed before following linefeed characters.&nbsp; On output, carriage-return characters
 are inserted before linefeed characters.
</dl>
<br>These modes are required since text files are stored with the two characters delimiting a line of text, while the C convention
 is for only the linefeed character to delimit a text line.
<br><br>When a program begins execution, there are a number of streams already open for use:
<dl>
<dt>stdin
<dd>Standard Input:&nbsp; input from the console
<dt><br>stdout
<dd>Standard Output:&nbsp; output to the console 
<dt><br>stderr
<dd>Standard Error:&nbsp; output to the console (used for error messages)
<dt><br>stdaux
<dd>Standard Auxiliary:&nbsp; auxiliary port, available for use by a program (not available in some Windows platforms)
<dt><br>stdprn
<dd>Standard Printer:&nbsp; available for use by a program (not available in some Windows platforms)
</dl>
<br>These standard streams may be re-directed by use of the <tt> freopen</tt> function.
<br><br>See also the section<b> File Manipulation Functions</b> for other functions which operate upon files.
<br><br>The functions referenced in the section<b> Operating System I/O Functions</b> may also be invoked (use the <tt> fileno</tt>
 function to obtain the file handle).&nbsp; Since the stream functions may buffer input and output, these functions should
 be used with caution to avoid unexpected results.
<br><br>The following functions are defined:
<dl>
<dt><a href="#clearerr">clearerr</a>
<dd>clear end-of-file and error indicators for stream
<dt><br><a href="#fclose">fclose</a>
<dd>close stream
<dt><br><a href="#fcloseall">fcloseall</a>
<dd>close all open streams
<dt><br><a href="#fdopen">fdopen</a>
<dd>open stream, given handle
<dt><br><a href="#feof">feof</a>
<dd>test for end of file
<dt><br><a href="#ferror">ferror</a>
<dd>test for file error
<dt><br><a href="#fflush">fflush</a>
<dd>flush output buffer
<dt><br><a href="#fgetc">fgetc</a>
<dd>get next character from file
<dt><br>_fgetchar (see <a href="#fgetchar">fgetchar</a>)
<dd>equivalent to &quot;fgetc&quot; with the argument &quot;stdin&quot;
<dt><br><a href="#fgetpos">fgetpos</a>
<dd>get current file position
<dt><br><a href="#fgets">fgets</a>
<dd>get a string
<dt><br><a href="#flushall">flushall</a>
<dd>flush output buffers for all streams
<dt><br><a href="#fopen">fopen</a>
<dd>open a stream
<dt><br><a href="#fprintf">fprintf</a>
<dd>format output
<dt><br><a href="#fputc">fputc</a>
<dd>write a character
<dt><br>_fputchar (see <a href="#fputchar">fputchar</a>)
<dd>write a character to the &quot;stdout&quot; stream
<dt><br><a href="#fputs">fputs</a>
<dd>write a string
<dt><br><a href="#fread">fread</a>
<dd>read a number of objects
<dt><br><a href="#freopen">freopen</a>
<dd>re-opens a stream
<dt><br><a href="#fscanf">fscanf</a>
<dd>scan input according to format
<dt><br><a href="#fseek">fseek</a>
<dd>set current file position, relative
<dt><br><a href="#fsetpos">fsetpos</a>
<dd>set current file position, absolute
<dt><br><a href="#_fsopen">_fsopen</a>
<dd>open a shared stream
<dt><br><a href="#ftell">ftell</a>
<dd>get current file position
<dt><br><a href="#fwrite">fwrite</a>
<dd>write a number of objects
<dt><br><a href="#getc">getc</a>
<dd>read character
<dt><br><a href="#getchar">getchar</a>
<dd>get next character from &quot;stdin&quot;
<dt><br><a href="#gets">gets</a>
<dd>get string from &quot;stdin&quot;
<dt><br><a href="#_getw">_getw</a>
<dd>read int from stream file
<dt><br><a href="#perror">perror</a>
<dd>write error message to &quot;stderr&quot; stream
<dt><br><a href="#printf">printf</a>
<dd>format output to &quot;stdout&quot;
<dt><br><a href="#putc">putc</a>
<dd>write character to file
<dt><br><a href="#putchar">putchar</a>
<dd>write character to &quot;stdout&quot;
<dt><br><a href="#puts">puts</a>
<dd>write string to &quot;stdout&quot;
<dt><br><a href="#_putw">_putw</a>
<dd>write int to stream file
<dt><br><a href="#rewind">rewind</a>
<dd>position to start of file
<dt><br><a href="#scanf">scanf</a>
<dd>scan input from &quot;stdin&quot; under format control
<dt><br><a href="#setbuf">setbuf</a>
<dd>set buffer
<dt><br><a href="#setvbuf">setvbuf</a>
<dd>set buffering
<dt><br><a href="#tmpfile">tmpfile</a>
<dd>create temporary file
<dt><br><a href="#ungetc">ungetc</a>
<dd>push character back on input stream
<dt><br><a href="#vfprintf">vfprintf</a>
<dd>same as &quot;fprintf&quot; but with variable arguments
<dt><br><a href="#vfscanf">vfscanf</a>
<dd>same as &quot;fscanf&quot; but with variable arguments
<dt><br><a href="#vprintf">vprintf</a>
<dd>same as &quot;printf&quot; but with variable arguments
<dt><br><a href="#vscanf">vscanf</a>
<dd>same as &quot;scanf&quot; but with variable arguments
</dl>
<br>See the section<b> Directory Functions</b> for functions which are related to directories.
<h3 id="Wide_Character_Stream_IDO_Functions"> Wide Character Stream I/O Functions </h3>
<br>The previous section describes some general aspects of stream input/output.&nbsp; The following describes functions dealing
 with streams containing multibyte character sequences.
<br><br>After a stream is associated with an external file, but before any operations are performed on it, the stream is without
 orientation.&nbsp; Once a wide character input/output function has been applied to a stream without orientation, the stream
 becomes<b> wide-oriented.</b>&nbsp; Similarly, once a byte input/output function has been applied to a stream without orientation,
 the stream becomes<b> byte-oriented.</b>&nbsp; Only a successful call to <tt> freopen</tt> can otherwise alter the orientation
 of a stream (it removes any orientation).&nbsp; You cannot mix byte input/output functions and wide character input/output
 functions on the same stream.
<br><br>A file positioning function can cause the next wide character output function to overwrite a partial multibyte character.
&nbsp; This can lead to the subsequent reading of a stream of multibyte characters containing an invalid character.
<br><br>When multibyte characters are read from a stream, they are converted to wide characters.&nbsp; Similarly, when wide
 characters are written to a stream, they are converted to multibyte characters.
<br><br>The following functions are defined:
<dl>
<dt>fgetwc (see <a href="#fgetc">fgetc</a>)
<dd>get next wide character from file
<dt><br>_fgetwchar (see <a href="#fgetchar">fgetchar</a>)
<dd>equivalent to &quot;fgetwc&quot; with the argument &quot;stdin&quot;
<dt><br>fgetws (see <a href="#fgets">fgets</a>)
<dd>get a wide character string
<dt><br><a href="#fprintf">fprintf</a>
<dd>&quot;C&quot; and &quot;S&quot; extensions to the format specifier
<dt><br>fputwc (see <a href="#fputc">fputc</a>)
<dd>write a wide character
<dt><br>_fputwchar (see <a href="#fputchar">fputchar</a>)
<dd>write a character to the &quot;stdout&quot; stream
<dt><br>fputws (see <a href="#fputs">fputs</a>)
<dd>write a wide character string
<dt><br><a href="#fscanf">fscanf</a>
<dd>&quot;C&quot; and &quot;S&quot; extensions to the format specifier
<dt><br>fwprintf (see <a href="#fprintf">fprintf</a>)
<dd>formatted wide character output
<dt><br>fwscanf (see <a href="#fscanf">fscanf</a>)
<dd>scan wide character input according to format
<dt><br>getwc (see <a href="#getc">getc</a>)
<dd>read wide character
<dt><br>getwchar (see <a href="#getchar">getchar</a>)
<dd>get next wide character from &quot;stdin&quot;
<dt><br>_getws (see <a href="#gets">gets</a>)
<dd>get wide character string from &quot;stdin&quot;
<dt><br>putwc (see <a href="#putc">putc</a>)
<dd>write wide character to file
<dt><br>putwchar (see <a href="#putchar">putchar</a>)
<dd>write wide character to &quot;stdout&quot;
<dt><br>_putws (see <a href="#puts">puts</a>)
<dd>write wide character string to &quot;stdout&quot;
<dt><br>ungetwc (see <a href="#ungetc">ungetc</a>)
<dd>push wide character back on input stream
<dt><br>vfwprintf (see <a href="#vfprintf">vfprintf</a>)
<dd>same as &quot;fwprintf&quot; but with variable arguments
<dt><br>vfwscanf (see <a href="#vfscanf">vfscanf</a>)
<dd>same as &quot;fwscanf&quot; but with variable arguments
<dt><br>vswprintf (see <a href="#vsprintf">vsprintf</a>)
<dd>same as &quot;swprintf&quot; but with variable arguments
<dt><br>vwprintf (see <a href="#vprintf">vprintf</a>)
<dd>same as &quot;wprintf&quot; but with variable arguments
<dt><br>vwscanf (see <a href="#vscanf">vscanf</a>)
<dd>same as &quot;wscanf&quot; but with variable arguments
<dt><br>_wfdopen (see <a href="#fdopen">fdopen</a>)
<dd>open stream, given handle using a wide character &quot;mode&quot;
<dt><br>_wfopen (see <a href="#fopen">fopen</a>)
<dd>open a stream using wide character arguments
<dt><br>_wfreopen (see <a href="#freopen">freopen</a>)
<dd>re-opens a stream using wide character arguments
<dt><br>_wfsopen (see <a href="#_fsopen">_fsopen</a>)
<dd>open a shared stream using wide character arguments
<dt><br>_wperror (see <a href="#perror">perror</a>)
<dd>write error message to &quot;stderr&quot; stream
<dt><br>wprintf (see <a href="#printf">printf</a>)
<dd>format wide character output to &quot;stdout&quot;
<dt><br>wscanf (see <a href="#scanf">scanf</a>)
<dd>scan wide character input from &quot;stdin&quot; under format control
</dl>
<br>See the section<b> Directory Functions</b> for functions which are related to directories.
<h3 id="Process_Primitive_Functions"> Process Primitive Functions </h3>
<br>These functions deal with process creation, execution and termination, signal handling, and timer operations.
<br><br>When a new process is started, it may replace the existing process
<ul>
<li><tt> P_OVERLAY</tt> is specified with the <tt> spawn...</tt>&nbsp; functions
<li>the <tt> exec...</tt>&nbsp; routines are invoked
</ul>
<br>or the existing process may be suspended while the new process executes (control continues at the point following the
 place where the new process was started)
<ul>
<li><tt> P_WAIT</tt> is specified with the <tt> spawn...</tt>&nbsp; functions
<li><tt> system</tt> is used
</ul>
<br>The following functions are defined:
<dl>
<dt><a href="#abort">abort</a>
<dd>immediate termination of process, return code 3
<dt><br><a href="#atexit">atexit</a>
<dd>register exit routine
<dt><br><a href="#_beginthread">_beginthread</a>
<dd>start a new thread of execution
<dt><br><a href="#cwait">cwait</a>
<dd>wait for a child process to terminate
<dt><br><a href="#delay">delay</a>
<dd>delay for number of milliseconds
<dt><br><a href="#_endthread">_endthread</a>
<dd>end the current thread
<dt><br>execl (see <a href="#exec___">exec...</a>)
<dd>chain to program
<dt><br>execle (see <a href="#exec___">exec...</a>)
<dd>chain to program, pass environment
<dt><br>execlp (see <a href="#exec___">exec...</a>)
<dd>chain to program
<dt><br>execlpe (see <a href="#exec___">exec...</a>)
<dd>chain to program, pass environment
<dt><br>execv (see <a href="#exec___">exec...</a>)
<dd>chain to program
<dt><br>execve (see <a href="#exec___">exec...</a>)
<dd>chain to program, pass environment
<dt><br>execvp (see <a href="#exec___">exec...</a>)
<dd>chain to program
<dt><br>execvpe (see <a href="#exec___">exec...</a>)
<dd>chain to program, pass environment
<dt><br><a href="#exit">exit</a>
<dd>exit process, set return code
<dt><br><a href="#_Exit">_Exit</a>
<dd>exit process, set return code
<dt><br>_exit (see <a href="#_Exit">_Exit</a>)
<dd>exit process, set return code
<dt><br><a href="#onexit">onexit</a>
<dd>register exit routine
<dt><br><a href="#raise">raise</a>
<dd>signal an exceptional condition
<dt><br><a href="#signal">signal</a>
<dd>set handling for exceptional condition
<dt><br><a href="#sleep">sleep</a>
<dd>delay for number of seconds
<dt><br>spawnl (see <a href="#spawn___">spawn...</a>)
<dd>create process
<dt><br>spawnle (see <a href="#spawn___">spawn...</a>)
<dd>create process, set environment
<dt><br>spawnlp (see <a href="#spawn___">spawn...</a>)
<dd>create process
<dt><br>spawnlpe (see <a href="#spawn___">spawn...</a>)
<dd>create process, set environment
<dt><br>spawnv (see <a href="#spawn___">spawn...</a>)
<dd>create process
<dt><br>spawnve (see <a href="#spawn___">spawn...</a>)
<dd>create process, set environment
<dt><br>spawnvp (see <a href="#spawn___">spawn...</a>)
<dd>create process
<dt><br>spawnvpe (see <a href="#spawn___">spawn...</a>)
<dd>create process, set environment
<dt><br><a href="#system">system</a>
<dd>execute system command
<dt><br><a href="#wait">wait</a>
<dd>wait for any child process to terminate
<dt><br>_wexecl (see <a href="#exec___">exec...</a>)
<dd>chain to program
<dt><br>_wexecle (see <a href="#exec___">exec...</a>)
<dd>chain to program, pass environment
<dt><br>_wexeclp (see <a href="#exec___">exec...</a>)
<dd>chain to program
<dt><br>_wexeclpe (see <a href="#exec___">exec...</a>)
<dd>chain to program, pass environment
<dt><br>_wexecv (see <a href="#exec___">exec...</a>)
<dd>chain to program
<dt><br>_wexecve (see <a href="#exec___">exec...</a>)
<dd>chain to program, pass environment
<dt><br>_wexecvp (see <a href="#exec___">exec...</a>)
<dd>chain to program
<dt><br>_wexecvpe (see <a href="#exec___">exec...</a>)
<dd>chain to program, pass environment
<dt><br>_wspawnl (see <a href="#spawn___">spawn...</a>)
<dd>create process
<dt><br>_wspawnle (see <a href="#spawn___">spawn...</a>)
<dd>create process, set environment
<dt><br>_wspawnlp (see <a href="#spawn___">spawn...</a>)
<dd>create process
<dt><br>_wspawnlpe (see <a href="#spawn___">spawn...</a>)
<dd>create process, set environment
<dt><br>_wspawnv (see <a href="#spawn___">spawn...</a>)
<dd>create process
<dt><br>_wspawnve (see <a href="#spawn___">spawn...</a>)
<dd>create process, set environment
<dt><br>_wspawnvp (see <a href="#spawn___">spawn...</a>)
<dd>create process
<dt><br>_wspawnvpe (see <a href="#spawn___">spawn...</a>)
<dd>create process, set environment
<dt><br>_wsystem (see <a href="#system">system</a>)
<dd>execute system command
</dl>
<br>There are eight <tt> spawn...</tt>&nbsp; and <tt> exec...</tt>&nbsp; functions each.&nbsp; The<tt> &quot;...&quot;</tt>
 is one to three letters:
<ul>
<li>&quot;l&quot; or &quot;v&quot; (one is required) to indicate the way the process parameters are passed
<li>&quot;p&quot; (optional) to indicate whether the<b> PATH</b> environment variable is searched to locate the program for
 the process
<li>&quot;e&quot; (optional) to indicate that the environment variables are being passed
</ul>
<h3 id="Process_Environment"> Process Environment </h3>
<br>These functions deal with process identification, process groups, system identification, system time, environment variables,
 and terminal identification.&nbsp; The following functions are defined:
<dl>
<dt><a href="#_bgetcmd">_bgetcmd</a>
<dd>get command line
<dt><br><a href="#clearenv">clearenv</a>
<dd>delete environment variables
<dt><br><a href="#getcmd">getcmd</a>
<dd>get command line
<dt><br><a href="#getpid">getpid</a>
<dd>return process ID of calling process
<dt><br><a href="#getenv">getenv</a>
<dd>get environment variable value
<dt><br><a href="#isatty">isatty</a>
<dd>determine if file descriptor associated with a terminal
<dt><br><a href="#putenv">putenv</a>
<dd>add, change or delete environment variable
<dt><br><a href="#_searchenv">_searchenv</a>
<dd>search for a file in list of directories
<dt><br><a href="#setenv">setenv</a>
<dd>add, change or delete environment variable
<dt><br>_wgetenv (see <a href="#getenv">getenv</a>)
<dd>get environment variable value
<dt><br>_wputenv (see <a href="#putenv">putenv</a>)
<dd>add, change or delete environment variable
<dt><br>_wsearchenv (see <a href="#_searchenv">_searchenv</a>)
<dd>search for a file in list of directories
<dt><br>_wsetenv (see <a href="#setenv">setenv</a>)
<dd>add, change or delete environment variable
</dl>
<h3 id="Directory_Functions"> Directory Functions </h3>
<br>These functions pertain to directory manipulation.&nbsp; The following functions are defined:
<dl>
<dt><a href="#chdir">chdir</a>
<dd>change current working directory
<dt><br><a href="#closedir">closedir</a>
<dd>close opened directory file
<dt><br><a href="#getcwd">getcwd</a>
<dd>get current working directory
<dt><br><a href="#_getdcwd">_getdcwd</a>
<dd>get current directory on drive
<dt><br><a href="#mkdir">mkdir</a>
<dd>make a new directory
<dt><br><a href="#opendir">opendir</a>
<dd>open directory file
<dt><br><a href="#readdir">readdir</a>
<dd>read file name from directory
<dt><br><a href="#rewinddir">rewinddir</a>
<dd>reset position of directory stream
<dt><br><a href="#rmdir">rmdir</a>
<dd>remove a directory
<dt><br>_wchdir (see <a href="#chdir">chdir</a>)
<dd>change current working directory
<dt><br>_wclosedir (see <a href="#closedir">closedir</a>)
<dd>close opened directory file
<dt><br>_wgetcwd (see <a href="#getcwd">getcwd</a>)
<dd>get current working directory
<dt><br>_wgetdcwd (see <a href="#_getdcwd">_getdcwd</a>)
<dd>get current directory on drive
<dt><br>_wmkdir (see <a href="#mkdir">mkdir</a>)
<dd>make a new directory
<dt><br>_wopendir (see <a href="#opendir">opendir</a>)
<dd>open directory file
<dt><br>_wreaddir (see <a href="#readdir">readdir</a>)
<dd>read file name from directory
<dt><br>_wrewinddir (see <a href="#rewinddir">rewinddir</a>)
<dd>reset position of directory stream
<dt><br>_wrmdir (see <a href="#rmdir">rmdir</a>)
<dd>remove a directory
</dl>
<h3 id="Operating_System_IDO_Functions"> Operating System I/O Functions </h3>
<br>These functions operate at the operating-system level and are included for compatibility with other C implementations.
&nbsp; It is recommended that the functions used in the section<b> File Manipulation Functions</b> be used for new programs,
 as these functions are defined portably and are part of the ANSI standard for the C language.
<br><br>The functions in this section reference opened files and devices using a<b> file handle</b> which is returned when
 the file is opened.&nbsp; The file handle is passed to the other functions.
<br><br>The following functions are defined:
<dl>
<dt><a href="#chsize">chsize</a>
<dd>change the size of a file
<dt><br><a href="#close">close</a>
<dd>close file
<dt><br><a href="#_commit">_commit</a>
<dd>commit changes to disk
<dt><br><a href="#creat">creat</a>
<dd>create a file
<dt><br><a href="#dup">dup</a>
<dd>duplicate file handle, get unused handle number
<dt><br><a href="#dup2">dup2</a>
<dd>duplicate file handle, supply new handle number
<dt><br><a href="#eof">eof</a>
<dd>test for end of file
<dt><br><a href="#filelength">filelength</a>
<dd>get file size
<dt><br><a href="#fileno">fileno</a>
<dd>get file handle for stream file
<dt><br><a href="#fstat">fstat</a>
<dd>get file status
<dt><br><a href="#fsync">fsync</a>
<dd>write queued file and filesystem data to disk
<dt><br><a href="#_hdopen">_hdopen</a>
<dd>get POSIX handle from OS handle
<dt><br><a href="#lock">lock</a>
<dd>lock a section of a file
<dt><br><a href="#locking">locking</a>
<dd>lock/unlock a section of a file
<dt><br><a href="#lseek">lseek</a>
<dd>set current file position
<dt><br><a href="#open">open</a>
<dd>open a file
<dt><br><a href="#_os_handle">_os_handle</a>
<dd>get OS handle from POSIX handle
<dt><br><a href="#read">read</a>
<dd>read a record
<dt><br><a href="#setmode">setmode</a>
<dd>set file mode
<dt><br><a href="#sopen">sopen</a>
<dd>open a file for shared access
<dt><br><a href="#tell">tell</a>
<dd>get current file position
<dt><br><a href="#umask">umask</a>
<dd>set file permission mask
<dt><br><a href="#unlink">unlink</a>
<dd>delete a file
<dt><br><a href="#unlock">unlock</a>
<dd>unlock a section of a file
<dt><br><a href="#write">write</a>
<dd>write a record
<dt><br>_wcreat (see <a href="#creat">creat</a>)
<dd>create a file
<dt><br>_wopen (see <a href="#open">open</a>)
<dd>open a file
<dt><br>_wpopen (see <a href="#_popen">_popen</a>)
<dd>open a pipe
<dt><br>_wsopen (see <a href="#sopen">sopen</a>)
<dd>open a file for shared access
<dt><br>_wunlink (see <a href="#unlink">unlink</a>)
<dd>delete a file
</dl>
<h3 id="File_Manipulation_Functions"> File Manipulation Functions </h3>
<br>These functions operate directly with files.&nbsp; The following functions are defined:
<dl>
<dt><a href="#access">access</a>
<dd>test file or directory for mode of access
<dt><br><a href="#chmod">chmod</a>
<dd>change permissions for a file
<dt><br>lstat (see <a href="#stat">stat</a>)
<dd>get file status
<dt><br><a href="#remove">remove</a>
<dd>delete a file
<dt><br><a href="#rename">rename</a>
<dd>rename a file
<dt><br><a href="#stat">stat</a>
<dd>get file status
<dt><br><a href="#tmpnam">tmpnam</a>
<dd>create name for temporary file
<dt><br><a href="#utime">utime</a>
<dd>set modification time for a file
<dt><br>_waccess (see <a href="#access">access</a>)
<dd>test file or directory for mode of access
<dt><br>_wchmod (see <a href="#chmod">chmod</a>)
<dd>change permissions for a file
<dt><br>_wremove (see <a href="#remove">remove</a>)
<dd>delete a file
<dt><br>_wrename (see <a href="#rename">rename</a>)
<dd>rename a file
<dt><br>_wstat (see <a href="#stat">stat</a>)
<dd>get file status
<dt><br>_wtmpnam (see <a href="#tmpnam">tmpnam</a>)
<dd>create name for temporary file
<dt><br>_wutime (see <a href="#utime">utime</a>)
<dd>set modification time for a file
</dl>
<h3 id="Console_IDO_Functions"> Console I/O Functions </h3>
<br>These functions provide the capability to read and write data from the console.&nbsp; Data is read or written without
 any special initialization (devices are not opened or closed), since the functions operate at the hardware level.
<br><br>The following functions are defined:
<dl>
<dt><a href="#cgets">cgets</a>
<dd>get a string from the console
<dt><br><a href="#cprintf">cprintf</a>
<dd>print formatted string to the console
<dt><br><a href="#cputs">cputs</a>
<dd>write a string to the console
<dt><br><a href="#cscanf">cscanf</a>
<dd>scan formatted data from the console
<dt><br><a href="#getch">getch</a>
<dd>get character from console, no echo
<dt><br><a href="#getche">getche</a>
<dd>get character from console, echo it
<dt><br><a href="#kbhit">kbhit</a>
<dd>test if keystroke available
<dt><br><a href="#putch">putch</a>
<dd>write a character to the console
<dt><br><a href="#ungetch">ungetch</a>
<dd>push back next character from console
</dl>
<h3 id="Default_Windowing_Functions"> Default Windowing Functions </h3>
<br>These functions provide the capability to manipulate attributes of various windows created by Watcom's default windowing
 system for Microsoft Windows and IBM OS/2.
<br><br>The following functions are defined:
<dl>
<dt><a href="#_dwDeleteOnClose">_dwDeleteOnClose</a>
<dd>delete console window upon close
<dt><br><a href="#_dwSetAboutDlg">_dwSetAboutDlg</a>
<dd>set about dialogue box title and contents
<dt><br><a href="#_dwSetAppTitle">_dwSetAppTitle</a>
<dd>set main window's application title
<dt><br><a href="#_dwSetConTitle">_dwSetConTitle</a>
<dd>set console window's title
<dt><br><a href="#_dwShutDown">_dwShutDown</a>
<dd>shut down default windowing system
<dt><br><a href="#_dwYield">_dwYield</a>
<dd>yield control to other processes
</dl>
<h3 id="BIOS_Functions"> BIOS Functions </h3>
<br>This set of functions allows access to services provided by the BIOS.&nbsp; The following functions are defined:
<dl>
<dt><a href="#_bios_disk">_bios_disk</a>
<dd>provide disk access functions
<dt><br><a href="#_bios_equiplist">_bios_equiplist</a>
<dd>determine equipment list
<dt><br><a href="#_bios_keybrd">_bios_keybrd</a>
<dd>provide low-level keyboard access
<dt><br><a href="#_bios_memsize">_bios_memsize</a>
<dd>determine amount of system board memory
<dt><br><a href="#_bios_printer">_bios_printer</a>
<dd>provide access to printer services
<dt><br><a href="#_bios_serialcom">_bios_serialcom</a>
<dd>provide access to serial services
<dt><br><a href="#_bios_timeofday">_bios_timeofday</a>
<dd>get and set system clock
</dl>
<h3 id="DOSMSpecific_Functions"> DOS-Specific Functions </h3>
<br>These functions provide the capability to invoke DOS functions directly from a program.&nbsp; The following functions
 are defined:
<dl>
<dt><a href="#bdos">bdos</a>
<dd>DOS call (short form)
<dt><br><a href="#dosexterr">dosexterr</a>
<dd>extract DOS error information
<dt><br><a href="#_dos_allocmem">_dos_allocmem</a>
<dd>allocate a block of memory
<dt><br><a href="#_dos_close">_dos_close</a>
<dd>close a file
<dt><br><a href="#_dos_commit">_dos_commit</a>
<dd>flush buffers to disk
<dt><br><a href="#_dos_creat">_dos_creat</a>
<dd>create a file
<dt><br><a href="#_dos_creatnew">_dos_creatnew</a>
<dd>create a new file
<dt><br>_dos_findclose (see <a href="#_dos_find___">_dos_find...</a>)
<dd>close find file matching
<dt><br>_dos_findfirst (see <a href="#_dos_find___">_dos_find...</a>)
<dd>find first file matching a specified pattern
<dt><br>_dos_findnext (see <a href="#_dos_find___">_dos_find...</a>)
<dd>find the next file matching a specified pattern
<dt><br><a href="#_dos_freemem">_dos_freemem</a>
<dd>free a block of memory
<dt><br><a href="#_dos_getdate">_dos_getdate</a>
<dd>get current system date
<dt><br><a href="#_dos_getdiskfree">_dos_getdiskfree</a>
<dd>get information about disk
<dt><br><a href="#_dos_getdrive">_dos_getdrive</a>
<dd>get the current drive
<dt><br><a href="#_dos_getfileattr">_dos_getfileattr</a>
<dd>get file attributes
<dt><br><a href="#_dos_getftime">_dos_getftime</a>
<dd>get file's last modification time
<dt><br><a href="#_dos_gettime">_dos_gettime</a>
<dd>get the current system time
<dt><br><a href="#_dos_getvect">_dos_getvect</a>
<dd>get contents of interrupt vector
<dt><br><a href="#_dos_keep">_dos_keep</a>
<dd>install a terminate-and-stay-resident program
<dt><br><a href="#_dos_open">_dos_open</a>
<dd>open a file
<dt><br><a href="#_dos_read">_dos_read</a>
<dd>read data from a file
<dt><br><a href="#_dos_setblock">_dos_setblock</a>
<dd>change the size of allocated block
<dt><br><a href="#_dos_setdate">_dos_setdate</a>
<dd>change current system date
<dt><br><a href="#_dos_setdrive">_dos_setdrive</a>
<dd>change the current default drive
<dt><br><a href="#_dos_setfileattr">_dos_setfileattr</a>
<dd>set the attributes of a file
<dt><br><a href="#_dos_setftime">_dos_setftime</a>
<dd>set a file's last modification time
<dt><br><a href="#_dos_settime">_dos_settime</a>
<dd>set the current system time
<dt><br><a href="#_dos_setvect">_dos_setvect</a>
<dd>set an interrupt vector
<dt><br><a href="#_dos_write">_dos_write</a>
<dd>write data to a file
<dt><br><a href="#intdos">intdos</a>
<dd>cause DOS interrupt
<dt><br><a href="#intdosx">intdosx</a>
<dd>cause DOS interrupt, with segment registers
<dt><br>_wdos_findclose (see <a href="#_dos_find___">_dos_find...</a>)
<dd>close find file matching
<dt><br>_wdos_findfirst (see <a href="#_dos_find___">_dos_find...</a>)
<dd>find first file matching a specified pattern
<dt><br>_wdos_findnext (see <a href="#_dos_find___">_dos_find...</a>)
<dd>find the next file matching a specified pattern
</dl>
<h3 id="Intel_80x86_ArchitectureMSpecific_Functions"> Intel 80x86 Architecture-Specific Functions </h3>
<br>These functions provide the capability to invoke Intel 80x86 processor-related functions directly from a program.&nbsp;
 Functions that apply to the Intel 8086 CPU apply to that family including the 80286, 80386, 80486 and Pentium processors.
&nbsp; The following functions are defined:
<dl>
<dt><a href="#_chain_intr">_chain_intr</a>
<dd>chain to the previous interrupt handler
<dt><br><a href="#_disable">_disable</a>
<dd>disable interrupts
<dt><br><a href="#_enable">_enable</a>
<dd>enable interrupts
<dt><br><a href="#FP_OFF">FP_OFF</a>
<dd>get offset part of far pointer
<dt><br><a href="#FP_SEG">FP_SEG</a>
<dd>get segment part of far pointer
<dt><br><a href="#inp">inp</a>
<dd>get one byte from hardware port
<dt><br><a href="#inpw">inpw</a>
<dd>get two bytes (one word) from hardware port
<dt><br><a href="#int386">int386</a>
<dd>cause 386/486/Pentium CPU interrupt
<dt><br><a href="#int386x">int386x</a>
<dd>cause 386/486/Pentium CPU interrupt, with segment registers
<dt><br><a href="#int86">int86</a>
<dd>cause 8086 CPU interrupt
<dt><br><a href="#int86x">int86x</a>
<dd>cause 8086 CPU interrupt, with segment registers
<dt><br><a href="#intr">intr</a>
<dd>cause 8086 CPU interrupt, with segment registers
<dt><br><a href="#MK_FP">MK_FP</a>
<dd>make a far pointer from the segment and offset values
<dt><br><a href="#nosound">nosound</a>
<dd>turn off the speaker
<dt><br><a href="#outp">outp</a>
<dd>write one byte to hardware port
<dt><br><a href="#outpw">outpw</a>
<dd>write two bytes (one word) to hardware port
<dt><br><a href="#segread">segread</a>
<dd>read segment registers
<dt><br><a href="#sound">sound</a>
<dd>turn on the speaker at specified frequency
</dl>
<h3 id="Intel_Pentium_Multimedia_Extension_Functions"> Intel Pentium Multimedia Extension Functions </h3>
<br>This set of functions allows access to Intel Architecture Multimedia Extensions (MMX).&nbsp; These functions are implemented
 as in-line intrinsic functions.&nbsp; The general format for most functions is:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; mm_result = mm_function( mm_operand1, mm_operand2 );</tt>
<br><br>These functions provide a simple model for use of Intel Multimedia Extension (MMX).&nbsp; More advanced use of MMX
 can be implemented in much the same way that these functions are implemented.&nbsp; See the<tt> &lt;mmintrin.h&gt;</tt> header
 file for examples.&nbsp; The following functions are defined:
<dl>
<dt><a href="#_m_empty">_m_empty</a>
<dd>empty multimedia state
<dt><br><a href="#_m_from_int">_m_from_int</a>
<dd>form 64-bit MM value from unsigned 32-bit integer value
<dt><br><a href="#_m_packssdw">_m_packssdw</a>
<dd>pack and saturate 32-bit double-words from two MM elements into signed 16-bit words
<dt><br><a href="#_m_packsswb">_m_packsswb</a>
<dd>pack and saturate 16-bit words from two MM elements into signed bytes
<dt><br><a href="#_m_packuswb">_m_packuswb</a>
<dd>pack and saturate signed 16-bit words from two MM elements into unsigned bytes
<dt><br><a href="#_m_paddb">_m_paddb</a>
<dd>add packed bytes
<dt><br><a href="#_m_paddd">_m_paddd</a>
<dd>add packed 32-bit double-words
<dt><br><a href="#_m_paddsb">_m_paddsb</a>
<dd>add packed signed bytes with saturation
<dt><br><a href="#_m_paddsw">_m_paddsw</a>
<dd>add packed signed 16-bit words with saturation
<dt><br><a href="#_m_paddusb">_m_paddusb</a>
<dd>add packed unsigned bytes with saturation
<dt><br><a href="#_m_paddusw">_m_paddusw</a>
<dd>add packed unsigned 16-bit words with saturation
<dt><br><a href="#_m_paddw">_m_paddw</a>
<dd>add packed 16-bit words
<dt><br><a href="#_m_pand">_m_pand</a>
<dd>AND 64 bits of two MM elements
<dt><br><a href="#_m_pandn">_m_pandn</a>
<dd>invert the 64 bits in MM element, then AND 64 bits from second MM element
<dt><br><a href="#_m_pcmpeqb">_m_pcmpeqb</a>
<dd>compare packed bytes for equality
<dt><br><a href="#_m_pcmpeqd">_m_pcmpeqd</a>
<dd>compare packed 32-bit double-words for equality
<dt><br><a href="#_m_pcmpeqw">_m_pcmpeqw</a>
<dd>compare packed 16-bit words for equality
<dt><br><a href="#_m_pcmpgtb">_m_pcmpgtb</a>
<dd>compare packed bytes for greater than relationship
<dt><br><a href="#_m_pcmpgtd">_m_pcmpgtd</a>
<dd>compare packed 32-bit double-words for greater than relationship
<dt><br><a href="#_m_pcmpgtw">_m_pcmpgtw</a>
<dd>compare packed 16-bit words for greater than relationship
<dt><br><a href="#_m_pmaddwd">_m_pmaddwd</a>
<dd>multiply packed 16-bit words, then add 32-bit results pair-wise
<dt><br><a href="#_m_pmulhw">_m_pmulhw</a>
<dd>multiply the packed 16-bit words of two MM elements, then store high-order 16 bits of results
<dt><br><a href="#_m_pmullw">_m_pmullw</a>
<dd>multiply the packed 16-bit words of two MM elements, then store low-order 16 bits of results
<dt><br><a href="#_m_por">_m_por</a>
<dd>OR 64 bits of two MM elements
<dt><br><a href="#_m_pslld">_m_pslld</a>
<dd>shift left each 32-bit double-word by amount specified in second MM element
<dt><br><a href="#_m_pslldi">_m_pslldi</a>
<dd>shift left each 32-bit double-word by amount specified in constant value
<dt><br><a href="#_m_psllq">_m_psllq</a>
<dd>shift left each 64-bit quad-word by amount specified in second MM element
<dt><br><a href="#_m_psllqi">_m_psllqi</a>
<dd>shift left each 64-bit quad-word by amount specified in constant value
<dt><br><a href="#_m_psllw">_m_psllw</a>
<dd>shift left each 16-bit word by amount specified in second MM element
<dt><br><a href="#_m_psllwi">_m_psllwi</a>
<dd>shift left each 16-bit word by amount specified in constant value
<dt><br><a href="#_m_psrad">_m_psrad</a>
<dd>shift right (with sign propagation) each 32-bit double-word by amount specified in second MM element
<dt><br><a href="#_m_psradi">_m_psradi</a>
<dd>shift right (with sign propagation) each 32-bit double-word by amount specified in constant value
<dt><br><a href="#_m_psraw">_m_psraw</a>
<dd>shift right (with sign propagation) each 16-bit word by amount specified in second MM element
<dt><br><a href="#_m_psrawi">_m_psrawi</a>
<dd>shift right (with sign propagation) each 16-bit word by amount specified in constant value
<dt><br><a href="#_m_psrld">_m_psrld</a>
<dd>shift right (with zero fill) each 32-bit double-word by an amount specified in second MM element
<dt><br><a href="#_m_psrldi">_m_psrldi</a>
<dd>shift right (with zero fill) each 32-bit double-word by an amount specified in constant value
<dt><br><a href="#_m_psrlq">_m_psrlq</a>
<dd>shift right (with zero fill) each 64-bit quad-word by an amount specified in second MM element
<dt><br><a href="#_m_psrlqi">_m_psrlqi</a>
<dd>shift right (with zero fill) each 64-bit quad-word by an amount specified in constant value
<dt><br><a href="#_m_psrlw">_m_psrlw</a>
<dd>shift right (with zero fill) each 16-bit word by an amount specified in second MM element
<dt><br><a href="#_m_psrlwi">_m_psrlwi</a>
<dd>shift right (with zero fill) each 16-bit word by an amount specified in constant value
<dt><br><a href="#_m_psubb">_m_psubb</a>
<dd>subtract packed bytes in MM element from second MM element
<dt><br><a href="#_m_psubd">_m_psubd</a>
<dd>subtract packed 32-bit dwords in MM element from second MM element
<dt><br><a href="#_m_psubsb">_m_psubsb</a>
<dd>subtract packed signed bytes in MM element from second MM element with saturation
<dt><br><a href="#_m_psubsw">_m_psubsw</a>
<dd>subtract packed signed 16-bit words in MM element from second MM element with saturation
<dt><br><a href="#_m_psubusb">_m_psubusb</a>
<dd>subtract packed unsigned bytes in MM element from second MM element with saturation
<dt><br><a href="#_m_psubusw">_m_psubusw</a>
<dd>subtract packed unsigned 16-bit words in MM element from second MM element with saturation
<dt><br><a href="#_m_psubw">_m_psubw</a>
<dd>subtract packed 16-bit words in MM element from second MM element
<dt><br><a href="#_m_punpckhbw">_m_punpckhbw</a>
<dd>interleave bytes from the high halves of two MM elements
<dt><br><a href="#_m_punpckhdq">_m_punpckhdq</a>
<dd>interleave 32-bit double-words from the high halves of two MM elements
<dt><br><a href="#_m_punpckhwd">_m_punpckhwd</a>
<dd>interleave 16-bit words from the high halves of two MM elements
<dt><br><a href="#_m_punpcklbw">_m_punpcklbw</a>
<dd>interleave bytes from the low halves of two MM elements
<dt><br><a href="#_m_punpckldq">_m_punpckldq</a>
<dd>interleave 32-bit double-words from the low halves of two MM elements
<dt><br><a href="#_m_punpcklwd">_m_punpcklwd</a>
<dd>interleave 16-bit words from the low halves of two MM elements
<dt><br><a href="#_m_pxor">_m_pxor</a>
<dd>XOR 64 bits from two MM elements
<dt><br><a href="#_m_to_int">_m_to_int</a>
<dd>retrieve low-order 32 bits from MM value
</dl>
<h3 id="Miscellaneous_Functions"> Miscellaneous Functions </h3>
<br>The following functions are defined:
<dl>
<dt><a href="#assert">assert</a>
<dd>test an assertion and output a string upon failure
<dt><br><a href="#_fullpath">_fullpath</a>
<dd>return full path specification for file
<dt><br><a href="#_getmbcp">_getmbcp</a>
<dd>get current multibyte code page
<dt><br><a href="#getopt">getopt</a>
<dd>a command-line parser that can be used by applications that follow guidelines outlined in the Single UNIX Specification
<dt><br><a href="#_harderr">_harderr</a>
<dd>critical error handler
<dt><br>_hardresume (see <a href="#_harderr">_harderr</a>)
<dd>critical error handler resume
<dt><br><a href="#localeconv">localeconv</a>
<dd>obtain locale specific conversion information
<dt><br><a href="#longjmp">longjmp</a>
<dd>return and restore environment saved by &quot;setjmp&quot;
<dt><br><a href="#_lrotl">_lrotl</a>
<dd>rotate an &quot;unsigned long&quot; left
<dt><br><a href="#_lrotr">_lrotr</a>
<dd>rotate an &quot;unsigned long&quot; right
<dt><br><a href="#main">main</a>
<dd>the main program (user written)
<dt><br><a href="#offsetof">offsetof</a>
<dd>get offset of field in structure
<dt><br><a href="#_rotl">_rotl</a>
<dd>rotate an &quot;unsigned int&quot; left
<dt><br><a href="#_rotr">_rotr</a>
<dd>rotate an &quot;unsigned int&quot; right
<dt><br><a href="#setjmp">setjmp</a>
<dd>save environment for use with &quot;longjmp&quot; function
<dt><br><a href="#_makepath">_makepath</a>
<dd>make a full filename from specified components
<dt><br><a href="#setlocale">setlocale</a>
<dd>set locale category
<dt><br><a href="#_setmbcp">_setmbcp</a>
<dd>set current multibyte code page
<dt><br><a href="#_splitpath">_splitpath</a>
<dd>split a filename into its components
<dt><br><a href="#_splitpath2">_splitpath2</a>
<dd>split a filename into its components
<dt><br>_wfullpath (see <a href="#_fullpath">_fullpath</a>)
<dd>return full path specification for file
<dt><br>_wmakepath (see <a href="#_makepath">_makepath</a>)
<dd>make a full filename from specified components
<dt><br>_wsetlocale (see <a href="#setlocale">setlocale</a>)
<dd>set locale category
<dt><br>_wsplitpath (see <a href="#_splitpath">_splitpath</a>)
<dd>split a filename into its components
<dt><br>_wsplitpath2 (see <a href="#_splitpath2">_splitpath2</a>)
<dd>split a filename into its components
</dl>
<h3 id="DOS_LFN_aware_Functions"> DOS LFN aware Functions </h3>
<br>These functions deal with DOS Long File Name if an application is compiled with -D__WATCOM_LFN__ option and DOS LFN support
 is available on host system.&nbsp; The following functions are defined:
<dl>
<dt><a href="#access">access</a>
<dd>test file or directory for mode of access
<dt><br><a href="#chdir">chdir</a>
<dd>change current working directory
<dt><br><a href="#chmod">chmod</a>
<dd>change permissions for a file
<dt><br><a href="#creat">creat</a>
<dd>create a file
<dt><br><a href="#_dos_creat">_dos_creat</a>
<dd>create a file
<dt><br><a href="#_dos_creatnew">_dos_creatnew</a>
<dd>create a new file
<dt><br>_dos_findfirst (see <a href="#_dos_find___">_dos_find...</a>)
<dd>find first file matching a specified pattern
<dt><br><a href="#_dos_getfileattr">_dos_getfileattr</a>
<dd>get file attributes
<dt><br><a href="#_dos_open">_dos_open</a>
<dd>open a file
<dt><br><a href="#_dos_setfileattr">_dos_setfileattr</a>
<dd>set the attributes of a file
<dt><br><a href="#_findfirst">_findfirst</a>
<dd>find first file matching a specified pattern
<dt><br><a href="#_fullpath">_fullpath</a>
<dd>return full path specification for file
<dt><br><a href="#getcwd">getcwd</a>
<dd>get current working directory
<dt><br><a href="#_getdcwd">_getdcwd</a>
<dd>get current directory on drive
<dt><br>lstat (see <a href="#stat">stat</a>)
<dd>get file status
<dt><br><a href="#mkdir">mkdir</a>
<dd>make a new directory
<dt><br><a href="#open">open</a>
<dd>open a file
<dt><br><a href="#opendir">opendir</a>
<dd>open directory file
<dt><br><a href="#remove">remove</a>
<dd>delete a file
<dt><br><a href="#rename">rename</a>
<dd>rename a file
<dt><br><a href="#rmdir">rmdir</a>
<dd>remove a directory
<dt><br><a href="#sopen">sopen</a>
<dd>open a file for shared access
<dt><br><a href="#stat">stat</a>
<dd>get file status
<dt><br><a href="#tmpnam">tmpnam</a>
<dd>create name for temporary file
<dt><br><a href="#unlink">unlink</a>
<dd>delete a file
<dt><br><a href="#utime">utime</a>
<dd>set modification time for a file
<dt><br>_waccess (see <a href="#access">access</a>)
<dd>test file or directory for mode of access
<dt><br>_wchdir (see <a href="#chdir">chdir</a>)
<dd>change current working directory
<dt><br>_wchmod (see <a href="#chmod">chmod</a>)
<dd>change permissions for a file
<dt><br>_wcreat (see <a href="#creat">creat</a>)
<dd>create a file
<dt><br>_wdos_findfirst (see <a href="#_dos_find___">_dos_find...</a>)
<dd>find first file matching a specified pattern
<dt><br>_wfindfirst (see <a href="#_findfirst">_findfirst</a>)
<dd>find first file matching a specified pattern
<dt><br>_wfullpath (see <a href="#_fullpath">_fullpath</a>)
<dd>return full path specification for file
<dt><br>_wgetcwd (see <a href="#getcwd">getcwd</a>)
<dd>get current working directory
<dt><br>_wgetdcwd (see <a href="#_getdcwd">_getdcwd</a>)
<dd>get current directory on drive
<dt><br>_wmkdir (see <a href="#mkdir">mkdir</a>)
<dd>make a new directory
<dt><br>_wopen (see <a href="#open">open</a>)
<dd>open a file
<dt><br>_wopendir (see <a href="#opendir">opendir</a>)
<dd>open directory file
<dt><br>_wremove (see <a href="#remove">remove</a>)
<dd>delete a file
<dt><br>_wrename (see <a href="#rename">rename</a>)
<dd>rename a file
<dt><br>_wrmdir (see <a href="#rmdir">rmdir</a>)
<dd>remove a directory
<dt><br>_wsopen (see <a href="#sopen">sopen</a>)
<dd>open a file for shared access
<dt><br>_wstat (see <a href="#stat">stat</a>)
<dd>get file status
<dt><br>_wtmpnam (see <a href="#tmpnam">tmpnam</a>)
<dd>create name for temporary file
<dt><br>_wunlink (see <a href="#unlink">unlink</a>)
<dd>delete a file
<dt><br>_wutime (see <a href="#utime">utime</a>)
<dd>set modification time for a file
</dl>
<h2 id="Header_Files"> Header Files </h2>
<br>The following header files are supplied with the C library.&nbsp; As has been previously noted, when a library function
 is referenced in a source file, the related header files (shown in the synopsis for that function) should be included into
 that source file.&nbsp; The header files provide the proper declarations for the functions and for the number and types of
 arguments used with them.&nbsp; Constant values used in conjunction with the functions are also declared.&nbsp; The files
 can be included multiple times and in any order.
<h3 id="Header_Files_in_DwatcomDh"> Header Files in /watcom/h </h3>
<br>The following header files are provided with the software.&nbsp; The header files that are located in the<tt> \WATCOM\H</tt>
 directory are described first.&nbsp; 
<dl>
<dt>assert.h
<dd>This ISO C90 header file is required when an <tt> assert</tt> macro is used.&nbsp; These assertions will be ignored when the
 identifier<tt> NDEBUG</tt> is defined.&nbsp; 
<dt><br>bios.h
<dd>This header file declares all BIOS related functions.&nbsp; 
<dt><br>conio.h
<dd>This header file declares console and Intel 80x86 port input/output functions.&nbsp; 
<dt><br>ctype.h
<dd>This ISO C90 header file declares functions that perform character classification and case conversion operations.&nbsp; Similar
 functions for wide characters are declared in &lt;wctype.h&gt;.&nbsp; 
<dt><br>direct.h
<dd>This header file declares functions related to directories and the type <tt> DIR</tt> which describes an entry in a directory.
&nbsp; 
<dt><br>dos.h
<dd>This header file declares functions that interact with DOS.&nbsp; It includes the definitions of the <tt> FP_OFF</tt>, <tt>
 FP_SEG</tt> and <tt> MK_FP</tt> macros, and for the following structures and unions:&nbsp; 
<dl>
<dt>DOSERROR
<dd>describes the DOS error information.&nbsp; 
<dt><br>REGS
<dd>describes the CPU registers for Intel 8086 family.&nbsp; 
<dt><br>SREGS
<dd>describes the segment registers for the Intel 8086 family.&nbsp; 
<dt><br>REGPACK
<dd>describes the CPU registers and segment registers for Intel 8086 family.&nbsp; 
<dt><br>INTPACK
<dd>describes the input parameter to an &quot;interrupt&quot; function.
</dl>
<dt><br>env.h
<dd>This POSIX header file declares environment string functions.&nbsp; 
<dt><br>errno.h
<dd>This ISO C90 header file provides the <tt> extern</tt> declaration for error variable <tt> errno</tt> and provides the symbolic
 names for error codes that can be placed in the error variable.&nbsp; 
<dt><br>fcntl.h
<dd>This POSIX header file defines the flags used by the <tt> open</tt> and <tt> sopen</tt> functions.&nbsp; The function declarations
 for these functions are found in the<tt> &lt;io.h&gt;</tt> header file.&nbsp; 
<dt><br>fenv.h
<dd>This ISO C99 header file defines several types and declares several functions that give access to the floating point environment.
&nbsp; These functions can be used to control status flags and control modes in the floating point processor.&nbsp; 
<dt><br>float.h
<dd>This ISO C90 header file declares constants related to floating-point numbers, declarations for low-level floating-point functions,
 and the declaration of the floating-point exception codes.&nbsp; 
<dt><br>fnmatch.h
<dd>This header file declares the pattern matching function <tt> fnmatch</tt> 
<dt><br>graph.h
<dd>This header file contains structure definitions and function declarations for the Watcom C Graphics library functions.&nbsp;
 
<dt><br>inttypes.h
<dd>This ISO C99 header file includes &lt;stdint.h&gt; and expands on it by definition macros for printing and scanning specific
 sized integer types.&nbsp; This header also declares several functions for manipulating maximum sized integers.
<br>Note that the format macros are not visible in C++ programs unless the macro <tt> __STDC_FORMAT_MACROS</tt> is defined.
&nbsp; 
<dt><br>io.h
<dd>This header file declares functions that perform input/output operations at the operating system level.&nbsp; These functions
 use file handles to reference files or devices.&nbsp; The function <tt> fstat</tt> is declared in the<tt> &lt;sys\stat.h&gt;</tt>
 header file.&nbsp; 
<dt><br>limits.h
<dd>This ISO C90 header file contains constant declarations for limits or boundary values for ranges of integers and characters.
&nbsp; 
<dt><br>locale.h
<dd>This ISO C90 header file contains declarations for the categories<tt> (LC...)</tt> of locales which can be selected using
 the <tt> setlocale</tt> function which is also declared.&nbsp; 
<dt><br>malloc.h
<dd>This header file declares the memory allocation and deallocation functions.&nbsp; 
<dt><br>math.h
<dd>This ANSI header file declares the mathematical functions (which operate with floating-point numbers) and the structures:
&nbsp; 
<dl>
<dt>exception
<dd>describes the exception structure passed to the <tt> matherr</tt> function; symbolic constants for the types of exceptions
 are included 
<dt><br>complex
<dd>declares a complex number
</dl>
<dt><br>mmintrin.h
<dd>This header file declares functions that interact with the Intel Architecture Multimedia Extensions.&nbsp; It defines the
 datatype used to store multimedia values:&nbsp; 
<dl>
<dt>__m64
<dd>describes the 64-bit multimedia data element.&nbsp; Note:&nbsp; the underlying implementation details of this datatype are
 subject to change.&nbsp; Other compilers may implement a similar datatype in a different manner.
</dl>
<br>It also contains prototypes for multimedia functions and pragmas for the in-line generation of code that operates on multimedia
 registers.&nbsp; 
<dt><br>process.h
<dd>This header file declares the <tt> spawn...</tt>&nbsp; functions, the <tt> exec...</tt>&nbsp; functions, and the <tt> system</tt>
 function.&nbsp; The file also contains declarations for the constants <tt> P_WAIT</tt>, <tt> P_NOWAIT</tt>, <tt> P_NOWAITO</tt>,
 and <tt> P_OVERLAY</tt>.&nbsp; 
<dt><br>search.h
<dd>This header file declares the functions <tt> lfind</tt> and <tt> lsearch</tt> 
<dt><br>setjmp.h
<dd>This ISO C90 header file declares the <tt> setjmp</tt> and <tt> longjmp</tt> functions.&nbsp; 
<dt><br>share.h
<dd>This header file defines constants for shared access to files using the <tt> sopen</tt> function.&nbsp; 
<dt><br>signal.h
<dd>This ISO C90 header file declares the <tt> signal</tt> and <tt> raise</tt> functions.&nbsp; 
<dt><br>stdarg.h
<dd>This ISO C90 header file defines the macros which handle variable argument lists.&nbsp; 
<dt><br>stdbool.h
<dd>This ISO C99 header file defines the macro <tt> bool</tt> and the macros <tt> true</tt> and <tt> false</tt> for use in C programs.
&nbsp; If this header is included in a C++ program there is no effect.&nbsp; The C++ reserved words will not be redefined.
&nbsp; However the definition of <tt> bool</tt> , <tt> true</tt> , and <tt> false</tt> used in a C program will be compatible
 with their C++ counterparts.&nbsp; In particular, a C function declared as taking a <tt> bool</tt> parameter and a structure
 containing a <tt> bool</tt> member can both be shared between C and C++ without error.&nbsp; 
<dt><br>stddef.h
<dd>This ISO C90 header file defines a few popular constants and types including<tt> NULL</tt> (null pointer), <tt> size_t</tt>
 (unsigned size of an object), and <tt> ptrdiff_t</tt> (difference between two pointers).&nbsp; It also contains a declaration
 for the <tt> offsetof</tt> macro.&nbsp; 
<dt><br>stdint.h
<dd>This ISO C99 header file defines numerous type names for integers of various sizes.&nbsp; Such type names provide a reasonably
 portable way to refer to integers with a specific number of bits.&nbsp; This header file also defines macros that describe
 the minimum and maximum values for these types (similar to the macros in limits.h), and macros for writing integer constants
 with specific sized types.
<br>Note that in C++ programs the limit macros are not visible unless the macro <tt> __STDC_LIMIT_MACROS</tt> is defined.
&nbsp; Similarly the constant writing macros are not visible unless the macro <tt> __STDC_CONSTANT_MACROS</tt> is defined.
&nbsp; 
<dt><br>stdio.h
<dd>This ISO C90 header file declares the standard input/output functions.&nbsp; Files, devices and directories are referenced
 using pointers to objects of the type <tt> FILE</tt>.&nbsp; 
<dt><br>stdlib.h
<dd>This ISO C90 header file declares many standard functions excluding those declared in other header files discussed in this
 section.&nbsp; 
<dt><br>string.h
<dd>This ISO C90 header file declares functions that manipulate strings or blocks of memory.&nbsp; 
<dt><br>time.h
<dd>This ANSI header file declares functions related to times and dates and defines the structure <tt> struct tm</tt>.&nbsp; 
<dt><br>varargs.h
<dd>This UNIX System V header file provides an alternate way of handling variable argument lists.&nbsp; The equivalent ANSI header
 file is &lt;stdarg.h&gt;.&nbsp; 
<dt><br>wchar.h
<dd>This ISO C99 header file defines several data types including <tt> wchar_t</tt>, <tt> size_t</tt>, <tt> mbstate_t</tt> (an
 object that can hold conversion state information necessary to convert between multibyte characters and wide characters),
 <tt> wctype_t</tt> (a scalar type that can hold values which represent locale-specific character classification), and <tt>
 wint_t</tt> which is an integral type that can hold any <tt> wchar_t</tt> value as well as <tt> WEOF</tt> (a character that
 is not in the set of &quot;wchar_t&quot; characters and that is used to indicate<b> end-of-file</b> on an input stream).
&nbsp; The functions that are declared in this header file are grouped as follows:
<ul>
<li>Wide character classification and case conversion.
<li>Input and output of wide characters, or multibyte characters, or both.
<li>Wide string numeric conversion.
<li>Wide string manipulation.
<li>Wide string data and time conversion.
<li>Conversion between multibyte and wide character sequences.
</ul>
<dt><br>wctype.h
<dd>This ISO C99 header file declares functions that perform characater classification and case conversion operations on wide
 characters.&nbsp; Similar functions for ordinary characters are declared in &lt;ctype.h&gt;.
</dl>
<h3 id="Header_Files_in_DwatcomDhDsys"> Header Files in /watcom/h/sys </h3>
<br>The following header files are present in the <tt> sys</tt> subdirectory.&nbsp; Their presence in this directory indicates
 that they are system-dependent header files.&nbsp; 
<dl>
<dt>sys\locking.h
<dd>This header file contains the manifest constants used by the <tt> locking</tt> function.&nbsp; 
<dt><br>sys\stat.h
<dd>This POSIX header file contains the declarations pertaining to file status, including definitions for the <tt> fstat</tt>
 and <tt> stat</tt> functions and for the structure:&nbsp; 
<dl>
<dt>stat
<dd>describes the information obtained for a directory, file or device
</dl>
<dt><br>sys\timeb.h
<dd>This header file describes the <tt> timeb</tt> structure used in conjunction with the <tt> ftime</tt> function.&nbsp; 
<dt><br>sys\types.h
<dd>This POSIX header file contains declarations for the types used by system-level calls to obtain file status or time information.
&nbsp; 
<dt><br>sys\utime.h
<dd>This POSIX header file contains a declaration for the <tt> utime</tt> function and for the structured type <tt> utimbuf</tt>
 used by it.
</dl>
<h2 id="Global_Data"> Global Data </h2>
<br>Certain data items are used by the Watcom C/C++ run-time library and may be inspected (or changed in some cases) by a
 program.&nbsp; The defined items are:&nbsp; 
<dl>
<dt>_amblksiz
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> unsigned int</tt> data item contains the increment by which the &quot;break&quot; pointer for memory allocation
 will be advanced when there is no freed block large enough to satisfy a request to allocate a block of memory.&nbsp; This
 value may be changed by a program at any time.&nbsp; 
<dt><br>__argc
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> int</tt> item contains the number of arguments passed to <tt> main</tt>.&nbsp; 
<dt><br>__argv
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> char **</tt> item contains a pointer to a vector containing the actual arguments passed to <tt> main</tt>.&nbsp;
 
<dt><br>daylight
<dd>Prototype in<tt> &lt;time.h&gt;.</tt>
<br>This<tt> unsigned int</tt> has a value of one when daylight saving time is supported in this locale and zero otherwise.
&nbsp; Whenever a time function is called, the <tt> tzset</tt> function is called to set the value of the variable.&nbsp;
 The value will be determined from the value of the<tt> TZ</tt> environment variable.&nbsp; 
<dt><br>_doserrno
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> int</tt> item contains the actual error code returned when a DOS, Windows or OS/2 function fails.&nbsp; 
<dt><br>environ
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> char ** __near</tt> data item is a pointer to an array of character pointers to the environment strings.
<dt><br>errno
<dd>Prototype in<tt> &lt;errno.h&gt;.</tt>
<br>This<tt> int</tt> item contains the number of the last error that was detected.&nbsp; The run-time library never resets
 <tt> errno</tt> to 0.&nbsp; Symbolic names for these errors are found in the<tt> &lt;errno.h&gt;</tt> header file.&nbsp;
 See the descriptions for the <tt> perror</tt> and <tt> strerror</tt> functions for information about the text which describes
 these errors.&nbsp; 
<dt><br>fltused_
<dd>The C compiler places a reference to the <tt> fltused_</tt> symbol into any module that uses a floating-point library routine
 or library routine that requires floating-point support (e.g., the use of a<tt> float</tt> or<tt> double</tt> as an argument
 to the <tt> printf</tt> function).&nbsp; 
<dt><br>_fmode
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This data item contains the default type of file (text or binary) translation for a file.&nbsp; It will contain a value
 of either
<dl>
<dt>O_BINARY
<dd>indicates that data is transmitted to and from streams unchanged.
<dt><br>O_TEXT
<dd>indicates that carriage return characters are added before linefeed characters on output operations and are removed on input
 operations when they precede linefeed characters.
</dl>
<br>These values are defined in the<tt> &lt;fcntl.h&gt;</tt> header file.&nbsp; The value of <tt> _fmode</tt> may be changed
 by a program to change the default behavior of the <tt> open</tt>, <tt> fopen</tt>, <tt> creat</tt> and <tt> sopen</tt> functions.
&nbsp; The default setting of <tt> _fmode</tt> is <tt> O_TEXT</tt>, for text-mode translation.&nbsp; <tt> O_BINARY</tt> is
 the setting for binary mode.&nbsp; You can change the value of <tt> _fmode</tt> in either of two ways:&nbsp; 
<ul>
<li>You can include the object file<tt> BINMODE.OBJ</tt> when linking your application.&nbsp; This object file contains code
 to change the initial setting of <tt> _fmode</tt> to <tt> O_BINARY</tt>, causing all files except <tt> stdin</tt>, <tt> stdout</tt>,
 and <tt> stderr</tt> to be opened in binary mode.
<li>You can change the value of <tt> _fmode</tt> directly by setting it in your program.
</ul>
<dt><br>__MaxThreads
<dd>There is a limit to the number of threads an application can create under 16-bit OS/2 and 32-bit NetWare.&nbsp; The default
 limit is 32.&nbsp; This limit can be adjusted by statically initializing the unsigned global variable<tt> __MaxThreads.</tt>
<br>Under 32-bit OS/2, there is no limit to the number of threads an application can create.&nbsp; However, due to the way
 in which multiple threads are supported in the Watcom libraries, there is a small performance penalty once the number of
 threads exceeds the default limit of 32 (this number includes the initial thread).&nbsp; If you are creating more than 32
 threads and wish to avoid this performance penalty, you can redefine the threshold value of 32.&nbsp; You can statically
 initialize the global variable<tt> __MaxThreads.</tt>
<br><br>By adding the following line to your multi-threaded application, the new threshold value will be set to 48.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned __MaxThreads = { 48 };</tt>
<dt><br>__minreal
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This data item contains the minimum amount of real memory (below 640K) to reserve when running a 32-bit DOS extended application.
&nbsp; 
<dt><br>optarg
<dd>Prototype in<tt> &lt;unistd.h&gt;.</tt>
<br>This<tt> char *</tt> variable contains a pointer to an option-argument parsed by the <tt> getopt</tt> function.&nbsp;
 
<dt><br>opterr
<dd>Prototype in<tt> &lt;unistd.h&gt;.</tt>
<br>This<tt> int</tt> variable controls whether the <tt> getopt</tt> function will print error messages.&nbsp; The default
 value is non-zero and will cause the <tt> getopt</tt> function to print error messages on the console.&nbsp; 
<dt><br>optind
<dd>Prototype in<tt> &lt;unistd.h&gt;.</tt>
<br>This<tt> int</tt> variable holds the index of the argument array element currently processed by the <tt> getopt</tt> function.
&nbsp; 
<dt><br>optopt
<dd>Prototype in<tt> &lt;unistd.h&gt;.</tt>
<br>This<tt> int</tt> variable contains the unrecognized option character in case the <tt> getopt</tt> function returns an
 error.&nbsp; 
<dt><br>_osmajor
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> unsigned char</tt> variable contains the major number for the version of DOS executing on the computer.&nbsp;
 If the current version is 3.20, then the value will be 3.&nbsp; 
<dt><br>_osminor
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> unsigned char</tt> variable contains the minor number for the version of DOS executing on the computer.&nbsp;
 If the current version is 3.20, then the value will be 20.&nbsp; 
<dt><br>_osbuild
<dd>(Win32 only) Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> unsigned short</tt> variable contains the operating system build number for the version of Windows executing
 on the computer.&nbsp; 
<dt><br>_osver
<dd>(Win32 only) Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> unsigned int</tt> variable contains the operating system build number for the version of Windows executing on
 the computer.
<br>On Win32s or Windows 95/98 platforms, the high bit of the low-order 16-bit word is turned on.&nbsp; Windows 95/98 do not
 have build numbers.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned short dwBuild;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; // Get build numbers for Win32 or Win32s</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( _osver &lt; 0x8000 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Windows NT/2000</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwBuild = _osver;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; else if (_winmajor &lt; 4)&nbsp;&nbsp;&nbsp;&nbsp; // Win32s</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwBuild = _osver &amp; 0x8000;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Windows 95 or 98</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dwBuild =&nbsp; 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; // No build numbers provided</tt>
<br><br>Note that the Win32 <tt> GetVersionEx</tt> function is the preferred method for obtaining operating system version
 number information.&nbsp; 
<dt><br>_osmode
<dd>(16-bit only) Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> unsigned char</tt> variable contains either the value DOS_MODE which indicates the program is running in real
 address mode, or it contains the value OS2_MODE which indicates the program is running in protected address mode.&nbsp; 
<dt><br>_psp
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This data item contains the segment value for the DOS Program Segment Prefix.&nbsp; Consult the technical documentation
 for your DOS system for the process information contained in the Program Segment Prefix.&nbsp; 
<dt><br>_stacksize
<dd>On 16-bit 80x86 systems, this<tt> unsigned int</tt> value contains the size of the stack for a TINY memory model program.
&nbsp; Changing the value of this item during the execution of a program will have no effect upon the program, since the value
 is used when the program starts execution.&nbsp; To change the size of the stack to be 8K bytes, a statement such as follows
 can be included with the program.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned int _stacksize = { 8 * 1024 };</tt>
<dt><br>stdaux
<dd>Prototype in<tt> &lt;stdio.h&gt;.</tt>
<br>This variable (with type<tt> FILE *)</tt> indicates the standard auxiliary port (not available in some Windows platforms).
&nbsp; 
<dt><br>stderr
<dd>Prototype in<tt> &lt;stdio.h&gt;.</tt>
<br>This variable (with type<tt> FILE *)</tt> indicates the standard error stream (set to the console by default).&nbsp; 
<dt><br>stdin
<dd>Prototype in<tt> &lt;stdio.h&gt;.</tt>
<br>This variable (with type<tt> FILE *)</tt> indicates the standard input stream (set to the console by default).&nbsp; 
<dt><br>stdout
<dd>Prototype in<tt> &lt;stdio.h&gt;.</tt>
<br>This variable (with type<tt> FILE *)</tt> indicates the standard output stream (set to the console by default).&nbsp;
 
<dt><br>stdprn
<dd>Prototype in<tt> &lt;stdio.h&gt;.</tt>
<br>This variable (with type<tt> FILE *)</tt> indicates the standard printer.&nbsp; (not available in some Windows platforms).
&nbsp; 
<dt><br>sys_errlist
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This variable is an array of pointers to character strings for each error code defined in the<tt> &lt;errno.h&gt;</tt>
 header file.&nbsp; 
<dt><br>sys_nerr
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> int</tt> variable contains the number of messages declared in <tt> sys_errlist</tt>.&nbsp; 
<dt><br>_threadid
<dd>Prototype in<tt> &lt;stddef.h&gt;.</tt>
<br>This variable/function may be used to obtain the id of the current thread which is an<tt> int.</tt>&nbsp; In the 32-bit
 libraries, <tt> _threadid</tt> is a function that returns a pointer to an int.&nbsp; In the 16-bit libraries, <tt> _threadid</tt>
 is a far pointer to an int.&nbsp; Note that the value stored where <tt> _threadid</tt> points does not necessarily change
 when a thread context switch occurs (so do not make a copy of the pointer ...&nbsp; it may change).&nbsp; To obtain the current
 thread identifier, simply code:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; int tid = *_threadid;</tt>
<dt><br>timezone
<dd>Prototype in<tt> &lt;time.h&gt;.</tt>
<br>This<tt> long int</tt> contains the number of seconds of time that the local time zone is earlier than Coordinated Universal
 Time (UTC) (formerly known as Greenwich Mean Time (GMT)).&nbsp; Whenever a time function is called, the <tt> tzset</tt> function
 is called to set the value of the variable.&nbsp; The value will be determined from the value of the<tt> TZ</tt> environment
 variable.&nbsp; 
<dt><br>tzname
<dd>Prototype in<tt> &lt;time.h&gt;.</tt>
<br>This array of two pointers to character strings indicates the name of the standard abbreviation for the time zone and
 the name of the abbreviation for the time zone when daylight saving time is in effect.&nbsp; Whenever a time function is
 called, the <tt> tzset</tt> function is called to set the values in the array.&nbsp; These values will be determined from
 the value of the<tt> TZ</tt> environment variable.&nbsp; 
<dt><br>__wargc
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> int</tt> item contains the number of arguments passed to <tt> wmain</tt>.&nbsp; 
<dt><br>__wargv
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> wchar_t **</tt> item contains a pointer to a vector containing the actual arguments passed to <tt> wmain</tt>.
&nbsp; 
<dt><br>_wenviron
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> wchar_t ** __near</tt> data item is a pointer to an array of wide-character pointers to the wide-character equivalents
 of the environment strings.&nbsp; 
<dt><br>__win_alloc_flags
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> unsigned long int</tt> variable contains the flags to be used when allocating memory in Windows.&nbsp; 
<dt><br>__win_realloc_flags
<dd>Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> unsigned long int</tt> variable contains the flags to be used when reallocating memory in Windows.&nbsp; 
<dt><br>_winmajor
<dd>(Win32 only) Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> unsigned int</tt> variable contains the operating system major version number for the version of Windows executing
 on the computer.&nbsp; For example, the major version number of the Daytona release of Windows NT is 3.
<br>Note that the Win32 <tt> GetVersionEx</tt> function is the preferred method for obtaining operating system version number
 information.&nbsp; 
<dt><br>_winminor
<dd>(Win32 only) Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> unsigned int</tt> variable contains the operating system minor version number for the version of Windows executing
 on the computer.&nbsp; For example, the minor version number of the Daytona release of Windows NT is 5.
<br>Note that the Win32 <tt> GetVersionEx</tt> function is the preferred method for obtaining operating system version number
 information.&nbsp; 
<dt><br>_winver
<dd>(Win32 only) Prototype in<tt> &lt;stdlib.h&gt;.</tt>
<br>This<tt> unsigned int</tt> variable contains the operating system version number for the version of Windows executing
 on the computer.&nbsp; The low-order byte contains the minor version number (see also <tt> _winminor</tt>).&nbsp; The next
 byte contains the major version number (see also <tt> _winmajor</tt>).&nbsp; The high-order word contains no useful information.
<br>Note that the Win32 <tt> GetVersionEx</tt> function is the preferred method for obtaining operating system version number
 information.
</dl>
<h2 id="The_TZ_Environment_Variable"> The TZ Environment Variable </h2>
<br>The <tt> TZ</tt> environment variable is used to establish the local time zone.&nbsp; The value of the variable is used
 by various time functions to compute times relative to Coordinated Universal Time (UTC) (formerly known as Greenwich Mean
 Time (GMT)).
<br><br>The time on the computer should be set to the local time.&nbsp; Use the DOS<tt> time</tt> command and the DOS<tt>
 date</tt> command if the time is not automatically maintained by the computer hardware.
<br><br>The <tt> TZ</tt> environment variable can be set (before the program is executed) by using the DOS<tt> set</tt> command
 as follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET TZ=PST8PDT</tt>
<br><br>or (during the program execution) by using the <tt> setenv</tt> or <tt> putenv</tt> library functions:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setenv( &quot;TZ&quot;, &quot;PST8PDT&quot;, 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putenv( &quot;TZ=PST8PDT&quot; );</tt>
<br><br>The value of the variable can be obtained by using the <tt> getenv</tt> function:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *tzvalue;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . . .</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tzvalue = getenv( &quot;TZ&quot; );</tt>
<br><br>The <tt> tzset</tt> function processes the <tt> TZ</tt> environment variable and sets the global variables <tt> daylight</tt>
 (indicates if daylight saving time is supported in the locale), <tt> timezone</tt> (contains the number of seconds of time
 difference between the local time zone and Coordinated Universal Time (UTC)), and <tt> tzname</tt> (a vector of two pointers
 to character strings containing the standard and daylight time-zone names).
<br><br>The value of the <tt> TZ</tt> environment variable should be set as follows (spaces are for clarity only):
<dl>
<dt>std offset dst offset , rule
<dd>
</dl>
<br>On the OS/2 platform, an alternate format is also supported.&nbsp; Please refer to the following section for details.
<br>The expanded format is as follows:
<dl>
<dt>stdoffset&#91;dst&#91;offset&#93;&#91;,start&#91;/time&#93;,end&#91;/time&#93;&#93;&#93;
<dd>
</dl>
<dl>
<dt>std, dst
<dd>three or more letters that are the designation for the standard<b> (std)</b> or summer<b> (dst)</b> time zone.&nbsp; Only<b>
 std</b> is required.&nbsp; If<b> dst</b> is omitted, then summer time does not apply in this locale.&nbsp; Upper- and lowercase
 letters are allowed.&nbsp; Any characters except for a leading colon (:), digits, comma (,), minus (-), plus (+), and ASCII
 NUL (\0) are allowed.
<dt><br>offset
<dd>indicates the value one must add to the local time to arrive at Coordinated Universal Time (UTC).&nbsp; The<b> offset</b>
 has the form:
<dl>
<dt>hh&#91;:mm&#91;:ss&#93;&#93;
<dd>
</dl>
<br>The minutes<b> (mm)</b> and seconds<b> (ss)</b> are optional.&nbsp; The hour<b> (hh)</b> is required and may be a single
 digit.&nbsp; The<b> offset</b> following<b> std</b> is required.&nbsp; If no<b> offset</b> follows<b> dst,</b> summer time
 is assumed to be one hour ahead of standard time.&nbsp; One or more digits may be used; the value is always interpreted as
 a decimal number.&nbsp; The hour may be between 0 and 24, and the minutes (and seconds) - if present - between 0 and 59.
&nbsp; If preceded by a &quot;-&quot;, the time zone will be east of the <b> Prime Meridian</b>; otherwise it will be west
 (which may be indicated by an optional preceding &quot;+&quot;).
<dt><br>rule
<dd>indicates when to change to and back from summer time.&nbsp; The<b> rule</b> has the form:
<dl>
<dt>date/time,date/time
<dd>
</dl>
<br>where the first<b> date</b> describes when the change from standard to summer time occurs and the second<b> date</b> describes
 when the change back happens.&nbsp; Each<b> time</b> field describes when, in current local time, the change to the other
 time is made.
<br><br>The format of<b> date</b> may be one of the following:
<dl>
<dt>Jn
<dd>The Julian day n (1 &lt;= n &lt;= 365).&nbsp; Leap days are not counted.&nbsp; That is, in all years - including leap years
 - February 28 is day 59 and March 1 is day 60.&nbsp; It is impossible to explicitly refer to the occasional February 29.
<dt><br>n
<dd>The zero-based Julian day (0 &lt;= n &lt;= 365).&nbsp; Leap years are counted, and it is possible to refer to February 29.
<dt><br>Mm.n.d
<dd>The d'th day (0 &lt;= d &lt;= 6) of week n of month m of the year (1 &lt;= n &lt;= 5, 1 &lt;= m &lt;= 12, where week 5 means
 &quot;the last d day in month m&quot; which may occur in the fourth or fifth week).&nbsp; Week 1 is the first week in which
 the d'th day occurs.&nbsp; Day zero is Sunday.
</dl>
<br>The<b> time</b> has the same format as<b> offset</b> except that no leading sign (&quot;+&quot; or &quot;-&quot;) is allowed.
&nbsp; The default, if<b> time</b> is omitted, is<tt> 02:00:00.</tt>
</dl>
<br>Whenever <tt> ctime</tt>, <tt> _ctime</tt>, <tt> localtime</tt>, <tt> _localtime</tt> or <tt> mktime</tt> is called, the
 time zone names contained in the external variable <tt> tzname</tt> will be set as if the <tt> tzset</tt> function had been
 called.&nbsp; The same is true if the<tt> %Z</tt> directive of <tt> strftime</tt> is used.
<br><br>Some examples are:
<dl>
<dt>TZ=EST5EDT
<dd>Eastern Standard Time is 5 hours earlier than Coordinated Universal Time (UTC).&nbsp; Standard time and daylight saving time
 both apply to this locale.&nbsp; By default, Eastern Daylight Time (EDT) is one hour ahead of standard time (i.e., EDT4).
&nbsp; Since it is not specified, daylight saving time starts on the first Sunday of April at 2:00 A.M.&nbsp; and ends on
 the last Sunday of October at 2:00 A.M.&nbsp; This is the default when the <tt> TZ</tt> variable is not set.
<dt><br>TZ=EST5EDT4,M4.1.0/02:00:00,M10.5.0/02:00:00
<dd>This is the full specification for the default when the <tt> TZ</tt> variable is not set.&nbsp; Eastern Standard Time is 5
 hours earlier than Coordinated Universal Time (UTC).&nbsp; Standard time and daylight saving time both apply to this locale.
&nbsp; Eastern Daylight Time (EDT) is one hour ahead of standard time.&nbsp; Daylight saving time starts on the first (1)
 Sunday (0) of April (4) at 2:00 A.M.&nbsp; and ends on the last (5) Sunday (0) of October (10) at 2:00 A.M.
<dt><br>TZ=PST8PDT
<dd>Pacific Standard Time is 8 hours earlier than Coordinated Universal Time (UTC).&nbsp; Standard time and daylight saving time
 both apply to this locale.&nbsp; By default, Pacific Daylight Time is one hour ahead of standard time (i.e., PDT7).&nbsp;
 Since it is not specified, daylight saving time starts on the first Sunday of April at 2:00 A.M.&nbsp; and ends on the last
 Sunday of October at 2:00 A.M.
<dt><br>TZ=NST3:30NDT1:30
<dd>Newfoundland Standard Time is 3 and 1/2 hours earlier than Coordinated Universal Time (UTC).&nbsp; Standard time and daylight
 saving time both apply to this locale.&nbsp; Newfoundland Daylight Time is 1 and 1/2 hours earlier than Coordinated Universal
 Time (UTC).
<dt><br>TZ=Central Europe Time-2:00
<dd>Central European Time is 2 hours later than Coordinated Universal Time (UTC).&nbsp; Daylight saving time does not apply in
 this locale.
</dl>
<h2 id="The_OSD2_TZ_Environment_Variable"> The OS/2 TZ Environment Variable </h2>
<br>On the OS/2 platform, an alternate format of the <tt> TZ</tt> environment variable is supported, in addition to the standard
 format described in the preceding section.&nbsp; The value of the OS/2 <tt> TZ</tt> environment variable should be set as
 follows (spaces are for clarity only):
<dl>
<dt>std offset dst, rule
<dd>
</dl>
<br>This format will be used if after scanning the standard format there are additional fields or the format has not been
 identified as standard.
<br>The standard format is identified if an offset follows dst; characters J, M, /, or :&nbsp; are found in rule; or some
 fields are empty.
<br><br>The alternate expanded format is as follows (fields may not be empty):
<dl>
<dt>stdoffsetdst,sm,sw,sd,st,em,ew,ed,et,shift
<dd>
</dl>
<dl>
<dt>std, dst
<dd>three or more letters that are the designation for the standard<b> (std)</b> and summer<b> (dst)</b> time zone.&nbsp; Upper-
 and lowercase letters are allowed.&nbsp; Any characters except for a leading colon (:), digits, comma (,), minus (-), plus
 (+), and ASCII NUL (\0) are allowed.
<dt><br>offset
<dd>indicates the value one must add to the local time to arrive at Coordinated Universal Time (UTC).&nbsp; The<b> offset</b>
 has the form:
<dl>
<dt>hh&#91;:mm&#91;:ss&#93;&#93;
<dd>
</dl>
<br>The minutes<b> (mm)</b> and seconds<b> (ss)</b> are optional.&nbsp; The hour<b> (hh)</b> is required and may be a single
 digit.&nbsp; The value is always interpreted as a decimal number.&nbsp; The hour may be between 0 and 24, and the minutes
 (and seconds) - if present - between 0 and 59.&nbsp; If preceded by a &quot;-&quot;, the time zone will be east of the <b>
 Prime Meridian</b>; otherwise it will be west (which may be indicated by an optional preceding &quot;+&quot;).
<dt><br>rule
<dd>indicates when to change to and back from summer time and the time shift for summer time.&nbsp; The<b> rule</b> has the form:
<dl>
<dt>sm,sw,sd,st,em,ew,ed,et,shift
<dd>
</dl>
<br>where<b> sm,sw,sd,st</b> describe when the change from standard to summer time occurs and<b> em,ew,ed,et</b> describe
 when the change back happens.
<br><br><b>sm</b> and<b> em</b> specify the starting and ending month (1 - 12) of the summer time.
<br><br><b>sw</b> and<b> ew</b> specify the starting and ending week of the summer time.&nbsp; You can specify the last week
 of the month ( -1 ), or week 1 to 4.&nbsp; Week 0 has a special meaning for the day field (<b> sd</b> or<b> ed</b> ).
<br><br><b>sd/ed</b> Starting/ending day of dst,
<br><br>0 - 6 ( weekday Sun to Sat ) if<b> sw/ew</b> is not zero,
<br><br>1 - 31 ( day of the month ) if<b> sw/ew</b> is zero
<br><br><b>st/et</b> Starting/ending time (in seconds after midnight) of the summer time.
<br><br><b>shift</b> Amount of time change (in seconds).
</dl>
<br>An example of the default setting is:
<dl>
<dt>TZ=EST5EDT,4,1,0,7200,10,-1,0,7200,3600
<dd>This is the full specification for the default when the <tt> TZ</tt> variable is not set.&nbsp; Eastern Standard Time is 5
 hours earlier than Coordinated Universal Time (UTC).&nbsp; Standard time and daylight saving time both apply to this locale.
&nbsp; Eastern Daylight Time (EDT) is one hour ahead of standard time.&nbsp; Daylight saving time starts on the first (1)
 Sunday (0) of April (4) at 2:00 A.M.&nbsp; and ends on the last (-1) Sunday (0) of October (10) at 2:00 A.M.
</dl>
<h1 id="Graphics_Library"> Graphics Library </h1>
<br>The Watcom C Graphics Library consists of a large number of functions that provide graphical image support under DOS and
 QNX.&nbsp; This chapter provides an overview of this support.&nbsp; The following topics are discussed.
<ul>
<li>Graphics Functions
<li>Graphics Adapters
<li>Classes of Graphics Functions
<ol>
<li>Environment Functions
<li>Coordinate System Functions
<li>Attribute Functions
<li>Drawing Functions
<li>Text Functions
<li>Graphics Text Functions
<li>Image Manipulation Functions
<li>Font Manipulation Functions
<li>Presentation Graphics Functions
<br><br>&nbsp;&nbsp;&nbsp;&nbsp; Display Functions
<br>&nbsp;&nbsp;&nbsp;&nbsp; Analyze Functions
<br>&nbsp;&nbsp;&nbsp;&nbsp; Utility Functions
</ol>
<li>Graphics Header Files
</ul>
<h2 id="Graphics_Functions"> Graphics Functions </h2>
<br>Graphics functions are used to display graphical images such as lines and circles upon the computer screen.&nbsp; Functions
 are also provided for displaying text along with the graphics output.
<h2 id="Graphics_Adapters"> Graphics Adapters </h2>
<br>Support is provided for both color and monochrome screens which are connected to the computer using any of the following
 graphics adapters:
<ul>
<li>IBM Monochrome Display/Printer Adapter (MDPA)
<li>IBM Color Graphics Adapter (CGA)
<li>IBM Enhanced Graphics Adapter (EGA)
<li>IBM Multi-Color Graphics Array (MCGA)
<li>IBM Video Graphics Array (VGA)
<li>Hercules Monochrome Adapter
<li>SuperVGA adapters (SVGA) supplied by various manufacturers
</ul>
<h2 id="Classes_of_Graphics_Functions"> Classes of Graphics Functions </h2>
<br>The functions in the Watcom C Graphics Library can be organized into a number of classes:
<dl>
<dt>Environment Functions
<dd>
<br>These functions deal with the hardware environment.
<dt><br>Coordinate System Functions
<dd>
<br>These functions deal with coordinate systems and mapping coordinates from one system to another.
<dt><br>Attribute Functions
<dd>
<br>These functions control the display of graphical images.
<dt><br>Drawing Functions
<dd>
<br>These functions display graphical images such as lines and ellipses.
<dt><br>Text Functions
<dd>
<br>These functions deal with displaying text in both graphics and text modes.
<dt><br>Graphics Text Functions
<dd>
<br>These functions deal with displaying graphics text.
<dt><br>Image Manipulation Functions
<dd>
<br>These functions store and retrieve screen images.
<dt><br>Font Manipulation Functions
<dd>
<br>These functions deal with displaying font based text.
<dt><br>Presentation Graphics Functions
<dd>
<br>These functions deal with displaying presentation graphics elements such as bar charts and pie charts.
</dl>
<br>The following subsections describe these function classes in more detail.&nbsp; Each function in the class is noted with
 a brief description of its purpose.
<h3 id="Environment_Functions"> Environment Functions </h3>
<br>These functions deal with the hardware environment.&nbsp; The <tt> _getvideoconfig</tt> function returns information about
 the current video mode and the hardware configuration.&nbsp; The <tt> _setvideomode</tt> function selects a new video mode.
<br><br>Some video modes support multiple pages of screen memory.&nbsp; The visual page (the one displayed on the screen)
 may be different than the active page (the one to which objects are being written).
<br><br>The following functions are defined:
<dl>
<dt><a href="#_getactivepage">_getactivepage</a>
<dd>get the number of the current active graphics page
<dt><br><a href="#_getvideoconfig">_getvideoconfig</a>
<dd>get information about the graphics configuration
<dt><br><a href="#_getvisualpage">_getvisualpage</a>
<dd>get the number of the current visual graphics page
<dt><br><a href="#_grstatus">_grstatus</a>
<dd>get the status of the most recently called graphics library function
<dt><br><a href="#_setactivepage">_setactivepage</a>
<dd>set the active graphics page (the page to which graphics objects are drawn)
<dt><br><a href="#_settextrows">_settextrows</a>
<dd>set the number of rows of text displayed on the screen
<dt><br><a href="#_setvideomode">_setvideomode</a>
<dd>select the video mode to be used
<dt><br><a href="#_setvideomoderows">_setvideomoderows</a>
<dd>select the video mode and the number of text rows to be used
<dt><br><a href="#_setvisualpage">_setvisualpage</a>
<dd>set the visual graphics page (the page displayed on the screen)
</dl>
<h3 id="Coordinate_System_Functions"> Coordinate System Functions </h3>
<br>These functions deal with coordinate systems and mapping coordinates from one system to another.&nbsp; The Watcom C Graphics
 Library supports three coordinate systems:&nbsp; 
<ol>
<li>Physical coordinates
<li>View coordinates
<li>Window coordinates
</ol>
<br>Physical coordinates match the physical dimensions of the screen.&nbsp; The physical origin, denoted (0,0), is located
 at the top left corner of the screen.&nbsp; A pixel to the right of the origin has a positive x-coordinate and a pixel below
 the origin will have a positive y-coordinate.&nbsp; The x- and y-coordinates will never be negative values.
<br><br>The view coordinate system can be defined upon the physical coordinate system by moving the origin from the top left
 corner of the screen to any physical coordinate (see the <tt> _setvieworg</tt> function).&nbsp; In the view coordinate system,
 negative x- and y-coordinates are allowed.&nbsp; The scale of the view and physical coordinate systems is identical (both
 are in terms of pixels).
<br><br>The window coordinate system is defined in terms of a range of user-specified values (see the <tt> _setwindow</tt>
 function).&nbsp; These values are scaled to map onto the physical coordinates of the screen.&nbsp; This allows for consistent
 pictures regardless of the resolution (number of pixels) of the screen.
<br><br>The following functions are defined:
<dl>
<dt><a href="#_getcliprgn">_getcliprgn</a>
<dd>get the boundary of the current clipping region
<dt><br><a href="#_getphyscoord">_getphyscoord</a>
<dd>get the physical coordinates of a point in view coordinates
<dt><br><a href="#_getviewcoord">_getviewcoord</a>
<dd>get the view coordinates of a point in physical coordinates
<dt><br>_getviewcoord_w (see <a href="#_getviewcoord">_getviewcoord</a>)
<dd>get the view coordinates of a point in window coordinates
<dt><br>_getviewcoord_wxy (see <a href="#_getviewcoord">_getviewcoord</a>)
<dd>get the view coordinates of a point in window coordinates
<dt><br><a href="#_getwindowcoord">_getwindowcoord</a>
<dd>get the window coordinates of a point in view coordinates
<dt><br><a href="#_setcliprgn">_setcliprgn</a>
<dd>set the boundary of the clipping region
<dt><br><a href="#_setvieworg">_setvieworg</a>
<dd>set the position to be used as the origin of the view coordinate system
<dt><br><a href="#_setviewport">_setviewport</a>
<dd>set the boundary of the clipping region and the origin of the view coordinate system
<dt><br><a href="#_setwindow">_setwindow</a>
<dd>define the boundary of the window coordinate system
</dl>
<h3 id="Attribute_Functions"> Attribute Functions </h3>
<br>These functions control the display of graphical images such as lines and circles.&nbsp; Lines and figures are drawn using
 the current color (see the <tt> _setcolor</tt> function), the current line style (see the <tt> _setlinestyle</tt> function),
 the current fill mask (see the <tt> _setfillmask</tt> function), and the current plotting action (see the <tt> _setplotaction</tt>
 function).
<br><br>The following functions are defined:
<dl>
<dt><a href="#_getarcinfo">_getarcinfo</a>
<dd>get the endpoints of the most recently drawn arc
<dt><br><a href="#_getbkcolor">_getbkcolor</a>
<dd>get the background color
<dt><br><a href="#_getcolor">_getcolor</a>
<dd>get the current color
<dt><br><a href="#_getfillmask">_getfillmask</a>
<dd>get the current fill mask
<dt><br><a href="#_getlinestyle">_getlinestyle</a>
<dd>get the current line style
<dt><br><a href="#_getplotaction">_getplotaction</a>
<dd>get the current plotting action
<dt><br><a href="#_remapallpalette">_remapallpalette</a>
<dd>assign colors for all pixel values
<dt><br><a href="#_remappalette">_remappalette</a>
<dd>assign color for one pixel value
<dt><br><a href="#_selectpalette">_selectpalette</a>
<dd>select a palette
<dt><br><a href="#_setbkcolor">_setbkcolor</a>
<dd>set the background color
<dt><br><a href="#_setcolor">_setcolor</a>
<dd>set the current color
<dt><br><a href="#_setfillmask">_setfillmask</a>
<dd>set the current fill mask
<dt><br><a href="#_setlinestyle">_setlinestyle</a>
<dd>set the current line style
<dt><br><a href="#_setplotaction">_setplotaction</a>
<dd>set the current plotting action
</dl>
<h3 id="Drawing_Functions"> Drawing Functions </h3>
<br>These functions display graphical images such as lines and ellipses.&nbsp; Functions exist to draw straight lines (see
 the <tt> _lineto</tt> functions), rectangles (see the <tt> _rectangle</tt> functions), polygons (see the <tt> _polygon</tt>
 functions), ellipses (see the <tt> _ellipse</tt> functions), elliptical arcs (see the <tt> _arc</tt> functions) and pie-shaped
 wedges from ellipses (see the <tt> _pie</tt> functions).
<br><br>These figures are drawn using the attributes described in the previous section.&nbsp; The functions ending with<tt>
 _w</tt> or<tt> _wxy</tt> use the window coordinate system; the others use the view coordinate system.
<br><br>The following functions are defined:
<dl>
<dt><a href="#_arc">_arc</a>
<dd>draw an arc
<dt><br>_arc_w (see <a href="#_arc">_arc</a>)
<dd>draw an arc using window coordinates
<dt><br>_arc_wxy (see <a href="#_arc">_arc</a>)
<dd>draw an arc using window coordinates
<dt><br><a href="#_clearscreen">_clearscreen</a>
<dd>clear the screen and fill with the background color
<dt><br><a href="#_ellipse">_ellipse</a>
<dd>draw an ellipse
<dt><br>_ellipse_w (see <a href="#_ellipse">_ellipse</a>)
<dd>draw an ellipse using window coordinates
<dt><br>_ellipse_wxy (see <a href="#_ellipse">_ellipse</a>)
<dd>draw an ellipse using window coordinates
<dt><br><a href="#_floodfill">_floodfill</a>
<dd>fill an area of the screen with the current color
<dt><br>_floodfill_w (see <a href="#_floodfill">_floodfill</a>)
<dd>fill an area of the screen in window coordinates with the current color
<dt><br><a href="#_getcurrentposition">_getcurrentposition</a>
<dd>get the coordinates of the current output position
<dt><br>_getcurrentposition_w (see <a href="#_getcurrentposition">_getcurrentposition</a>)
<dd>get the window coordinates of the current output position
<dt><br><a href="#_getpixel">_getpixel</a>
<dd>get the color of the pixel at the specified position
<dt><br>_getpixel_w (see <a href="#_getpixel">_getpixel</a>)
<dd>get the color of the pixel at the specified position in window coordinates
<dt><br><a href="#_lineto">_lineto</a>
<dd>draw a line from the current position to a specified position
<dt><br>_lineto_w (see <a href="#_lineto">_lineto</a>)
<dd>draw a line from the current position to a specified position in window coordinates
<dt><br><a href="#_moveto">_moveto</a>
<dd>set the current output position
<dt><br>_moveto_w (see <a href="#_moveto">_moveto</a>)
<dd>set the current output position using window coordinates
<dt><br><a href="#_pie">_pie</a>
<dd>draw a wedge of a &quot;pie&quot;
<dt><br>_pie_w (see <a href="#_pie">_pie</a>)
<dd>draw a wedge of a &quot;pie&quot; using window coordinates
<dt><br>_pie_wxy (see <a href="#_pie">_pie</a>)
<dd>draw a wedge of a &quot;pie&quot; using window coordinates
<dt><br><a href="#_polygon">_polygon</a>
<dd>draw a polygon
<dt><br>_polygon_w (see <a href="#_polygon">_polygon</a>)
<dd>draw a polygon using window coordinates
<dt><br>_polygon_wxy (see <a href="#_polygon">_polygon</a>)
<dd>draw a polygon using window coordinates
<dt><br><a href="#_rectangle">_rectangle</a>
<dd>draw a rectangle
<dt><br>_rectangle_w (see <a href="#_rectangle">_rectangle</a>)
<dd>draw a rectangle using window coordinates
<dt><br>_rectangle_wxy (see <a href="#_rectangle">_rectangle</a>)
<dd>draw a rectangle using window coordinates
<dt><br><a href="#_setpixel">_setpixel</a>
<dd>set the color of the pixel at the specified position
<dt><br>_setpixel_w (see <a href="#_setpixel">_setpixel</a>)
<dd>set the color of the pixel at the specified position in window coordinates
</dl>
<h3 id="Text_Functions"> Text Functions </h3>
<br>These functions deal with displaying text in both graphics and text modes.&nbsp; This type of text output can be displayed
 in only one size.
<br><br>This text is displayed using the <tt> _outtext</tt> and <tt> _outmem</tt> functions.&nbsp; The output position for
 text follows the last text that was displayed or can be reset (see the <tt> _settextposition</tt> function).&nbsp; Text windows
 can be created (see the <tt> _settextwindow</tt> function) in which the text will scroll.&nbsp; Text is displayed with the
 current text color (see the <tt> _settextcolor</tt> function).
<br><br>The following functions are defined:
<dl>
<dt><a href="#_clearscreen">_clearscreen</a>
<dd>clear the screen and fill with the background color
<dt><br><a href="#_displaycursor">_displaycursor</a>
<dd>determine whether the cursor is to be displayed after a graphics function completes execution
<dt><br><a href="#_getbkcolor">_getbkcolor</a>
<dd>get the background color
<dt><br><a href="#_gettextcolor">_gettextcolor</a>
<dd>get the color used to display text
<dt><br><a href="#_gettextcursor">_gettextcursor</a>
<dd>get the shape of the text cursor
<dt><br><a href="#_gettextposition">_gettextposition</a>
<dd>get the current output position for text
<dt><br><a href="#_gettextwindow">_gettextwindow</a>
<dd>get the boundary of the current text window
<dt><br><a href="#_outmem">_outmem</a>
<dd>display a text string of a specified length
<dt><br><a href="#_outtext">_outtext</a>
<dd>display a text string
<dt><br><a href="#_scrolltextwindow">_scrolltextwindow</a>
<dd>scroll the contents of the text window
<dt><br><a href="#_setbkcolor">_setbkcolor</a>
<dd>set the background color
<dt><br><a href="#_settextcolor">_settextcolor</a>
<dd>set the color used to display text
<dt><br><a href="#_settextcursor">_settextcursor</a>
<dd>set the shape of the text cursor
<dt><br><a href="#_settextposition">_settextposition</a>
<dd>set the output position for text
<dt><br><a href="#_settextwindow">_settextwindow</a>
<dd>set the boundary of the region used to display text
<dt><br><a href="#_wrapon">_wrapon</a>
<dd>permit or disallow wrap-around of text in a text window
</dl>
<h3 id="Graphics_Text_Functions"> Graphics Text Functions </h3>
<br>These functions deal with displaying graphics text.&nbsp; Graphics text is displayed as a sequence of line segments, and
 can be drawn in different sizes (see the <tt> _setcharsize</tt> function), with different orientations (see the <tt> _settextorient</tt>
 function) and alignments (see the <tt> _settextalign</tt> function).&nbsp; The functions ending with<tt> _w</tt> use the
 window coordinate system; the others use the view coordinate system.
<br><br>The following functions are defined:
<dl>
<dt><a href="#_gettextextent">_gettextextent</a>
<dd>get the bounding rectangle for a graphics text string
<dt><br><a href="#_gettextsettings">_gettextsettings</a>
<dd>get information about the current settings used to display graphics text
<dt><br><a href="#_grtext">_grtext</a>
<dd>display graphics text
<dt><br>_grtext_w (see <a href="#_grtext">_grtext</a>)
<dd>display graphics text using window coordinates
<dt><br><a href="#_setcharsize">_setcharsize</a>
<dd>set the character size used to display graphics text
<dt><br>_setcharsize_w (see <a href="#_setcharsize">_setcharsize</a>)
<dd>set the character size in window coordinates used to display graphics text
<dt><br><a href="#_setcharspacing">_setcharspacing</a>
<dd>set the character spacing used to display graphics text
<dt><br>_setcharspacing_w (see <a href="#_setcharspacing">_setcharspacing</a>)
<dd>set the character spacing in window coordinates used to display graphics text
<dt><br><a href="#_settextalign">_settextalign</a>
<dd>set the alignment used to display graphics text
<dt><br><a href="#_settextorient">_settextorient</a>
<dd>set the orientation used to display graphics text
<dt><br><a href="#_settextpath">_settextpath</a>
<dd>set the path used to display graphics text
</dl>
<h3 id="Image_Manipulation_Functions"> Image Manipulation Functions </h3>
<br>These functions are used to transfer screen images.&nbsp; The <tt> _getimage</tt> function transfers a rectangular image
 from the screen into memory.&nbsp; The <tt> _putimage</tt> function transfers an image from memory back onto the screen.
&nbsp; The functions ending with<tt> _w</tt> or<tt> _wxy</tt> use the window coordinate system; the others use the view coordinate
 system.
<br><br>The following functions are defined:
<dl>
<dt><a href="#_getimage">_getimage</a>
<dd>store an image of an area of the screen into memory
<dt><br>_getimage_w (see <a href="#_getimage">_getimage</a>)
<dd>store an image of an area of the screen in window coordinates into memory
<dt><br>_getimage_wxy (see <a href="#_getimage">_getimage</a>)
<dd>store an image of an area of the screen in window coordinates into memory
<dt><br><a href="#_imagesize">_imagesize</a>
<dd>get the size of a screen area
<dt><br>_imagesize_w (see <a href="#_imagesize">_imagesize</a>)
<dd>get the size of a screen area in window coordinates
<dt><br>_imagesize_wxy (see <a href="#_imagesize">_imagesize</a>)
<dd>get the size of a screen area in window coordinates
<dt><br><a href="#_putimage">_putimage</a>
<dd>display an image from memory on the screen
<dt><br>_putimage_w (see <a href="#_putimage">_putimage</a>)
<dd>display an image from memory on the screen using window coordinates
</dl>
<h3 id="Font_Manipulation_Functions"> Font Manipulation Functions </h3>
<br>These functions are for the display of fonts compatible with Microsoft Windows.&nbsp; Fonts are contained in files with
 an extension of<tt> .FON.</tt>&nbsp; Before font based text can be displayed, the fonts must be registered with the <tt>
 _registerfonts</tt> function, and a font must be selected with the <tt> _setfont</tt> function.
<br><br>The following functions are defined:
<dl>
<dt><a href="#_getfontinfo">_getfontinfo</a>
<dd>get information about the currently selected font
<dt><br><a href="#_getgtextextent">_getgtextextent</a>
<dd>get the length in pixels of a text string
<dt><br><a href="#_getgtextvector">_getgtextvector</a>
<dd>get the current value of the font text orientation vector
<dt><br><a href="#_outgtext">_outgtext</a>
<dd>display a string of text in the current font
<dt><br><a href="#_registerfonts">_registerfonts</a>
<dd>initialize the font graphics system
<dt><br><a href="#_setfont">_setfont</a>
<dd>select a font from among the registered fonts
<dt><br><a href="#_setgtextvector">_setgtextvector</a>
<dd>set the font text orientation vector
<dt><br><a href="#_unregisterfonts">_unregisterfonts</a>
<dd>frees memory allocated by the font graphics system
</dl>
<h3 id="Presentation_Graphics_Functions"> Presentation Graphics Functions </h3>
<br>These functions provide a system for displaying and manipulating presentation graphics elements such as bar charts and
 pie charts.&nbsp; The presentation graphics functions can be further divided into three classes:
<dl>
<dt>Display Functions
<dd>
<br>These functions are for the initialization of the presentation graphics system and the displaying of charts.
<dt><br>Analyze Functions
<dd>
<br>These functions calculate default values for chart elements without actually displaying the chart.
<dt><br>Utility Functions
<dd>
<br>These functions provide additional support to control the appearance of presentation graphics elements.
</dl>
<br>The following subsections describe these function classes in more detail.&nbsp; Each function in the class is noted with
 a brief description of its purpose.
<h4 id="Display_Functions"> Display Functions </h4>
<br>These functions are for the initialization of the presentation graphics system and the displaying of charts.&nbsp; The
 <tt> _pg_initchart</tt> function initializes the system and should be the first presentation graphics function called.&nbsp;
 The single-series functions display a single set of data on a chart; the multi-series functions (those ending with<tt> ms)</tt>
 display several sets of data on the same chart.
<br><br>The following functions are defined:
<dl>
<dt><a href="#_pg_chart">_pg_chart</a>
<dd>display a bar, column or line chart
<dt><br>_pg_chartms (see <a href="#_pg_chart">_pg_chart</a>)
<dd>display a multi-series bar, column or line chart
<dt><br><a href="#_pg_chartpie">_pg_chartpie</a>
<dd>display a pie chart
<dt><br><a href="#_pg_chartscatter">_pg_chartscatter</a>
<dd>display a scatter chart
<dt><br>_pg_chartscatterms (see <a href="#_pg_chartscatter">_pg_chartscatter</a>)
<dd>display a multi-series scatter chart
<dt><br><a href="#_pg_defaultchart">_pg_defaultchart</a>
<dd>initialize the chart environment for a specific chart type
<dt><br><a href="#_pg_initchart">_pg_initchart</a>
<dd>initialize the presentation graphics system
</dl>
<h4 id="Analyze_Functions"> Analyze Functions </h4>
<br>These functions calculate default values for chart elements without actually displaying the chart.&nbsp; The functions
 ending with<tt> ms</tt> analyze multi-series charts; the others analyze single-series charts.
<br><br>The following functions are defined:
<dl>
<dt><a href="#_pg_analyzechart">_pg_analyzechart</a>
<dd>analyze a bar, column or line chart
<dt><br>_pg_analyzechartms (see <a href="#_pg_analyzechart">_pg_analyzechart</a>)
<dd>analyze a multi-series bar, column or line chart
<dt><br><a href="#_pg_analyzepie">_pg_analyzepie</a>
<dd>analyze a pie chart
<dt><br><a href="#_pg_analyzescatter">_pg_analyzescatter</a>
<dd>analyze a scatter chart
<dt><br>_pg_analyzescatterms (see <a href="#_pg_analyzescatter">_pg_analyzescatter</a>)
<dd>analyze a multi-series scatter chart
</dl>
<h4 id="Utility_Functions"> Utility Functions </h4>
<br>These functions provide additional support to control the appearance of presentation graphics elements.
<br><br>The following functions are defined:
<dl>
<dt><a href="#_pg_getchardef">_pg_getchardef</a>
<dd>get bit-map definition for a specific character
<dt><br><a href="#_pg_getpalette">_pg_getpalette</a>
<dd>get presentation graphics palette (colors, line styles, fill patterns and plot characters)
<dt><br><a href="#_pg_getstyleset">_pg_getstyleset</a>
<dd>get presentation graphics style-set (line styles for window borders and grid lines)
<dt><br><a href="#_pg_hlabelchart">_pg_hlabelchart</a>
<dd>display text horizontally on a chart
<dt><br><a href="#_pg_resetpalette">_pg_resetpalette</a>
<dd>reset presentation graphics palette to default values
<dt><br><a href="#_pg_resetstyleset">_pg_resetstyleset</a>
<dd>reset presentation graphics style-set to default values
<dt><br><a href="#_pg_setchardef">_pg_setchardef</a>
<dd>set bit-map definition for a specific character
<dt><br><a href="#_pg_setpalette">_pg_setpalette</a>
<dd>set presentation graphics palette (colors, line styles, fill patterns and plot characters)
<dt><br><a href="#_pg_setstyleset">_pg_setstyleset</a>
<dd>set presentation graphics style-set (line styles for window borders and grid lines)
<dt><br><a href="#_pg_vlabelchart">_pg_vlabelchart</a>
<dd>display text vertically on a chart
</dl>
<h2 id="Graphics_Header_Files"> Graphics Header Files </h2>
<br>All program modules which use the Graphics Library should include the header file<tt> graph.h.</tt>&nbsp; This file contains
 prototypes for all the functions in the library as well as the structures and constants used by them.
<br><br>Modules using the presentation graphics functions should also include the header file<tt> pgchart.h.</tt>
<h1 id="DOS_Considerations"> DOS Considerations </h1>
<br>For the most part, DOS (Disk Operating System) for your personal computer can be ignored, unless an application is highly
 dependent upon the hardware or uses specialized functions from the operating system.&nbsp; In this section, some of these
 aspects will be addressed.&nbsp; For a more detailed explanation, the technical documentation for the DOS that you are using
 should be consulted.
<h2 id="DOS_Devices"> DOS Devices </h2>
<br>Most of the hardware devices attached to your computer have names which are recognized by DOS.&nbsp; These names cannot
 be used as the names of files.&nbsp; Some examples are:
<dl>
<dt>CON
<dd>the console (screen)
<dt><br>AUX
<dd>the serial (auxiliary) port
<dt><br>COM1
<dd>serial port 1
<dt><br>COM2
<dd>serial port 2
<dt><br>PRN
<dd>the printer on the parallel port
<dt><br>LPT1
<dd>the printer on the first parallel port
<dt><br>LPT2
<dd>the printer on the second parallel port
<dt><br>LPT3
<dd>the printer on the third parallel port
<dt><br>NUL
<dd>a non-existent device, which accepts (and discards) output
</dl>
<br>Disks (such as diskette drives and hard disks) are specified as single letters, starting with the letter A.&nbsp; A colon
 character (:) follows the letter for the drive.&nbsp; Either uppercase or lowercase letters can be used.&nbsp; Some examples
 are:
<dl>
<dt>A:
<dd>the first disk drive
<dt><br>a:
<dd>the first disk drive
<dt><br>e:
<dd>the fifth disk drive
</dl>
<h2 id="DOS_Directories"> DOS Directories </h2>
<br>Each disk drive is conceptually divided into directories.&nbsp; Each directory is capable of containing files and/or other
 directories.&nbsp; The initial directory, called the<b> root directory,</b> is not named; all other directories are named
 and can be accessed with a<b> path</b> specification.&nbsp; A path is either absolute or relative to the current working
 directory.&nbsp; Some examples are:
<dl>
<dt>b:\
<dd>the root directory of the second disk drive
<dt><br>\
<dd>the root directory of the current disk drive
<dt><br>\outer\middle\inner
<dd>
<br>directory<tt> inner</tt> which is contained within directory<tt> middle</tt> which is contained within directory<tt> outer</tt>
 which is contained within the root directory of the current disk drive.
</dl>
<br>Directory names are separated by backslash characters (\).&nbsp; The initial backslash character informs DOS that the
 path starts with the root directory.&nbsp; When the first character is not a backslash, the path starts with the current
 working directory on the indicated device.
<br><br>The DOS<tt> CHDIR (CD)</tt> command can be used to change the current working directory for a device.&nbsp; Suppose
 that the following DOS commands were issued:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; chdir a:\apps\payroll</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; chdir c:\mydir</tt>
<br><br>Then, the following path specifications are:
<dl>
<dt>Relative Path&nbsp;&nbsp;&nbsp;&nbsp; Absolute Path
<dt>a:xxx\y
<dd>a:\apps\payroll\xxx\y
<dt><br>c:zzzzz
<dd>c:\mydir\zzzzz
</dl>
<br>When no drive is specified, DOS uses the current disk drive.
<h2 id="DOS_File_Names"> DOS File Names </h2>
<br>The name of a file within a directory has the format<tt> filename.ext</tt> where the required<tt> filename</tt> portion
 is up to eight characters in length and the optional<tt> ext</tt> portion is up to three characters in length.&nbsp; A period
 character (.) separates the two names when the<tt> ext</tt> portion is present.
<br><br>More than eight characters can be given in the<tt> filename.</tt>&nbsp; DOS truncates the name to eight characters
 when a longer<tt> filename</tt> is given.&nbsp; This may lead to erroneous results in some cases, since the files<tt> MYBIGDATAFILE</tt>
 and<tt> MYBIGDATES</tt> both refer to the file<tt> MYBIGDAT.</tt>
<br><br>The characters used in file names may be letters, digits as well as some other characters documented in your DOS technical
 documentation.&nbsp; Most people restrict their file names to contain only letters and digits.&nbsp; Uppercase and lowercase
 letters are treated as being equivalent (file names are case insensitive).&nbsp; Thus, the files
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MYDATA.NEW</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; mydata.new</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MyData.New</tt>
<br><br>all refer to the same file.
<br><br>You cannot use a DOS device name (such as <tt> CON</tt> or <tt> PRN</tt>, for example) for a file name.&nbsp; See
 the section<b> DOS Devices</b> for a list of these reserved names.
<br><br>A complete file designation has the following format:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; drive:\path\filename.ext</tt>
<br><br>where:
<dl>
<dt>drive:
<dd>is an optional disk drive specification.&nbsp; If omitted, the default drive is used.&nbsp; Some examples are:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; A:&nbsp; (first disk drive)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; c:&nbsp; (third disk drive)</tt>
<dt><br>\path\
<dd>is the path specification for the directory containing the desired file.&nbsp; Some examples are:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; \mylib\</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; \apps\payroll\</tt>
<dt><br>filename.ext
<dd>is the name of the file.
</dl>
<br>Suppose that the current working directories are as follows:
<dl>
<dt>Drive&nbsp;&nbsp;&nbsp;&nbsp; Directory
<dt>A:
<dd>\payroll
<dt><br>B:
<dd>\&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (root directory)
<dt><br>C:
<dd>\source\c
</dl>
<br>and that the default disk drive is<tt> C:.</tt>&nbsp; Then, the following file designations will result in the indicated
 file references:
<dl>
<dt>Designation&nbsp;&nbsp;&nbsp;&nbsp; Actual File
<dt>pgm.c
<dd>C:\SOURCE\C\PGM.C
<dt><br>\basic.dat
<dd>C:\BASIC.DAT
<dt><br>paypgm\outsep.c
<dd>C:\SOURCE\C\PAYPGM\OUTSEP.C
<dt><br>b:data
<dd>B:\DATA
<dt><br>a:employee
<dd>A:\PAYROLL\EMPLOYEE
<dt><br>a:\deduct\yr1988
<dd>A:\DEDUCT\YR1988
</dl>
<h2 id="DOS_Files"> DOS Files </h2>
<br>DOS files are stored within directories on disk drives.&nbsp; Most software, including Watcom C/C++, treats files in two
 representations:
<dl>
<dt>BINARY
<dd>These files can contain arbitrary data.&nbsp; It is the responsibility of the software to recognize records within the file
 if they exist.
<dt><br>TEXT
<dd>These files contain lines of &quot;printable&quot; characters.&nbsp; Each line is delimited by a carriage return character
 followed by a linefeed character.
</dl>
<br>Since the conceptual view of text files in the C and C++ languages is that lines are terminated by only linefeed characters,
 the Watcom C library will remove carriage returns on input and add them on output, provided the mode is set to be<b> text.</b>
&nbsp; This mode is set upon opening the file or with the <tt> setmode</tt> function.
<h2 id="DOS_Commands"> DOS Commands </h2>
<br>DOS commands are documented in the technical documentation for your DOS system.&nbsp; These may be invoked from a C or
 C++ program with the <tt> system</tt> function.
<h2 id="DOS_Interrupts"> DOS Interrupts </h2>
<br>DOS interrupts and 8086 interrupts are documented in the technical documentation for your DOS system.&nbsp; These may
 be generated from a C or C++ program by calling the <tt> bdos</tt>, <tt> intdos</tt>, <tt> intdosx</tt>, <tt> intr</tt>,
 <tt> int386</tt>, <tt> int386x</tt>, <tt> int86</tt> and <tt> int86x</tt> functions.
<h2 id="DOS_Processes"> DOS Processes </h2>
<br>Currently, DOS has the capability to execute only one process at a time.&nbsp; Thus, when a process is initiated with
 the <tt> spawn...</tt>&nbsp; parameter <tt> P_WAIT</tt>, the new process will execute to completion before control returns
 to the initiating program.&nbsp; Otherwise, the new task replaces the initial task.&nbsp; Tasks can be started by using the
 <tt> system</tt>, <tt> exec...</tt>&nbsp; and <tt> spawn...</tt>&nbsp; functions.
<h1 id="Library_Functions_and_Macros"> Library Functions and Macros </h1>
<br>Each of the functions or macros in the C Library is described in this chapter.&nbsp; Each description consists of a number
 of subsections:
<dl>
<dt>Synopsis:
<dd>This subsection gives the header files that should be included within a source file that references the function or macro.
&nbsp; It also shows an appropriate declaration for the function or for a function that could be substituted for a macro.
&nbsp; This declaration is not included in your program; only the header file(s) should be included.
<br>When a pointer argument is passed to a function and that function does not modify the item indicated by that pointer,
 the argument is shown with <tt> const</tt> before the argument.&nbsp; For example,
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; const char *string</tt>
<br><br>indicates that the array pointed at by<b> string</b> is not changed.
<dt><br>Constraints:
<dd>This subsection describes Runtime-constraints for Safer C Library functions.
<dt><br>Safer C:
<dd>This subsection points to the Safer C version of the described &quot;unsafe&quot; function.
<dt><br>Description:
<dd>This subsection is a description of the function or macro.
<dt><br>Returns:
<dd>This subsection describes the return value (if any) for the function or macro.
<dt><br>Errors:
<dd>This subsection describes the possible <tt> errno</tt> values.
<dt><br>See Also:
<dd>This optional subsection provides a list of related functions or macros.
<dt><br>Example:
<dd>This optional subsection consists of one or more examples of the use of the function.&nbsp; The examples are often just fragments
 of code (not complete programs) for illustration purposes.
<dt><br>Classification:
<dd>This subsection provides an indication of where the function or macro is commonly found.&nbsp; The following notation is used:
<dl>
<dt>ANSI
<dd>These functions or macros are defined by the ANSI/ISO C standard.
<dt><br>POSIX 1003.1
<dd>These functions or macros are not defined by the ANSI/ISO C standard.&nbsp; These function are specified in the document<b>
 IEEE Standard Portable Operating System Interface for Computer Environments</b> (IEEE Draft Standard 1003.1-1990).
<dt><br>BIOS
<dd>These functions access a service of the BIOS found in IBM Personal Computers and compatibles.&nbsp; These functions should
 not be used if portability is a consideration.
<dt><br>DOS
<dd>These functions or macros are neither ANSI/ISO nor POSIX.&nbsp; They perform a function related to DOS.&nbsp; They may be
 found in other implementations of C for personal computers with DOS.&nbsp; Use these functions with caution, if portability
 is a consideration.
<dt><br>Intel
<dd>These functions or macros are neither ANSI/ISO nor POSIX.&nbsp; They performs a function related to the Intel x86 architecture.
&nbsp; They may be found in other implementations of C for personal computers using Intel chips.&nbsp; Use these functions
 with caution, if portability is a consideration.
<dt><br>OS/2
<dd>These functions are specific to OS/2.
<dt><br>PC Graphics
<dd>These functions are part of the PC graphics library.
<dt><br>Windows
<dd>These functions are specific to Microsoft Windows.
<dt><br>WATCOM
<dd>These functions or macros are neither ANSI/ISO nor POSIX.&nbsp; They may be found in other implementations of the C language,
 but caution should be used if portability is a consideration.
<dt><br>TR 24731
<dd>These functions are &quot;safer&quot; versions of normal C library functions.&nbsp; They perform more checks on parameters
 and should be used in preference over their &quot;unsafe&quot; version.
</dl>
<dt><br>Systems:
<dd>This subsection provides an indication of where the function or macro is supported.&nbsp; The following notation is used:
<dl>
<dt>All
<dd>This function is available on all systems (we do not include Netware or DOS/PM in this category).
<dt><br>DOS
<dd>This function is available on both 16-bit DOS and 32-bit extended DOS.
<dt><br>DOS/16
<dd>This function is available on 16-bit, real-mode DOS.
<dt><br>DOS/32
<dd>This function is available on 32-bit, protected-mode extended DOS.
<dt><br>DOS/PM
<dd>This 16-bit DOS protected-mode function is supported under Phar Lap's 286|DOS-Extender &quot;RUN286&quot;.&nbsp; The function
 is found in one of Watcom's 16-bit protected-mode DOS libraries (DOSPM*.LIB under the 16-bit OS2 subdirectory).
<dt><br>MACRO
<dd>This function is implemented as a macro (#define) on all systems.
<dt><br>Math
<dd>This function is a math function.&nbsp; Math functions are available on all systems.
<dt><br>Netware
<dd>This function is available on the 32-bit Novell Netware operating system.
<dt><br>OS/2 1.x
<dd>This function is available on IBM OS/2 1.x, a 16-bit protected-mode system for Intel 80286 and upwards compatible systems.
<br>When &quot;(MT)&quot; appears after OS/2, it refers to the<tt> CLIBMTL</tt> library which supports multi-threaded applications.
<br><br>When &quot;(DL)&quot; appears after OS/2, it refers to the<tt> CLIBDLL</tt> library which supports creation of Dynamic
 Link Libraries.
<br><br>When &quot;(all)&quot; appears after &quot;OS/2 1&quot;, it means all versions of the OS/2 1.x libraries.
<br><br>If a function is missing from the OS/2 library, it may be found in Watcom's 16-bit protected-mode DOS libraries (DOSPM*.LIB)
 for Phar Lap's 286|DOS-Extender (RUN286).
<dt><br>OS/2-32
<dd>This function is available on 32-bit IBM OS/2, a protected-mode system for Intel 80386 and upwards compatible systems.
<dt><br>QNX
<dd>This function is available on QNX Software Systems' 16 or 32-bit operating systems.
<dt><br>QNX/16
<dd>This function is available on QNX Software Systems' 16-bit operating system.
<dt><br>QNX/32
<dd>This function is available on QNX Software Systems' 32-bit operating system.
<dt><br>Windows
<dd>This function is available on 16-bit, protected-mode Windows 3.x.
<dt><br>Win386
<dd>This function is available on Microsoft Windows 3.x, using Watcom's Windows Extender for 32-bit protected-mode applications
 running on Intel 386 or upward compatible systems.
<dt><br>Win32
<dd>This function is available on 32-bit Microsoft Windows platforms (Windows 95, Windows 98, Windows NT, Windows 2000, etc.).
&nbsp; It may also be available for Windows 3.x using Win32s support.
</dl>
</dl>
<h2 id="abort"> abort </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void abort( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> abort</tt> function raises the signal SIGABRT.&nbsp; The default action for SIGABRT is to terminate program execution,
 returning control to the process that started the calling program (usually the operating system).&nbsp; The status<b> unsuccessful
 termination</b> is returned to the invoking process by means of the function call<tt> raise(SIGABRT).</tt>&nbsp; The exit
 code returned to the invoking process is <tt> EXIT_FAILURE</tt> which is defined in the<tt> &lt;stdlib.h&gt;</tt> header
 file.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> abort</tt> function does not return to its caller.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atexit">atexit</a>, <a href="#_bgetcmd">_bgetcmd</a>, <a href="#exec___">exec...</a>, <a href="#exit">exit</a>,
 <a href="#_Exit">_Exit</a>, <a href="#_exit">_exit</a>, <a href="#getcmd">getcmd</a>, <a href="#getenv">getenv</a>, <a href="#main">main</a>,
 <a href="#onexit">onexit</a>, <a href="#putenv">putenv</a>, <a href="#spawn___">spawn...</a>, <a href="#system">system</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int major_error = 1;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( major_error )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; abort();</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="abort_handler_s"> abort_handler_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void abort_handler_s(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict msg,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void * restrict ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errno_t error );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> abort_handler_s</tt> function may be passed as an argument to the<tt> set_constraint_handler_s</tt> function.&nbsp;
 It writes a message on the standard error stream in the following format:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Runtime-constraint violation: &lt;msg&gt;</tt>
<br><br>The<tt> abort_handler_s</tt> function then calls the<tt> abort</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> abort_handler_s</tt> function does not return to its caller.
</dl>
<dl>
<dt>See Also:
<dd><a href="#ignore_handler_s">ignore_handler_s</a>, <a href="#set_constraint_handler_s">set_constraint_handler_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; constraint_handler_t&nbsp;&nbsp;&nbsp; old_handler;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; old_handler = set_constraint_handler_s( abort_handler_s );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( getenv_s( NULL, NULL, 0, NULL ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;getenv_s failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; set_constraint_handler_s( old_handler );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Runtime-constraint violation: getenv_s, name == NULL.</tt>
<br><tt>ABNORMAL TERMINATION</tt>
</dl>
<dl>
<dt>Classification:
<dd>TR 24731
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="abs"> abs </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>int abs( int j );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> abs</tt> function returns the absolute value of its integer argument<b> j</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> abs</tt> function returns the absolute value of its argument.
</dl>
<dl>
<dt>See Also:
<dd><a href="#labs">labs</a>, <a href="#llabs">llabs</a>, <a href="#imaxabs">imaxabs</a>, <a href="#fabs">fabs</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d %d %d\n&quot;, abs( -5 ), abs( 0 ), abs( 5 ) );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>5 0 5</tt>
</dl>
<dl>
<dt>Classification:
<dd>ISO C90
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="access"> access, _access, _waccess </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int access( const char *path, int mode );</tt>
<br><tt>int _access( const char *path, int mode );</tt>
<br><tt>int _waccess( const wchar_t *path, int mode );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> access</tt> function determines if the file or directory specified by<b> path</b> exists and if it can be accessed
 with the file permission given by<b> mode</b>.
<br>The<tt> _access</tt> function is identical to<tt> access</tt>.&nbsp; Use<tt> _access</tt> for ANSI naming conventions.
<br><br>When the value of<b> mode</b> is zero, only the existence of the file is verified.&nbsp; The read and/or write permission
 for the file can be determined when<b> mode</b> is a combination of the bits:
<dl>
<dt>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>R_OK
<dd>test for read permission
<dt><br>W_OK
<dd>test for write permission
<dt><br>X_OK
<dd>test for execute permission
<dt><br>F_OK
<dd>test for existence of file
</dl>
<br>With DOS, all files have read permission; it is a good idea to test for read permission anyway, since a later version
 of DOS may support write-only files.
<br><br>The<tt> _waccess</tt> function is identical to<tt> access</tt> except that it accepts a wide-character string argument
 for<b> path</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> access</tt> function returns zero if the file or directory exists and can be accessed with the specified mode.&nbsp;
 Otherwise, -1 is returned and <tt> errno</tt> is set to indicate the error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EACCES
<dd>Access denied because the file's permission does not allow the specified access.
<dt><br>ENOENT
<dd>Path or file not found.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#chmod">chmod</a>, <a href="#fstat">fstat</a>, <a href="#open">open</a>, <a href="#sopen">sopen</a>, <a href="#stat">stat</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main( int argc, char *argv&#91;&#93; )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( argc != 2 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Use: check &lt;filename&gt;\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( access( argv&#91;1&#93;, F_OK ) == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s exists\n&quot;, argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s does not exist\n&quot;, argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( access( argv&#91;1&#93;, R_OK ) == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s is readable\n&quot;, argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( access( argv&#91;1&#93;, W_OK ) == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s is writeable\n&quot;, argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( access( argv&#91;1&#93;, X_OK ) == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s is executable\n&quot;, argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; exit( EXIT_SUCCESS );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>access is POSIX 1003.1
<br>_access is not POSIX
<br>_waccess is not POSIX
</dl>
<dl>
<dt>Systems:
<dd><tt> access - All, Netware</tt>
<br><tt>_access - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_waccess - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="acos"> acos </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double acos( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> acos</tt> function computes the principal value of the arccosine of<b> x</b>.&nbsp; A domain error occurs for arguments
 not in the range &#91;-1,1&#93;.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> acos</tt> function returns the arccosine in the range &#91;0,P&#93;.&nbsp; When the argument is outside the permissible
 range, the <tt> matherr</tt> function is called.&nbsp; Unless the default <tt> matherr</tt> function is replaced, it will
 set the global variable <tt> errno</tt> to <tt> EDOM</tt>, and print a &quot;DOMAIN error&quot; diagnostic message using
 the <tt> stderr</tt> stream.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asin">asin</a>, <a href="#atan">atan</a>, <a href="#atan2">atan2</a>, <a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, acos(.5) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>1.047197</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="acosh"> acosh </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double acosh( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> acosh</tt> function computes the inverse hyperbolic cosine of<b> x</b>.&nbsp; A domain error occurs if the value of<b>
 x</b> is less than 1.0.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> acosh</tt> function returns the inverse hyperbolic cosine value.&nbsp; When the argument is outside the permissible
 range, the <tt> matherr</tt> function is called.&nbsp; Unless the default <tt> matherr</tt> function is replaced, it will
 set the global variable <tt> errno</tt> to <tt> EDOM</tt>, and print a &quot;DOMAIN error&quot; diagnostic message using
 the <tt> stderr</tt> stream.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asinh">asinh</a>, <a href="#atanh">atanh</a>, <a href="#cosh">cosh</a>, <a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, acosh( 1.5 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.962424</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="alloca"> alloca </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>void *alloca( size_t size );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> alloca</tt> function allocates space for an object of<b> size</b> bytes from the stack.&nbsp; The allocated space
 is automatically discarded when the current function exits.&nbsp; The<tt> alloca</tt> function should not be used in an expression
 that is an argument to a function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> alloca</tt> function returns a pointer to the start of the allocated memory.&nbsp; The return value is<tt> NULL</tt>
 if there is insufficient stack space available.
</dl>
<dl>
<dt>See Also:
<dd><a href="#calloc">calloc</a>, <a href="#malloc">malloc</a>, <a href="#stackavail">stackavail</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>FILE *open_err_file( char * );</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = open_err_file( &quot;alloca&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open error file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>FILE *open_err_file( char *name )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; char *buffer;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; /* allocate temp buffer for file name */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; buffer = (char *) alloca( strlen(name) + 5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; if( buffer ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buffer, &quot;%s.err&quot;, name );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( fopen( buffer, &quot;w&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; return( (FILE *) NULL );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_arc"> _arc, _arc_w, _arc_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _arc( short x1, short y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x2, short y2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x3, short y3,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x4, short y4
 );</tt>
<br><br><tt>short _FAR _arc_w( double x1, double y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
 x2, double y2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
 x3, double y3,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double
 x4, double y4 );</tt>
<br><br><tt>short _FAR _arc_wxy( struct _wxycoord _FAR *p1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; struct _wxycoord _FAR *p2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; struct _wxycoord _FAR *p3,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; struct _wxycoord _FAR *p4 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _arc</tt> functions draw elliptical arcs.&nbsp; The<tt> _arc</tt> function uses the view coordinate system.&nbsp;
 The<tt> _arc_w</tt> and<tt> _arc_wxy</tt> functions use the window coordinate system.
<br>The center of the arc is the center of the rectangle established by the points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>
&nbsp; The arc is a segment of the ellipse drawn within this bounding rectangle.&nbsp; The arc starts at the point on this
 ellipse that intersects the vector from the centre of the ellipse to the point<tt> (x3,y3).</tt>&nbsp; The arc ends at the
 point on this ellipse that intersects the vector from the centre of the ellipse to the point<tt> (x4,y4).</tt>&nbsp; The
 arc is drawn in a counter-clockwise direction with the current plot action using the current color and the current line style.
<br><br>The following picture illustrates the way in which the bounding rectangle and the vectors specifying the start and
 end points are defined.
<br><br><img src="pic1.bmp" style="vertical-align:middle">
<br>When the coordinates<tt> (x1,y1)</tt> and<tt> (x2,y2)</tt> establish a line or a point (this happens when one or more
 of the x-coordinates or y-coordinates are equal), nothing is drawn.
<br><br>The current output position for graphics output is set to be the point at the end of the arc that was drawn.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _arc</tt> functions return a non-zero value when the arc was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_ellipse">_ellipse</a>, <a href="#_pie">_pie</a>, <a href="#_rectangle">_rectangle</a>, <a href="#_getarcinfo">_getarcinfo</a>,
 <a href="#_setcolor">_setcolor</a>, <a href="#_setlinestyle">_setlinestyle</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _arc( 120, 90, 520, 390, 500, 20, 450, 460 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_arc.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _arc - DOS, QNX</tt>
<br><tt>_arc_w - DOS, QNX</tt>
<br><tt>_arc_wxy - DOS, QNX</tt>
</dl>
<h2 id="asctime"> asctime Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>char * asctime( const struct tm *timeptr );</tt>
<br><tt>char *_asctime( const struct tm *timeptr, char *buf );</tt>
<br><tt>wchar_t * _wasctime( const struct tm *timeptr );</tt>
<br><tt>wchar_t *__wasctime( const struct tm *timeptr, wchar_t *buf );</tt>
<br><br><tt>struct&nbsp; tm {</tt>
<br><tt>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- &#91;0,61&#93; */</tt>
<br><tt>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- &#91;0,59&#93; */</tt>
<br><tt>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,23&#93; */</tt>
<br><tt>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;1,31&#93; */</tt>
<br><tt>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,11&#93; */</tt>
<br><tt>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,6&#93;&nbsp; */</tt>
<br><tt>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,365&#93;*/</tt>
<br><tt>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#asctime_s">asctime_s</a> function which is a safer alternative to<b>
 asctime</b>.&nbsp; This newer<tt> asctime_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<b>
 asctime</b> function.
</dl>
<dl>
<dt>Description:
<dd>The<b> asctime</b> functions convert the time information in the structure pointed to by<b> timeptr</b> into a string containing
 exactly 26 characters.&nbsp; This string has the form shown in the following example:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Sat Mar 21 15:58:27 1987\n\0</tt>
<br><br>All fields have a constant width.&nbsp; The new-line character<tt> '\n'</tt> and the null character<tt> '\0'</tt>
 occupy the last two positions of the string.
<br><br>The ANSI function<b> asctime</b> places the result string in a static buffer that is re-used each time<b> asctime</b>
 or <tt> ctime</tt> is called.&nbsp; The non-ANSI function <tt> _asctime</tt> places the result string in the buffer pointed
 to by<b> buf</b>.
<br><br>The <tt> _wasctime</tt> and <tt> __wasctime</tt> functions are identical to their <tt> asctime</tt> and <tt> _asctime</tt>
 counterparts except that they deal with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<b> asctime</b> functions return a pointer to the character string result.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime_s">asctime_s</a>, <a href="#clock">clock</a>, <a href="#ctime">ctime</a> Functions, <a href="#ctime_s">ctime_s</a>,
 <a href="#difftime">difftime</a>, <a href="#gmtime">gmtime</a>, <a href="#gmtime_s">gmtime_s</a>, <a href="#localtime">localtime</a>,
 <a href="#localtime_s">localtime_s</a>, <a href="#mktime">mktime</a>, <a href="#strftime">strftime</a>, <a href="#time">time</a>,
 <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct tm&nbsp; time_of_day;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp; ltime;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char&nbsp; buf&#91;26&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; time( &amp;ltime );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _localtime( &amp;ltime, &amp;time_of_day );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Date and time is: %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asctime( &amp;time_of_day, buf ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Date and time is: Sat Mar 21 15:58:27 1987</tt>
</dl>
<dl>
<dt>Classification:
<dd>asctime is ANSI
<br>_asctime is not ANSI
<br>_wasctime is not ANSI
<br>__wasctime is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> asctime - All, Netware</tt>
<br><tt>_asctime - All, Netware</tt>
<br><tt>_wasctime - All</tt>
<br><tt>__wasctime - All</tt>
</dl>
<h2 id="asctime_s"> asctime_s, _wasctime_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>errno_t asctime_s( char * s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 maxsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 struct tm * timeptr);</tt>
<br><tt>errno_t _wasctime_s( wchar_t * s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; rsize_t maxsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const struct tm * timeptr);</tt>
<br><br><tt>struct&nbsp; tm {</tt>
<br><tt>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- &#91;0,61&#93; */</tt>
<br><tt>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- &#91;0,59&#93; */</tt>
<br><tt>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,23&#93; */</tt>
<br><tt>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;1,31&#93; */</tt>
<br><tt>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,11&#93; */</tt>
<br><tt>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,6&#93;&nbsp; */</tt>
<br><tt>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,365&#93;*/</tt>
<br><tt>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 asctime_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> s</b> nor<b> timeptr</b> shall be a null pointer.&nbsp; maxsize shall not be less than 26 and shall not be
 greater than<b> RSIZE_MAX</b>.&nbsp; The broken-down time pointed to by<b> timeptr</b> shall be normalized.&nbsp; The calendar
 year represented by the broken-down time pointed to by<b> timeptr</b> shall not be less than calendar year 0 and shall not
 be greater than calendar year 9999.&nbsp; If there is a runtime-constraint violation, there is no attempt to convert the
 time, and<b> s&#91;0&#93;</b> is set to a null character if<b> s</b> is not a null pointer and<b> maxsize</b> is not zero
 and is not greater than<b> RSIZE_MAX</b>.
</dl>
<dl>
<dt>Description:
<dd>The<tt> asctime_s</tt> function converts the normalized broken-down time in the structure pointed to by<b> timeptr</b> into
 a 26 character (including the null character) string in the form
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Sun Sep 16 01:03:52 1973\n\0</tt>
<br><br>The fields making up this string are (in order):
<ol>
<li>The name of the day of the week represented by<b> timeptr-&gt;tm_wday</b> using the following three character weekday
 names:
<br><br>Sun, Mon, Tue, Wed, Thu, Fri, and Sat.
<li>The character space.
<li>The name of the month represented by<b> timeptr-&gt;tm_mon</b> using the following three character month names:
<br><br>Jan, Feb, Mar,Apr,May,Jun, Jul, Aug, Sep, Oct, Nov, and Dec.
<li>The character space.
<li>The value of<b> timeptr-&gt;tm_mday</b> as if printed using the fprintf format &quot;%2d&quot;.
<li>The character space.
<li>The value of timeptr-&gt;tm_hour as if printed using the fprintf format &quot;%.2d&quot;.
<li>The character colon.
<li>The value of<b> timeptr-&gt;tm_min</b> as if printed using the fprintf format &quot;%.2d&quot;.
<li>The character colon.
<li>The value of<b> timeptr-&gt;tm_sec</b> as if printed using the fprintf format &quot;%.2d&quot;.
<li>The character space.
<li>The value of<b> timeptr-&gt;tm_year + 1900</b> as if printed using the fprintf format &quot;%4d&quot;.
<li>The character new line.
<li>The null character.
</ol>
<br>The<tt> _wasctime_s</tt> function is a wide-character version of<tt> asctime_s</tt> that operates with wide-character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> asctime_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#clock">clock</a>, <a href="#ctime">ctime</a> Functions, <a href="#ctime_s">ctime_s</a>,
 <a href="#difftime">difftime</a>, <a href="#gmtime">gmtime</a>, <a href="#gmtime_s">gmtime_s</a>, <a href="#localtime">localtime</a>,
 <a href="#localtime_s">localtime_s</a>, <a href="#mktime">mktime</a>, <a href="#strftime">strftime</a>, <a href="#time">time</a>,
 <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct tm&nbsp; time_of_day;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp; ltime;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char&nbsp; buf&#91;26&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; time( &amp;ltime );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _localtime( &amp;ltime, &amp;time_of_day );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; asctime_s( buf, sizeof( buf ), &amp;time_of_day );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Date and time is: %s\n&quot;, buf );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Date and time is: Mon Jan 30 11:32:45 2006</tt>
</dl>
<dl>
<dt>Classification:
<dd>asctime_s is TR 24731
<br>_wasctime_s is not TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> asctime_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Netware</tt>
<br><tt>_wasctime_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="asin"> asin </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double asin( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> asin</tt> function computes the principal value of the arcsine of<b> x</b>.&nbsp; A domain error occurs for arguments
 not in the range &#91;-1,1&#93;.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> asin</tt> function returns the arcsine in the range &#91;-P/2,P/2&#93;.&nbsp; When the argument is outside the permissible
 range, the <tt> matherr</tt> function is called.&nbsp; Unless the default <tt> matherr</tt> function is replaced, it will
 set the global variable <tt> errno</tt> to <tt> EDOM</tt>, and print a &quot;DOMAIN error&quot; diagnostic message using
 the <tt> stderr</tt> stream.
</dl>
<dl>
<dt>See Also:
<dd><a href="#acos">acos</a>, <a href="#atan">atan</a>, <a href="#atan2">atan2</a>, <a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, asin(.5) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.523599</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="asinh"> asinh </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double asinh( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> asinh</tt> function computes the inverse hyperbolic sine of<b> x</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> asinh</tt> function returns the inverse hyperbolic sine value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#acosh">acosh</a>, <a href="#atanh">atanh</a>, <a href="#sinh">sinh</a>, <a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, asinh( 0.5 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.481212</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="assert"> assert </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;assert.h&gt;</tt>
<br><tt>void assert( int expression );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> assert</tt> macro prints a diagnostic message upon the <tt> stderr</tt> stream and terminates the program if<b> expression</b>
 is false (0).&nbsp; The diagnostic message has the form
<br><tt>Assertion failed:</tt><b>&nbsp; expression</b>,<tt> file</tt><b> filename</b>,<tt> line</tt><b> linenumber</b>
<br><br>where<b> filename</b> is the name of the source file and<b> linenumber</b> is the line number of the assertion that
 failed in the source file.<b>&nbsp; Filename</b> and<b> linenumber</b> are the values of the preprocessing macros <tt> __FILE__</tt>
 and <tt> __LINE__</tt> respectively.&nbsp; No action is taken if<b> expression</b> is true (non-zero).
<br><br>The<tt> assert</tt> macro is typically used during program development to identify program logic errors.&nbsp; The
 given<b> expression</b> should be chosen so that it is true when the program is functioning as intended.&nbsp; After the
 program has been debugged, the special &quot;no debug&quot; identifier <tt> NDEBUG</tt> can be used to remove<tt> assert</tt>
 calls from the program when it is re-compiled.&nbsp; If <tt> NDEBUG</tt> is defined (with any value) with a<tt> -d</tt> command
 line option or with a<tt> #define</tt> directive, the C preprocessor ignores all<tt> assert</tt> calls in the program source.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> assert</tt> macro does not return a value.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;assert.h&gt;</tt>
<br><br><tt>void process_string( char *string )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* use assert to check argument */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; assert( string != NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; assert( *string != '\0' );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* rest of code follows here */</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; process_string( &quot;hello&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; process_string( &quot;&quot; );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="atan"> atan </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double atan( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> atan</tt> function computes the principal value of the arctangent of<b> x</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> atan</tt> function returns the arctangent in the range (-P/2,P/2).
</dl>
<dl>
<dt>See Also:
<dd><a href="#acos">acos</a>, <a href="#asin">asin</a>, <a href="#atan2">atan2</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, atan(.5) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.463648</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="atan2"> atan2 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double atan2( double y, double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> atan2</tt> function computes the principal value of the arctangent of<b> y/x</b>, using the signs of both arguments
 to determine the quadrant of the return value.&nbsp; A domain error occurs if both arguments are zero.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> atan2</tt> function returns the arctangent of<b> y/x</b>, in the range (-P,P).&nbsp; When the argument is outside
 the permissible range, the <tt> matherr</tt> function is called.&nbsp; Unless the default <tt> matherr</tt> function is replaced,
 it will set the global variable <tt> errno</tt> to <tt> EDOM</tt>, and print a &quot;DOMAIN error&quot; diagnostic message
 using the <tt> stderr</tt> stream.
</dl>
<dl>
<dt>See Also:
<dd><a href="#acos">acos</a>, <a href="#asin">asin</a>, <a href="#atan">atan</a>, <a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, atan2( .5, 1. ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.463648</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="atanh"> atanh </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double atanh( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> atanh</tt> function computes the inverse hyperbolic tangent of<b> x</b>.&nbsp; A domain error occurs if the value
 of<b> x</b> is outside the range (-1,1).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> atanh</tt> function returns the inverse hyperbolic tangent value.&nbsp; When the argument is outside the permissible
 range, the <tt> matherr</tt> function is called.&nbsp; Unless the default <tt> matherr</tt> function is replaced, it will
 set the global variable <tt> errno</tt> to <tt> EDOM</tt>, and print a &quot;DOMAIN error&quot; diagnostic message using
 the <tt> stderr</tt> stream.
</dl>
<dl>
<dt>See Also:
<dd><a href="#acosh">acosh</a>, <a href="#asinh">asinh</a>, <a href="#matherr">matherr</a>, <a href="#tanh">tanh</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, atanh( 0.5 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.549306</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="atexit"> atexit </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>int atexit( void (*func)(void) );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> atexit</tt> function is passed the address of function<b> func</b> to be called when the program terminates normally.
&nbsp; Successive calls to<tt> atexit</tt> create a list of functions that will be executed on a &quot;last-in, first-out&quot;
 basis.&nbsp; No more than 32 functions can be registered with the<tt> atexit</tt> function.
<br>The functions have no parameters and do not return values.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> atexit</tt> function returns zero if the registration succeeds, non-zero if it fails.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abort">abort</a>, <a href="#_exit">_exit</a>, <a href="#exit">exit</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; extern void func1(void), func2(void), func3(void);</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; atexit( func1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; atexit( func2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; atexit( func3 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Do this first.\n&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void func1(void) { printf( &quot;last.\n&quot; ); }</tt>
<br><br><tt>void func2(void) { printf( &quot;this &quot; ); }</tt>
<br><br><tt>void func3(void) { printf( &quot;Do &quot; ); }</tt>
<br><br>produces the following:
<br><br><tt>Do this first.</tt>
<br><tt>Do this last.</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="atof"> atof, _wtof </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>double atof( const char *ptr );</tt>
<br><tt>double _wtof( const wchar_t *ptr );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> atof</tt> function converts the string pointed to by<b> ptr</b> to<tt> double</tt> representation.&nbsp; It is equivalent
 to
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; strtod( ptr, (char **)NULL )</tt>
<br><br>The<tt> _wtof</tt> function is identical to<tt> atof</tt> except that it accepts a wide-character string argument.
&nbsp; It is equivalent to
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; wcstod( ptr, (wchar_t **)NULL )</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> atof</tt> function returns the converted value.&nbsp; Zero is returned when the input string cannot be converted.
&nbsp; In this case, <tt> errno</tt> is not set.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating
 the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#sscanf">sscanf</a>, <a href="#strtod">strtod</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; double x;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; x = atof( &quot;3.1415926&quot; );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>atof is ANSI
<br>_wtof is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> atof - Math</tt>
<br><tt>_wtof - Math</tt>
</dl>
<h2 id="atoi"> atoi, _wtoi </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>int atoi( const char *ptr );</tt>
<br><tt>int _wtoi( const wchar_t *ptr );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> atoi</tt> function converts the string pointed to by<b> ptr</b> to<tt> int</tt> representation.
<br>The<tt> _wtoi</tt> function is identical to<tt> atoi</tt> except that it accepts a wide-character string argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> atoi</tt> function returns the converted value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atol">atol</a>, <a href="#atoll">atoll</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>, <a href="#lltoa">lltoa</a>,
 <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoul">strtoul</a>,
 <a href="#strtoull">strtoull</a>, <a href="#strtoimax">strtoimax</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ultoa">ultoa</a>,
 <a href="#ulltoa">ulltoa</a>, <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int x;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; x = atoi( &quot;-289&quot; );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>atoi is ANSI
<br>_wtoi is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> atoi - All, Netware</tt>
<br><tt>_wtoi - All</tt>
</dl>
<h2 id="atol"> atol, _wtol </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>long int atol( const char *ptr );</tt>
<br><tt>long int _wtol( const wchar_t *ptr );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> atol</tt> function converts the string pointed to by<b> ptr</b> to<tt> long int</tt> representation.
<br>The<tt> _wtol</tt> function is identical to<tt> atol</tt> except that it accepts a wide-character string argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> atol</tt> function returns the converted value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atoll">atoll</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>, <a href="#lltoa">lltoa</a>,
 <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoul">strtoul</a>,
 <a href="#strtoull">strtoull</a>, <a href="#strtoimax">strtoimax</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ultoa">ultoa</a>,
 <a href="#ulltoa">ulltoa</a>, <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long int x;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; x = atol( &quot;-289&quot; );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>atol is ANSI
<br>_wtol is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> atol - All, Netware</tt>
<br><tt>_wtol - All</tt>
</dl>
<h2 id="atoll"> atoll, _wtoll </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>long long int atoll( const char *ptr );</tt>
<br><tt>long long int _wtoll( const wchar_t *ptr );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> atoll</tt> function converts the string pointed to by<b> ptr</b> to<tt> long long int</tt> representation.
<br>The<tt> _wtoll</tt> function is identical to<tt> atoll</tt> except that it accepts a wide-character string argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> atoll</tt> function returns the converted value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>, <a href="#lltoa">lltoa</a>,
 <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoul">strtoul</a>,
 <a href="#strtoull">strtoull</a>, <a href="#strtoimax">strtoimax</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ultoa">ultoa</a>,
 <a href="#ulltoa">ulltoa</a>, <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long int x;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; x = atoll( &quot;-289356768201&quot; );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>atoll is ANSI
<br>_wtoll is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> atoll - All, Netware</tt>
<br><tt>_wtoll - All</tt>
</dl>
<h2 id="_atouni"> _atouni </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>wchar_t *_atouni( wchar_t *wcs, const char *sbcs );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _atouni</tt> function converts the string pointed to by<b> sbcs</b> to a wide-character string and places it in the
 buffer pointed to by<b> wcs</b>.
<br>The conversion ends at the first null character.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _atouni</tt> function returns the first argument as a result.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>, <a href="#strtod">strtod</a>,
 <a href="#strtol">strtol</a>, <a href="#strtoul">strtoul</a>, <a href="#ultoa">ultoa</a>, <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wchar_t wcs&#91;12&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _atouni( wcs, &quot;Hello world&quot; );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="basename"> basename </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;libgen.h&gt;</tt>
<br><tt>char *basename( char *path );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> basename</tt> function returns a pointer to the final component of a pathname pointed to by the<b> path</b> argument,
 deleting trailing path separators.
<br>If the string pointed to by<b> path</b> consists entirely of path separators, a string consisting of single path separator
 is returned.
<br><br>If<b> path</b> is a null pointer or points to an empty string, a pointer to the string &quot;.&quot; is returned.
<br><br>The<tt> basename</tt> function may modify the string pointed to by<b> path</b> and may return a pointer to static
 storage that may be overwritten by a subsequent call to<tt> basename</tt>.
<br><br>The<tt> basename</tt> function is not re-entrant or thread-safe.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> basename</tt> function returns a pointer to the final component of<b> path</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#dirname">dirname</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;libgen.h&gt;</tt>
<br><br><tt>int main( void )</tt>
<br><tt>{</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; puts( basename( &quot;/usr/lib&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; puts( basename( &quot;//usr//lib//&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; puts( basename( &quot;///&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; puts( basename( &quot;foo&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; puts( basename( NULL ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>lib</tt>
<br><tt>lib</tt>
<br><tt>/</tt>
<br><tt>foo</tt>
<br><tt>.</tt>
</dl>
<dl>
<dt>Classification:
<dd>POSIX
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="bdos"> bdos </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>int bdos( int dos_func, unsigned dx, unsigned char al );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> bdos</tt> function causes the computer's central processor (CPU) to be interrupted with an interrupt number hexadecimal
 21 (<tt>0x21</tt>), which is a request to invoke a specific DOS function.&nbsp; Before the interrupt, the DX register is
 loaded from<b> dx</b>, the AH register is loaded with the DOS function number from<b> dos_func</b> and the AL register is
 loaded from<b> al</b>.&nbsp; The remaining registers are passed unchanged to DOS.
<br>You should consult the technical documentation for the DOS operating system you are using to determine the expected register
 contents before and after the interrupt in question.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> bdos</tt> function returns the value of the AX register after the interrupt has completed.
</dl>
<dl>
<dt>See Also:
<dd><a href="#int386">int386</a>, <a href="#int386x">int386x</a>, <a href="#int86">int86</a>, <a href="#int86x">int86x</a>, <a href="#intdos">intdos</a>,
 <a href="#intdosx">intdosx</a>, <a href="#intr">intr</a>, <a href="#segread">segread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>#define DISPLAY_OUTPUT&nbsp; 2</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = bdos( DISPLAY_OUTPUT, 'B', 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = bdos( DISPLAY_OUTPUT, 'D', 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = bdos( DISPLAY_OUTPUT, 'O', 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = bdos( DISPLAY_OUTPUT, 'S', 0 );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, DOS/PM
</dl>
<h2 id="_beginthread"> _beginthread, _beginthreadex </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;process.h&gt;</tt>
<br><tt>#if defined(__386__)</tt>
<br><tt>#&nbsp;&nbsp; define FAR</tt>
<br><tt>#else</tt>
<br><tt>#&nbsp;&nbsp; define FAR __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#if defined(__NT__)</tt>
<br><tt>unsigned long _beginthread(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (*start_address)(void *),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned stack_size,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp; *arglist);</tt>
<br><tt>unsigned long _beginthreadex(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *security,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned stack_size,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned (__stdcall *start_address)(void *),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *arglist,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned initflag,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned *thrdid );</tt>
<br><tt>#else</tt>
<br><tt>int FAR _beginthread(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void (FAR *start_address)(void FAR *),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void FAR *stack_bottom,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned stack_size,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void FAR *arglist );</tt>
<br><tt>#endif</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _beginthread</tt> function is used to start a new thread of execution at the function identified by<b> start_address</b>
 with a single parameter identified by<b> arglist</b>.
<br>For each operating environment under which<tt> _beginthread</tt> is supported, the<tt> _beginthread</tt> function uses
 the appropriate system call to begin a new thread of execution.
<br><br>The new thread will use the memory identified by<b> stack_bottom</b> and<b> stack_size</b> for its stack.
<br><br><b>Note for 16-bit applications:</b>&nbsp; If the stack is not in DGROUP (i.e., the stack pointer does not point to
 an area in DGROUP) then you must compile your application with the &quot;zu&quot; option.&nbsp; For example, the pointer
 returned by <tt> malloc</tt> in a large data model may not be in DGROUP.&nbsp; The &quot;zu&quot; option relaxes the restriction
 that the SS register contains the base address of the default data segment, &quot;DGROUP&quot;.&nbsp; Normally, all data
 items are placed into the group DGROUP and the SS register contains the base address of this group.&nbsp; In a thread, the
 SS register will likely not contain the base address of this group.&nbsp; When the &quot;zu&quot; option is selected, the
 SS register is volatile (assumed to point to another segment) and any global data references require loading a segment register
 such as DS with the base address of DGROUP.
<br><br><b>Note for OS/2 32-bit applications:</b>&nbsp; Memory for a stack need not be provided by the application.&nbsp;
 The<b> stack_bottom</b> may be NULL in which case the run-time system will provide a stack.&nbsp; You must specify a non-zero<b>
 stack_size</b> for this stack.
<br><br><b>Note for Win32 applications:</b>&nbsp; Memory for a stack is provided by the run-time system.&nbsp; The size of
 the stack is determined by<b> stack_size</b> and must not be zero.
<br><br>The <tt> _beginthreadex</tt> function can be used to create a new thread, in a running or suspended state specified
 by<b> initflag</b>, with security attributes specified by<b> security</b>.
<br><br>The initial state of the new thread (running or suspended) is specified by the<b> initflag</b> argument.&nbsp; If
 the <tt> CREATE_SUSPENDED</tt> flag (WINBASE.H) is specified, the thread is created in a suspended state, and will not run
 until the Win32 <tt> ResumeThread</tt> function is called with the thread handle as an argument.&nbsp; If this value is zero,
 the thread runs immediately after creation.
<br><br>The security descriptor for the new thread is specified by the<b> security</b> argument.&nbsp; This is a pointer to
 a Win32 <tt> SECURITY_ATTRIBUTES</tt> structure (see Microsoft's<b> Win32 Programmer's Reference</b> for more information).
&nbsp; For default behaviour, the security structure pointer can be <tt> NULL</tt>.
<br><br>The thread identifier is returned in the location identified by the<b> thrdid</b> argument.
<br><br>The thread ends when it exits from its main function or calls <tt> exit</tt>, <tt> _exit</tt>, <tt> _endthread</tt>
 or <tt> _endthreadex</tt>.
<br><br>The variable/function <tt> _threadid</tt> which is defined in<tt> &lt;stddef.h&gt;</tt> may be used by the executing
 thread to obtain its thread ID.&nbsp; In the 16-bit libraries, <tt> __threadid</tt> is a far pointer to an int.&nbsp; In
 the 32-bit libraries, it is a function that returns an int.
<br><br>There is no limit to the number of threads an application can create under Win32 platforms.
<br><br>There is a limit to the number of threads an application can create under 16-bit OS/2 and 32-bit NetWare.&nbsp; The
 default limit is 32.&nbsp; This limit can be adjusted by statically initializing the unsigned global variable<tt> __MaxThreads.</tt>
<br><br>Under 32-bit OS/2, there is no limit to the number of threads an application can create.&nbsp; However, due to the
 way in which multiple threads are supported in the Watcom libraries, there is a small performance penalty once the number
 of threads exceeds the default limit of 32 (this number includes the initial thread).&nbsp; If you are creating more than
 32 threads and wish to avoid this performance penalty, you can redefine the threshold value of 32.&nbsp; You can statically
 initialize the global variable<tt> __MaxThreads.</tt>
<br><br>By adding the following line to your multi-threaded application, the new threshold value will be set to 48.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; unsigned __MaxThreads = { 48 };</tt>
</dl>
<dl>
<dt>Returns:
<dd>Under Win32, the<tt> _beginthread</tt> function returns the thread handle for the new thread if successful; otherwise it returns
 -1 to indicate that the thread could not be started.
<br>Under all other systems that support the<tt> _beginthread</tt> function (OS/2, Netware and QNX), it returns the thread
 ID for the new thread if successful; otherwise it returns -1 to indicate that the thread could not be started.
<br><br>The <tt> _beginthreadex</tt> function returns the thread handle for the new thread if successful; otherwise it returns
 0 to indicate that the thread could not be started.
<br><br>When the thread could not be started, the value of <tt> errno</tt> could be set to <tt> EAGAIN</tt> if there are too
 many threads, or to <tt> EINVAL</tt> if the argument is invalid or the stack size is incorrect, or to <tt> ENOMEM</tt> if
 there is not enough available memory.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_endthread">_endthread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;stddef.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>#include &lt;process.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>#if defined(__386__)</tt>
<br><tt>&nbsp; #define FAR</tt>
<br><tt>&nbsp; #define STACK_SIZE&nbsp;&nbsp;&nbsp; 8192</tt>
<br><tt>#else</tt>
<br><tt>&nbsp; #define FAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>&nbsp; #define STACK_SIZE&nbsp;&nbsp;&nbsp; 4096</tt>
<br><tt>#endif</tt>
<br><br><tt>static volatile int&nbsp;&nbsp;&nbsp;&nbsp; WaitForThread;</tt>
<br><br><tt>void FAR child( void FAR *parm )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char * FAR *argv = (char * FAR *) parm;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Child thread ID = %x\n&quot;, *_threadid );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; argv&#91;i&#93;; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;argv&#91;%d&#93; = %s\n&quot;, i, argv&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WaitForThread = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _endthread();</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *args&#91;3&#93;;</tt>
<br><tt>#if defined(__NT__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp; tid;</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *stack;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tid;</tt>
<br><tt>#endif</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; args&#91;0&#93; = &quot;child&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; args&#91;1&#93; = &quot;parm&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; args&#91;2&#93; = NULL;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WaitForThread = 1;</tt>
<br><tt>#if defined(__NT__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tid = _beginthread( child, STACK_SIZE, args );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Thread handle = %lx\n&quot;, tid );</tt>
<br><tt>#else</tt>
<br><tt>&nbsp; #if defined(__386__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; stack = (char *) malloc( STACK_SIZE );</tt>
<br><tt>&nbsp; #else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; stack = (char *) _nmalloc( STACK_SIZE );</tt>
<br><tt>&nbsp; #endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tid = _beginthread( child, stack, STACK_SIZE, args );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Thread ID = %x\n&quot;, tid );</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( WaitForThread ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sleep( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _beginthread - Win32, QNX/32, OS/2 1.x(MT), OS/2 1.x(DL), OS/2-32, Netware</tt>
<br><tt>_beginthreadex - Win32</tt>
</dl>
<h2 id="bessel"> bessel Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double j0( double x );</tt>
<br><tt>double j1( double x );</tt>
<br><tt>double jn( int n, double x );</tt>
<br><tt>double y0( double x );</tt>
<br><tt>double y1( double x );</tt>
<br><tt>double yn( int n, double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>Functions <tt> j0</tt>, <tt> j1</tt>, and <tt> jn</tt> return Bessel functions of the first kind.
<br>Functions <tt> y0</tt>, <tt> y1</tt>, and <tt> yn</tt> return Bessel functions of the second kind.&nbsp; The argument<b>
 x</b> must be positive.&nbsp; If<b> x</b> is negative, <tt> _matherr</tt> will be called to print a DOMAIN error message
 to <tt> stderr</tt>, set <tt> errno</tt> to <tt> EDOM</tt>, and return the value<tt> -HUGE_VAL.</tt>&nbsp; This error handling
 can be modified by using the <tt> matherr</tt> routine.
</dl>
<dl>
<dt>Returns:
<dd>These functions return the result of the desired Bessel function of<b> x</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; double x, y, z;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; x = j0( 2.4 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; y = y1( 1.58 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; z = jn( 3, 2.4 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;j0(2.4) = %f, y1(1.58) = %f\n&quot;, x, y );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;jn(3,2.4) = %f\n&quot;, z );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> j0 - Math</tt>
<br><tt>j1 - Math</tt>
<br><tt>jn - Math</tt>
<br><tt>y0 - Math</tt>
<br><tt>y1 - Math</tt>
<br><tt>yn - Math</tt>
</dl>
<h2 id="bcmp"> bcmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>int bcmp(const void *s1, const void *s2, size_t n);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> bcmp</tt> function compares the byte string pointed to by<b> s1</b> to the string pointed to by<b> s2</b>.&nbsp; The
 number of bytes to compare is specified by<b> n</b>.&nbsp; Null characters may be included in the comparision.
<br>Note that this function is similar to the ANSI <tt> memcmp</tt> function but just tests for equality (new code should
 use the ANSI function).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> bcmp</tt> function returns zero if the byte strings are identical otherwise it returns 1.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bcopy">bcopy</a>, <a href="#bzero">bzero</a>, <a href="#memcmp">memcmp</a>, <a href="#strcmp">strcmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bcmp( &quot;Hello there&quot;, &quot;Hello world&quot;, 6 ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Not equal\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Equal\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Equal</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="bcopy"> bcopy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>void bcopy( const void *src, void *dst, size_t n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> bcopy</tt> function copies the byte string pointed to by<b> src</b> (including any null characters) into the array
 pointed to by<b> dst</b>.&nbsp; The number of bytes to copy is specified by<b> n</b>.&nbsp; Copying of overlapping objects
 is guaranteed to work properly.
<br>Note that this function is similar to the ANSI <tt> memmove</tt> function but the order of arguments is different (new
 code should use the ANSI function).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> bcopy</tt> function has no return value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bcmp">bcmp</a>, <a href="#bzero">bzero</a>, <a href="#memmove">memmove</a>, <a href="#strcpy">strcpy</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; bcopy( &quot;Hello &quot;, buffer,&nbsp;&nbsp;&nbsp;&nbsp; 6 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; bcopy( &quot;world&quot;,&nbsp; &amp;buffer&#91;6&#93;, 6 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Hello world</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_bfreeseg"> _bfreeseg </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>int _bfreeseg( __segment seg );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _bfreeseg</tt> function frees a based-heap segment.
<br>The argument<b> seg</b> indicates the segment returned by an earlier call to <tt> _bheapseg</tt>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _bfreeseg</tt> function returns 0 if successful and -1 if an error occurred.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bheapseg">_bheapseg</a>, <a href="#calloc">calloc</a>, <a href="#_expand">_expand</a>, <a href="#free">free</a>,
 <a href="#malloc">malloc</a>, <a href="#realloc">realloc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>struct list {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct list __based(__self) *next;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value;</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; __segment&nbsp;&nbsp; seg;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct list __based(seg) *head;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct list __based(seg) *p;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* allocate based heap */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; seg = _bheapseg( 1024 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( seg == _NULLSEG ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to allocate based heap\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* create a linked list in the based heap */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; head = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; 10; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = _bmalloc( seg, sizeof( struct list ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( p == _NULLOFF ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_bmalloc failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;next = head;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;value = i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head = p;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* traverse the linked list, printing out values */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( p = head; p != 0; p = p-&gt;next ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Value = %d\n&quot;, p-&gt;value );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* free all the elements of the linked list */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( ; p = head; ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head = p-&gt;next;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _bfree( seg, p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* free the based heap */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _bfreeseg( seg );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS/16, Windows, QNX/16, OS/2 1.x(all)
</dl>
<h2 id="_bgetcmd"> _bgetcmd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;process.h&gt;</tt>
<br><tt>int _bgetcmd( char *cmd_line, int len );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _bgetcmd</tt> function causes the command line information, with the program name removed, to be copied to<b> cmd_line</b>.
&nbsp; The argument<b> len</b> specifies the size of<b> cmd_line</b>.&nbsp; The information is terminated with a<tt> '\0'</tt>
 character.&nbsp; This provides a method of obtaining the original parameters to a program unchanged (with the white space
 intact).
<br>This information can also be obtained by examining the vector of program parameters passed to the main function in the
 program.
</dl>
<dl>
<dt>Returns:
<dd>The number of bytes required to store the entire command line, excluding the terminating null character, is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abort">abort</a>, <a href="#atexit">atexit</a>, <a href="#exec___">exec...</a>, <a href="#exit">exit</a>, <a href="#_Exit">_Exit</a>,
 <a href="#_exit">_exit</a>, <a href="#getcmd">getcmd</a>, <a href="#getenv">getenv</a>, <a href="#main">main</a>, <a href="#onexit">onexit</a>,
 <a href="#putenv">putenv</a>, <a href="#spawn___">spawn...</a>, <a href="#system">system</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>Suppose a program were invoked with the command line
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; myprog arg-1 ( my&nbsp;&nbsp; stuff ) here</tt>
<br><br>where that program contains
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;process.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp; *cmdline;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; cmdlen;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; cmdlen = _bgetcmd( NULL, 0 ) + 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cmdline = malloc( cmdlen );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( cmdline != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmdlen = _bgetcmd( cmdline, cmdlen );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, cmdline );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>&nbsp; arg-1 ( my&nbsp;&nbsp; stuff ) here</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_bheapseg"> _bheapseg </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>__segment _bheapseg( size_t size );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _bheapseg</tt> function allocates a based-heap segment of at least<b> size</b> bytes.
<br>The argument<b> size</b> indicates the initial size for the heap.&nbsp; The heap will automatically be enlarged as needed
 if there is not enough space available within the heap to satisfy an allocation request by <tt> _bcalloc</tt>, <tt> _bexpand</tt>,
 <tt> _bmalloc</tt>, or <tt> _brealloc</tt>.
<br><br>The value returned by<tt> _bheapseg</tt> is the segment value or selector for the based heap.&nbsp; This value must
 be saved and used as an argument to other based heap functions to indicate which based heap to operate upon.
<br><br>Each call to<tt> _bheapseg</tt> allocates a new based heap.
</dl>
<dl>
<dt>Returns:
<dd>The value returned by<tt> _bheapseg</tt> is the segment value or selector for the based heap.&nbsp; This value must be saved
 and used as an argument to other based heap functions to indicate which based heap to operate upon.&nbsp; A special value
 of <tt> _NULLSEG</tt> is returned if the segment could not be allocated.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bfreeseg">_bfreeseg</a>, <a href="#calloc">calloc</a>, <a href="#_expand">_expand</a>, <a href="#malloc">malloc</a>,
 <a href="#realloc">realloc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>struct list {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct list __based(__self) *next;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value;</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; __segment&nbsp;&nbsp; seg;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct list __based(seg) *head;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct list __based(seg) *p;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* allocate based heap */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; seg = _bheapseg( 1024 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( seg == _NULLSEG ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to allocate based heap\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* create a linked list in the based heap */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; head = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; 10; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = _bmalloc( seg, sizeof( struct list ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( p == _NULLOFF ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_bmalloc failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;next = head;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;value = i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head = p;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* traverse the linked list, printing out values */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( p = head; p != 0; p = p-&gt;next ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Value = %d\n&quot;, p-&gt;value );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* free all the elements of the linked list */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( ; p = head; ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head = p-&gt;next;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _bfree( seg, p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* free the based heap */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _bfreeseg( seg );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS/16, Windows, QNX/16, OS/2 1.x(all)
</dl>
<h2 id="_bios_disk"> _bios_disk </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><tt>unsigned short _bios_disk( unsigned service,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct diskinfo_t *diskinfo );</tt>
<br><tt>struct&nbsp; diskinfo_t {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disk parameters&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned drive;&nbsp;&nbsp;&nbsp;&nbsp; /* drive number&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned head;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* head number&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned track;&nbsp;&nbsp;&nbsp;&nbsp; /* track number&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned sector;&nbsp;&nbsp;&nbsp; /* sector number&nbsp;&nbsp;&nbsp;&nbsp;
 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned nsectors;&nbsp; /* number of sectors */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void __far *buffer; /* buffer address&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _bios_disk</tt> function uses INT 0x13 to provide access to the BIOS disk functions.&nbsp; Information for the desired<b>
 service</b> is passed the <tt> diskinfo_t</tt> structure pointed to by<b> diskinfo</b>.&nbsp; The value for<b> service</b>
 can be one of the following values:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_DISK_RESET
<dd>Forces the disk controller to do a reset on the disk.&nbsp; This request does not use the<b> diskinfo</b> argument.
<dt><br>_DISK_STATUS
<dd>Obtains the status of the last disk operation.
<dt><br>_DISK_READ
<dd>Reads the specified number of sectors from the disk.&nbsp; This request uses all of the information passed in the<b> diskinfo</b>
 structure.
<dt><br>_DISK_WRITE
<dd>Writes the specified amount of data to the disk.&nbsp; This request uses all of the information passed in the<b> diskinfo</b>
 structure.
<dt><br>_DISK_VERIFY
<dd>Checks the disk to be sure the specified sectors exist and can be read.&nbsp; A CRC (cyclic redundancy check) test is performed.
&nbsp; This request uses all of the information passed in the<b> diskinfo</b> structure except for the<b> buffer</b> field.
<dt><br>_DISK_FORMAT
<dd>Formats the specified track on the disk.&nbsp; The<b> head</b> and<b> track</b> fields indicate the track to be formatted.
&nbsp; Only one track can be formatted per call.&nbsp; The<b> buffer</b> field points to a set of sector markers, whose format
 depends on the type of disk drive.&nbsp; This service has no return value.
</dl>
<br>This function is not supported by DOS/4GW (you must use the Simulate Real-Mode Interrupt DPMI call).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _bios_disk</tt> function returns status information in the high-order byte when<b> service</b> is _DISK_STATUS, _DISK_READ,
 _DISK_WRITE, or _DISK_VERIFY.&nbsp; The possible values are:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>0x00
<dd>Operation successful
<dt><br>0x01
<dd>Bad command
<dt><br>0x02
<dd>Address mark not found
<dt><br>0x03
<dd>Attempt to write to write-protected disk
<dt><br>0x04
<dd>Sector not found
<dt><br>0x05
<dd>Reset failed
<dt><br>0x06
<dd>Disk changed since last operation
<dt><br>0x07
<dd>Drive parameter activity failed
<dt><br>0x08
<dd>DMA overrun
<dt><br>0x09
<dd>Attempt to DMA across 64K boundary
<dt><br>0x0A
<dd>Bad sector detected
<dt><br>0x0B
<dd>Bad track detected
<dt><br>0x0C
<dd>Unsupported track
<dt><br>0x10
<dd>Data read (CRC/ECC) error
<dt><br>0x11
<dd>CRC/ECC corrected data error
<dt><br>0x20
<dd>Controller failure
<dt><br>0x40
<dd>Seek operation failed
<dt><br>0x80
<dd>Disk timed out or failed to respond
<dt><br>0xAA
<dd>Drive not ready
<dt><br>0xBB
<dd>Undefined error occurred
<dt><br>0xCC
<dd>Write fault occurred
<dt><br>0xE0
<dd>Status error
<dt><br>0xFF
<dd>Sense operation failed
</dl>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct diskinfo_t di;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short status;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; di.drive = di.head = di.track = di.sector = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; di.nsectors = 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; di.buffer = NULL;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; status = _bios_disk( _DISK_VERIFY, &amp;di );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Status = 0x%4.4X\n&quot;, status );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>BIOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386
</dl>
<h2 id="_bios_equiplist"> _bios_equiplist </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><tt>unsigned short _bios_equiplist( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _bios_equiplist</tt> function uses INT 0x11 to determine what hardware and peripherals are installed on the machine.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _bios_equiplist</tt> function returns a set of bits indicating what is currently installed on the machine.&nbsp; Those
 bits are defined as follows:
<dl>
<dt>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>bit 0
<dd>Set to 1 if system boots from disk
<dt><br>bit 1
<dd>Set to 1 if a math coprocessor is installed
<dt><br>bits 2-3
<dd>Indicates motherboard RAM size
<dt><br>bits 4-5
<dd>Initial video mode
<dt><br>bits 6-7
<dd>Number of diskette drives
<dt><br>bit 8
<dd>Set to 1 if machine does not have DMA
<dt><br>bits 9-11
<dd>Number of serial ports
<dt><br>bit 12
<dd>Set to 1 if a game port is attached
<dt><br>bit 13
<dd>Set to 1 if a serial printer is attached
<dt><br>bits 14-15
<dd>Number of parallel printers installed
</dl>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short equipment;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; equipment = _bios_equiplist();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Equipment flags = 0x%4.4X\n&quot;, equipment );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>BIOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386
</dl>
<h2 id="_bios_keybrd"> _bios_keybrd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><tt>unsigned short _bios_keybrd( unsigned service );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _bios_keybrd</tt> function uses INT 0x16 to access the BIOS keyboard services.&nbsp; The possible values for<b> service</b>
 are the following constants:
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_KEYBRD_READ
<dd>Reads the next character from the keyboard.&nbsp; The function will wait until a character has been typed.
<dt><br>_KEYBRD_READY
<dd>Checks to see if a character has been typed.&nbsp; If there is one, then its value will be returned, but it is not removed
 from the input buffer.
<dt><br>_KEYBRD_SHIFTSTATUS
<dd>Returns the current state of special keys.
<dt><br>_NKEYBRD_READ
<dd>Reads the next character from an enhanced keyboard.&nbsp; The function will wait until a character has been typed.
<dt><br>_NKEYBRD_READY
<dd>Checks to see if a character has been typed on an enhanced keyboard.&nbsp; If there is one, then its value will be returned,
 but it is not removed from the input buffer.
<dt><br>_NKEYBRD_SHIFTSTATUS
<dd>Returns the current state of special keys on an enhanced keyboard.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The return value depends on the<b> service</b> requested.
<br>The <tt> _KEYBRD_READ</tt> and <tt> _NKEYBRD_READ</tt> services return the character's ASCII value in the low-order byte
 and the character's keyboard scan code in the high-order byte.
<br><br>The <tt> _KEYBRD_READY</tt> and <tt> _NKEYBRD_READY</tt> services return zero if there was no character available,
 otherwise it returns the same value returned by <tt> _KEYBRD_READ</tt> and <tt> _NKEYBRD_READ</tt>.
<br><br>The shift status is returned in the low-order byte with one bit for each special key defined as follows:
<dl>
<dt>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>bit 0 (0x01)
<dd>Right SHIFT key is pressed
<dt><br>bit 1 (0x02)
<dd>Left SHIFT key is pressed
<dt><br>bit 2 (0x04)
<dd>CTRL key is pressed
<dt><br>bit 3 (0x08)
<dd>ALT key is pressed
<dt><br>bit 4 (0x10)
<dd>SCROLL LOCK is on
<dt><br>bit 5 (0x20)
<dd>NUM LOCK is on
<dt><br>bit 6 (0x40)
<dd>CAPS LOCK is on
<dt><br>bit 7 (0x80)
<dd>Insert mode is set
</dl>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short key_state;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; key_state = _bios_keybrd( _KEYBRD_SHIFTSTATUS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( key_state &amp; 0x10 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;SCROLL LOCK is on\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( key_state &amp; 0x20 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;NUM LOCK is on\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( key_state &amp; 0x40 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;CAPS LOCK is on\n&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>NUM LOCK is on</tt>
</dl>
<dl>
<dt>Classification:
<dd>BIOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386
</dl>
<h2 id="_bios_memsize"> _bios_memsize </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><tt>unsigned short _bios_memsize( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _bios_memsize</tt> function uses INT 0x12 to determine the total amount of memory available.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _bios_memsize</tt> function returns the total amount of 1K blocks of memory installed (maximum 640).
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short memsize;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; memsize = _bios_memsize();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The total amount of memory is: %dK\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memsize );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>The total amount of memory is: 640K</tt>
</dl>
<dl>
<dt>Classification:
<dd>BIOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386
</dl>
<h2 id="_bios_printer"> _bios_printer </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><tt>unsigned short _bios_printer( unsigned service,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned port,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned data );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _bios_printer</tt> function uses INT 0x17 to perform printer output services to the printer specified by<b> port</b>.
&nbsp; The values for service are:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_PRINTER_WRITE
<dd>Sends the low-order byte of<b> data</b> to the printer specified by<b> port</b>.
<dt><br>_PRINTER_INIT
<dd>Initializes the printer specified by<b> port</b>.
<dt><br>_PRINTER_STATUS
<dd>Get the status of the printer specified by<b> port</b>.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _bios_printer</tt> function returns a printer status byte defined as follows:
<dl>
<dt>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>bit 0 (0x01)
<dd>Printer timed out
<dt><br>bits 1-2
<dd>Unused
<dt><br>bit 3 (0x08)
<dd>I/O error
<dt><br>bit 4 (0x10)
<dd>Printer selected
<dt><br>bit 5 (0x20)
<dd>Out of paper
<dt><br>bit 6 (0x40)
<dd>Printer acknowledge
<dt><br>bit 7 (0x80)
<dd>Printer not busy
</dl>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short status;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; status = _bios_printer( _PRINTER_STATUS, 1, 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Printer status: 0x%2.2X\n&quot;, status );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>BIOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386
</dl>
<h2 id="_bios_serialcom"> _bios_serialcom </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><tt>unsigned short _bios_serialcom( unsigned service,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned serial_port,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned data );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _bios_serialcom</tt> function uses INT 0x14 to provide serial communications services to the serial port specified
 by<b> serial_port</b>.&nbsp; 0 represents COM1, 1 represents COM2, etc.&nbsp; The values for service are:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_COM_INIT
<dd>Initializes the serial port to the parameters specified in<b> data</b>.
<dt><br>_COM_SEND
<dd>Transmits the low-order byte of<b> data</b> to the serial port.
<dt><br>_COM_RECEIVE
<dd>Reads an input character from the serial port.
<dt><br>_COM_STATUS
<dd>Returns the current status of the serial port.
</dl>
<br>The value passed in<b> data</b> for the <tt> _COM_INIT</tt> service can be built using the appropriate combination of
 the following values:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_COM_110
<dd>110 baud
<dt><br>_COM_150
<dd>150 baud
<dt><br>_COM_300
<dd>300 baud
<dt><br>_COM_600
<dd>600 baud
<dt><br>_COM_1200
<dd>1200 baud
<dt><br>_COM_2400
<dd>2400 baud
<dt><br>_COM_4800
<dd>4800 baud
<dt><br>_COM_9600
<dd>9600 baud
<dt><br>_COM_NOPARITY
<dd>No parity
<dt><br>_COM_EVENPARITY
<dd>Even parity
<dt><br>_COM_ODDPARITY
<dd>Odd parity
<dt><br>_COM_CHR7
<dd>7 data bits
<dt><br>_COM_CHR8
<dd>8 data bits
<dt><br>_COM_STOP1
<dd>1 stop bit
<dt><br>_COM_STOP2
<dd>2 stop bits
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _bios_serialcom</tt> function returns a 16-bit value with the high-order byte containing status information defined
 as follows:
<dl>
<dt>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>bit 15 (0x8000)
<dd>Timed out
<dt><br>bit 14 (0x4000)
<dd>Transmit shift register empty
<dt><br>bit 13 (0x2000)
<dd>Transmit holding register empty
<dt><br>bit 12 (0x1000)
<dd>Break detected
<dt><br>bit 11 (0x0800)
<dd>Framing error
<dt><br>bit 10 (0x0400)
<dd>Parity error
<dt><br>bit 9 (0x0200)
<dd>Overrun error
<dt><br>bit 8 (0x0100)
<dd>Data ready
</dl>
<br>The low-order byte of the return value depends on the value of the<b> service</b> argument.
<br><br>When<b> service</b> is _COM_SEND, bit 15 will be set if the<b> data</b> could not be sent.&nbsp; If bit 15 is clear,
 the return value equals the byte sent.
<br><br>When<b> service</b> is _COM_RECEIVE, the byte read will be returned in the low-order byte if there was no error.&nbsp;
 If there was an error, at least one of the high-order status bits will be set.
<br><br>When<b> service</b> is _COM_INIT or _COM_STATUS the low-order bits are defined as follows:
<dl>
<dt>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>bit 0 (0x01)
<dd>Clear to send (CTS) changed
<dt><br>bit 1 (0x02)
<dd>Data set ready changed
<dt><br>bit 2 (0x04)
<dd>Trailing-edge ring detector
<dt><br>bit 3 (0x08)
<dd>Receive line signal detector changed
<dt><br>bit 4 (0x10)
<dd>Clear to send
<dt><br>bit 5 (0x20)
<dd>Data-set ready
<dt><br>bit 6 (0x40)
<dd>Ring indicator
<dt><br>bit 7 (0x80)
<dd>Receive-line signal detected
</dl>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short status;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; status = _bios_serialcom( _COM_STATUS, 1, 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Serial status: 0x%2.2X\n&quot;, status );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>BIOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386
</dl>
<h2 id="_bios_timeofday"> _bios_timeofday </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><tt>int _bios_timeofday( int service, long *timeval );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _bios_timeofday</tt> function uses INT 0x1A to get or set the current system clock value.&nbsp; The values for service
 are:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_TIME_GETCLOCK
<dd>Places the current system clock value in the location pointed to by<b> timeval</b>.&nbsp; The function returns zero if midnight
 has not passed since the last time the system clock was read or set; otherwise, it returns 1.
<dt><br>_TIME_SETCLOCK
<dd>Sets the system clock to the value in the location pointed to by<b> timeval</b>.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>A value of -1 is returned if neither _TIME_GETCLOCK nor _TIME_SETCLOCK were specified; otherwise 0 is returned.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;bios.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long time_of_day;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _bios_timeofday( _TIME_GETCLOCK, &amp;time_of_day );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Ticks since midnight: %lu\n&quot;, time_of_day );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Ticks since midnight: 762717</tt>
</dl>
<dl>
<dt>Classification:
<dd>BIOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386
</dl>
<h2 id="_bprintf"> _bprintf, _bwprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int _bprintf( char *buf, size_t bufsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format, ... );</tt>
<br><tt>int _bwprintf( wchar_t *buf, size_t bufsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format, ... );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _bprintf</tt> function is equivalent to the <tt> sprintf</tt> function, except that the argument<b> bufsize</b> specifies
 the size of the character array<b> buf</b> into which the generated output is placed.&nbsp; A null character is placed at
 the end of the generated character string.&nbsp; The<b> format</b> string is described under the description of the <tt>
 printf</tt> function.
<br>The<tt> _bwprintf</tt> function is identical to<tt> _bprintf</tt> except that the argument<b> buf</b> specifies an array
 of wide characters into which the generated output is to be written, rather than converted to multibyte characters and written
 to a stream.&nbsp; The<tt> _bwprintf</tt> function accepts a wide-character string argument for<b> format</b>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _bprintf</tt> function returns the number of characters written into the array, not counting the terminating null
 character.&nbsp; An error can occur while converting a value for output.&nbsp; When an error has occurred, <tt> errno</tt>
 contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>, <a href="#sprintf">sprintf</a>,
 <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vprintf">vprintf</a>,
 <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( int argc, char *argv&#91;&#93; )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char file_name&#91;9&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char file_ext&#91;4&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _bprintf( file_name, 9, &quot;%s&quot;, argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _bprintf( file_ext,&nbsp; 4, &quot;%s&quot;, argv&#91;2&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s.%s\n&quot;, file_name, file_ext );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _bprintf - All, Netware</tt>
<br><tt>_bwprintf - All</tt>
</dl>
<h2 id="break___"> break...&nbsp; Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void break_off( void );</tt>
<br><tt>void break_on( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The <tt> break_off</tt> function can be used with DOS to restrict break checking (Ctrl/C, Ctrl/Break) to screen output and
 keyboard input.&nbsp; The <tt> break_on</tt> function can be used with DOS to add break checking (Ctrl/C, Ctrl/Break) to
 other activities such as disk file input/output.
</dl>
<dl>
<dt>Returns:
<dd>The <tt> break_off</tt> and <tt> break_on</tt> functions to not return anything.
</dl>
<dl>
<dt>See Also:
<dd><a href="#signal">signal</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *tmpf;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; tmpf = tmpfile();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( tmpf != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Start\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break_off();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; 100000; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( tmpf, &quot;%ld\n&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break_on();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Finish\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd><tt> break_off - DOS, Windows, Win386</tt>
<br><tt>break_on - DOS, Windows, Win386</tt>
</dl>
<h2 id="bsearch"> bsearch </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void *bsearch( const void *key,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *base,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t num,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t width,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*compar)( const void *pkey,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *pbase) );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#bsearch_s">bsearch_s</a> function which is a safer alternative to<tt>
 bsearch</tt>.&nbsp; This newer<tt> bsearch_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 bsearch</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> bsearch</tt> function performs a binary search of a sorted array of<b> num</b> elements, which is pointed to by<b>
 base</b>, for an item which matches the object pointed to by<b> key</b>.&nbsp; Each element in the array is<b> width</b>
 bytes in size.&nbsp; The comparison function pointed to by<b> compar</b> is called with two arguments that point to elements
 in the array.&nbsp; The first argument<b> pkey</b> points to the same object pointed to by<b> key</b>.&nbsp; The second argument<b>
 pbase</b> points to a element in the array.&nbsp; The comparison function shall return an integer less than, equal to, or
 greater than zero if the<b> key</b> object is less than, equal to, or greater than the element in the array.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> bsearch</tt> function returns a pointer to the matching member of the array, or<tt> NULL</tt> if a matching object
 could not be found.&nbsp; If there are multiple values in the array which are equal to the<b> key</b>, the return value is
 not necessarily the first occurrence of a matching value when the array is searched linearly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bsearch_s">bsearch_s</a>, <a href="#lfind">lfind</a>, <a href="#lsearch">lsearch</a>, <a href="#qsort">qsort</a>,
 <a href="#qsort_s">qsort_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>static const char *keywords&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;auto&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;break&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;case&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;char&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;while&quot;</tt>
<br><tt>&nbsp; };</tt>
<br><br><tt>#define NUM_KW&nbsp; sizeof(keywords) / sizeof(char *)</tt>
<br><br><tt>int kw_compare( const void *p1, const void *p2 )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char *p1c = (const char *) p1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char **p2c = (const char **) p2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( strcmp( p1c, *p2c ) );</tt>
<br><tt>}</tt>
<br><br><tt>int keyword_lookup( const char *name )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char **key;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; key = (char const **) bsearch( name, keywords, NUM_KW,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(
 char * ),&nbsp; kw_compare );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( key == NULL ) return( -1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return key - keywords;</tt>
<br><tt>}</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, keyword_lookup( &quot;case&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, keyword_lookup( &quot;crigger&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, keyword_lookup( &quot;auto&quot; ) );</tt>
<br><tt>}</tt>
<br><tt>//************ Sample program output ************</tt>
<br><tt>//2</tt>
<br><tt>//-1</tt>
<br><tt>//0</tt>
<br><br>produces the following:
<br><br><tt>2</tt>
<br><tt>-1</tt>
<br><tt>0</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="bsearch_s"> bsearch_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void *bsearch_s( const void *key,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *base,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t nmemb,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t size,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int (*compar)( const void *k, const void *y, void *context ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *context );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 bsearch_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> nmemb</b> nor<b> size</b> shall be greater than <tt> RSIZE_MAX</tt>.&nbsp; If<b> nmemb</b> is not equal to
 zero, then none of<b> key, base</b>, or<b> compar</b> shall be a null pointer.&nbsp; If there is a runtime-constraint violation,
 the<tt> bsearch_s</tt> function does not search the array.
</dl>
<dl>
<dt>Description:
<dd>The<tt> bsearch_s</tt> function searches an array of<b> nmemb</b> objects, the initial element of which is pointed to by<b>
 base</b>, for an element that matches the object pointed to by<b> key</b>.&nbsp; The size of each element of the array is
 specified by<b> size</b>.&nbsp; The comparison function pointed to by<b> compar</b> is called with three arguments.&nbsp;
 The first two point to the key object and to an array element, in that order.&nbsp; The function shall return an integer
 less than, equal to, or greater than zero if the key object is considered, respectively, to be less than, to match, or to
 be greater than the array element.&nbsp; The array shall consist of:&nbsp; all the elements that compare less than, all the
 elements that compare equal to, and all the elements that compare greater than the key object, in that order.&nbsp; The third
 argument to the comparison function is the<b> context</b> argument passed to<tt> bsearch_s</tt> The sole use of context by
 &amp;funcs is to pass it to the comparison function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> bsearch_s</tt> function returns a pointer to a matching element of the array,or a null pointer if no match is found
 or there is a runtime-constraint violation.&nbsp; If two elements compare as equal, which element is matched is unspecified.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bsearch">bsearch</a>, <a href="#lfind">lfind</a>, <a href="#lsearch">lsearch</a>, <a href="#qsort">qsort</a>, <a href="#qsort_s">qsort_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>static const char *keywords&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;auto&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;break&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;case&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;char&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;while&quot;</tt>
<br><tt>};</tt>
<br><tt>static void * context = NULL;</tt>
<br><br><tt>#define NUM_KW&nbsp; sizeof(keywords) / sizeof(char *)</tt>
<br><br><tt>int kw_compare( const void *p1, const void *p2, void *context )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char *p1c = (const char *) p1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char **p2c = (const char **) p2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( strcmp( p1c, *p2c ) );</tt>
<br><tt>}</tt>
<br><br><tt>int keyword_lookup( const char *name )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char **key;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; key = (char const **) bsearch_s( name, keywords, NUM_KW,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(
 char * ),&nbsp; kw_compare, context );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( key == NULL ) return( -1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return key - keywords;</tt>
<br><tt>}</tt>
<br><br><tt>int main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, keyword_lookup( &quot;case&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, keyword_lookup( &quot;crigger&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, keyword_lookup( &quot;auto&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return 0;</tt>
<br><tt>}</tt>
<br><tt>//************ Sample program output ************</tt>
<br><tt>//2</tt>
<br><tt>//-1</tt>
<br><tt>//0</tt>
<br><br>produces the following:
<br><br><tt>2</tt>
<br><tt>-1</tt>
<br><tt>0</tt>
</dl>
<dl>
<dt>Classification:
<dd>TR 24731
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="btowc"> btowc </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wint_t btowc( int c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> btowc</tt> function determines whether<b> c</b> is a valid single-byte character in the initial shift state.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> btowc</tt> function returns<tt> WEOF</tt> if<b> c</b> has the value<tt> EOF</tt> or if<b> (unsigned char)c</b> does
 not constitute a valid single-byte character in the initial shift state.&nbsp; Otherwise,<tt> btowc</tt> returns the wide
 character representation of that character.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>,
 <a href="#mbrlen">mbrlen</a>, <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>,
 <a href="#mbstowcs">mbstowcs</a>, <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;EOF is %sa valid single-byte character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; btowc( EOF ) == WEOF ? &quot;not &quot; : &quot;&quot; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>EOF is not a valid single-byte character</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="bzero"> bzero </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>void bzero( void *dst, size_t n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> bzero</tt> function fills the first<b> n</b> bytes of the object pointed to by<b> dst</b> with zero (null) bytes.
<br>Note that this function is similar to the ANSI <tt> memset</tt> function (new code should use the ANSI function).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> bzero</tt> function has no return value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bcmp">bcmp</a>, <a href="#bcopy">bcopy</a>, <a href="#memset">memset</a>, <a href="#strset">strset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; bzero( buffer, 80 );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="cabs"> cabs </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double cabs( struct complex value );</tt>
<br><br><tt>struct _complex {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; double&nbsp; x;&nbsp; /* real part */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; double&nbsp; y;&nbsp; /* imaginary part */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> cabs</tt> function computes the absolute value of the complex number<b> value</b> by a calculation which is equivalent
 to
<br><tt>sqrt( (value.x*value.x) + (value.y*value.y) )</tt>
<br><br>In certain cases, overflow errors may occur which will cause the <tt> matherr</tt> routine to be invoked.
</dl>
<dl>
<dt>Returns:
<dd>The absolute value is returned.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>struct _complex c = { -3.0, 4.0 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, cabs( c ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>5.000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="calloc"> calloc Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;&nbsp; For ANSI compatibility (calloc only)</tt>
<br><tt>#include &lt;malloc.h&gt;&nbsp; Required for other function prototypes</tt>
<br><tt>void *calloc( size_t n, size_t size );</tt>
<br><tt>void __based(void) *_bcalloc( __segment seg,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</tt>
<br><tt>void __far&nbsp; *_fcalloc( size_t n, size_t size );</tt>
<br><tt>void __near *_ncalloc( size_t n, size_t size );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<b> calloc</b> functions allocate space for an array of<b> n</b> objects, each of length<b> size</b> bytes.&nbsp; Each
 element is initialized to 0.
<br>Each function allocates memory from a particular heap, as listed below:
<dl>
<dt>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap
<dt>calloc
<dd>Depends on data model of the program
<dt><br>_bcalloc
<dd>Based heap specified by<b> seg</b> value
<dt><br>_fcalloc
<dd>Far heap (outside the default data segment)
<dt><br>_ncalloc
<dd>Near heap (inside the default data segment)
</dl>
<br>In a small data memory model, the<b> calloc</b> function is equivalent to the <tt> _ncalloc</tt> function; in a large
 data memory model, the<b> calloc</b> function is equivalent to the <tt> _fcalloc</tt> function.
<br><br>A block of memory allocated should be freed using the appropriate <tt> free</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<b> calloc</b> functions return a pointer to the start of the allocated memory.&nbsp; The return value is<tt> NULL</tt>
 (<tt> _NULLOFF</tt> for <tt> _bcalloc</tt>) if there is insufficient memory available or if the value of the<b> size</b>
 argument is zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_expand">_expand</a> Functions, <a href="#free">free</a> Functions, <a href="#halloc">halloc</a>, <a href="#hfree">hfree</a>,
 <a href="#malloc">malloc</a> Functions, <a href="#_msize">_msize</a> Functions, <a href="#realloc">realloc</a> Functions,
 <a href="#sbrk">sbrk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *buffer;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; buffer = (char *)calloc( 80, sizeof(char) );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>calloc is ANSI
<br>_fcalloc is not ANSI
<br>_bcalloc is not ANSI
<br>_ncalloc is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> calloc - All, Netware</tt>
<br><tt>_bcalloc - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_fcalloc - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_ncalloc - DOS, Windows, Win386, Win32, QNX, OS/2 1.x, OS/2 1.x(MT), OS/2-32</tt>
</dl>
<h2 id="ceil"> ceil </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double ceil( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ceil</tt> function (ceiling function) computes the smallest integer not less than<b> x</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ceil</tt> function returns the smallest integer not less than<b> x</b>, expressed as a<tt> double.</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#floor">floor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f %f %f %f %f\n&quot;, ceil( -2.1 ), ceil( -2. ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ceil( 0.0 ), ceil( 2. ), ceil( 2.1 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>-2.000000 -2.000000 0.000000 2.000000 3.000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="cgets"> cgets </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>char *cgets( char *buf );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> cgets</tt> function gets a string of characters directly from the console and stores the string and its length in
 the array pointed to by<b> buf</b>.&nbsp; The first element of the array<b> buf&#91;0&#93;</b> must contain the maximum length
 in characters of the string to be read.&nbsp; The array must be big enough to hold the string, a terminating null character,
 and two additional bytes.
<br>The<tt> cgets</tt> function reads characters until a carriage-return line-feed combination is read, or until the specified
 number of characters is read.&nbsp; The string is stored in the array starting at<b> buf&#91;2&#93;</b>.&nbsp; The carriage-return
 line-feed combination, if read, is replaced by a null character.&nbsp; The actual length of the string read is placed in<b>
 buf&#91;1&#93;</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> cgets</tt> function returns a pointer to the start of the string which is at<b> buf&#91;2&#93;</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fgets">fgets</a>, <a href="#getch">getch</a>, <a href="#getche">getche</a>, <a href="#gets">gets</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;82&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; buffer&#91;0&#93; = 80;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cgets( buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cprintf( &quot;%s\r\n&quot;, &amp;buffer&#91;2&#93; );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_chain_intr"> _chain_intr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>void _chain_intr( void (__interrupt __far *func)() );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _chain_intr</tt> function is used at the end of an interrupt routine to start executing another interrupt handler
 (usually the previous handler for that interrupt).&nbsp; When the interrupt handler designated by<b> func</b> receives control,
 the stack and registers appear as though the interrupt just occurred.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _chain_intr</tt> function does not return.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_getvect">_dos_getvect</a>, <a href="#_dos_keep">_dos_keep</a>, <a href="#_dos_setvect">_dos_setvect</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>volatile int clock_ticks;</tt>
<br><tt>void (__interrupt __far *prev_int_1c)();</tt>
<br><tt>#define BLIP_COUNT&nbsp; (5*18)&nbsp; /* 5 seconds */</tt>
<br><br><tt>void __interrupt __far timer_rtn()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ++clock_ticks;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _chain_intr( prev_int_1c );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>int delays = 0;</tt>
<br><br><tt>int compile_a_line()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( delays &gt; 15 ) return( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; delay( 1000 );&nbsp; /* delay for 1 second */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Delayed for 1 second\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; delays++;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 1 );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; prev_int_1c = _dos_getvect( 0x1c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_setvect( 0x1c, timer_rtn );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( compile_a_line() ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( clock_ticks &gt;= BLIP_COUNT ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar( '.' );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clock_ticks -= BLIP_COUNT;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_setvect( 0x1c, prev_int_1c );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows
</dl>
<h2 id="chdir"> chdir, _chdir, _wchdir </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><tt>int chdir( const char *path );</tt>
<br><tt>int _chdir( const char *path );</tt>
<br><tt>int _wchdir( const wchar_t *path );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> chdir</tt> function changes the current directory on the specified drive to the specified<b> path</b>.&nbsp; If no
 drive is specified in<b> path</b> then the current drive is assumed.&nbsp; The<b> path</b> can be either relative to the
 current directory on the specified drive or it can be an absolute path name.
<br>Each drive under DOS, OS/2 or Windows has a current directory.&nbsp; The current working directory is the current directory
 of the current drive.&nbsp; If you wish to change the current drive, you must use the <tt> _dos_setdrive</tt> function.
<br><br>The<tt> _chdir</tt> function is identical to<tt> chdir</tt>.&nbsp; Use<tt> _chdir</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _wchdir</tt> function is identical to<tt> chdir</tt> except that it accepts a wide-character string argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> chdir</tt> function returns zero if successful.&nbsp; Otherwise, -1 is returned, <tt> errno</tt> is set to indicate
 the error, and the current working directory remains unchanged.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>ENOENT
<dd>The specified<b> path</b> does not exist or<b> path</b> is an empty string.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#chmod">chmod</a>, <a href="#_dos_setdrive">_dos_setdrive</a>, <a href="#getcwd">getcwd</a>, <a href="#mkdir">mkdir</a>,
 <a href="#rmdir">rmdir</a>, <a href="#stat">stat</a>, <a href="#umask">umask</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><br><tt>void main( int argc, char *argv&#91;&#93; )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( argc != 2 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Use: cd &lt;directory&gt;\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( chdir( argv&#91;1&#93; ) == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Directory changed to %s\n&quot;, argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>chdir is POSIX 1003.1
<br>_chdir is not POSIX
<br>_wchdir is not POSIX
<br>_chdir conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> chdir - All, Netware</tt>
<br><tt>_chdir - All, Netware</tt>
<br><tt>_wchdir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_chdrive"> _chdrive </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><tt>void _chdrive( int drive );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _chdrive</tt> function changes the current working drive to the one specified by<b> drive</b>.&nbsp; A value of 1
 is drive A, 2 is drive B, 3 is drive C, etc.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _chdrive</tt> function returns zero if drive is successfully changed.&nbsp; Otherwise, -1 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_getdrive">_dos_getdrive</a>, <a href="#_dos_setdrive">_dos_setdrive</a>, <a href="#_getdrive">_getdrive</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int drive = 3;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( _chdrive( drive&nbsp; ) == 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Changed the current drive to %c\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'A' + drive - 1 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Changed the current drive to C</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="chmod"> chmod, _chmod, _wchmod </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int chmod( const char *path, int permission );</tt>
<br><tt>int _chmod( const char *path, int permission );</tt>
<br><tt>int _wchmod( const wchar_t *path, int permission );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> chmod</tt> function changes the permissions for a file specified by<b> path</b> to be the settings in the mode given
 by<b> permission</b>.&nbsp; The access permissions for the file or directory are specified as a combination of bits (defined
 in the<tt> &lt;sys\stat.h&gt;</tt> header file).
<br>The following bits define permissions for the owner.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXU
<dd>Read, write, execute/search
<dt><br>S_IRUSR
<dd>Read permission
<dt><br>S_IWUSR
<dd>Write permission
<dt><br>S_IXUSR
<dd>Execute/search permission
</dl>
<br>The following bits define permissions for the group.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXG
<dd>Read, write, execute/search
<dt><br>S_IRGRP
<dd>Read permission
<dt><br>S_IWGRP
<dd>Write permission
<dt><br>S_IXGRP
<dd>Execute/search permission
</dl>
<br>The following bits define permissions for others.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXO
<dd>Read, write, execute/search
<dt><br>S_IROTH
<dd>Read permission
<dt><br>S_IWOTH
<dd>Write permission
<dt><br>S_IXOTH
<dd>Execute/search permission
</dl>
<br>The following bits define miscellaneous permissions used by other implementations.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IREAD
<dd>is equivalent to S_IRUSR (read permission)
<dt><br>S_IWRITE
<dd>is equivalent to S_IWUSR (write permission)
<dt><br>S_IEXEC
<dd>is equivalent to S_IXUSR (execute/search permission)
</dl>
<br>Upon successful completion, the<tt> chmod</tt> function will mark for update the<b> st_ctime</b> field of the file.
<br><br>The<tt> _chmod</tt> function is identical to<tt> chmod</tt>.&nbsp; Use<tt> _chmod</tt> for ANSI naming conventions.
<br><br>The<tt> _wchmod</tt> function is identical to<tt> chmod</tt> except that it accepts a wide-character string argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> chmod</tt> returns zero if the new settings are successfully made; otherwise, -1 is returned and <tt> errno</tt> is
 set to indicate the error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EACCES
<dd>Search permission is denied for a component of<b> path</b>.
<dt><br>ENOENT
<dd>The specified<b> path</b> does not exist or<b> path</b> is an empty string.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#fstat">fstat</a>, <a href="#open">open</a>, <a href="#sopen">sopen</a>, <a href="#stat">stat</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>/*</tt>
<br><tt> * change the permissions of a list of files</tt>
<br><tt> * to be read/write by the owner only</tt>
<br><tt> */</tt>
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main( int argc, char *argv&#91;&#93; )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int ecode = 0;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; argc; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( chmod( argv&#91;i&#93;, S_IRUSR | S_IWUSR ) == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( argv&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecode++;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; exit( ecode );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>chmod is POSIX 1003.1
<br>_chmod is not POSIX
<br>_wchmod is not POSIX
</dl>
<dl>
<dt>Systems:
<dd><tt> chmod - All, Netware</tt>
<br><tt>_chmod - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wchmod - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="chsize"> chsize, _chsize </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int chsize( int handle, long size );</tt>
<br><tt>int _chsize( int handle, long size );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> chsize</tt> function changes the size of the file associated with<b> handle</b> by extending or truncating the file
 to the length specified by<b> size</b>.&nbsp; If the file needs to be extended, the file is padded with NULL ('\0') characters.
<br>The<tt> _chsize</tt> function is identical to<tt> chsize</tt>.&nbsp; Use<tt> _chsize</tt> for ANSI naming conventions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> chsize</tt> function returns zero if successful.&nbsp; A return value of -1 indicates an error, and <tt> errno</tt>
 is set to indicate the error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EACCES
<dd>The specified file is locked against access.
<dt><br>EBADF
<dd>Invalid file handle.
<dt><br>ENOSPC
<dd>Not enough space left on the device to extend the file.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#close">close</a>, <a href="#creat">creat</a>, <a href="#open">open</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp; handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDWR | O_CREAT,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
 | S_IWGRP );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( chsize( handle, 32 * 1024L ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error extending file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> chsize - All, Netware</tt>
<br><tt>_chsize - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_clear87"> _clear87 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;float.h&gt;</tt>
<br><tt>unsigned int _clear87( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _clear87</tt> function clears the floating-point status word which is used to record the status of 8087/80287/80387/80486
 floating-point operations.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _clear87</tt> function returns the old floating-point status.&nbsp; The description of this status is found in the<tt>
 &lt;float.h&gt;</tt> header file.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_control87">_control87</a>, <a href="#_controlfp">_controlfp</a>, <a href="#_finite">_finite</a>, <a href="#_fpreset">_fpreset</a>,
 <a href="#_status87">_status87</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;float.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int fp_status;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp_status = _clear87();</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;80x87 status =&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp_status &amp; SW_INVALID )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; invalid&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp_status &amp; SW_DENORMAL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; denormal&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp_status &amp; SW_ZERODIVIDE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; zero_divide&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp_status &amp; SW_OVERFLOW )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; overflow&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp_status &amp; SW_UNDERFLOW )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; underflow&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp_status &amp; SW_INEXACT )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; inexact_result&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="clearenv"> clearenv </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;env.h&gt;</tt>
<br><tt>int clearenv( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> clearenv</tt> function clears the process environment area.&nbsp; No environment variables are defined immediately
 after a call to the<tt> clearenv</tt> function.&nbsp; Note that this clears the <tt> PATH</tt>, <tt> COMSPEC</tt>, and <tt>
 TZ</tt> environment variables which may then affect the operation of other library functions.
<br>The<tt> clearenv</tt> function may manipulate the value of the pointer <tt> environ</tt>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> clearenv</tt> function returns zero upon successful completion.&nbsp; Otherwise, it will return a non-zero value and
 set <tt> errno</tt> to indicate the error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>ENOMEM
<dd>Not enough memory to allocate a control structure.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#exec___">exec...</a>, <a href="#getenv">getenv</a>, <a href="#getenv_s">getenv_s</a>, <a href="#putenv">putenv</a>,
 <a href="#_searchenv">_searchenv</a>, <a href="#setenv">setenv</a>, <a href="#spawn___">spawn...</a>, <a href="#system">system</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>The following example clears the entire environment area and sets up a new TZ environment variable.
<br><br><tt>#include &lt;env.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; clearenv();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; setenv( &quot;TZ&quot;, &quot;EST5EDT&quot;, 0 );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="clearerr"> clearerr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>void clearerr( FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> clearerr</tt> function clears the end-of-file and error indicators for the stream pointed to by<b> fp</b>.&nbsp; These
 indicators are cleared only when the file is opened or by an explicit call to the<tt> clearerr</tt> or <tt> rewind</tt> functions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> clearerr</tt> function returns no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#feof">feof</a>, <a href="#ferror">ferror</a>, <a href="#perror">perror</a>, <a href="#strerror">strerror</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; c = 'J';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;w&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputc( c, fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ferror( fp ) ) {&nbsp; /* if error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clearerr( fp );&nbsp;&nbsp; /* clear the error */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputc( c, fp );&nbsp;&nbsp; /* and retry it&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_clearscreen"> _clearscreen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _clearscreen( short area );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _clearscreen</tt> function clears the indicated<b> area</b> and fills it with the background color.&nbsp; The<b> area</b>
 argument must be one of the following values:
<dl>
<dt>_GCLEARSCREEN
<dd>area is entire screen
<dt><br>_GVIEWPORT
<dd>area is current viewport or clip region
<dt><br>_GWINDOW
<dd>area is current text window
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _clearscreen</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setbkcolor">_setbkcolor</a>, <a href="#_setviewport">_setviewport</a>, <a href="#_setcliprgn">_setcliprgn</a>,
 <a href="#_settextwindow">_settextwindow</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setviewport( 200, 200, 440, 280 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _clearscreen( _GVIEWPORT );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="clock"> clock </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>clock_t clock(void);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> clock</tt> function returns the number of clock ticks of processor time used by program since the program started
 executing.&nbsp; This can be converted to seconds by dividing by the value of the macro <tt> CLOCKS_PER_SEC</tt>.
<br>Note that under DOS and OS/2, the clock tick counter will reset to 0 for each subsequent 24 hour interval that elapses.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> clock</tt> function returns the number of clock ticks that have occurred since the program started executing.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#asctime_s">asctime_s</a>, <a href="#ctime">ctime</a> Functions, <a href="#ctime_s">ctime_s</a>,
 <a href="#difftime">difftime</a>, <a href="#gmtime">gmtime</a>, <a href="#gmtime_s">gmtime_s</a>, <a href="#localtime">localtime</a>,
 <a href="#localtime_s">localtime_s</a>, <a href="#mktime">mktime</a>, <a href="#strftime">strftime</a>, <a href="#time">time</a>,
 <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void compute( void )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i, j;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; double x;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; x = 0.0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 100; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( j = 1; j &lt;= 100; j++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x += sqrt( (double) i * j );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%16.7f\n&quot;, x );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; clock_t start_time, end_time;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; start_time = clock();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; compute();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; end_time = clock();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Execution time was %lu seconds\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (end_time - start_time) / CLOCKS_PER_SEC );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="close"> close, _close </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int close( int handle );</tt>
<br><tt>int _close( int handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> close</tt> function closes a file at the operating system level.&nbsp; The<b> handle</b> value is the file handle
 returned by a successful execution of one of the <tt> creat</tt>, <tt> dup</tt>, <tt> dup2</tt>, <tt> open</tt> or <tt> sopen</tt>
 functions.
<br>The<tt> _close</tt> function is identical to<tt> close</tt>.&nbsp; Use<tt> _close</tt> for ANSI/ISO naming conventions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> close</tt> function returns zero if successful.&nbsp; Otherwise, it returns -1 and <tt> errno</tt> is set to indicate
 the error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EBADF
<dd>The<b> handle</b> argument is not a valid file handle.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#creat">creat</a>, <a href="#dup">dup</a>, <a href="#dup2">dup2</a>, <a href="#open">open</a>, <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* process file */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>close is POSIX 1003.1
<br>_close is not POSIX
<br>_close conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> close - All, Netware</tt>
<br><tt>_close - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="closedir"> closedir, _wclosedir </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><tt>int closedir( struct dirent *dirp );</tt>
<br><tt>int _wclosedir( struct _wdirent *dirp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> closedir</tt> function closes the directory specified by<b> dirp</b> and frees the memory allocated by <tt> opendir</tt>.
<br>The<tt> _wclosedir</tt> function is identical to<tt> closedir</tt> except that it closes a directory of wide-character
 filenames opened by <tt> _wopendir</tt>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> closedir</tt> function returns zero if successful, non-zero otherwise.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EBADF
<dd>The argument<b> dirp</b> does not refer to an open directory stream.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_find___">_dos_find...</a>, <a href="#opendir">opendir</a>, <a href="#readdir">readdir</a>, <a href="#rewinddir">rewinddir</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>To get a list of files contained in the directory<tt> \watcom\h</tt> on your default disk:
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; twosecs : 5;&nbsp;&nbsp;&nbsp; /* seconds / 2 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; minutes : 6;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; hours&nbsp;&nbsp; : 5;</tt>
<br><tt>} ftime_t;</tt>
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; day&nbsp;&nbsp;&nbsp;&nbsp; : 5;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; month&nbsp;&nbsp; : 4;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; year&nbsp;&nbsp;&nbsp; : 7;</tt>
<br><tt>} fdate_t;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; DIR *dirp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct dirent *direntp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ftime_t *f_time;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fdate_t *f_date;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; dirp = opendir( &quot;\\watcom\\h&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( dirp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp = readdir( dirp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( direntp == NULL ) break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time = (ftime_t *)&amp;direntp-&gt;d_time;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date = (fdate_t *)&amp;direntp-&gt;d_date;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%-12s %d/%2.2d/%2.2d &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2d:%2.2d:%2.2d
 \n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp-&gt;d_name,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;year + 1980,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;month,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;day,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;hours,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;minutes,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;twosecs * 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; closedir( dirp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</dl>
<dl>
<dt>Classification:
<dd>closedir is POSIX 1003.1
<br>_wclosedir is not POSIX
</dl>
<dl>
<dt>Systems:
<dd><tt> closedir - All, Netware</tt>
<br><tt>_wclosedir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_cmdname"> _cmdname </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;process.h&gt;</tt>
<br><tt>char *_cmdname( char *buffer );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _cmdname</tt> function obtains a copy of the executing program's pathname and places it in<b> buffer</b>.
</dl>
<dl>
<dt>Returns:
<dd>If the pathname of the executing program cannot be determined then<tt> NULL</tt> is returned; otherwise the address of<b>
 buffer</b> is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#getcmd">getcmd</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;process.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;PATH_MAX&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, _cmdname( buffer ) );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_commit"> _commit </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int _commit( int handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _commit</tt> function commits changes to the file specified by<b> handle</b> to disk immediately.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _commit</tt> function returns -1 if the changes have been successfully committed.&nbsp; Otherwise, 0 is returned and
 <tt> errno</tt> is set to indicate the error.
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_control87"> _control87 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;float.h&gt;</tt>
<br><tt>unsigned int _control87( unsigned int newcw,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int mask );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _control87</tt> function updates the control word of the 8087/80287/80387/80486.&nbsp; If<b> mask</b> is zero, then
 the control word is not updated.&nbsp; If<b> mask</b> is non-zero, then the control word is updated with bits from<b> newcw</b>
 corresponding to every bit that is on in<b> mask</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _control87</tt> function returns the new control word.&nbsp; The description of bits defined for the control word
 is found in the<tt> &lt;float.h&gt;</tt> header file.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_clear87">_clear87</a>, <a href="#_controlfp">_controlfp</a>, <a href="#_finite">_finite</a>, <a href="#_fpreset">_fpreset</a>,
 <a href="#_status87">_status87</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;float.h&gt;</tt>
<br><br><tt>char *status&#91;2&#93; = { &quot;disabled&quot;, &quot;enabled&quot; };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int fp_cw = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int fp_mask = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int bits;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp_cw = _control87( fp_cw,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; fp_mask );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Interrupt Exception Masks\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_EM;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Invalid Operation exception %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (bits &amp; EM_INVALID) == 0 &#93;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Denormalized exception %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (bits &amp; EM_DENORMAL) == 0 &#93;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Divide-By-Zero exception %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (bits &amp; EM_ZERODIVIDE) == 0 &#93;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Overflow exception %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (bits &amp; EM_OVERFLOW) == 0 &#93;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Underflow exception %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (bits &amp; EM_UNDERFLOW) == 0 &#93;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Precision exception %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (bits &amp; EM_PRECISION) == 0 &#93;
 );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Infinity Control = &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_IC;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == IC_AFFINE )&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;affine\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == IC_PROJECTIVE ) printf( &quot;projective\n&quot; );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Rounding Control = &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_RC;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == RC_NEAR )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;near\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == RC_DOWN )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;down\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == RC_UP )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;up\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == RC_CHOP )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;chop\n&quot; );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Precision Control = &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_PC;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == PC_24 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;24 bits\n&quot;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == PC_53 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;53 bits\n&quot;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == PC_64 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;64 bits\n&quot;
 );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_controlfp"> _controlfp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;float.h&gt;</tt>
<br><tt>unsigned int _controlfp( unsigned int newcw,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int mask );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _controlfp</tt> function updates the control word of the 8087/80287/80387/80486.&nbsp; If<b> mask</b> is zero, then
 the control word is not updated.&nbsp; If<b> mask</b> is non-zero, then the control word is updated with bits from<b> newcw</b>
 corresponding to every bit that is on in<b> mask</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _controlfp</tt> function returns the new control word.&nbsp; The description of bits defined for the control word
 is found in the<tt> &lt;float.h&gt;</tt> header file.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_clear87">_clear87</a>, <a href="#_control87">_control87</a>, <a href="#_finite">_finite</a>, <a href="#_fpreset">_fpreset</a>,
 <a href="#_status87">_status87</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;float.h&gt;</tt>
<br><br><tt>char *status&#91;2&#93; = { &quot;disabled&quot;, &quot;enabled&quot; };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int fp_cw = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int fp_mask = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int bits;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp_cw = _controlfp( fp_cw,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; fp_mask );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Interrupt Exception Masks\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_EM;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Invalid Operation exception %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (bits &amp; EM_INVALID) == 0 &#93;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Denormalized exception %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (bits &amp; EM_DENORMAL) == 0 &#93;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Divide-By-Zero exception %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (bits &amp; EM_ZERODIVIDE) == 0 &#93;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Overflow exception %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (bits &amp; EM_OVERFLOW) == 0 &#93;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Underflow exception %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (bits &amp; EM_UNDERFLOW) == 0 &#93;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; Precision exception %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (bits &amp; EM_PRECISION) == 0 &#93;
 );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Infinity Control = &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_IC;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == IC_AFFINE )&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;affine\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == IC_PROJECTIVE ) printf( &quot;projective\n&quot; );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Rounding Control = &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_RC;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == RC_NEAR )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;near\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == RC_DOWN )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;down\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == RC_UP )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;up\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == RC_CHOP )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;chop\n&quot; );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Precision Control = &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; bits = fp_cw &amp; MCW_PC;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == PC_24 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;24 bits\n&quot;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == PC_53 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;53 bits\n&quot;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( bits == PC_64 )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;64 bits\n&quot;
 );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="cos"> cos </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double cos( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> cos</tt> function computes the cosine of<b> x</b> (measured in radians).&nbsp; A large magnitude argument may yield
 a result with little or no significance.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> cos</tt> function returns the cosine value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#acos">acos</a>, <a href="#sin">sin</a>, <a href="#tan">tan</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; double value;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; value = cos( 3.1415278 );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="cosh"> cosh </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double cosh( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> cosh</tt> function computes the hyperbolic cosine of<b> x</b>.&nbsp; A range error occurs if the magnitude of<b> x</b>
 is too large.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> cosh</tt> function returns the hyperbolic cosine value.&nbsp; When the argument is outside the permissible range,
 the <tt> matherr</tt> function is called.&nbsp; Unless the default <tt> matherr</tt> function is replaced, it will set the
 global variable <tt> errno</tt> to <tt> ERANGE</tt>, and print a &quot;RANGE error&quot; diagnostic message using the <tt>
 stderr</tt> stream.
</dl>
<dl>
<dt>See Also:
<dd><a href="#sinh">sinh</a>, <a href="#tanh">tanh</a>, <a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, cosh(.5) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>1.127626</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="cprintf"> cprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>int cprintf( const char *format, ... );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> cprintf</tt> function writes output directly to the console under control of the argument<b> format</b>.&nbsp; The
 <tt> putch</tt> function is used to output characters to the console.&nbsp; The<b> format</b> string is described under the
 description of the <tt> printf</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> cprintf</tt> function returns the number of characters written.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>, <a href="#sprintf">sprintf</a>,
 <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vprintf">vprintf</a>,
 <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *weekday, *month;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; weekday = &quot;Saturday&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; month = &quot;April&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; day = 18;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; year = 1987;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cprintf( &quot;%s, %s %d, %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Saturday, April 18, 1987</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="cputs"> cputs </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>int cputs( const char *buf );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> cputs</tt> function writes the character string pointed to by<b> buf</b> directly to the console using the <tt> putch</tt>
 function.&nbsp; Unlike the <tt> puts</tt> function, the carriage-return and line-feed characters are not appended to the
 string.&nbsp; The terminating null character is not written.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> cputs</tt> function returns a non-zero value if an error occurs; otherwise, it returns zero.&nbsp; When an error has
 occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fputs">fputs</a>, <a href="#putch">putch</a>, <a href="#puts">puts</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;82&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; buffer&#91;0&#93; = 80;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cgets( buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cputs( &amp;buffer&#91;2&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; putch( '\r' );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; putch( '\n' );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="creat"> creat, _creat, _wcreat </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int creat( const char *path, int mode );</tt>
<br><tt>int _creat( const char *path, int mode );</tt>
<br><tt>int _wcreat( const wchar_t *path, int mode );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> creat</tt> function creates (and opens) a file at the operating system level.&nbsp; It is equivalent to:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; open( path, O_WRONLY | O_CREAT | O_TRUNC, mode );</tt>
<br><br>The<tt> _creat</tt> function is identical to<tt> creat</tt>.&nbsp; Use<tt> _creat</tt> for ANSI naming conventions.
<br><br>The<tt> _wcreat</tt> function is identical to<tt> creat</tt> except that it accepts a wide character string argument.
<br><br>The name of the file to be created is given by<b> path</b>.&nbsp; When the file exists (it must be writeable), it
 is truncated to contain no data and the preceding<b> mode</b> setting is unchanged.
<br><br>When the file does not exist, it is created with access permissions given by the<b> mode</b> argument.&nbsp; The access
 permissions for the file or directory are specified as a combination of bits (defined in the<tt> &lt;sys\stat.h&gt;</tt>
 header file).
<br><br>The following bits define permissions for the owner.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXU
<dd>Read, write, execute/search
<dt><br>S_IRUSR
<dd>Read permission
<dt><br>S_IWUSR
<dd>Write permission
<dt><br>S_IXUSR
<dd>Execute/search permission
</dl>
<br>The following bits define permissions for the group.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXG
<dd>Read, write, execute/search
<dt><br>S_IRGRP
<dd>Read permission
<dt><br>S_IWGRP
<dd>Write permission
<dt><br>S_IXGRP
<dd>Execute/search permission
</dl>
<br>The following bits define permissions for others.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXO
<dd>Read, write, execute/search
<dt><br>S_IROTH
<dd>Read permission
<dt><br>S_IWOTH
<dd>Write permission
<dt><br>S_IXOTH
<dd>Execute/search permission
</dl>
<br>The following bits define miscellaneous permissions used by other implementations.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IREAD
<dd>is equivalent to S_IRUSR (read permission)
<dt><br>S_IWRITE
<dd>is equivalent to S_IWUSR (write permission)
<dt><br>S_IEXEC
<dd>is equivalent to S_IXUSR (execute/search permission)
</dl>
<br>All files are readable with DOS; however, it is a good idea to set<tt> S_IREAD</tt> when read permission is intended for
 the file.
</dl>
<dl>
<dt>Returns:
<dd>If successful,<tt> creat</tt> returns a handle for the file.&nbsp; When an error occurs while opening the file, -1 is returned,
 and <tt> errno</tt> is set to indicate the error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EACCES
<dd>Access denied because<b> path</b> specifies a directory or a volume ID, or a read-only file.
<dt><br>EMFILE
<dd>No more handles available (too many open files).
<dt><br>ENOENT
<dd>The specified<b> path</b> does not exist or<b> path</b> is an empty string.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#chsize">chsize</a>, <a href="#close">close</a>, <a href="#dup">dup</a>, <a href="#dup2">dup2</a>, <a href="#eof">eof</a>,
 <a href="#exec___">exec...</a>, <a href="#fdopen">fdopen</a>, <a href="#filelength">filelength</a>, <a href="#fileno">fileno</a>,
 <a href="#fstat">fstat</a>, <a href="#_grow_handles">_grow_handles</a>, <a href="#isatty">isatty</a>, <a href="#lseek">lseek</a>,
 <a href="#open">open</a>, <a href="#read">read</a>, <a href="#setmode">setmode</a>, <a href="#sopen">sopen</a>, <a href="#stat">stat</a>,
 <a href="#tell">tell</a>, <a href="#write">write</a>, <a href="#umask">umask</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = creat( &quot;file&quot;, S_IWRITE | S_IREAD );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* process file */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>creat is POSIX 1003.1
<br>_creat is not POSIX
<br>_wcreat is not POSIX
</dl>
<dl>
<dt>Systems:
<dd><tt> creat - All, Netware</tt>
<br><tt>_creat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wcreat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="cscanf"> cscanf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>int cscanf( const char *format, ... );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> cscanf</tt> function scans input from the console under control of the argument<b> format</b>.&nbsp; Following the
 format string is a list of addresses to receive values.&nbsp; The<tt> cscanf</tt> function uses the function <tt> getche</tt>
 to read characters from the console.&nbsp; The<b> format</b> string is described under the description of the <tt> scanf</tt>
 function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> cscanf</tt> function returns <tt> EOF</tt> when the scanning is terminated by reaching the end of the input stream.
&nbsp; Otherwise, the number of input arguments for which values were successfully scanned and stored is returned.&nbsp; When
 a file input error occurs, the <tt> errno</tt> global variable may be set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fscanf">fscanf</a>, <a href="#scanf">scanf</a>, <a href="#sscanf">sscanf</a>, <a href="#vcscanf">vcscanf</a>, <a href="#vfscanf">vfscanf</a>,
 <a href="#vscanf">vscanf</a>, <a href="#vsscanf">vsscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>To scan a date in the form &quot;Saturday April 18 1987&quot;:
<br><br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; cscanf( &quot;%s %s %d %d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day, &amp;year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cprintf( &quot;\n%s, %s %d, %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="ctime"> ctime Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>char * ctime( const time_t *timer );</tt>
<br><tt>char *_ctime( const time_t *timer, char *buf );</tt>
<br><tt>wchar_t * _wctime( const time_t *timer );</tt>
<br><tt>wchar_t *__wctime( const time_t *timer, wchar_t *buf );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#ctime_s">ctime_s</a> function which is a safer alternative to<tt> ctime</tt>.
&nbsp; This newer<tt> ctime_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> ctime</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<b> ctime</b> functions convert the calendar time pointed to by<b> timer</b> to local time in the form of a string.&nbsp;
 The<b> ctime</b> function is equivalent to
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; asctime( localtime( timer ) )</tt>
<br><br>The<b> ctime</b> functions convert the time into a string containing exactly 26 characters.&nbsp; This string has
 the form shown in the following example:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Sat Mar 21 15:58:27 1987\n\0</tt>
<br><br>All fields have a constant width.&nbsp; The new-line character<tt> '\n'</tt> and the null character<tt> '\0'</tt>
 occupy the last two positions of the string.
<br><br>The ANSI function<b> ctime</b> places the result string in a static buffer that is re-used each time<b> ctime</b>
 or <tt> asctime</tt> is called.&nbsp; The non-ANSI function <tt> _ctime</tt> places the result string in the buffer pointed
 to by<b> buf</b>.
<br><br>The wide-character function <tt> _wctime</tt> is identical to<b> ctime</b> except that it produces a wide-character
 string (which is twice as long).&nbsp; The wide-character function <tt> __wctime</tt> is identical to <tt> _ctime</tt> except
 that it produces a wide-character string (which is twice as long).
<br><br>Whenever the<b> ctime</b> functions are called, the <tt> tzset</tt> function is also called.
<br><br>The calendar time is usually obtained by using the <tt> time</tt> function.&nbsp; That time is Coordinated Universal
 Time (UTC) (formerly known as Greenwich Mean Time (GMT)).
<br><br>The time set on the computer with the DOS<tt> time</tt> command and the DOS<tt> date</tt> command reflects the local
 time.&nbsp; The environment variable<tt> TZ</tt> is used to establish the time zone to which this local time applies.&nbsp;
 See the section<b> The TZ Environment Variable</b> for a discussion of how to set the time zone.
</dl>
<dl>
<dt>Returns:
<dd>The<b> ctime</b> functions return the pointer to the string containing the local time.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#asctime_s">asctime_s</a>, <a href="#clock">clock</a>, <a href="#ctime_s">ctime_s</a>,
 <a href="#difftime">difftime</a>, <a href="#gmtime">gmtime</a>, <a href="#gmtime_s">gmtime_s</a>, <a href="#localtime">localtime</a>,
 <a href="#localtime_s">localtime_s</a>, <a href="#mktime">mktime</a>, <a href="#strftime">strftime</a>, <a href="#time">time</a>,
 <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t time_of_day;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buf&#91;26&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %s&quot;, _ctime( &amp;time_of_day, buf ) );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>It is now: Fri Dec 25 15:58:42 1987</tt>
</dl>
<dl>
<dt>Classification:
<dd>ctime is ANSI
<br>_ctime is not ANSI
<br>_wctime is not ANSI
<br>__wctime is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> ctime - All, Netware</tt>
<br><tt>_ctime - All</tt>
<br><tt>_wctime - All</tt>
<br><tt>__wctime - All</tt>
</dl>
<h2 id="ctime_s"> ctime_s, _wctime_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>errno_t ctime_s( char * s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t maxsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const time_t * timer);</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>errno_t _wctime_s( wchar_t * s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 maxsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 time_t * timer);</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 ctime_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> s</b> nor<b> timer</b> shall be a null pointer.<b>&nbsp; maxsize</b> shall not be less than 26 and shall not
 be greater than<b> RSIZE_MAX</b>.&nbsp; If there is a runtime-constraint violation,<b> s&#91;0&#93;</b> is set to a null
 character if<b> s</b> is not a null pointer and<b> maxsize</b> is not equal zero and is not greater than<b> RSIZE_MAX</b>.
</dl>
<dl>
<dt>Description:
<dd>The<tt> ctime_s</tt> function converts the calendar time pointed to by<b> timer</b> to local time in the form of a string.
&nbsp; It is equivalent to
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; asctime_s( s, maxsize, localtime_s( timer ) )</tt>
</dl>
<dl>
<dt>Recommended practice:
<dd>
<br>The<b> strftime</b> function allows more flexible formatting and supports locale-specific behavior.&nbsp; If you do not
 require the exact form of the result string produced by the<tt> ctime_s</tt> function, consider using the<b> strftime</b>
 function instead.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ctime_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#asctime_s">asctime_s</a>, <a href="#clock">clock</a>, <a href="#ctime">ctime</a>
 Functions, <a href="#difftime">difftime</a>, <a href="#gmtime">gmtime</a>, <a href="#gmtime_s">gmtime_s</a>, <a href="#localtime">localtime</a>,
 <a href="#localtime_s">localtime_s</a>, <a href="#mktime">mktime</a>, <a href="#strftime">strftime</a>, <a href="#time">time</a>,
 <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t time_of_day;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buf&#91;26&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ctime_s( buf, sizeof( buf ), &amp;time_of_day );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %s&quot;, buf );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>It is now: Mon Jan 30 14:29:55 2006</tt>
</dl>
<dl>
<dt>Classification:
<dd>ctime_s is TR 24731
<br>_wctime_s is not TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> ctime_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Netware</tt>
<br><tt>_wctime_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="cwait"> cwait </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;process.h&gt;</tt>
<br><tt>int cwait( int *status, int process_id, int action );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> cwait</tt> function suspends the calling process until the specified process terminates.
<br>If<b> status</b> is not<tt> NULL,</tt> it points to a word that will be filled in with the termination status word and
 return code of the terminated child process.
<br><br>If the child process terminated normally, then the low order byte of the status word will be set to 0, and the high
 order byte will contain the low order byte of the return code that the child process passed to the <tt> DOSEXIT</tt> function.
&nbsp; The <tt> DOSEXIT</tt> function is called whenever <tt> main</tt> returns, or <tt> exit</tt> or <tt> _exit</tt> are
 explicity called.
<br><br>If the child process did not terminate normally, then the high order byte of the status word will be set to 0, and
 the low order byte will contain one of the following values:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>1
<dd>Hard-error abort
<dt><br>2
<dd>Trap operation
<dt><br>3
<dd>SIGTERM signal not intercepted
</dl>
<dl>
<dt>Note:
<dd>This implementation of the status value follows the OS/2 model and differs from the Microsoft implementation.&nbsp; Under
 Microsoft, the return code is returned in the low order byte and it is not possible to determine whether a return code of
 1, 2, or 3 imply that the process terminated normally.&nbsp; For portability to Microsoft compilers, you should ensure that
 the application that is waited on does not return one of these values.&nbsp; The following shows how to handle the status
 value in a portable manner.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; cwait( &amp;status, process_id, WAIT_CHILD );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__WATCOMC__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; switch( status &amp; 0xff ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 0:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal termination exit code = %d\n&quot;, status &gt;&gt;
 8 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 1:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hard-error abort\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 2:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Trap operation\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 3:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;SIGTERM signal not intercepted\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; default:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Bogus return status\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; #else if defined(_MSC_VER)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; switch( status &amp; 0xff ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 1:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Possible Hard-error abort\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 2:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Possible Trap operation\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 3:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Possible SIGTERM signal not intercepted\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; default:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal termination exit code = %d\n&quot;, status );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; #endif</tt>
</dl>
<br>The<b> process_id</b> argument specifies which process to wait for.&nbsp; Under Win32, any process can wait for any other
 process for which the process id is known.&nbsp; Under OS/2, a process can wait for any of its child processes.&nbsp; For
 example, a process id is returned by certain forms of the <tt> spawn</tt> function that is used to start a child process.
<br><br>The<b> action</b> argument specifies when the parent process resumes execution.&nbsp; This argument is ignored in
 Win32, but is accepted for compatibility with OS/2 (although Microsoft handles the<b> status</b> value differently from OS/2!).
&nbsp; The possible values are:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>WAIT_CHILD
<dd>Wait until the specified child process has ended.
<dt><br>WAIT_GRANDCHILD
<dd>Wait until the specified child process and all of the child processes of that child process have ended.
</dl>
<br>Under Win32, there is no parent-child relationship.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> cwait</tt> function returns the (child's) process id if the (child) process terminated normally.&nbsp; Otherwise,<tt>
 cwait</tt> returns -1 and sets <tt> errno</tt> to one of the following values:
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EINVAL
<dd>Invalid action code
<dt><br>ECHILD
<dd>Invalid process id, or the child does not exist.
<dt><br>EINTR
<dd>The child process terminated abnormally.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#exit">exit</a>, <a href="#_exit">_exit</a>, <a href="#spawn___">spawn...</a>, <a href="#wait">wait</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;process.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; process_id;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; status;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; process_id = spawnl( P_NOWAIT, &quot;child.exe&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;child&quot;, &quot;parm&quot;,
 NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; cwait( &amp;status, process_id, WAIT_CHILD );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="delay"> delay </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>void delay( unsigned milliseconds );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> delay</tt> function suspends execution by the specified number of<b> milliseconds</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> delay</tt> function has no return value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#sleep">sleep</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; sound( 200 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; delay( 500 );&nbsp; /* delay for 1/2 second */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; nosound();</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_dieeetomsbin"> _dieeetomsbin </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>extern int _dieeetomsbin( double *src, double *dest );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dieeetomsbin</tt> function loads the double pointed to by<b> src</b> in IEEE format and converts it to Microsoft
 binary format, storing the result into the double pointed to by<b> dest</b>.
<br>For<tt> _dieeetomsbin</tt>, IEEE Nan's and Infinities will cause overflow.&nbsp; IEEE denormals will be converted if within
 range.&nbsp; Otherwise, they will be converted to 0 in the Microsoft binary format.
<br><br>The range of Microsoft binary format floats is 2.938736e-39 to 1.701412e+38.&nbsp; The range of Microsoft binary format
 doubles is 2.938735877056e-39 to 1.701411834605e+38.
<br><br>Microsoft Binary Format was used by early versions of Microsoft QuickBASIC before coprocessors became standard.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dieeetomsbin</tt> function returns 0 if the conversion was successful.&nbsp; Otherwise, it returns 1 if conversion
 would cause an overflow.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dmsbintoieee">_dmsbintoieee</a>, <a href="#_fieeetomsbin">_fieeetomsbin</a>, <a href="#_fmsbintoieee">_fmsbintoieee</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; float fieee, fmsb;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; double dieee, dmsb;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fieee = 0.5;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; dieee = -2.0;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Convert IEEE format to Microsoft binary format */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _fieeetomsbin( &amp;fieee, &amp;fmsb );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dieeetomsbin( &amp;dieee, &amp;dmsb );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Convert Microsoft binary format back to IEEE format */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _fmsbintoieee( &amp;fmsb, &amp;fieee );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dmsbintoieee( &amp;dmsb, &amp;dieee );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Display results */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;fieee = %f, dieee = %f\n&quot;, fieee, dieee );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>fieee = 0.500000, dieee = -2.000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="difftime"> difftime </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>double difftime( time_t time1, time_t time0 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> difftime</tt> function calculates the difference between the two calendar times:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time1 - time0</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> difftime</tt> function returns the difference between the two times in seconds as a<tt> double.</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#asctime_s">asctime_s</a>, <a href="#clock">clock</a>, <a href="#ctime">ctime</a>
 Functions, <a href="#ctime_s">ctime_s</a>, <a href="#gmtime">gmtime</a>, <a href="#gmtime_s">gmtime_s</a>, <a href="#localtime">localtime</a>,
 <a href="#localtime_s">localtime_s</a>, <a href="#mktime">mktime</a>, <a href="#strftime">strftime</a>, <a href="#time">time</a>,
 <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void compute( void );</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t start_time, end_time;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; start_time = time( NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; compute();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; end_time = time( NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Elapsed time: %f seconds\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; difftime( end_time, start_time ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void compute( void )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i, j;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 20; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( j = 1; j &lt;= 20; j++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%3d &quot;, i * j );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="dirname"> dirname </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;libgen.h&gt;</tt>
<br><tt>char *dirname( char *path );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> dirname</tt> function takes a pointer to a character string that contains a pathname, and returns a pointer to a string
 that is a pathname of the parent directory of that file.&nbsp; Trailing path separators are not considered as part of the
 path.
<br>The<tt> dirname</tt> function may modify the string pointed to by<b> path</b> and may return a pointer to static storage
 that may be overwritten by a subsequent call to<tt> dirname</tt>.
<br><br>The<tt> dirname</tt> function is not re-entrant or thread-safe.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> dirname</tt> function returns a pointer to a string that is the parent directory of<b> path</b>.&nbsp; If<b> path</b>
 is a null pointer or points to an empty string, a pointer to the string &quot;.&quot; is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#basename">basename</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;libgen.h&gt;</tt>
<br><br><tt>int main( void )</tt>
<br><tt>{</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; puts( dirname( &quot;/usr/lib&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; puts( dirname( &quot;/usr/&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; puts( dirname( &quot;usr&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; puts( dirname( &quot;/&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; puts( dirname( &quot;..&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>/usr</tt>
<br><tt>/</tt>
<br><tt>.</tt>
<br><tt>/</tt>
<br><tt>.</tt>
</dl>
<dl>
<dt>Classification:
<dd>POSIX
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_disable"> _disable </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>void _disable( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _disable</tt> function causes interrupts to become disabled.
<br>The<tt> _disable</tt> function would be used in conjunction with the <tt> _enable</tt> function to make sure that a sequence
 of instructions are executed without any intervening interrupts occurring.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _disable</tt> function returns no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_enable">_enable</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>struct list_entry {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct list_entry *next;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; data;</tt>
<br><tt>};</tt>
<br><tt>volatile struct list_entry *ListHead = NULL;</tt>
<br><tt>volatile struct list_entry *ListTail = NULL;</tt>
<br><br><tt>void insert( struct list_entry *new_entry )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* insert new_entry at end of linked list */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; new_entry-&gt;next = NULL;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _disable();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disable interrupts */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( ListTail == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListHead = new_entry;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListTail-&gt;next = new_entry;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ListTail = new_entry;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _enable();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* enable interrupts now */</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct list_entry *p;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 10; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = (struct list_entry *)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; malloc( sizeof( struct list_entry ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( p == NULL ) break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;data = i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert( p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_displaycursor"> _displaycursor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _displaycursor( short mode );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _displaycursor</tt> function is used to establish whether the text cursor is to be displayed when graphics functions
 complete.&nbsp; On entry to a graphics function, the text cursor is turned off.&nbsp; When the function completes, the<b>
 mode</b> setting determines whether the cursor is turned back on.&nbsp; The<b> mode</b> argument can have one of the following
 values:
<dl>
<dt>_GCURSORON
<dd>the cursor will be displayed
<dt><br>_GCURSOROFF
<dd>the cursor will not be displayed
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _displaycursor</tt> function returns the previous setting for<b> mode</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_gettextcursor">_gettextcursor</a>, <a href="#_settextcursor">_settextcursor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 80 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextposition( 2, 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _displaycursor( _GCURSORON );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( &quot;Cursor ON\n\nEnter your name &gt;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; gets( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _displaycursor( _GCURSOROFF );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextposition( 6, 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( &quot;Cursor OFF\n\nEnter your name &gt;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; gets( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>_displaycursor is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="div"> div </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>div_t div( int numer, int denom );</tt>
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int quot;&nbsp;&nbsp;&nbsp;&nbsp; /* quotient */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int rem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* remainder */</tt>
<br><tt>} div_t;</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> div</tt> function calculates the quotient and remainder of the division of the numerator<b> numer</b> by the denominator<b>
 denom</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> div</tt> function returns a structure of type <tt> div_t</tt> which contains the fields <tt> quot</tt> and <tt> rem</tt>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#ldiv">ldiv</a>, <a href="#lldiv">lldiv</a>, <a href="#imaxdiv">imaxdiv</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void print_time( int seconds )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; div_t&nbsp; min_sec;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; min_sec = div( seconds, 60 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;It took %d minutes and %d seconds\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_sec.quot, min_sec.rem );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_time( 130 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>It took 2 minutes and 10 seconds</tt>
</dl>
<dl>
<dt>Classification:
<dd>ISO C90
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_dmsbintoieee"> _dmsbintoieee </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>extern int _dmsbintoieee( double *src, double *dest );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dmsbintoieee</tt> function loads the double pointed to by<b> src</b> in Microsoft binary format and converts it to
 IEEE format, storing the result into the double pointed to by<b> dest</b>.
<br>The range of Microsoft binary format floats is 2.938736e-39 to 1.701412e+38.&nbsp; The range of Microsoft binary format
 doubles is 2.938735877056e-39 to 1.701411834605e+38.
<br><br>Microsoft Binary Format was used by early versions of Microsoft QuickBASIC before coprocessors became standard.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dmsbintoieee</tt> function returns 0 if the conversion was successful.&nbsp; Otherwise, it returns 1 if conversion
 would cause an overflow.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dieeetomsbin">_dieeetomsbin</a>, <a href="#_fieeetomsbin">_fieeetomsbin</a>, <a href="#_fmsbintoieee">_fmsbintoieee</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; float fieee, fmsb;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; double dieee, dmsb;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fieee = 0.5;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; dieee = -2.0;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Convert IEEE format to Microsoft binary format */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _fieeetomsbin( &amp;fieee, &amp;fmsb );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dieeetomsbin( &amp;dieee, &amp;dmsb );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Convert Microsoft binary format back to IEEE format */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _fmsbintoieee( &amp;fmsb, &amp;fieee );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dmsbintoieee( &amp;dmsb, &amp;dieee );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Display results */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;fieee = %f, dieee = %f\n&quot;, fieee, dieee );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>fieee = 0.500000, dieee = -2.000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_dos_allocmem"> _dos_allocmem </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>#if defined(__NT__) || \</tt>
<br><tt>&nbsp; ( defined(__OS2__) &amp;&amp; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defined(__386__) || defined(__PPC__)) )</tt>
<br><tt>unsigned _dos_allocmem( unsigned size,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; void * *segment);</tt>
<br><tt>#else</tt>
<br><tt>unsigned _dos_allocmem( unsigned size,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned *segment);</tt>
<br><tt>#endif</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_allocmem</tt> function uses system call 0x48 to allocate<b> size</b> paragraphs directly from DOS.&nbsp; The
 size of a paragraph is 16 bytes.&nbsp; The allocated memory is always paragraph aligned.&nbsp; The segment descriptor for
 the allocated memory is returned in the word pointed to by<b> segment</b>.&nbsp; If the allocation request fails, the maximum
 number of paragraphs that can be allocated is returned in this word instead.
<br>For 32-bit DOS applications, it is recommended that the corresponding DPMI services be used.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_allocmem</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt>
 errno</tt> accordingly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#alloca">alloca</a>, <a href="#calloc">calloc</a>, <a href="#_dos_freemem">_dos_freemem</a>, <a href="#_dos_setblock">_dos_setblock</a>,
 <a href="#halloc">halloc</a>, <a href="#malloc">malloc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>#if defined(__NT__) || \</tt>
<br><tt>&nbsp; ( defined(__OS2__) &amp;&amp; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defined(__386__) || defined(__PPC__)) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; void *segment;</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned segment;</tt>
<br><tt>#endif</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Try to allocate 100 paragraphs, then free them */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( _dos_allocmem( 100, &amp;segment ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_allocmem failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Only %u paragraphs available\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_allocmem succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_freemem( segment ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_freemem failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_freemem succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_close"> _dos_close </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_close( int handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_close</tt> function uses system call 0x3E to close the file indicated by<b> handle</b>.&nbsp; The value for<b>
 handle</b> is the one returned by a function call that created or last opened the file.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_close</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt> errno</tt>
 accordingly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#creat">creat</a>, <a href="#_dos_creat">_dos_creat</a>, <a href="#_dos_creatnew">_dos_creatnew</a>, <a href="#_dos_open">_dos_open</a>,
 <a href="#dup">dup</a>, <a href="#fclose">fclose</a>, <a href="#open">open</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Try to open &quot;stdio.h&quot; and then close it */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;stdio.h&quot;, O_RDONLY, &amp;handle ) != 0 ){</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Open succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_close( handle ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Close failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Close succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_commit"> _dos_commit </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_commit( int handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_commit</tt> function uses system call 0x68 to flush to disk the DOS buffers associated with the file indicated
 by<b> handle</b>.&nbsp; It also forces an update on the corresponding disk directory and the file allocation table.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_commit</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt> errno</tt>
 accordingly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_close">_dos_close</a>, <a href="#_dos_creat">_dos_creat</a>, <a href="#_dos_open">_dos_open</a>, <a href="#_dos_write">_dos_write</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;file&quot;, O_RDONLY, handle ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_commit( handle ) == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Commit succeeded.\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Commit succeeded.</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_creat"> _dos_creat </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_creat( const char *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; unsigned attribute,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; int *handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_creat</tt> function uses system call 0x3C to create a new file named<b> path</b>, with the access attributes
 specified by<b> attribute</b>.&nbsp; The handle for the new file is returned in the word pointed to by<b> handle</b>.&nbsp;
 If the file already exists, the contents will be erased, and the attributes of the file will remain unchanged.&nbsp; The
 possible values for<b> attribute</b> are:
<dl>
<dt>Attribute&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_A_NORMAL
<dd>Indicates a normal file.&nbsp; File can be read or written without any restrictions.
<dt><br>_A_RDONLY
<dd>Indicates a read-only file.&nbsp; File cannot be opened for &quot;write&quot;.
<dt><br>_A_HIDDEN
<dd>Indicates a hidden file.&nbsp; This file will not show up in a normal directory search.
<dt><br>_A_SYSTEM
<dd>Indicates a system file.&nbsp; This file will not show up in a normal directory search.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_creat</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt> errno</tt>
 accordingly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#creat">creat</a>, <a href="#_dos_creatnew">_dos_creatnew</a>, <a href="#_dos_open">_dos_open</a>, <a href="#_dos_open">_dos_open</a>,
 <a href="#open">open</a>, <a href="#fdopen">fdopen</a>, <a href="#fopen">fopen</a>, <a href="#freopen">freopen</a>, <a href="#_fsopen">_fsopen</a>,
 <a href="#_grow_handles">_grow_handles</a>, <a href="#_hdopen">_hdopen</a>, <a href="#open">open</a>, <a href="#_open_osfhandle">_open_osfhandle</a>,
 <a href="#_popen">_popen</a>, <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( _dos_creat( &quot;file&quot;, _A_NORMAL, &amp;handle ) != 0 ){</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to create file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Create succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_creatnew"> _dos_creatnew </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_creatnew( const char *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned attribute,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; int *handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_creatnew</tt> function uses system call 0x5B to create a new file named<b> path</b>, with the access attributes
 specified by<b> attribute</b>.&nbsp; The handle for the new file is returned in the word pointed to by<b> handle</b>.&nbsp;
 If the file already exists, the create will fail.&nbsp; The possible values for<b> attribute</b> are:
<dl>
<dt>Attribute&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_A_NORMAL
<dd>Indicates a normal file.&nbsp; File can be read or written without any restrictions.
<dt><br>_A_RDONLY
<dd>Indicates a read-only file.&nbsp; File cannot be opened for &quot;write&quot;.
<dt><br>_A_HIDDEN
<dd>Indicates a hidden file.&nbsp; This file will not show up in a normal directory search.
<dt><br>_A_SYSTEM
<dd>Indicates a system file.&nbsp; This file will not show up in a normal directory search.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_creatnew</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt>
 errno</tt>.&nbsp; Possible values and their interpretations:
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EACCES
<dd>Access denied because the directory is full, or the file exists and cannot be overwritten.
<dt><br>EEXIST
<dd>File already exists
<dt><br>EMFILE
<dd>No more handles available (i.e., too many open files)
<dt><br>ENOENT
<dd>Path or file not found
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#creat">creat</a>, <a href="#_dos_creat">_dos_creat</a>, <a href="#_dos_open">_dos_open</a>, <a href="#_dos_open">_dos_open</a>,
 <a href="#open">open</a>, <a href="#fdopen">fdopen</a>, <a href="#fopen">fopen</a>, <a href="#freopen">freopen</a>, <a href="#_fsopen">_fsopen</a>,
 <a href="#_grow_handles">_grow_handles</a>, <a href="#_hdopen">_hdopen</a>, <a href="#open">open</a>, <a href="#_open_osfhandle">_open_osfhandle</a>,
 <a href="#_popen">_popen</a>, <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle1, handle2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( _dos_creat( &quot;file&quot;, _A_NORMAL, &amp;handle1 ) ){</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to create file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Create succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_creatnew( &quot;file&quot;, _A_NORMAL, &amp;handle2 ) ){</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to create new file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="dosexterr"> dosexterr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>int dosexterr( struct DOSERROR *err_info );</tt>
<br><br><tt>struct _DOSERROR {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int exterror;&nbsp;&nbsp; /* contents of AX register */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char errclass;&nbsp; /* contents of BH register */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char action;&nbsp;&nbsp;&nbsp; /* contents of BL register */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char locus;&nbsp;&nbsp;&nbsp;&nbsp; /* contents of CH register */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> dosexterr</tt> function extracts extended error information following a failed DOS function.&nbsp; This information
 is placed in the structure located by<b> err_info</b>.&nbsp; This function is only useful with DOS version 3.0 or later.
<br>You should consult the technical documentation for the DOS system on your computer for an interpretation of the error
 information.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> dosexterr</tt> function returns an unpredictable result when the preceding DOS call did not result in an error.&nbsp;
 Otherwise,<tt> dosexterr</tt> returns the number of the extended error.
</dl>
<dl>
<dt>See Also:
<dd><a href="#perror">perror</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><br><tt>struct _DOSERROR dos_err;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Try to open &quot;stdio.h&quot; and then close it */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;stdio.h&quot;, O_RDONLY, &amp;handle ) != 0 ){</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dosexterr( &amp;dos_err );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;exterror (AX) = %d\n&quot;, dos_err.exterror );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;errclass (BH) = %d\n&quot;, dos_err.errclass );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;action&nbsp;&nbsp; (BL) = %d\n&quot;, dos_err.action );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;locus&nbsp;&nbsp;&nbsp; (CH) = %d\n&quot;, dos_err.locus );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Open succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_close( handle ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Close failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Close succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Unable to open file</tt>
<br><tt>exterror (AX) = 2</tt>
<br><tt>errclass (BH) = 8</tt>
<br><tt>action&nbsp;&nbsp; (BL) = 3</tt>
<br><tt>locus&nbsp;&nbsp;&nbsp; (CH) = 2</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, DOS/PM
</dl>
<h2 id="_dos_find___"> _dos_find...&nbsp; Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_findfirst( const char *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned attributes,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct find_t *buffer );</tt>
<br><tt>unsigned _dos_findnext(&nbsp; struct find_t *buffer );</tt>
<br><tt>unsigned _dos_findclose( struct find_t *buffer );</tt>
<br><br><tt>struct find_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char reserved&#91;21&#93;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* reserved for use by DOS&nbsp;&nbsp;
 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char attrib;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* attribute byte
 for file&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short wr_time; /* time of last write to file*/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short wr_date; /* date of last write to file*/</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned long&nbsp; size;&nbsp;&nbsp;&nbsp; /* length of file in bytes&nbsp;&nbsp; */</tt>
<br><tt>#if defined(__OS2__) || defined(__NT__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char name&#91;256&#93;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* null-terminated filename
&nbsp; */</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char name&#91;13&#93;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* null-terminated
 filename&nbsp; */</tt>
<br><tt>#endif</tt>
<br><tt>};</tt>
<br><br><tt>unsigned _wdos_findfirst( const wchar_t *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned attributes,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wfind_t *buffer );</tt>
<br><tt>unsigned _wdos_findnext( struct _wfind_t *buffer );</tt>
<br><tt>unsigned _wdos_findclose( struct _wfind_t *buffer );</tt>
<br><br><tt>struct _wfind_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char reserved&#91;21&#93;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* reserved for use by DOS&nbsp;&nbsp;
&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char attrib;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* attribute byte
 for file&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short wr_time; /* time of last write to file */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short wr_date; /* date of last write to file */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned long&nbsp; size;&nbsp;&nbsp;&nbsp; /* length of file in bytes&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>#if defined(__OS2__) || defined(__NT__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wchar_t name&#91;256&#93;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* null-terminated filename&nbsp;&nbsp;
 */</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wchar_t name&#91;13&#93;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* null-terminated filename&nbsp;
&nbsp; */</tt>
<br><tt>#endif</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The <tt> _dos_findfirst</tt> function uses system call 0x4E to return information on the first file whose name and attributes
 match the<b> path</b> and<b> attributes</b> arguments.&nbsp; The information is returned in a <tt> find_t</tt> structure
 pointed to by<b> buffer</b>.&nbsp; The<b> path</b> argument may contain wildcard characters ('?' and '*').&nbsp; The<b> attributes</b>
 argument may be any combination of the following constants:
<dl>
<dt>Attribute&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_A_NORMAL
<dd>Indicates a normal file.&nbsp; File can be read or written without any restrictions.
<dt><br>_A_RDONLY
<dd>Indicates a read-only file.&nbsp; File cannot be opened for &quot;write&quot;.
<dt><br>_A_HIDDEN
<dd>Indicates a hidden file.&nbsp; This file will not show up in a normal directory search.
<dt><br>_A_SYSTEM
<dd>Indicates a system file.&nbsp; This file will not show up in a normal directory search.
<dt><br>_A_VOLID
<dd>Indicates a volume-ID.
<dt><br>_A_SUBDIR
<dd>Indicates a sub-directory.
<dt><br>_A_ARCH
<dd>This is the archive flag.&nbsp; It is set whenever the file is modified, and is cleared by the MS-DOS BACKUP command and other
 backup utility programs.
</dl>
<br>The<b> attributes</b> argument is interpreted by DOS as follows:
<ol>
<li>If <tt> _A_NORMAL</tt> is specified, then normal files are included in the search.
<li>If any of <tt> _A_HIDDEN</tt>, <tt> _A_SYSTEM</tt>, <tt> _A_SUBDIR</tt> are specified, then normal files and the specified
 type of files are included in the search.
<li>If <tt> _A_VOLID</tt> is specified, then volume-ID's are also included in the search.&nbsp; Note:&nbsp; The <tt> _A_VOLID</tt>
 attribute is not supported on systems other than DOS (e.g.&nbsp; Win32, OS/2).
<li><tt> _A_RDONLY</tt> and <tt> _A_ARCH</tt> are ignored by this function.
</ol>
<br>The format of the <tt> wr_time</tt> field is described by the following structure (this structure is not defined in any
 Watcom header file).
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; twosecs : 5;&nbsp;&nbsp;&nbsp; /* seconds / 2 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; minutes : 6;&nbsp;&nbsp;&nbsp; /* minutes (0,59) */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; hours&nbsp;&nbsp; : 5;&nbsp;&nbsp;&nbsp; /* hours (0,23) */</tt>
<br><tt>} ftime_t;</tt>
<br>The format of the <tt> wr_date</tt> field is described by the following structure (this structure is not defined in any
 Watcom header file).
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; day&nbsp;&nbsp;&nbsp;&nbsp; : 5;&nbsp;&nbsp;&nbsp; /* day (1,31) */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; month&nbsp;&nbsp; : 4;&nbsp;&nbsp;&nbsp; /* month (1,12) */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; year&nbsp;&nbsp;&nbsp; : 7;&nbsp;&nbsp;&nbsp; /* 0 is 1980 */</tt>
<br><tt>} fdate_t;</tt>
<br>The <tt> _dos_findnext</tt> function uses system call 0x4F to return information on the next file whose name and attributes
 match the pattern supplied to the <tt> _dos_findfirst</tt> function.
<br><br>On some systems (e.g.&nbsp; Win32, OS/2), you must call <tt> _dos_findclose</tt> to indicate that you are done matching
 files.&nbsp; This function deallocates any resources that were allocated by the <tt> _dos_findfirst</tt> function.&nbsp;
 The wide-character <tt> _wdos_findclose</tt>, <tt> _wdos_findfirst</tt> and <tt> _wdos_findnext</tt> functions are similar
 to their counterparts but operate on wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The <tt> _dos_find...</tt>&nbsp; functions return zero if successful.&nbsp; Otherwise, the <tt> _dos_findfirst</tt> and <tt>
 _dos_findnext</tt> functions return an OS error code and set <tt> errno</tt> accordingly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#opendir">opendir</a>, <a href="#readdir">readdir</a>, <a href="#closedir">closedir</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct find_t&nbsp;&nbsp; fileinfo;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; /* return code */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Display name and size of &quot;*.c&quot; files */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = _dos_findfirst( &quot;*.c&quot;, _A_NORMAL, &amp;fileinfo );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( rc == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%14s %10ld\n&quot;, fileinfo.name,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileinfo.size );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = _dos_findnext( &amp;fileinfo );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #if defined(__OS2__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_findclose( &amp;fileinfo );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #endif</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd><tt> _dos_findclose - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM</tt>
<br><tt>_dos_findfirst - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM</tt>
<br><tt>_dos_findnext - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM</tt>
<br><tt>_wdos_findclose - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wdos_findfirst - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wdos_findnext - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_dos_freemem"> _dos_freemem </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>#if defined(__NT__) || \</tt>
<br><tt>&nbsp; ( defined(__OS2__) &amp;&amp; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defined(__386__) || defined(__PPC__)) )</tt>
<br><tt>unsigned _dos_freemem( void *&nbsp;&nbsp; segment );</tt>
<br><tt>#else</tt>
<br><tt>unsigned _dos_freemem( unsigned segment );</tt>
<br><tt>#endif</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_freemem</tt> function uses system call 0x49 to release memory that was previously allocated by <tt> _dos_allocmem</tt>.
&nbsp; The value contained in<b> segment</b> is the one returned by a previous call to <tt> _dos_allocmem</tt>.
<br>For 32-bit DOS applications, it is recommended that the corresponding DPMI services be used.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_freemem</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt>
 errno</tt> accordingly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_allocmem">_dos_allocmem</a>, <a href="#_dos_setblock">_dos_setblock</a>, <a href="#free">free</a>, <a href="#hfree">hfree</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>#if defined(__NT__) || \</tt>
<br><tt>&nbsp; ( defined(__OS2__) &amp;&amp; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defined(__386__) || defined(__PPC__)) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; void *segment;</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned segment;</tt>
<br><tt>#endif</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Try to allocate 100 paragraphs, then free them */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( _dos_allocmem( 100, &amp;segment ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_allocmem failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Only %u paragraphs available\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segment );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_allocmem succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_freemem( segment ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_freemem failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_freemem succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_getdate"> _dos_getdate </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>void _dos_getdate( struct dosdate_t *date );</tt>
<br><br><tt>struct dosdate_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char day;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 1-31 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char month;&nbsp;&nbsp;&nbsp; /* 1-12 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short year;&nbsp;&nbsp;&nbsp; /* 1980-2099 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char dayofweek;/* 0-6 (0=Sunday) */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_getdate</tt> function uses system call 0x2A to get the current system date.&nbsp; The date information is returned
 in a <tt> dosdate_t</tt> structure pointed to by<b> date</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_getdate</tt> function has no return value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_gettime">_dos_gettime</a>, <a href="#_dos_setdate">_dos_setdate</a>, <a href="#_dos_settime">_dos_settime</a>,
 <a href="#gmtime">gmtime</a>, <a href="#localtime">localtime</a>, <a href="#mktime">mktime</a>, <a href="#time">time</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct dosdate_t date;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct dostime_t time;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Get and display the current date and time */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_getdate( &amp;date );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_gettime( &amp;time );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The date (MM-DD-YYYY) is: %d-%d-%d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date.month,
 date.day, date.year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The time (HH:MM:SS) is: %.2d:%.2d:%.2d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time.hour,
 time.minute, time.second );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>The date (MM-DD-YYYY) is: 12-25-1989</tt>
<br><tt>The time (HH:MM:SS) is: 14:23:57</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_getdiskfree"> _dos_getdiskfree </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_getdiskfree( unsigned drive,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; struct diskfree_t *diskspace );</tt>
<br><tt>struct diskfree_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short total_clusters;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short avail_clusters;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short sectors_per_cluster;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short bytes_per_sector;</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_getdiskfree</tt> function uses system call 0x36 to obtain useful information on the disk drive specified by<b>
 drive</b>.&nbsp; Specify 0 for the default drive, 1 for drive A, 2 for drive B, etc.&nbsp; The information about the drive
 is returned in the structure <tt> diskfree_t</tt> pointed to by<b> diskspace</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_getdiskfree</tt> function returns zero if successful.&nbsp; Otherwise, it returns a non-zero value and sets <tt>
 errno</tt> to <tt> EINVAL</tt> indicating an invalid drive was specified.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_getdrive">_dos_getdrive</a>, <a href="#_dos_setdrive">_dos_setdrive</a>, <a href="#_getdiskfree">_getdiskfree</a>,
 <a href="#_getdrive">_getdrive</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct diskfree_t disk_data;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* get information about drive 3 (the C drive) */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( _dos_getdiskfree( 3, &amp;disk_data ) == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;total clusters: %u\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; disk_data.total_clusters );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;available clusters: %u\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; disk_data.avail_clusters );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;sectors/cluster: %u\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; disk_data.sectors_per_cluster );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;bytes per sector: %u\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; disk_data.bytes_per_sector );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Invalid drive specified\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>total clusters: 16335</tt>
<br><tt>available clusters: 510</tt>
<br><tt>sectors/cluster: 4</tt>
<br><tt>bytes per sector: 512</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_getdrive"> _dos_getdrive </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>void _dos_getdrive( unsigned *drive );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_getdrive</tt> function uses system call 0x19 to get the current disk drive number.&nbsp; The current disk drive
 number is returned in the word pointed to by<b> drive</b>.&nbsp; A value of 1 is drive A, 2 is drive B, 3 is drive C, etc.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_getdrive</tt> function has no return value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_getdiskfree">_dos_getdiskfree</a>, <a href="#_dos_setdrive">_dos_setdrive</a>, <a href="#_getdiskfree">_getdiskfree</a>,
 <a href="#_getdrive">_getdrive</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned drive;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _dos_getdrive( &amp;drive );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The current drive is %c\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'A' + drive - 1 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>The current drive is C</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_getfileattr"> _dos_getfileattr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_getfileattr( const char *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned *attributes );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_getfileattr</tt> function uses system call 0x43 to get the current attributes of the file or directory that<b>
 path</b> points to.&nbsp; The possible attributes are:
<dl>
<dt>Attribute&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_A_NORMAL
<dd>Indicates a normal file.&nbsp; File can be read or written without any restrictions.
<dt><br>_A_RDONLY
<dd>Indicates a read-only file.&nbsp; File cannot be opened for &quot;write&quot;.
<dt><br>_A_HIDDEN
<dd>Indicates a hidden file.&nbsp; This file will not show up in a normal directory search.
<dt><br>_A_SYSTEM
<dd>Indicates a system file.&nbsp; This file will not show up in a normal directory search.
<dt><br>_A_VOLID
<dd>Indicates a volume-ID.
<dt><br>_A_SUBDIR
<dd>Indicates a sub-directory.
<dt><br>_A_ARCH
<dd>This is the archive flag.&nbsp; It is set whenever the file is modified, and is cleared by the MS-DOS BACKUP command and other
 backup utility programs.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_getfileattr</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt>
 errno</tt> accordingly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_setfileattr">_dos_setfileattr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>print_attribute()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned attribute;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _dos_getfileattr( &quot;file&quot;, &amp;attribute );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;File attribute is %d\n&quot;, attribute );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( attribute &amp; _A_RDONLY ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;This is a read-only file.\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;This is not a read-only file.\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( _dos_creat( &quot;file&quot;, _A_RDONLY, &amp;handle ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error creating file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_attribute();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_setfileattr( &quot;file&quot;, _A_NORMAL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_attribute();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_close( handle );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_getftime"> _dos_getftime </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_getftime( int handle,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned *date,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned *time );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_getftime</tt> function uses system call 0x57 to get the date and time that the file associated with<b> handle</b>
 was last modified.&nbsp; The date consists of the year, month and day packed into 16 bits as follows:
<dl>
<dt>Bits&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>bits 0-4
<dd>Day (1-31)
<dt><br>bits 5-8
<dd>Month (1-12)
<dt><br>bits 9-15
<dd>Year (0-119 representing 1980-2099)
</dl>
<br>The time consists of the hour, minute and seconds/2 packed into 16 bits as follows:
<dl>
<dt>Bits&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>bits 0-4
<dd>Seconds/2 (0-29)
<dt><br>bits 5-10
<dd>Minutes (0-59)
<dt><br>bits 11-15
<dd>Hours (0-23)
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_getftime</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt>
 errno</tt> accordingly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_setftime">_dos_setftime</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><br><tt>#define YEAR(t)&nbsp;&nbsp; (((t &amp; 0xFE00) &gt;&gt; 9) + 1980)</tt>
<br><tt>#define MONTH(t)&nbsp; ((t &amp; 0x01E0) &gt;&gt; 5)</tt>
<br><tt>#define DAY(t)&nbsp;&nbsp;&nbsp; (t &amp; 0x001F)</tt>
<br><tt>#define HOUR(t)&nbsp;&nbsp; ((t &amp; 0xF800) &gt;&gt; 11)</tt>
<br><tt>#define MINUTE(t) ((t &amp; 0x07E0) &gt;&gt; 5)</tt>
<br><tt>#define SECOND(t) ((t &amp; 0x001F) &lt;&lt; 1)</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned date, time;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;file&quot;, O_RDONLY, &amp;handle ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Open succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_getftime( handle, &amp;date, &amp;time );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;The file was last modified on %d/%d/%d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MONTH(date), DAY(date),
 YEAR(date) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; at %.2d:%.2d:%.2d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HOUR(time), MINUTE(time),
 SECOND(time) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Open succeeded</tt>
<br><tt>The file was last modified on 12/29/1989 at 14:32:46</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_gettime"> _dos_gettime </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>void _dos_gettime( struct dostime_t *time );</tt>
<br><br><tt>struct dostime_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char hour;&nbsp;&nbsp;&nbsp;&nbsp; /* 0-23 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char minute;&nbsp;&nbsp; /* 0-59 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char second;&nbsp;&nbsp; /* 0-59 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char hsecond;&nbsp; /* 1/100 second; 0-99 */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_gettime</tt> function uses system call 0x2C to get the current system time.&nbsp; The time information is returned
 in a <tt> dostime_t</tt> structure pointed to by<b> time</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_gettime</tt> function has no return value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_getdate">_dos_getdate</a>, <a href="#_dos_setdate">_dos_setdate</a>, <a href="#_dos_settime">_dos_settime</a>,
 <a href="#gmtime">gmtime</a>, <a href="#localtime">localtime</a>, <a href="#mktime">mktime</a>, <a href="#time">time</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct dosdate_t date;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct dostime_t time;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Get and display the current date and time */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_getdate( &amp;date );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_gettime( &amp;time );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The date (MM-DD-YYYY) is: %d-%d-%d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date.month, date.day, date.year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The time (HH:MM:SS) is: %.2d:%.2d:%.2d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time.hour, time.minute, time.second );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>The date (MM-DD-YYYY) is: 12-25-1989</tt>
<br><tt>The time (HH:MM:SS) is: 14:23:57</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_getvect"> _dos_getvect </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>void (__interrupt __far *_dos_getvect(unsigned intnum))();</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_getvect</tt> function gets the current value of interrupt vector number<b> intnum</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_getvect</tt> function returns a far pointer to the current interrupt handler for interrupt number<b> intnum</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_chain_intr">_chain_intr</a>, <a href="#_dos_keep">_dos_keep</a>, <a href="#_dos_setvect">_dos_setvect</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>volatile int clock_ticks;</tt>
<br><tt>void (__interrupt __far *prev_int_1c)();</tt>
<br><tt>#define BLIP_COUNT&nbsp; (5*18)&nbsp; /* 5 seconds */</tt>
<br><br><tt>void __interrupt __far timer_rtn()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ++clock_ticks;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _chain_intr( prev_int_1c );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>int delays = 0;</tt>
<br><br><tt>int compile_a_line()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( delays &gt; 15 ) return( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; delay( 1000 );&nbsp; /* delay for 1 second */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Delayed for 1 second\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; delays++;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 1 );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; prev_int_1c = _dos_getvect( 0x1c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_setvect( 0x1c, timer_rtn );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( compile_a_line() ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( clock_ticks &gt;= BLIP_COUNT ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar( '.' );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clock_ticks -= BLIP_COUNT;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_setvect( 0x1c, prev_int_1c );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, DOS/PM
</dl>
<h2 id="_dos_keep"> _dos_keep </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>void _dos_keep( unsigned retcode, unsigned memsize );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_keep</tt> function is used to install terminate-and-stay-resident programs (&quot;TSR's&quot;) in memory.&nbsp;
 The amount of memory kept for the program is<b> memsize</b> paragraphs (a paragraph is 16 bytes) from the Program Segment
 Prefix which is stored in the variable <tt> _psp</tt>.&nbsp; The value of<b> retcode</b> is returned to the parent process.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_keep</tt> function does not return.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_chain_intr">_chain_intr</a>, <a href="#_dos_getvect">_dos_getvect</a>, <a href="#_dos_setvect">_dos_setvect</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void permanent()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void transient()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* initialize our TSR */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; transient();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /*</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; now terminate and keep resident</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the non-transient portion</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NB: following calculation only works in .COM files</tt>
<br><tt>&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_keep( 0, (FP_OFF( transient ) + 15) &gt;&gt; 4 );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<h2 id="_dos_open"> _dos_open </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;share.h&gt;</tt>
<br><tt>unsigned _dos_open( const char *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 unsigned mode,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 int *handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_open</tt> function uses system call 0x3D to open the file specified by<b> path</b>, which must be an existing
 file.&nbsp; The<b> mode</b> argument specifies the file's access, sharing and inheritance permissions.&nbsp; The access mode
 must be one of:
<dl>
<dt>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>O_RDONLY
<dd>Read only
<dt><br>O_WRONLY
<dd>Write only
<dt><br>O_RDWR
<dd>Both read and write
</dl>
<br>The sharing permissions, if specified, must be one of:
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>SH_COMPAT
<dd>Set compatibility mode.
<dt><br>SH_DENYRW
<dd>Prevent read or write access to the file.
<dt><br>SH_DENYWR
<dd>Prevent write access of the file.
<dt><br>SH_DENYRD
<dd>Prevent read access to the file.
<dt><br>SH_DENYNO
<dd>Permit both read and write access to the file.
</dl>
<br>The inheritance permission, if specified, is:
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>O_NOINHERIT
<dd>File is not inherited by a child process
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_open</tt> function returns zero if successful.&nbsp; Otherwise, it returns an MS-DOS error code and sets <tt>
 errno</tt> to one of the following values:
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EACCES
<dd>Access denied because<b> path</b> specifies a directory or a volume ID, or opening a read-only file for write access
<dt><br>EINVAL
<dd>A sharing mode was specified when file sharing is not installed, or access-mode value is invalid
<dt><br>EMFILE
<dd>No more handles available, (too many open files)
<dt><br>ENOENT
<dd>Path or file not found
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_close">_dos_close</a>, <a href="#_dos_creat">_dos_creat</a>, <a href="#_dos_creatnew">_dos_creatnew</a>, <a href="#_dos_read">_dos_read</a>,
 <a href="#_dos_write">_dos_write</a>, <a href="#fdopen">fdopen</a>, <a href="#fopen">fopen</a>, <a href="#freopen">freopen</a>,
 <a href="#_fsopen">_fsopen</a>, <a href="#_grow_handles">_grow_handles</a>, <a href="#_hdopen">_hdopen</a>, <a href="#open">open</a>,
 <a href="#_open_osfhandle">_open_osfhandle</a>, <a href="#_popen">_popen</a>, <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;share.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;file&quot;, O_RDONLY, &amp;handle ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Open succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_read"> _dos_read </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_read( int handle, void __far *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 unsigned count, unsigned *bytes );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_read</tt> function uses system call 0x3F to read<b> count</b> bytes of data from the file specified by<b> handle</b>
 into the buffer pointed to by<b> buffer</b>.&nbsp; The number of bytes successfully read will be stored in the unsigned integer
 pointed to by<b> bytes</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_read</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt> errno</tt>
 accordingly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_close">_dos_close</a>, <a href="#_dos_open">_dos_open</a>, <a href="#_dos_write">_dos_write</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned len_read;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;file&quot;, O_RDONLY, &amp;handle ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Open succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_read( handle, buffer, 80, &amp;len_read );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_setblock"> _dos_setblock </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_setblock( unsigned size,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned segment,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned *maxsize );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_setblock</tt> function uses system call 0x4A to change the size of<b> segment</b>, which was previously allocated
 by <tt> _dos_allocmem</tt>, to<b> size</b> paragraphs.&nbsp; If the request fails, the maximum number of paragraphs that
 this memory block can be changed to is returned in the word pointed to by<b> maxsize</b>.
<br>For 32-bit DOS applications, it is recommended that the corresponding DPMI services be used.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_setblock</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt>
 errno</tt> to <tt> ENOMEM</tt> indicating a bad segment value, insufficient memory or corrupted memory.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_allocmem">_dos_allocmem</a>, <a href="#_dos_freemem">_dos_freemem</a>, <a href="#realloc">realloc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>#if defined(__NT__) || \</tt>
<br><tt>&nbsp; ( defined(__OS2__) &amp;&amp; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (defined(__386__) || defined(__PPC__)) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; void *segment;</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned segment;</tt>
<br><tt>#endif</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Try to allocate 100 paragraphs, then free them */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( _dos_allocmem( 100, &amp;segment ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_allocmem failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Only %u paragraphs available\n&quot;, segment);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_allocmem succeeded\n&quot; );</tt>
<br><br><tt>#if defined(__DOS__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { unsigned maxsize = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Try to increase it to 200 paragraphs */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_setblock( 200, segment, &amp;maxsize ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_setblock failed: max=%u, err=%s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 maxsize, strerror( errno) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_setblock succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>#endif</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _dos_freemem( segment ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_freemem failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;_dos_freemem succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, DOS/PM
</dl>
<h2 id="_dos_setdate"> _dos_setdate </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_setdate( struct dosdate_t *date );</tt>
<br><br><tt>struct dosdate_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char day;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* 1-31 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char month;&nbsp;&nbsp;&nbsp; /* 1-12 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short year;&nbsp;&nbsp;&nbsp; /* 1980-2099 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char dayofweek;/* 0-6 (0=Sunday) */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_setdate</tt> function uses system call 0x2B to set the current system date.&nbsp; The date information is passed
 in a <tt> dosdate_t</tt> structure pointed to by<b> date</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_setdate</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt>
 errno</tt> accordingly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_getdate">_dos_getdate</a>, <a href="#_dos_gettime">_dos_gettime</a>, <a href="#_dos_settime">_dos_settime</a>,
 <a href="#gmtime">gmtime</a>, <a href="#localtime">localtime</a>, <a href="#mktime">mktime</a>, <a href="#time">time</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct dosdate_t date;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct dostime_t time;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Get and display the current date and time */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_getdate( &amp;date );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_gettime( &amp;time );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The date (MM-DD-YYYY) is: %d-%d-%d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date.month, date.day, date.year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The time (HH:MM:SS) is: %.2d:%.2d:%.2d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time.hour, time.minute, time.second );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Change it to the turn of the century */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; date.year = 1999;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; date.month = 12;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; date.day = 31;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time.hour = 23;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time.minute = 59;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_setdate( &amp;date );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_settime( &amp;time );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;New date (MM-DD-YYYY) is: %d-%d-%d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date.month, date.day, date.year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;New time (HH:MM:SS) is: %.2d:%.2d:%.2d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time.hour, time.minute, time.second );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>The date (MM-DD-YYYY) is: 12-25-1989</tt>
<br><tt>The time (HH:MM:SS) is: 14:23:15</tt>
<br><tt>New date (MM-DD-YYYY) is: 12-31-1999</tt>
<br><tt>New time (HH:MM:SS) is: 23:59:16</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_setdrive"> _dos_setdrive </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>void _dos_setdrive( unsigned drive, unsigned *total );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_setdrive</tt> function uses system call 0x0E to set the current default disk drive to be the drive specified
 by<b> drive</b>, where 1 = drive A, 2 = drive B, etc.&nbsp; The total number of disk drives is returned in the word pointed
 to by<b> total</b>.&nbsp; For DOS versions 3.0 or later, the minimum number of drives returned is 5.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_setdrive</tt> function has no return value.&nbsp; If an invalid drive number is specified, the function fails
 with no error indication.&nbsp; You must use the <tt> _dos_getdrive</tt> function to check that the desired drive has been
 set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_getdiskfree">_dos_getdiskfree</a>, <a href="#_dos_getdrive">_dos_getdrive</a>, <a href="#_getdiskfree">_getdiskfree</a>,
 <a href="#_getdrive">_getdrive</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned drive1, drive2, total;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _dos_getdrive( &amp;drive1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Current drive is %c\n&quot;, 'A' + drive1 - 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* try to change to drive C */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_setdrive( 3, &amp;total );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_getdrive( &amp;drive2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Current drive is %c\n&quot;, 'A' + drive2 - 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* go back to original drive */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_setdrive( drive1, &amp;total );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_getdrive( &amp;drive1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Current drive is %c\n&quot;, 'A' + drive1 - 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Total number of drives is %u\n&quot;, total );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Current drive is D</tt>
<br><tt>Current drive is C</tt>
<br><tt>Total number of drives is 6</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_setfileattr"> _dos_setfileattr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_setfileattr( const char *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned attributes );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_setfileattr</tt> function uses system call 0x43 to set the attributes of the file or directory that<b> path</b>
 points to.&nbsp; The possible attributes are:
<dl>
<dt>Attribute&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_A_NORMAL
<dd>Indicates a normal file.&nbsp; File can be read or written without any restrictions.
<dt><br>_A_RDONLY
<dd>Indicates a read-only file.&nbsp; File cannot be opened for &quot;write&quot;.
<dt><br>_A_HIDDEN
<dd>Indicates a hidden file.&nbsp; This file will not show up in a normal directory search.
<dt><br>_A_SYSTEM
<dd>Indicates a system file.&nbsp; This file will not show up in a normal directory search.
<dt><br>_A_VOLID
<dd>Indicates a volume-ID.
<dt><br>_A_SUBDIR
<dd>Indicates a sub-directory.
<dt><br>_A_ARCH
<dd>This is the archive flag.&nbsp; It is set whenever the file is modified, and is cleared by the MS-DOS BACKUP command and other
 backup utility programs.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_setfileattr</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt>
 errno</tt> accordingly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_getfileattr">_dos_getfileattr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>print_attribute()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned attribute;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _dos_getfileattr( &quot;file&quot;, &amp;attribute );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;File attribute is %x\n&quot;, attribute );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( attribute &amp; _A_RDONLY ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;This is a read-only file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;This is not a read-only file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( _dos_creat( &quot;file&quot;, _A_RDONLY, &amp;handle ) != 0 ){</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error creating file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_attribute();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_setfileattr( &quot;file&quot;, _A_NORMAL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_attribute();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_close( handle );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_setftime"> _dos_setftime </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_setftime( int handle,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned date,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned time );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_setftime</tt> function uses system call 0x57 to set the date and time that the file associated with<b> handle</b>
 was last modified.&nbsp; The date consists of the year, month and day packed into 16 bits as follows:
<dl>
<dt>Bits&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>bits 0-4
<dd>Day (1-31)
<dt><br>bits 5-8
<dd>Month (1-12)
<dt><br>bits 9-15
<dd>Year (0-119 representing 1980-2099)
</dl>
<br>The time consists of the hour, minute and seconds/2 packed into 16 bits as follows:
<dl>
<dt>Bits&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>bits 0-4
<dd>Seconds/2 (0-29)
<dt><br>bits 5-10
<dd>Minutes (0-59)
<dt><br>bits 11-15
<dd>Hours (0-23)
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_setftime</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt>
 errno</tt> accordingly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_getftime">_dos_getftime</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><br><tt>#define YEAR(t)&nbsp;&nbsp; (((t &amp; 0xFE00) &gt;&gt; 9) + 1980)</tt>
<br><tt>#define MONTH(t)&nbsp; ((t &amp; 0x01E0) &gt;&gt; 5)</tt>
<br><tt>#define DAY(t)&nbsp;&nbsp;&nbsp; (t &amp; 0x001F)</tt>
<br><tt>#define HOUR(t)&nbsp;&nbsp; ((t &amp; 0xF800) &gt;&gt; 11)</tt>
<br><tt>#define MINUTE(t) ((t &amp; 0x07E0) &gt;&gt; 5)</tt>
<br><tt>#define SECOND(t) ((t &amp; 0x001F) &lt;&lt; 1)</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short date, time;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( _dos_open( &quot;file&quot;, O_RDWR, &amp;handle ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Open succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_getftime( handle, &amp;date, &amp;time );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;The file was last modified on %d/%d/%d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MONTH(date), DAY(date),
 YEAR(date) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; at %.2d:%.2d:%.2d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HOUR(time), MINUTE(time),
 SECOND(time) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* set the time to 12 noon */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time = (12 &lt;&lt; 11) + (0 &lt;&lt; 5) + 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_setftime( handle, date, time );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_getftime( handle, &amp;date, &amp;time );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;The file was last modified on %d/%d/%d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MONTH(date), DAY(date),
 YEAR(date) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; at %.2d:%.2d:%.2d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HOUR(time), MINUTE(time),
 SECOND(time) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Open succeeded</tt>
<br><tt>The file was last modified on 12/29/1989 at 14:32:46</tt>
<br><tt>The file was last modified on 12/29/1989 at 12:00:00</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_settime"> _dos_settime </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_settime( struct dostime_t *time );</tt>
<br><tt>struct dostime_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char hour;&nbsp;&nbsp;&nbsp;&nbsp; /* 0-23 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char minute;&nbsp;&nbsp; /* 0-59 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char second;&nbsp;&nbsp; /* 0-59 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char hsecond;&nbsp; /* 1/100 second; 0-99 */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_settime</tt> function uses system call 0x2D to set the current system time.&nbsp; The time information is passed
 in a <tt> dostime_t</tt> structure pointed to by<b> time</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_settime</tt> function returns zero if successful.&nbsp; Otherwise, it returns a non-zero value and sets <tt>
 errno</tt> to <tt> EINVAL</tt> indicating that an invalid time was given.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_getdate">_dos_getdate</a>, <a href="#_dos_setdate">_dos_setdate</a>, <a href="#_dos_gettime">_dos_gettime</a>,
 <a href="#gmtime">gmtime</a>, <a href="#localtime">localtime</a>, <a href="#mktime">mktime</a>, <a href="#time">time</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct dosdate_t date;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct dostime_t time;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Get and display the current date and time */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_getdate( &amp;date );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_gettime( &amp;time );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The date (MM-DD-YYYY) is: %d-%d-%d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date.month, date.day, date.year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The time (HH:MM:SS) is: %.2d:%.2d:%.2d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time.hour, time.minute, time.second );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Change it to the turn of the century */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; date.year = 1999;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; date.month = 12;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; date.day = 31;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time.hour = 23;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time.minute = 59;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_setdate( &amp;date );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_settime( &amp;time );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;New date (MM-DD-YYYY) is: %d-%d-%d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; date.month,
 date.day, date.year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;New time (HH:MM:SS) is: %.2d:%.2d:%.2d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time.hour,
 time.minute, time.second );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>The date (MM-DD-YYYY) is: 12-25-1989</tt>
<br><tt>The time (HH:MM:SS) is: 14:23:15</tt>
<br><tt>New date (MM-DD-YYYY) is: 12-31-1999</tt>
<br><tt>New time (HH:MM:SS) is: 23:59:16</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="_dos_setvect"> _dos_setvect </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>void _dos_setvect( unsigned intnum,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void
 (__interrupt __far *handler)() );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_setvect</tt> function sets interrupt vector number<b> intnum</b> to point to the interrupt handling function
 pointed to by<b> handler</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_setvect</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_chain_intr">_chain_intr</a>, <a href="#_dos_getvect">_dos_getvect</a>, <a href="#_dos_keep">_dos_keep</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>volatile int clock_ticks;</tt>
<br><tt>void (__interrupt __far *prev_int_1c)();</tt>
<br><tt>#define BLIP_COUNT&nbsp; (5*18)&nbsp; /* 5 seconds */</tt>
<br><br><tt>void __interrupt __far timer_rtn()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ++clock_ticks;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _chain_intr( prev_int_1c );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>int compile_a_line()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; static int delays = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( delays &gt; 15 ) return( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; delay( 1000 );&nbsp; /* delay for 1 second */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Delayed for 1 second\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; delays++;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 1 );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; prev_int_1c = _dos_getvect( 0x1c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_setvect( 0x1c, timer_rtn );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( compile_a_line() ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( clock_ticks &gt;= BLIP_COUNT ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar( '.' );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clock_ticks -= BLIP_COUNT;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dos_setvect( 0x1c, prev_int_1c );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, DOS/PM
</dl>
<h2 id="_dos_write"> _dos_write </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned _dos_write( int handle, void const __far *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; unsigned count, unsigned *bytes );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dos_write</tt> function uses system call 0x40 to write<b> count</b> bytes of data from the buffer pointed to by<b>
 buffer</b> to the file specified by<b> handle</b>.&nbsp; The number of bytes successfully written will be stored in the unsigned
 integer pointed to by<b> bytes</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dos_write</tt> function returns zero if successful.&nbsp; Otherwise, it returns an OS error code and sets <tt> errno</tt>
 accordingly.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_close">_dos_close</a>, <a href="#_dos_open">_dos_open</a>, <a href="#_dos_read">_dos_read</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><br><tt>char buffer&#91;&#93; = &quot;This is a test for _dos_write.&quot;;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned len_written;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( _dos_creat( &quot;file&quot;, _A_NORMAL, &amp;handle ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to create file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Create succeeded\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_write( handle, buffer, sizeof(buffer),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;len_written
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dos_close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, DOS/PM
</dl>
<h2 id="dup"> dup, _dup </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int dup( int handle );</tt>
<br><tt>int _dup( int handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> dup</tt> function duplicates the file handle given by the argument<b> handle</b>.&nbsp; The new file handle refers
 to the same open file handle as the original file handle, and shares any locks.&nbsp; The new file handle is identical to
 the original in that it references the same file or device, it has the same open mode (read and/or write) and it will have
 file position identical to the original.&nbsp; Changing the position with one handle will result in a changed position in
 the other.
<br>The<tt> _dup</tt> function is identical to<tt> dup</tt>.&nbsp; Use<tt> _dup</tt> for ANSI/ISO naming conventions.
</dl>
<dl>
<dt>Returns:
<dd>If successful, the new file handle is returned to be used with the other functions which operate on the file.&nbsp; Otherwise,
 -1 is returned and <tt> errno</tt> is set to indicate the error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EBADF
<dd>The argument<b> handle</b> is not a valid open file handle.
<dt><br>EMFILE
<dd>The number of file handles would exceed {OPEN_MAX}.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#chsize">chsize</a>, <a href="#close">close</a>, <a href="#creat">creat</a>, <a href="#dup2">dup2</a>, <a href="#eof">eof</a>,
 <a href="#exec___">exec...</a>, <a href="#fdopen">fdopen</a>, <a href="#filelength">filelength</a>, <a href="#fileno">fileno</a>,
 <a href="#fstat">fstat</a>, <a href="#_grow_handles">_grow_handles</a>, <a href="#isatty">isatty</a>, <a href="#lseek">lseek</a>,
 <a href="#open">open</a>, <a href="#read">read</a>, <a href="#setmode">setmode</a>, <a href="#sopen">sopen</a>, <a href="#stat">stat</a>,
 <a href="#tell">tell</a>, <a href="#write">write</a>, <a href="#umask">umask</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle, dup_handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC
 | O_TEXT,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
 | S_IWGRP );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup_handle = dup( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( dup_handle != -1 ) {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* process file */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( dup_handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>dup is POSIX 1003.1
<br>_dup is not POSIX
<br>_dup conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> dup - All, Netware</tt>
<br><tt>_dup - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="dup2"> dup2, _dup2 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int dup2( int handle, int handle2 );</tt>
<br><tt>int _dup2( int handle, int handle2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> dup2</tt> function duplicates the file handle given by the argument<b> handle</b>.&nbsp; The new file handle is identical
 to the original in that it references the same file or device, it has the same open mode (read and/or write) and it will
 have identical file position to the original (changing the position with one handle will result in a changed position in
 the other).
<br>The number of the new handle is<b> handle2</b>.&nbsp; If a file already is opened with this handle, the file is closed
 before the duplication is attempted.
<br><br>The<tt> _dup2</tt> function is identical to<tt> dup2</tt>.&nbsp; Use<tt> _dup2</tt> for ANSI/ISO naming conventions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> dup2</tt> function returns zero if successful.&nbsp; Otherwise, -1 is returned and <tt> errno</tt> is set to indicate
 the error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EBADF
<dd>The argument<b> handle</b> is not a valid open file handle or<b> handle2</b> is out of range.
<dt><br>EMFILE
<dd>The number of file handles would exceed {OPEN_MAX}, or no file handles above<b> handle2</b> are available.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#chsize">chsize</a>, <a href="#close">close</a>, <a href="#creat">creat</a>, <a href="#dup">dup</a>, <a href="#eof">eof</a>,
 <a href="#exec___">exec...</a>, <a href="#fdopen">fdopen</a>, <a href="#filelength">filelength</a>, <a href="#fileno">fileno</a>,
 <a href="#fstat">fstat</a>, <a href="#_grow_handles">_grow_handles</a>, <a href="#isatty">isatty</a>, <a href="#lseek">lseek</a>,
 <a href="#open">open</a>, <a href="#read">read</a>, <a href="#setmode">setmode</a>, <a href="#sopen">sopen</a>, <a href="#stat">stat</a>,
 <a href="#tell">tell</a>, <a href="#write">write</a>, <a href="#umask">umask</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle, dup_handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC
 | O_TEXT,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
 | S_IWGRP );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup_handle = 4;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( dup2( handle, dup_handle ) != -1 ) {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* process file */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( dup_handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>dup2 is POSIX 1003.1
<br>_dup2 is not POSIX
</dl>
<dl>
<dt>Systems:
<dd><tt> dup2 - All, Netware</tt>
<br><tt>_dup2 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_dwDeleteOnClose"> _dwDeleteOnClose </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wdefwin.h&gt;</tt>
<br><tt>int _dwDeleteOnClose( int handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dwDeleteOnClose</tt> function tells the console window that it should close itself when the corresponding file is
 closed.&nbsp; The argument<b> handle</b> is the handle associated with the opened console.
<br>The<tt> _dwDeleteOnClose</tt> function is one of the support functions that can be called from an application using Watcom's
 default windowing support.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dwDeleteOnClose</tt> function returns 1 if it was successful and 0 if not.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dwSetAboutDlg">_dwSetAboutDlg</a>, <a href="#_dwSetAppTitle">_dwSetAppTitle</a>, <a href="#_dwSetConTitle">_dwSetConTitle</a>,
 <a href="#_dwShutDown">_dwShutDown</a>, <a href="#_dwYield">_dwYield</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;wdefwin.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *sec;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _dwSetAboutDlg( &quot;Hello World About Dialog&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;About Hello World\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;Copyright 1994 by WATCOM\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetAppTitle( &quot;Hello World Application Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetConTitle( 0, &quot;Hello World Console Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Hello World\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; sec = fopen( &quot;CON&quot;, &quot;r+&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetConTitle( fileno( sec ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;Hello World Second Console Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwDeleteOnClose( fileno( sec ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Hello to second console\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Press Enter to close this console\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fflush( sec );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fgetc( sec );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( sec );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Windows, Win386, Win32, OS/2-32
</dl>
<h2 id="_dwSetAboutDlg"> _dwSetAboutDlg </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wdefwin.h&gt;</tt>
<br><tt>int _dwSetAboutDlg( const char *title, const char *text );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dwSetAboutDlg</tt> function sets the &quot;About&quot; dialog box of the default windowing system.&nbsp; The argument<b>
 title</b> points to the string that will replace the current title.&nbsp; If<b> title</b> is NULL then the title will not
 be replaced.&nbsp; The argument<b> text</b> points to a string which will be placed in the &quot;About&quot; box.&nbsp; To
 get multiple lines, embed a new line after each logical line in the string.&nbsp; If<b> text</b> is NULL, then the current
 text in the &quot;About&quot; box will not be replaced.
<br>The<tt> _dwSetAboutDlg</tt> function is one of the support functions that can be called from an application using Watcom's
 default windowing support.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dwSetAboutDlg</tt> function returns 1 if it was successful and 0 if not.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dwDeleteOnClose">_dwDeleteOnClose</a>, <a href="#_dwSetAppTitle">_dwSetAppTitle</a>, <a href="#_dwSetConTitle">_dwSetConTitle</a>,
 <a href="#_dwShutDown">_dwShutDown</a>, <a href="#_dwYield">_dwYield</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;wdefwin.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *sec;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _dwSetAboutDlg( &quot;Hello World About Dialog&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;About Hello World\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;Copyright 1994 by WATCOM\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetAppTitle( &quot;Hello World Application Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetConTitle( 0, &quot;Hello World Console Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Hello World\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; sec = fopen( &quot;CON&quot;, &quot;r+&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetConTitle( fileno( sec ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;Hello World Second Console Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwDeleteOnClose( fileno( sec ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Hello to second console\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Press Enter to close this console\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fflush( sec );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fgetc( sec );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( sec );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Windows, Win386, Win32, OS/2-32
</dl>
<h2 id="_dwSetAppTitle"> _dwSetAppTitle </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wdefwin.h&gt;</tt>
<br><tt>int _dwSetAppTitle( const char *title );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dwSetAppTitle</tt> function sets the main window's title.&nbsp; The argument<b> title</b> points to the string that
 will replace the current title.
<br>The<tt> _dwSetAppTitle</tt> function is one of the support functions that can be called from an application using Watcom's
 default windowing support.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dwSetAppTitle</tt> function returns 1 if it was successful and 0 if not.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dwDeleteOnClose">_dwDeleteOnClose</a>, <a href="#_dwSetAboutDlg">_dwSetAboutDlg</a>, <a href="#_dwSetConTitle">_dwSetConTitle</a>,
 <a href="#_dwShutDown">_dwShutDown</a>, <a href="#_dwYield">_dwYield</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;wdefwin.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *sec;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _dwSetAboutDlg( &quot;Hello World About Dialog&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;About Hello World\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;Copyright 1994 by WATCOM\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetAppTitle( &quot;Hello World Application Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetConTitle( 0, &quot;Hello World Console Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Hello World\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; sec = fopen( &quot;CON&quot;, &quot;r+&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetConTitle( fileno( sec ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;Hello World Second Console Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwDeleteOnClose( fileno( sec ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Hello to second console\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Press Enter to close this console\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fflush( sec );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fgetc( sec );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( sec );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Windows, Win386, Win32, OS/2-32
</dl>
<h2 id="_dwSetConTitle"> _dwSetConTitle </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wdefwin.h&gt;</tt>
<br><tt>int _dwSetConTitle( int handle, const char *title );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dwSetConTitle</tt> function sets the console window's title which corresponds to the handle passed to it.&nbsp; The
 argument<b> handle</b> is the handle associated with the opened console.&nbsp; The argument<b> title</b> points to the string
 that will replace the current title.
<br>The<tt> _dwSetConTitle</tt> function is one of the support functions that can be called from an application using Watcom's
 default windowing support.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dwSetConTitle</tt> function returns 1 if it was successful and 0 if not.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dwDeleteOnClose">_dwDeleteOnClose</a>, <a href="#_dwSetAboutDlg">_dwSetAboutDlg</a>, <a href="#_dwSetAppTitle">_dwSetAppTitle</a>,
 <a href="#_dwShutDown">_dwShutDown</a>, <a href="#_dwYield">_dwYield</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;wdefwin.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *sec;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _dwSetAboutDlg( &quot;Hello World About Dialog&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;About Hello World\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;Copyright 1994 by WATCOM\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetAppTitle( &quot;Hello World Application Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetConTitle( 0, &quot;Hello World Console Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Hello World\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; sec = fopen( &quot;CON&quot;, &quot;r+&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetConTitle( fileno( sec ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;Hello World Second Console Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwDeleteOnClose( fileno( sec ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Hello to second console\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Press Enter to close this console\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fflush( sec );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fgetc( sec );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( sec );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Windows, Win386, Win32, OS/2-32
</dl>
<h2 id="_dwShutDown"> _dwShutDown </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wdefwin.h&gt;</tt>
<br><tt>int _dwShutDown( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dwShutDown</tt> function shuts down the default windowing I/O system.&nbsp; The application will continue to execute
 but no windows will be available for output.&nbsp; Care should be exercised when using this function since any subsequent
 output may cause unpredictable results.
<br>When the application terminates, it will not be necessary to manually close the main window.
<br><br>The<tt> _dwShutDown</tt> function is one of the support functions that can be called from an application using Watcom's
 default windowing support.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dwShutDown</tt> function returns 1 if it was successful and 0 if not.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dwDeleteOnClose">_dwDeleteOnClose</a>, <a href="#_dwSetAboutDlg">_dwSetAboutDlg</a>, <a href="#_dwSetAppTitle">_dwSetAppTitle</a>,
 <a href="#_dwSetConTitle">_dwSetConTitle</a>, <a href="#_dwYield">_dwYield</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;wdefwin.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *sec;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _dwSetAboutDlg( &quot;Hello World About Dialog&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;About Hello World\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;Copyright 1994 by WATCOM\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetAppTitle( &quot;Hello World Application Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetConTitle( 0, &quot;Hello World Console Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Hello World\n&quot; );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; sec = fopen( &quot;CON&quot;, &quot;r+&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwSetConTitle( fileno( sec ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 &quot;Hello World Second Console Title&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwDeleteOnClose( fileno( sec ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Hello to second console\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( sec, &quot;Press Enter to close this console\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fflush( sec );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fgetc( sec );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( sec );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dwShutDown();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /*</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do more computing that does not involve</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console input/output</tt>
<br><tt>&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Windows, Win386, Win32, OS/2-32
</dl>
<h2 id="_dwYield"> _dwYield </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wdefwin.h&gt;</tt>
<br><tt>int _dwYield( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _dwYield</tt> function yields control back to the operating system, thereby giving other processes a chance to run.
<br>The<tt> _dwYield</tt> function is one of the support functions that can be called from an application using Watcom's default
 windowing support.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _dwYield</tt> function returns 1 if it was successful and 0 if not.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dwDeleteOnClose">_dwDeleteOnClose</a>, <a href="#_dwSetAboutDlg">_dwSetAboutDlg</a>, <a href="#_dwSetAppTitle">_dwSetAppTitle</a>,
 <a href="#_dwSetConTitle">_dwSetConTitle</a>, <a href="#_dwShutDown">_dwShutDown</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;wdefwin.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 1000; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* give other processes a chance to run */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _dwYield();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* do CPU-intensive calculation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; .&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; .&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*&nbsp; .&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Windows, Win386, Win32, OS/2-32
</dl>
<h2 id="ecvt"> ecvt, _ecvt, _wecvt </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>char *ecvt( double value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *dec,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *sign );</tt>
<br><tt>char *_ecvt( double value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *dec,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *sign );</tt>
<br><tt>wchar_t *_wecvt( double value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *dec,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *sign );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ecvt</tt> function converts the floating-point number<b> value</b> into a character string.&nbsp; The parameter<b>
 ndigits</b> specifies the number of significant digits desired.&nbsp; The converted number will be rounded to<b> ndigits</b>
 of precision.
<br>The character string will contain only digits and is terminated by a null character.&nbsp; The integer pointed to by<b>
 dec</b> will be filled in with a value indicating the position of the decimal point relative to the start of the string of
 digits.&nbsp; A zero or negative value indicates that the decimal point lies to the left of the first digit.&nbsp; The integer
 pointed to by<b> sign</b> will contain 0 if the number is positive, and non-zero if the number is negative.
<br><br>The<tt> _ecvt</tt> function is identical to<tt> ecvt</tt>.&nbsp; Use<tt> _ecvt</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _wecvt</tt> function is identical to<tt> ecvt</tt> except that it produces a wide-character string.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ecvt</tt> function returns a pointer to a static buffer containing the converted string of digits.&nbsp; Note:<tt>
&nbsp; ecvt</tt> and <tt> fcvt</tt> both use the same static buffer.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fcvt">fcvt</a>, <a href="#gcvt">gcvt</a>, <a href="#printf">printf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; char *str;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; dec, sign;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; str = ecvt( 123.456789, 6, &amp;dec, &amp;sign );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;str=%s, dec=%d, sign=%d\n&quot;, str,dec,sign );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>str=123457, dec=3, sign=0</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_ecvt conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> ecvt - Math</tt>
<br><tt>_ecvt - Math</tt>
<br><tt>_wecvt - Math</tt>
</dl>
<h2 id="_ellipse"> _ellipse, _ellipse_w, _ellipse_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _ellipse( short fill, short x1, short y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x2, short y2 );</tt>
<br><br><tt>short _FAR _ellipse_w( short fill, double x1, double y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x2, double y2 );</tt>
<br><br><tt>short _FAR _ellipse_wxy( short fill,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *p1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *p2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ellipse</tt> functions draw ellipses.&nbsp; The<tt> _ellipse</tt> function uses the view coordinate system.&nbsp;
 The<tt> _ellipse_w</tt> and<tt> _ellipse_wxy</tt> functions use the window coordinate system.
<br>The center of the ellipse is the center of the rectangle established by the points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>
<br><br>The argument<b> fill</b> determines whether the ellipse is filled in or has only its outline drawn.&nbsp; The argument
 can have one of two values:
<dl>
<dt>_GFILLINTERIOR
<dd>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<dt><br>_GBORDER
<dd>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
 style
</dl>
<br>When the coordinates<tt> (x1,y1)</tt> and<tt> (x2,y2)</tt> establish a line or a point (this happens when one or more
 of the x-coordinates or y-coordinates are equal), nothing is drawn.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ellipse</tt> functions return a non-zero value when the ellipse was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_arc">_arc</a>, <a href="#_rectangle">_rectangle</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_setfillmask">_setfillmask</a>,
 <a href="#_setlinestyle">_setlinestyle</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _ellipse( _GBORDER, 120, 90, 520, 390 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_ellip.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>_ellipse is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _ellipse - DOS, QNX</tt>
<br><tt>_ellipse_w - DOS, QNX</tt>
<br><tt>_ellipse_wxy - DOS, QNX</tt>
</dl>
<h2 id="_enable"> _enable </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>void _enable( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _enable</tt> function causes interrupts to become enabled.
<br>The<tt> _enable</tt> function would be used in conjunction with the <tt> _disable</tt> function to make sure that a sequence
 of instructions are executed without any intervening interrupts occurring.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _enable</tt> function returns no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_disable">_disable</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>struct list_entry {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct list_entry *next;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; data;</tt>
<br><tt>};</tt>
<br><tt>struct list_entry *ListHead = NULL;</tt>
<br><tt>struct list_entry *ListTail = NULL;</tt>
<br><br><tt>void insert( struct list_entry *new_entry )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* insert new_entry at end of linked list */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; new_entry-&gt;next = NULL;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _disable();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disable interrupts */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( ListTail == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListHead = new_entry;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ListTail-&gt;next = new_entry;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ListTail = new_entry;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _enable();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* enable interrupts now */</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct list_entry *p;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 10; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = (struct list_entry *)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; malloc( sizeof( struct list_entry ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( p == NULL ) break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p-&gt;data = i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert( p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_endthread"> _endthread, _endthreadex </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;process.h&gt;</tt>
<br><tt>void _endthread(void);</tt>
<br><tt>void _endthreadex( unsigned retval );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _endthread</tt> function is used to terminate a thread created by <tt> _beginthread</tt>.&nbsp; For each operating
 environment under which<tt> _endthread</tt> is supported, the<tt> _endthread</tt> function uses the appropriate system call
 to end the current thread of execution.
<br>The <tt> _endthreadex</tt> function is used to terminate a thread created by <tt> _beginthreadex</tt>.&nbsp; The thread
 exit code<b> retval</b> must be specified.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _endthread</tt> function does not return any value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_beginthread">_beginthread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;stddef.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>#include &lt;process.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>#if defined(__386__)</tt>
<br><tt>&nbsp; #define FAR</tt>
<br><tt>&nbsp; #define STACK_SIZE&nbsp;&nbsp;&nbsp; 8192</tt>
<br><tt>#else</tt>
<br><tt>&nbsp; #define FAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>&nbsp; #define STACK_SIZE&nbsp;&nbsp;&nbsp; 4096</tt>
<br><tt>#endif</tt>
<br><br><tt>static volatile int&nbsp;&nbsp;&nbsp;&nbsp; WaitForThread;</tt>
<br><br><tt>void FAR child( void FAR *parm )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char * FAR *argv = (char * FAR *) parm;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Child thread ID = %x\n&quot;, *_threadid );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; argv&#91;i&#93;; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;argv&#91;%d&#93; = %s\n&quot;, i, argv&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WaitForThread = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _endthread();</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *args&#91;3&#93;;</tt>
<br><tt>#if defined(__NT__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned long&nbsp;&nbsp; tid;</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *stack;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tid;</tt>
<br><tt>#endif</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; args&#91;0&#93; = &quot;child&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; args&#91;1&#93; = &quot;parm&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; args&#91;2&#93; = NULL;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WaitForThread = 1;</tt>
<br><tt>#if defined(__NT__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tid = _beginthread( child, STACK_SIZE, args );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Thread handle = %lx\n&quot;, tid );</tt>
<br><tt>#else</tt>
<br><tt>&nbsp; #if defined(__386__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; stack = (char *) malloc( STACK_SIZE );</tt>
<br><tt>&nbsp; #else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; stack = (char *) _nmalloc( STACK_SIZE );</tt>
<br><tt>&nbsp; #endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tid = _beginthread( child, stack, STACK_SIZE, args );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Thread ID = %x\n&quot;, tid );</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( WaitForThread ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sleep( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _endthread - Win32, QNX/32, OS/2 1.x(MT), OS/2 1.x(DL), OS/2-32, Netware</tt>
<br><tt>_endthreadex - Win32</tt>
</dl>
<h2 id="eof"> eof, _eof </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int eof( int handle );</tt>
<br><tt>int _eof( int handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> eof</tt> function determines, at the operating system level, if the end of the file has been reached for the file
 whose file handle is given by<b> handle</b>.&nbsp; Because the current file position is set following an input operation,
 the<tt> eof</tt> function may be called to detect the end of the file before an input operation beyond the end of the file
 is attempted.
<br>The<tt> _eof</tt> function is identical to<tt> eof</tt>.&nbsp; Use<tt> _eof</tt> for ANSI/ISO naming conventions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> eof</tt> function returns 1 if the current file position is at the end of the file, 0 if the current file position
 is not at the end.&nbsp; A return value of -1 indicates an error, and in this case <tt> errno</tt> is set to indicate the
 error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>EBADF
<dd>The<b> handle</b> argument is not a valid file handle.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#read">read</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle, len;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;100&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( ! eof( handle ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = read( handle, buffer, sizeof(buffer) - 1
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer&#91; len &#93; = '\0';</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s&quot;, buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> eof - All, Netware</tt>
<br><tt>_eof - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="exec___"> exec...&nbsp; Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;process.h&gt;</tt>
<br><tt>int execl(&nbsp;&nbsp; path, arg0, arg1..., argn, NULL );</tt>
<br><tt>int execle(&nbsp; path, arg0, arg1..., argn, NULL, envp );</tt>
<br><tt>int execlp(&nbsp; file, arg0, arg1..., argn, NULL );</tt>
<br><tt>int execlpe( file, arg0, arg1..., argn, NULL, envp );</tt>
<br><tt>int execv(&nbsp;&nbsp; path, argv );</tt>
<br><tt>int execve(&nbsp; path, argv, envp );</tt>
<br><tt>int execvp(&nbsp; file, argv );</tt>
<br><tt>int execvpe( file, argv, envp );</tt>
<br><tt>&nbsp; const char *path;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name incl.
 path */</tt>
<br><tt>&nbsp; const char *file;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; const char *arg0, ..., *argn; /* arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 */</tt>
<br><tt>&nbsp; const char *const argv&#91;&#93;;&nbsp;&nbsp;&nbsp;&nbsp; /* array of arguments&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; const char *const envp&#91;&#93;;&nbsp;&nbsp;&nbsp;&nbsp; /* environment strings&nbsp; */</tt>
<br><tt>int _wexecl(&nbsp;&nbsp; path, arg0, arg1..., argn, NULL );</tt>
<br><tt>int _wexecle(&nbsp; path, arg0, arg1..., argn, NULL, envp );</tt>
<br><tt>int _wexeclp(&nbsp; file, arg0, arg1..., argn, NULL );</tt>
<br><tt>int _wexeclpe( file, arg0, arg1..., argn, NULL, envp );</tt>
<br><tt>int _wexecv(&nbsp;&nbsp; path, argv );</tt>
<br><tt>int _wexecve(&nbsp; path, argv, envp );</tt>
<br><tt>int _wexecvp(&nbsp; file, argv );</tt>
<br><tt>int _wexecvpe( file, argv, envp );</tt>
<br><tt>&nbsp; const wchar_t *path;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name incl. path
 */</tt>
<br><tt>&nbsp; const wchar_t *file;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; const wchar_t *arg0, ..., *argn;/* arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 */</tt>
<br><tt>&nbsp; const wchar_t *const argv&#91;&#93;;&nbsp;&nbsp;&nbsp; /* array of arguments&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; const wchar_t *const envp&#91;&#93;;&nbsp;&nbsp;&nbsp; /* environment strings&nbsp; */</tt>
</dl>
<dl>
<dt>Description:
<dd>The<b> exec...</b>&nbsp; functions load and execute a new child process, named by<b> path</b> or<b> file</b>.&nbsp; If the
 child process is successfully loaded, it replaces the current process in memory.&nbsp; No return is made to the original
 program.
<br>The program is located by using the following logic in sequence:
<ol>
<li>An attempt is made to locate the program in the current working directory if no directory specification precedes the program
 name; otherwise, an attempt is made in the specified directory.
<li>If no file extension is given, an attempt is made to find the program name, in the directory indicated in the first point,
 with<tt> .COM</tt> concatenated to the end of the program name.
<li>If no file extension is given, an attempt is made to find the program name, in the directory indicated in the first point,
 with<tt> .EXE</tt> concatenated to the end of the program name.
<li>When no directory specification is given as part of the program name, the <tt> execlp</tt>, <tt> execlpe</tt>, <tt> execvp</tt>,
 and <tt> execvpe</tt> functions will repeat the preceding three steps for each of the directories specified by the <tt> PATH</tt>
 environment variable.&nbsp; The command
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; path c:\myapps;d:\lib\applns</tt>
<br><br>indicates that the two directories
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; c:\myapps</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; d:\lib\applns</tt>
<br><br>are to be searched.&nbsp; The DOS<tt> PATH</tt> command (without any directory specification) will cause the current
 path definition to be displayed.
</ol>
<br>An error is detected when the program cannot be found.
<br><br>Arguments are passed to the child process by supplying one or more pointers to character strings as arguments in the<b>
 exec...</b>&nbsp; call.&nbsp; These character strings are concatenated with spaces inserted to separate the arguments to
 form one argument string for the child process.&nbsp; The length of this concatenated string must not exceed 128 bytes for
 DOS systems.
<br><br>The arguments may be passed as a list of arguments (<tt> execl</tt>, <tt> execle</tt>, <tt> execlp</tt>, and <tt>
 execlpe</tt>) or as a vector of pointers (<tt> execv</tt>, <tt> execve</tt>, <tt> execvp</tt>, and <tt> execvpe</tt>).&nbsp;
 At least one argument,<b> arg0</b> or<b> argv&#91;0&#93;</b>, must be passed to the child process.&nbsp; By convention, this
 first argument is a pointer to the name of the program.
<br><br>If the arguments are passed as a list, there must be a<tt> NULL</tt> pointer to mark the end of the argument list.
&nbsp; Similarly, if a pointer to an argument vector is passed, the argument vector must be terminated by a<tt> NULL</tt>
 pointer.
<br><br>The environment for the invoked program is inherited from the parent process when you use the <tt> execl</tt>, <tt>
 execlp</tt>, <tt> execv</tt>, and <tt> execvp</tt> functions.&nbsp; The <tt> execle</tt>, <tt> execlpe</tt>, <tt> execve</tt>,
 and <tt> execvpe</tt> functions allow a different environment to be passed to the child process through the<b> envp</b> argument.
&nbsp; The argument<b> envp</b> is a pointer to an array of character pointers, each of which points to a string defining
 an environment variable.&nbsp; The array is terminated with a<tt> NULL</tt> pointer.&nbsp; Each pointer locates a character
 string of the form
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable=value</tt>
<br><br>that is used to define an environment variable.&nbsp; If the value of<b> envp</b> is<tt> NULL</tt>, then the child
 process inherits the environment of the parent process.
<br><br>The environment is the collection of environment variables whose values have been defined with the DOS<tt> SET</tt>
 command or by the successful execution of the <tt> putenv</tt> function.&nbsp; A program may read these values with the <tt>
 getenv</tt> function.
<br><br>The <tt> execvpe</tt> and <tt> execlpe</tt> functions are extensions to POSIX 1003.1.&nbsp; The wide-character <tt>
 _wexecl</tt>, <tt> _wexecle</tt>, <tt> _wexeclp</tt>, <tt> _wexeclpe</tt>, <tt> _wexecv</tt>, <tt> _wexecve</tt>, <tt> _wexecvp</tt>
 and <tt> _wexecvpe</tt> functions are similar to their counterparts but operate on wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>When the invoked program is successfully initiated, no return occurs.&nbsp; When an error is detected while invoking the indicated
 program,<b> exec...</b>&nbsp; returns -1 and <tt> errno</tt> is set to indicate the error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>E2BIG
<dd>The argument list exceeds 128 bytes, or the space required for the environment information exceeds 32K.
<dt><br>EACCES
<dd>The specified file has a locking or sharing violation.
<dt><br>EMFILE
<dd>Too many files open
<dt><br>ENOENT
<dd>Path or file not found
<dt><br>ENOMEM
<dd>Not enough memory is available to execute the child process.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#abort">abort</a>, <a href="#atexit">atexit</a>, <a href="#exit">exit</a>, <a href="#_exit">_exit</a>, <a href="#getcmd">getcmd</a>,
 <a href="#getenv">getenv</a>, <a href="#main">main</a>, <a href="#putenv">putenv</a>, <a href="#spawn___">spawn...</a>, <a href="#system">system</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stddef.h&gt;</tt>
<br><tt>#include &lt;process.h&gt;</tt>
<br><br><tt>execl( &quot;myprog&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;myprog&quot;, &quot;ARG1&quot;, &quot;ARG2&quot;, NULL );</tt>
<br><br>The preceding invokes &quot;myprog&quot; as if
<br><br><tt>&nbsp;&nbsp;&nbsp; myprog ARG1 ARG2</tt>
<br><br>had been entered as a command to DOS.&nbsp; The program will be found if one of
<br><br><tt>&nbsp;&nbsp;&nbsp; myprog.</tt>
<br><tt>&nbsp;&nbsp;&nbsp; myprog.com</tt>
<br><tt>&nbsp;&nbsp;&nbsp; myprog.exe</tt>
<br><br>is found in the current working directory.
<br><br><tt>#include &lt;stddef.h&gt;</tt>
<br><tt>#include &lt;process.h&gt;</tt>
<br><br><tt>char *env_list&#91;&#93; = { &quot;SOURCE=MYDATA&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &quot;TARGET=OUTPUT&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &quot;lines=65&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; NULL</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 };</tt>
<br><br><tt>execle( &quot;myprog&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;myprog&quot;, &quot;ARG1&quot;, &quot;ARG2&quot;, NULL,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env_list );</tt>
<br><br>The preceding invokes &quot;myprog&quot; as if
<br><br><tt>&nbsp;&nbsp;&nbsp; myprog ARG1 ARG2</tt>
<br><br>had been entered as a command to DOS.&nbsp; The program will be found if one of
<br><br><tt>&nbsp;&nbsp;&nbsp; myprog.</tt>
<br><tt>&nbsp;&nbsp;&nbsp; myprog.com</tt>
<br><tt>&nbsp;&nbsp;&nbsp; myprog.exe</tt>
<br><br>is found in the current working directory.&nbsp; The DOS environment for the invoked program will consist of the three
 environment variables<tt> SOURCE, TARGET</tt> and<tt> lines.</tt>
<br><br><tt>#include &lt;stddef.h&gt;</tt>
<br><tt>#include &lt;process.h&gt;</tt>
<br><br><tt>char *arg_list&#91;&#93; = { &quot;myprog&quot;, &quot;ARG1&quot;, &quot;ARG2&quot;, NULL };</tt>
<br><br><tt>execv( &quot;myprog&quot;, arg_list );</tt>
<br><br>The preceding invokes &quot;myprog&quot; as if
<br><tt>&nbsp;&nbsp;&nbsp; myprog ARG1 ARG2</tt>
<br><br>had been entered as a command to DOS.&nbsp; The program will be found if one of
<br><br><tt>&nbsp;&nbsp;&nbsp; myprog.</tt>
<br><tt>&nbsp;&nbsp;&nbsp; myprog.com</tt>
<br><tt>&nbsp;&nbsp;&nbsp; myprog.exe</tt>
<br><br>is found in the current working directory.
</dl>
<dl>
<dt>Classification:
<dd>exec...&nbsp; is POSIX 1003.1 with extensions
<br>_wexec...&nbsp; is not POSIX
</dl>
<dl>
<dt>Systems:
<dd><tt> execl - DOS/16, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>execle - DOS/16, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>execlp - DOS/16, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>execlpe - DOS/16, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>execv - DOS/16, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>execve - DOS/16, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>execvp - DOS/16, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>execvpe - DOS/16, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wexecl - DOS/16, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wexecle - DOS/16, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wexeclp - DOS/16, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wexeclpe - DOS/16, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wexecv - DOS/16, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wexecve - DOS/16, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wexecvp - DOS/16, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wexecvpe - DOS/16, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_exit"> _exit, _Exit </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void _exit( int status );</tt>
<br><tt>void _Exit( int status );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _exit</tt> function causes normal program termination to occur.
<ol>
<li>The functions registered by the <tt> atexit</tt> or <tt> onexit</tt> functions are not called.
<li>Any unopened files are not closed and any buffered output is not flushed to the associated files or devices.
<li>Any files created by <tt> tmpfile</tt> are not removed.
<li>The return<b> status</b> is made available to the parent process.&nbsp; Only the low order byte of<b> status</b> is available
 on DOS systems.&nbsp; The<b> status</b> value is typically set to 0 to indicate successful termination and set to some other
 value to indicate an error.
</ol>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _exit</tt> function does not return to its caller.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abort">abort</a>, <a href="#atexit">atexit</a>, <a href="#_bgetcmd">_bgetcmd</a>, <a href="#exec___">exec...</a>,
 <a href="#exit">exit</a>, <a href="#_Exit">_Exit</a>, <a href="#getcmd">getcmd</a>, <a href="#getenv">getenv</a>, <a href="#main">main</a>,
 <a href="#onexit">onexit</a>, <a href="#putenv">putenv</a>, <a href="#spawn___">spawn...</a>, <a href="#system">system</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main( int argc, char *argv&#91;&#93; )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( argc &lt;= 1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Missing argument\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( argv&#91;1&#93;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Unable to open '%s'\n&quot;, argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _exit( EXIT_SUCCESS );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>POSIX 1003.1
<br>_Exit is ISO C99
</dl>
<dl>
<dt>Systems:
<dd><tt> _exit - All, Netware</tt>
<br><tt>_Exit - All, Netware</tt>
</dl>
<h2 id="exit"> exit </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void exit( int status );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> exit</tt> function causes normal program termination to occur.
<br>First, all functions registered by the <tt> atexit</tt> function are called in the reverse order of their registration.
&nbsp; Next, all open files are flushed and closed, and all files created by the <tt> tmpfile</tt> function are removed.&nbsp;
 Finally, the return<b> status</b> is made available to the parent process.&nbsp; Only the low order byte of<b> status</b>
 is available on DOS systems.&nbsp; The<b> status</b> value is typically set to 0 to indicate successful termination and set
 to some other value to indicate an error.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> exit</tt> function does not return to its caller.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abort">abort</a>, <a href="#atexit">atexit</a>, <a href="#_exit">_exit</a>, <a href="#onexit">onexit</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main( int argc, char *argv&#91;&#93; )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( argc &lt;= 1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Missing argument\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( argv&#91;1&#93;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Unable to open '%s'\n&quot;, argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; exit( EXIT_SUCCESS );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="exp"> exp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double exp( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> exp</tt> function computes the exponential function of<b> x</b>.&nbsp; A range error occurs if the magnitude of<b>
 x</b> is too large.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> exp</tt> function returns the exponential value.&nbsp; When the argument is outside the permissible range, the <tt>
 matherr</tt> function is called.&nbsp; Unless the default <tt> matherr</tt> function is replaced, it will set the global
 variable <tt> errno</tt> to <tt> ERANGE</tt>, and print a &quot;RANGE error&quot; diagnostic message using the <tt> stderr</tt>
 stream.
</dl>
<dl>
<dt>See Also:
<dd><a href="#log">log</a>, <a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, exp(.5) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>1.648721</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="_expand"> _expand Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *_expand( void *mem_blk, size_t size );</tt>
<br><tt>void __based(void) *_bexpand( __segment seg,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void __based(void) *mem_blk,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</tt>
<br><tt>void __far&nbsp; *_fexpand(void __far&nbsp; *mem_blk,size_t size);</tt>
<br><tt>void __near *_nexpand(void __near *mem_blk,size_t size);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _expand</tt> functions change the size of the previously allocated block pointed to by<b> mem_blk</b> by attempting
 to expand or contract the memory block without moving its location in the heap.&nbsp; The argument<b> size</b> specifies
 the new desired size for the memory block.&nbsp; The contents of the memory block are unchanged up to the shorter of the
 new and old sizes.
<br>Each function expands the memory from a particular heap, as listed below:
<dl>
<dt>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap Expanded
<dt>_expand
<dd>Depends on data model of the program
<dt><br>_bexpand
<dd>Based heap specified by<b> seg</b> value
<dt><br>_fexpand
<dd>Far heap (outside the default data segment)
<dt><br>_nexpand
<dd>Near heap (inside the default data segment)
</dl>
<br>In a small data memory model, the<tt> _expand</tt> function is equivalent to the <tt> _nexpand</tt> function; in a large
 data memory model, the<tt> _expand</tt> function is equivalent to the <tt> _fexpand</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _expand</tt> functions return the value<b> mem_blk</b> if it was successful in changing the size of the block.&nbsp;
 The return value is<tt> NULL</tt> (<tt>_NULLOFF</tt> for <tt> _bexpand</tt>) if the memory block could not be expanded to
 the desired size.&nbsp; It will be expanded as much as possible in this case.
<br>The appropriate <tt> _msize</tt> function can be used to determine the new size of the expanded block.
</dl>
<dl>
<dt>See Also:
<dd><a href="#calloc">calloc</a> Functions, <a href="#free">free</a> Functions, <a href="#halloc">halloc</a>, <a href="#hfree">hfree</a>,
 <a href="#malloc">malloc</a> Functions, <a href="#_msize">_msize</a> Functions, <a href="#realloc">realloc</a> Functions,
 <a href="#sbrk">sbrk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *buf;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char __far *buf2;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; buf = (char *) malloc( 80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Size of buffer is %u\n&quot;, _msize(buf) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( _expand( buf, 100 ) == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to expand buffer\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;New size of buffer is %u\n&quot;, _msize(buf) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; buf2 = (char __far *) _fmalloc( 2000 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Size of far buffer is %u\n&quot;, _fmsize(buf2) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( _fexpand( buf2, 8000 ) == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to expand far buffer\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;New size of far buffer is %u\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmsize(buf2) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Size of buffer is 80</tt>
<br><tt>Unable to expand buffer</tt>
<br><tt>New size of buffer is 80</tt>
<br><tt>Size of far buffer is 2000</tt>
<br><tt>New size of far buffer is 8000</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _expand - All</tt>
<br><tt>_bexpand - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_fexpand - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_nexpand - DOS, Windows, Win386, Win32, QNX, OS/2 1.x, OS/2 1.x(MT), OS/2-32</tt>
</dl>
<h2 id="fabs"> fabs </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double fabs( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fabs</tt> function computes the absolute value of the argument<b> x</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fabs</tt> function returns the absolute value of<b> x</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abs">abs</a>, <a href="#labs">labs</a>, <a href="#imaxabs">imaxabs</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f %f\n&quot;, fabs(.5), fabs(-.5) );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>0.500000 0.500000</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="fclose"> fclose </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fclose( FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fclose</tt> function closes the file<b> fp</b>.&nbsp; If there was any unwritten buffered data for the file, it is
 written out before the file is closed.&nbsp; Any unread buffered data is discarded.&nbsp; If the associated buffer was automatically
 allocated, it is deallocated.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fclose</tt> function returns zero if the file was successfully closed, or non-zero if any errors were detected.&nbsp;
 When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fcloseall">fcloseall</a>, <a href="#fdopen">fdopen</a>, <a href="#fopen">fopen</a>, <a href="#freopen">freopen</a>,
 <a href="#_fsopen">_fsopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;stdio.h&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="fcloseall"> fcloseall </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fcloseall( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fcloseall</tt> function closes all open stream files, except <tt> stdin</tt>, <tt> stdout</tt>, <tt> stderr</tt>,
 <tt> stdaux</tt>, and <tt> stdprn</tt>.&nbsp; This includes streams created (and not yet closed) by <tt> fdopen</tt>, <tt>
 fopen</tt> and <tt> freopen</tt>.&nbsp; The<b> stdaux</b> and<b> stdprn</b> files are not available for some Windows platforms.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fcloseall</tt> function returns the number of streams that were closed if no errors were encountered.&nbsp; When an
 error occurs, <tt> EOF</tt> is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fclose">fclose</a>, <a href="#fdopen">fdopen</a>, <a href="#fopen">fopen</a>, <a href="#freopen">freopen</a>, <a href="#_fsopen">_fsopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The number of files closed is %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fcloseall() );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="fcvt"> fcvt, _fcvt, _wfcvt </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>char *fcvt( double value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *dec,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *sign );</tt>
<br><tt>char *_fcvt( double value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *dec,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *sign );</tt>
<br><tt>wchar_t *_wfcvt( double value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *dec,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int *sign );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fcvt</tt> function converts the floating-point number<b> value</b> into a character string.&nbsp; The parameter<b>
 ndigits</b> specifies the number of digits desired after the decimal point.&nbsp; The converted number will be rounded to
 this position.
<br>The character string will contain only digits and is terminated by a null character.&nbsp; The integer pointed to by<b>
 dec</b> will be filled in with a value indicating the position of the decimal point relative to the start of the string of
 digits.&nbsp; A zero or negative value indicates that the decimal point lies to the left of the first digit.&nbsp; The integer
 pointed to by<b> sign</b> will contain 0 if the number is positive, and non-zero if the number is negative.
<br><br>The<tt> _fcvt</tt> function is identical to<tt> fcvt</tt>.&nbsp; Use<tt> _fcvt</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _wfcvt</tt> function is identical to<tt> fcvt</tt> except that it produces a wide-character string.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fcvt</tt> function returns a pointer to a static buffer containing the converted string of digits.&nbsp; Note:&nbsp;
 <tt> ecvt</tt> and<tt> fcvt</tt> both use the same static buffer.
</dl>
<dl>
<dt>See Also:
<dd><a href="#ecvt">ecvt</a>, <a href="#gcvt">gcvt</a>, <a href="#printf">printf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; char *str;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; dec, sign;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; str = fcvt( -123.456789, 5, &amp;dec, &amp;sign );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;str=%s, dec=%d, sign=%d\n&quot;, str,dec,sign );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>str=12345679, dec=3, sign=-1</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_fcvt conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> fcvt - Math</tt>
<br><tt>_fcvt - Math</tt>
<br><tt>_wfcvt - Math</tt>
</dl>
<h2 id="fdopen"> fdopen, _fdopen, _wfdopen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>FILE *fdopen( int handle, const char *mode );</tt>
<br><tt>FILE *_fdopen( int handle, const char *mode );</tt>
<br><tt>FILE *_wfdopen( int handle, const wchar_t *mode );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fdopen</tt> function associates a stream with the file handle<b> handle</b> which represents an opened file or device.
&nbsp; The handle was returned by one of <tt> creat</tt>, <tt> dup</tt>, <tt> dup2</tt>, <tt> open</tt>, or <tt> sopen</tt>.
&nbsp; The open mode<b> mode</b> must match the mode with which the file or device was originally opened.
<br>The argument<b> mode</b> is described in the description of the <tt> fopen</tt> function.
<br><br>The<tt> _fdopen</tt> function is identical to<tt> fdopen</tt>.&nbsp; Use<tt> _fdopen</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _wfdopen</tt> function is identical to<tt> fdopen</tt> except that it accepts a wide character string for
 the second argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fdopen</tt> function returns a pointer to the object controlling the stream.&nbsp; This pointer must be passed as
 a parameter to subsequent functions for performing operations on the file.&nbsp; If the open operation fails,<tt> fdopen</tt>
 returns a NULL pointer.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that
 has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#creat">creat</a>, <a href="#_dos_open">_dos_open</a>, <a href="#dup">dup</a>, <a href="#dup2">dup2</a>, <a href="#fopen">fopen</a>,
 <a href="#freopen">freopen</a>, <a href="#_fsopen">_fsopen</a>, <a href="#_grow_handles">_grow_handles</a>, <a href="#_hdopen">_hdopen</a>,
 <a href="#open">open</a>, <a href="#_open_osfhandle">_open_osfhandle</a>, <a href="#_popen">_popen</a>, <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY | O_TEXT );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp = fdopen( handle, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; process the stream</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>fdopen is POSIX 1003.1
<br>_fdopen is not POSIX
<br>_wfdopen is not POSIX
</dl>
<dl>
<dt>Systems:
<dd><tt> fdopen - All, Netware</tt>
<br><tt>_fdopen - All, Netware</tt>
<br><tt>_wfdopen - All</tt>
</dl>
<h2 id="feclearexcept"> feclearexcept </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><tt>int feclearexcept( int __excepts );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> feclearexcept</tt> function attempts to clear the supported floating-point exceptions represented by its argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> feclearexcept</tt> function returns zero if the excepts argument is zero or if all the specified exceptions were successfully
 cleared.&nbsp; Otherwise, it returns a nonzero value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fegetexceptflag">fegetexceptflag</a>, <a href="#feraiseexcept">feraiseexcept</a>, <a href="#fesetexceptflag">fesetexceptflag</a>,
 <a href="#fetestexcept">fetestexcept</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; feclearexcept( FE_OVERFLOW|FE_UNDERFLOW );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>C99
</dl>
<h2 id="__fedisableexcept"> __fedisableexcept </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><tt>void __fedisableexcept( int __excepts );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> __fedisableexcept</tt> function disables the specified floating point exceptions.
</dl>
<dl>
<dt>Returns:
<dd>No value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#__feenableexcept">__feenableexcept</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; __fedisableexcept( FE_DIVBYZERO );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<h2 id="__feenableexcept"> __feenableexcept </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><tt>void __feenableexcept( int __excepts );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> __feenableexcept</tt> function enables the specified floating point exceptions.
</dl>
<dl>
<dt>Returns:
<dd>No value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#__fedisableexcept">__fedisableexcept</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; __feenableexcept( FE_DIVBYZERO );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<h2 id="fegetenv"> fegetenv </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><tt>int fegetenv( fenv_t *__envp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fegetenv</tt> function attempts to store the current floating-point environment in the object pointed to by envp.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fegetenv</tt> function returns zero if the environment was successfully stored.&nbsp; Otherwise, it returns a nonzero
 value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#feholdexcept">feholdexcept</a>, <a href="#fesetenv">fesetenv</a>, <a href="#feupdateenv">feupdateenv</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fenv_t env;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fegetenv( &amp;env );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>C99
</dl>
<h2 id="fegetexceptflag"> fegetexceptflag </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><tt>int fegetexceptflag( fexcept_t *__flagp, int __excepts );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fegetexceptflag</tt> function attempts to store a representation of the states of the floating-point status flags
 indicated by the argument excepts in the object pointed to by the argument flagp.
<br>Valid exceptions are <tt> FE_INVALID</tt>, <tt> FE_DENORMAL</tt>, <tt> FE_DIVBYZERO</tt>, <tt> FE_OVERFLOW</tt>, <tt>
 FE_UNDERFLOW</tt> and <tt> FE_INEXACT</tt>.
<br><br>The value <tt> FE_ALL_EXCEPT</tt> is the logical OR of these values.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fegetexceptflag</tt> function returns zero if the representation was successfully stored.&nbsp; Otherwise, it returns
 a nonzero value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#feclearexcept">feclearexcept</a>, <a href="#feraiseexcept">feraiseexcept</a>, <a href="#fesetexceptflag">fesetexceptflag</a>,
 <a href="#fetestexcept">fetestexcept</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fexcept_t flags;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fegetexceptflag( &amp;flags, FE_DIVBYZERO );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>C99
</dl>
<h2 id="fegetround"> fegetround </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><tt>int fegetround( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fegetround</tt> function gets the current rounding direction.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fegetround</tt> function returns the value of the rounding direction macro representing the current rounding direction
 or a negative value if there is no such rounding direction macro or the current rounding direction is not determinable.
<br>Valid rounding modes are <tt> FE_TONEAREST</tt> <tt> FE_DOWNWARD</tt> <tt> FE_TOWARDZERO</tt> <tt> FE_UPWARD</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#fesetround">fesetround</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int mode;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mode = fegetround();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if ( mode == FE_TONEAREST )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Nearest\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else if ( mode == FE_DOWNWARD )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Down\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else if ( mode == FE_TOWARDZERO )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;To Zero\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else if ( mode == FE_UPWARD )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Up\n&quot; );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>C99
</dl>
<h2 id="feholdexcept"> feholdexcept </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><tt>int feholdexcept( fenv_t *__envp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> feholdexcept</tt> function saves the current floating-point environment in the object pointed to by envp, clears the
 floating-point status flags, and then installs a non-stop (continue on floating-point exceptions) mode, if available, for
 all floating-point exceptions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> feholdexcept</tt> function returns zero if and only if non-stop floating-point exception handling was successfully
 installed.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fegetenv">fegetenv</a>, <a href="#fesetenv">fesetenv</a>, <a href="#feupdateenv">feupdateenv</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fenv_t env;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; feholdexcept( &amp;env );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>C99
</dl>
<h2 id="feof"> feof </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int feof( FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> feof</tt> function tests the end-of-file indicator for the stream pointed to by<b> fp</b>.&nbsp; Because this indicator
 is set when an input operation attempts to read past the end of the file the<tt> feof</tt> function will detect the end of
 the file only after an attempt is made to read beyond the end of the file.&nbsp; Thus, if a file contains 10 lines, the<tt>
 feof</tt> will not detect end of file after the tenth line is read; it will detect end of file once the program attempts
 to read more data.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> feof</tt> function returns non-zero if the end-of-file indicator is set for<b> fp</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#clearerr">clearerr</a>, <a href="#ferror">ferror</a>, <a href="#fopen">fopen</a>, <a href="#freopen">freopen</a>,
 <a href="#perror">perror</a>, <a href="#read">read</a>, <a href="#strerror">strerror</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void process_record( char *buf )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buf );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;100&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fgets( buffer, sizeof( buffer ), fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( ! feof( fp ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; process_record( buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets( buffer, sizeof( buffer ), fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="feraiseexcept"> feraiseexcept </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><tt>int feraiseexcept( int __excepts );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> feraiseexcept</tt> function attempts to raise the supported floating-point exceptions represented by its argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> feraiseexcept</tt> function returns zero if the excepts argument is zero or if all the specified exceptions were successfully
 raised.&nbsp; Otherwise, it returns a nonzero value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#feclearexcept">feclearexcept</a>, <a href="#fegetexceptflag">fegetexceptflag</a>, <a href="#fetestexcept">fetestexcept</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; feraiseexcept( FE_DIVBYZERO );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>C99
</dl>
<h2 id="ferror"> ferror </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int ferror( FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ferror</tt> function tests the error indicator for the stream pointed to by<b> fp</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ferror</tt> function returns non-zero if the error indicator is set for<b> fp</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#clearerr">clearerr</a>, <a href="#feof">feof</a>, <a href="#perror">perror</a>, <a href="#strerror">strerror</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = fgetc( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( ferror( fp ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error reading file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="fesetenv"> fesetenv </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><tt>int fesetenv( const fenv_t *__envp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fesetenv</tt> function attempts to establishe the floating-point environment represented by the object pointed to
 by envp.&nbsp; The argument envp shall point to an object set by a call to <tt> fegetenv</tt> or <tt> feholdexcept</tt> ,
 or equal the <tt> FE_DFL_ENV</tt> macro.&nbsp; Note that fesetenv merely installs the state of the floating-point status
 flags represented through its argument, and does not raise these floating-point exceptions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fesetenv</tt> function returns zero if the environment was successfully established.&nbsp; Otherwise, it returns a
 nonzero value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fegetenv">fegetenv</a>, <a href="#feholdexcept">feholdexcept</a>, <a href="#feupdateenv">feupdateenv</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fenv_t env;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fegetenv( &amp;env );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fesetenv( FE_DFL_ENV );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fesetenv( &amp;env );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>C99
</dl>
<h2 id="fesetexceptflag"> fesetexceptflag </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><tt>int fesetexceptflag( const fexcept_t *__flagp, int __excepts );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fesetexceptflag</tt> function attempts to set the floating-point status flags indicated by the argument excepts to
 the states stored in the object pointed to by flagp.&nbsp; The value of *flagp shall have been set by a previous call to
 <tt> fegetexceptflag</tt> whose second argument represented at least those floating-point exceptions represented by the argument
 excepts.&nbsp; This function does not raise floating-point exceptions, but only sets the state of the flags.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fesetexceptflag</tt> function returns zero if the excepts argument is zero or if all the specified flags were successfully
 set to the appropriate state.&nbsp; Otherwise, it returns a nonzero value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#feclearexcept">feclearexcept</a>, <a href="#fegetexceptflag">fegetexceptflag</a>, <a href="#fetestexcept">fetestexcept</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fexcept_t flags;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fgetexceptflag( &amp;flags, FE_DENORMAL|FE_INVALID );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fsetexceptflag( &amp;flags, FE_INVALID );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>C99
</dl>
<h2 id="fesetround"> fesetround </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><tt>int fesetround( int __round );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fesetround</tt> function establishes the rounding direction represented by its argument round.&nbsp; If the argument
 is not equal to the value of a rounding direction macro, the rounding direction is not changed.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fesetround</tt> function returns a zero value if and only if the requested rounding direction was established.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fegetround">fegetround</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fesetround( FE_UPWARD );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>C99
</dl>
<h2 id="fetestexcept"> fetestexcept </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><tt>int fetestexcept( int __excepts );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fetestexcept</tt> function determines which of a specified subset of the floatingpoint exception flags are currently
 set.&nbsp; The excepts argument specifies the floating point status flags to be queried.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fetestexcept</tt> function returns the value of the bitwise OR of the floating-point exception macros corresponding
 to the currently set floating-point exceptions included in excepts.
</dl>
<dl>
<dt>See Also:
<dd><a href="#feclearexcept">feclearexcept</a>, <a href="#fegetexceptflag">fegetexceptflag</a>, <a href="#feraiseexcept">feraiseexcept</a>,
 <a href="#fesetexceptflag">fesetexceptflag</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int excepts;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; feclearexcept( FE_DIVBYZERO );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; ...code that may cause a divide by zero exception</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; excepts = fetestexcept( FE_DIVBYZERO );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if ( excepts &amp; FE_DIVBYZERO)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Divide by zero occurred\n&quot; );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>C99
</dl>
<h2 id="feupdateenv"> feupdateenv </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><tt>int feupdateenv( const fenv_t *__envp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> feupdateenv</tt> function attempts to save the currently raised floating-point exceptions in its automatic storage,
 installs the floating-point environment represented by the object pointed to by envp, and then raises the saved floating-point
 exceptions.&nbsp; The argument envp shall point to an object set by a call to feholdexcept or fegetenv, or equal a floating-point
 environment macro.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> feupdateenv</tt> function returns zero if all the actions were successfully carried out.&nbsp; Otherwise, it returns
 a nonzero value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fegetenv">fegetenv</a>, <a href="#feholdexcept">feholdexcept</a>, <a href="#fesetenv">fesetenv</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;fenv.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fenv_t env;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fegetenv( &amp;env );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fesetenv( FE_DFL_ENV );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; feupdateenv( &amp;env );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>C99
</dl>
<h2 id="fflush"> fflush </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fflush( FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>If the file<b> fp</b> is open for output or update, the<tt> fflush</tt> function causes any unwritten data to be written to
 the file.&nbsp; If the file<b> fp</b> is open for input or update, the<tt> fflush</tt> function undoes the effect of any
 preceding <tt> ungetc</tt> operation on the stream.&nbsp; If the value of<b> fp</b> is<tt> NULL,</tt> then all files that
 are open will be flushed.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fflush</tt> function returns non-zero if a write error occurs and zero otherwise.&nbsp; When an error has occurred,
 <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fgetc">fgetc</a>, <a href="#fgets">fgets</a>, <a href="#flushall">flushall</a>, <a href="#fopen">fopen</a>, <a href="#getc">getc</a>,
 <a href="#gets">gets</a>, <a href="#setbuf">setbuf</a>, <a href="#setvbuf">setvbuf</a>, <a href="#ungetc">ungetc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Press any key to continue...&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fflush( stdout );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="ffs"> ffs </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strings.h&gt;</tt>
<br><tt>int ffs( int i );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ffs</tt> finds the first bit set, beginning with the least significant bit, in<b> i</b>.&nbsp; Bits are numbered starting
 at one (the least significant bit).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ffs</tt> function returns the index of the first bit set.&nbsp; If<b> i</b> is 0,<tt> ffs</tt> returns zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_lrotl">_lrotl</a>, <a href="#_lrotr">_lrotr</a>, <a href="#_rotl">_rotl</a>, <a href="#_rotr">_rotr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;strings.h&gt;</tt>
<br><br><tt>int main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, ffs( 0 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, ffs( 16 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, ffs( 127 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, ffs( -16 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>0</tt>
<br><tt>5</tt>
<br><tt>1</tt>
<br><tt>5</tt>
</dl>
<dl>
<dt>Classification:
<dd>POSIX
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="fgetc"> fgetc, fgetwc </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fgetc( FILE *fp );</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wint_t fgetwc( FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fgetc</tt> function gets the next character from the file designated by<b> fp</b>.&nbsp; The character is<tt> signed.</tt>
<br>The<tt> fgetwc</tt> function is identical to<tt> fgetc</tt> except that it gets the next multibyte character (if present)
 from the input stream pointed to by<b> fp</b> and converts it to a wide character.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fgetc</tt> function returns the next character from the input stream pointed to by<b> fp</b>.&nbsp; If the stream
 is at end-of-file, the end-of-file indicator is set and<tt> fgetc</tt> returns <tt> EOF</tt>.&nbsp; If a read error occurs,
 the error indicator is set and<tt> fgetc</tt> returns <tt> EOF</tt>.
<br>The<tt> fgetwc</tt> function returns the next wide character from the input stream pointed to by<b> fp</b>.&nbsp; If the
 stream is at end-of-file, the end-of-file indicator is set and<tt> fgetwc</tt> returns <tt> WEOF</tt>.&nbsp; If a read error
 occurs, the error indicator is set and<tt> fgetwc</tt> returns <tt> WEOF</tt>.&nbsp; If an encoding error occurs, <tt> errno</tt>
 is set to <tt> EILSEQ</tt> and<tt> fgetwc</tt> returns <tt> WEOF</tt>.
<br><br>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fgetchar">fgetchar</a>, <a href="#fgets">fgets</a>, <a href="#fopen">fopen</a>, <a href="#getc">getc</a>, <a href="#getchar">getchar</a>,
 <a href="#gets">gets</a>, <a href="#ungetc">ungetc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetc( fp )) != EOF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputc( c, stdout );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>fgetc is ANSI
<br>fgetwc is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> fgetc - All, Netware</tt>
<br><tt>fgetwc - All</tt>
</dl>
<h2 id="fgetchar"> fgetchar, _fgetchar, _fgetwchar </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fgetchar( void );</tt>
<br><tt>int _fgetchar( void );</tt>
<br><tt>wint_t _fgetwchar( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fgetchar</tt> function is equivalent to <tt> fgetc</tt> with the argument <tt> stdin</tt>.
<br>The<tt> _fgetchar</tt> function is identical to<tt> fgetchar</tt>.&nbsp; Use<tt> _fgetchar</tt> for ANSI naming conventions.
<br><br>The<tt> _fgetwchar</tt> function is identical to<tt> fgetchar</tt> except that it gets the next multibyte character
 (if present) from the input stream pointed to by <tt> stdin</tt> and converts it to a wide character.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fgetchar</tt> function returns the next character from the input stream pointed to by <tt> stdin</tt>.&nbsp; If the
 stream is at end-of-file, the end-of-file indicator is set and<tt> fgetchar</tt> returns <tt> EOF</tt>.&nbsp; If a read error
 occurs, the error indicator is set and<tt> fgetchar</tt> returns <tt> EOF</tt>.
<br>The<tt> _fgetwchar</tt> function returns the next wide character from the input stream pointed to by <tt> stdin</tt>.
&nbsp; If the stream is at end-of-file, the end-of-file indicator is set and<tt> _fgetwchar</tt> returns <tt> WEOF</tt>.&nbsp;
 If a read error occurs, the error indicator is set and<tt> _fgetwchar</tt> returns <tt> WEOF</tt>.&nbsp; If an encoding error
 occurs, <tt> errno</tt> is set to <tt> EILSEQ</tt> and<tt> _fgetwchar</tt> returns <tt> WEOF</tt>.
<br><br>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fgetc">fgetc</a>, <a href="#fgets">fgets</a>, <a href="#fopen">fopen</a>, <a href="#getc">getc</a>, <a href="#getchar">getchar</a>,
 <a href="#gets">gets</a>, <a href="#ungetc">ungetc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = freopen( &quot;file&quot;, &quot;r&quot;, stdin );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetchar()) != EOF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputchar(c);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> fgetchar - All, Netware</tt>
<br><tt>_fgetchar - All, Netware</tt>
<br><tt>_fgetwchar - All</tt>
</dl>
<h2 id="fgetpos"> fgetpos </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fgetpos( FILE *fp, fpos_t *pos );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fgetpos</tt> function stores the current position of the file<b> fp</b> in the object pointed to by<b> pos</b>.&nbsp;
 The value stored is usable by the <tt> fsetpos</tt> function for repositioning the file to its position at the time of the
 call to the<tt> fgetpos</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fgetpos</tt> function returns zero if successful, otherwise, the<tt> fgetpos</tt> function returns a non-zero value.
&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#fseek">fseek</a>, <a href="#fsetpos">fsetpos</a>, <a href="#ftell">ftell</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fpos_t position;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgetpos( fp, &amp;position ); /* get position&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets( buffer, 80, fp );&nbsp; /* read record&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsetpos( fp, &amp;position ); /* set position&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets( buffer, 80, fp );&nbsp; /* read same record */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="fgets"> fgets, fgetws </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>char *fgets( char *buf, int n, FILE *fp );</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *fgetws( wchar_t *buf, int n, FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fgets</tt> function gets a string of characters from the file designated by<b> fp</b> and stores them in the array
 pointed to by<b> buf</b>.&nbsp; The<tt> fgets</tt> function stops reading characters when end-of-file is reached, or when
 a newline character is read, or when<b> n-1</b> characters have been read, whichever comes first.&nbsp; The new-line character
 is not discarded.&nbsp; A null character is placed immediately after the last character read into the array.
<br>The<tt> fgetws</tt> function is identical to<tt> fgets</tt> except that it gets a string of multibyte characters (if present)
 from the input stream pointed to by<b> fp</b>, converts them to wide characters, and stores them in the wide-character array
 pointed to by<b> buf</b>.&nbsp; In this case,<b> n</b> specifies the number of wide characters, less one, to be read.
<br><br>A common programming error is to assume the presence of a new-line character in every string that is read into the
 array.&nbsp; A new-line character will not be present when more than<b> n-1</b> characters occur before the new-line.&nbsp;
 Also, a new-line character may not appear as the last character in a file, just before end-of-file.
<br><br>The <tt> gets</tt> function is similar to<tt> fgets</tt> except that it operates with<tt> stdin</tt>, it has no size
 argument, and it replaces a newline character with the null character.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fgets</tt> function returns<b> buf</b> if successful.<tt>&nbsp; NULL</tt> is returned if end-of-file is encountered,
 or a read error occurs.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that
 has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fgetc">fgetc</a>, <a href="#fgetchar">fgetchar</a>, <a href="#fopen">fopen</a>, <a href="#getc">getc</a>, <a href="#getchar">getchar</a>,
 <a href="#gets">gets</a>, <a href="#ungetc">ungetc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( fgets( buffer, 80, fp ) != NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs( buffer, stdout );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>fgets is ANSI
<br>fgetws is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> fgets - All, Netware</tt>
<br><tt>fgetws - All</tt>
</dl>
<h2 id="_fieeetomsbin"> _fieeetomsbin </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>extern int _fieeetomsbin( float *src, float *dest );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _fieeetomsbin</tt> function loads the float pointed to by<b> src</b> in IEEE format and converts it to Microsoft binary
 format, storing the result into the float pointed to by<b> dest</b>.
<br>For<tt> _fieeetomsbin</tt>, IEEE Nan's and Infinities will cause overflow.&nbsp; IEEE denormals will be converted if within
 range.&nbsp; Otherwise, they will be converted to 0 in the Microsoft binary format.
<br><br>The range of Microsoft binary format floats is 2.938736e-39 to 1.701412e+38.&nbsp; The range of Microsoft binary format
 doubles is 2.938735877056e-39 to 1.701411834605e+38.
<br><br>Microsoft Binary Format was used by early versions of Microsoft QuickBASIC before coprocessors became standard.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _fieeetomsbin</tt> function returns 0 if the conversion was successful.&nbsp; Otherwise, it returns 1 if conversion
 would cause an overflow.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dieeetomsbin">_dieeetomsbin</a>, <a href="#_dmsbintoieee">_dmsbintoieee</a>, <a href="#_fmsbintoieee">_fmsbintoieee</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; float fieee, fmsb;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; double dieee, dmsb;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fieee = 0.5;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; dieee = -2.0;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Convert IEEE format to Microsoft binary format */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _fieeetomsbin( &amp;fieee, &amp;fmsb );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dieeetomsbin( &amp;dieee, &amp;dmsb );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Convert Microsoft binary format back to IEEE format */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _fmsbintoieee( &amp;fmsb, &amp;fieee );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dmsbintoieee( &amp;dmsb, &amp;dieee );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Display results */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;fieee = %f, dieee = %f\n&quot;, fieee, dieee );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>fieee = 0.500000, dieee = -2.000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="filelength"> filelength, _filelength, _filelengthi64 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>long filelength( int handle );</tt>
<br><tt>long _filelength( int handle );</tt>
<br><tt>__int64 _filelengthi64( int handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> filelength</tt> function returns, as a 32-bit long integer, the number of bytes in the opened file indicated by the
 file handle<b> handle</b>.
<br>The<tt> _filelengthi64</tt> function returns, as a 64-bit integer, the number of bytes in the opened file indicated by
 the file handle<b> handle</b>.
<br><br>The<tt> _filelength</tt> function is identical to<tt> filelength</tt>.&nbsp; Use<tt> _filelength</tt> for ANSI/ISO
 naming conventions.
</dl>
<dl>
<dt>Returns:
<dd>If an error occurs in<tt> filelength</tt>, (-1L) is returned.
<br>If an error occurs in<tt> _filelengthi64</tt>, (-1I64) is returned.
<br><br>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<br><br>Otherwise, the number of bytes written to the file is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fstat">fstat</a>, <a href="#lseek">lseek</a>, <a href="#tell">tell</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* open a file for input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY | O_TEXT );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Size of file is %ld bytes\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filelength( handle ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Size of file is 461 bytes</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> filelength - All, Netware</tt>
<br><tt>_filelength - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_filelengthi64 - All</tt>
</dl>
<h2 id="FILENAME_MAX"> FILENAME_MAX </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#define FILENAME_MAX 123</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> FILENAME_MAX</tt> macro is the size of an array of char big enough to hold a string naming any file that the implementation
 expects to open; If there is no practical file name length limit,<tt> FILENAME_MAX</tt> is the recommended size of such an
 array.&nbsp; As file name string contents must meet other system-specific constraints, some strings of length<tt> FILENAME_MAX</tt>
 may not work.
<br><tt>FILENAME_MAX</tt> typically sizes an array to hold a file name.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> FILENAME_MAX</tt> macro returns a positive integer value.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>int main( int argc, char *argv&#91;&#93; )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( argc ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char fname&#91;FILENAME_MAX&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( fname, argv&#91;0&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( fname );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="fileno"> fileno </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fileno( FILE *stream );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fileno</tt> function returns the number of the file handle for the file designated by<b> stream</b>.&nbsp; This number
 can be used in POSIX input/output calls anywhere the value returned by <tt> open</tt> can be used.&nbsp; The following symbolic
 values in<tt> &lt;io.h&gt;</tt> define the file handles that are associated with the C language <b> stdin, stdout, stderr,
 stdaux,</b> and<b> stdprn</b> files when the application is started.&nbsp; The<b> stdaux</b> and<b> stdprn</b> files are
 not available for Win32.
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>STDIN_FILENO
<dd>Standard input file number,<b> stdin</b> (0)
<dt><br>STDOUT_FILENO
<dd>Standard output file number,<b> stdout</b> (1)
<dt><br>STDERR_FILENO
<dd>Standard error file number,<b> stderr</b> (2)
<dt><br>STDAUX_FILENO
<dd>Standard auxiliary file number,<b> stdaux</b> (3)
<dt><br>STDPRN_FILENO
<dd>Standard printer file number,<b> stdprn</b> (4)
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fileno</tt> function returns the number of the file handle for the file designated by<b> stream</b>.&nbsp; If an error
 occurs, a value of -1 is returned and <tt> errno</tt> is set to indicate the error.
</dl>
<dl>
<dt>See Also:
<dd><a href="#open">open</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *stream;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; stream = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;File number is %d\n&quot;, fileno( stream ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( stream );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>File number is 7</tt>
</dl>
<dl>
<dt>Classification:
<dd>POSIX 1003.1
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_findclose"> _findclose </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int _findclose( long handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _findclose</tt> function closes the directory of filenames established by a call to the <tt> _findfirst</tt> function.
&nbsp; The<b> handle</b> argument was returned by the <tt> _findfirst</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>If successful,<tt> _findclose</tt> returns 0 otherwise,<tt> _findclose</tt> and returns -1 and sets <tt> errno</tt> to one
 of the following values:
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>ENOENT
<dd>No matching files
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_find___">_dos_find...</a>, <a href="#_findfirst">_findfirst</a>, <a href="#_findnext">_findnext</a>, <a href="#closedir">closedir</a>,
 <a href="#opendir">opendir</a>, <a href="#readdir">readdir</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct _finddata_t&nbsp; fileinfo;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Display name and size of &quot;*.c&quot; files */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; handle = _findfirst( &quot;*.c&quot;, &amp;fileinfo );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( rc != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%14s %10ld\n&quot;, fileinfo.name,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileinfo.size );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = _findnext( handle, &amp;fileinfo );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _findclose( handle );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_findfirst"> _findfirst, _findfirsti64, _wfindfirst, _wfindfirsti64 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>long _findfirst( const char *filespec,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _finddata_t
 *fileinfo );</tt>
<br><tt>long _findfirsti64( const char *filespec,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 struct _finddatai64_t *fileinfo );</tt>
<br><tt>long _wfindfirst( const wchar_t *filespec,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wfinddata_t
 *fileinfo );</tt>
<br><tt>long _wfindfirsti64( const wchar_t *filespec,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wfinddatai64_t
 *fileinfo );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _findfirst</tt> function returns information on the first file whose name matches the<b> filespec</b> argument.&nbsp;
 The<b> filespec</b> argument may contain wildcard characters ('?' and '*').&nbsp; The information is returned in a <tt> _finddata_t</tt>
 structure pointed to by<b> fileinfo</b>.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct _finddata_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fsize_t&nbsp; size;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name&#91;_MAX_PATH&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The<tt> _findfirsti64</tt> function returns information on the first file whose name matches the<b> filespec</b> argument.
&nbsp; It differs from the<tt> _findfirst</tt> function in that it returns a 64-bit file size.&nbsp; The<b> filespec</b> argument
 may contain wildcard characters ('?' and '*').&nbsp; The information is returned in a <tt> _finddatai64_t</tt> structure
 pointed to by<b> fileinfo</b>.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct _finddatai64_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64&nbsp;&nbsp; size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
 64-bit size info */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name&#91;_MAX_PATH&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The wide-character<tt> _wfindfirst</tt> function is similar to the<tt> _findfirst</tt> function but operates on wide-character
 strings.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct _wfinddata_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fsize_t&nbsp; size;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp; name&#91;_MAX_PATH&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The wide-character<tt> _wfindfirsti64</tt> function is similar to the<tt> _findfirsti64</tt> function but operates
 on wide-character strings.&nbsp; It differs from the<tt> _wfindfirst</tt> function in that it returns a 64-bit file size.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct _wfinddatai64_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64&nbsp;&nbsp; size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
 64-bit size info */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp; name&#91;_MAX_PATH&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
</dl>
<dl>
<dt>Returns:
<dd>If successful,<tt> _findfirst</tt> returns a unique search handle identifying the file or group of files matching the<b> filespec</b>
 specification, which can be used in a subsequent call to <tt> _findnext</tt> or to <tt> _findclose</tt>.&nbsp; Otherwise,<tt>
 _findfirst</tt> and returns -1 and sets <tt> errno</tt> to one of the following values:
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>ENOENT
<dd>No matching files
<dt><br>EINVAL
<dd>Invalid filename specification
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_find___">_dos_find...</a>, <a href="#_findclose">_findclose</a>, <a href="#_findnext">_findnext</a>, <a href="#closedir">closedir</a>,
 <a href="#opendir">opendir</a>, <a href="#readdir">readdir</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct _finddata_t&nbsp; fileinfo;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Display name and size of &quot;*.c&quot; files */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; handle = _findfirst( &quot;*.c&quot;, &amp;fileinfo );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( rc != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%14s %10ld\n&quot;, fileinfo.name,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileinfo.size );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = _findnext( handle, &amp;fileinfo );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _findclose( handle );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd><tt> _findfirst - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_findfirsti64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wfindfirst - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wfindfirsti64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_findnext"> _findnext, _findnexti64, _wfindnext, _wfindnexti64 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int _findnext( long handle,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _finddata_t *fileinfo
 );</tt>
<br><tt>int _findnexti64( long handle,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _finddatai64_t
 *fileinfo );</tt>
<br><tt>int _wfindnext( long handle,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wfinddata_t *fileinfo
 );</tt>
<br><tt>int _wfindnexti64( long handle,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct
 _wfinddatai64_t *fileinfo );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _findnext</tt> function returns information on the next file whose name matches the<b> filespec</b> argument that
 was specified in a call to the <tt> _findfirst</tt> function.&nbsp; The<b> handle</b> argument was returned by the <tt> _findfirst</tt>
 function.&nbsp; The information is returned in a <tt> _finddata_t</tt> structure pointed to by<b> fileinfo</b>.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct _finddata_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fsize_t&nbsp; size;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name&#91;_MAX_PATH&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The<tt> _findnexti64</tt> function returns information on the next file whose name matches the<b> filespec</b> argument
 that was specified in a call to the <tt> _findfirsti64</tt> function.&nbsp; It differs from the<tt> _findnext</tt> function
 in that it returns a 64-bit file size.&nbsp; The<b> handle</b> argument was returned by the <tt> _findfirsti64</tt> function.
&nbsp; The information is returned in a <tt> _finddatai64_t</tt> structure pointed to by<b> fileinfo</b>.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct _finddatai64_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64&nbsp;&nbsp; size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
 64-bit size info */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name&#91;_MAX_PATH&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The wide-character<tt> _wfindnext</tt> function is similar to the<tt> _findnext</tt> function but operates on wide-character
 strings.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct _wfinddata_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fsize_t&nbsp; size;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp; name&#91;_MAX_PATH&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The wide-character<tt> _wfindnexti64</tt> function is similar to the<tt> _findnexti64</tt> function but operates on
 wide-character strings.&nbsp; It differs from the<tt> _wfindnext</tt> function in that it returns a 64-bit file size.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct _wfinddatai64_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned&nbsp; attrib;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_create;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_access;&nbsp; /* -1 for FAT file systems */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp; time_write;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __int64&nbsp;&nbsp; size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*
 64-bit size info */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp; name&#91;_MAX_PATH&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
</dl>
<dl>
<dt>Returns:
<dd>If successful,<tt> _findnext</tt> returns 0 otherwise,<tt> _findnext</tt> and returns -1 and sets <tt> errno</tt> to one of
 the following values:
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>ENOENT
<dd>No matching files
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_find___">_dos_find...</a>, <a href="#_findclose">_findclose</a>, <a href="#_findfirst">_findfirst</a>, <a href="#closedir">closedir</a>,
 <a href="#opendir">opendir</a>, <a href="#readdir">readdir</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct _finddata_t&nbsp; fileinfo;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Display name and size of &quot;*.c&quot; files */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; handle = _findfirst( &quot;*.c&quot;, &amp;fileinfo );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( rc != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%14s %10ld\n&quot;, fileinfo.name,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fileinfo.size );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = _findnext( handle, &amp;fileinfo );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _findclose( handle );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd><tt> _findnext - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_findnexti64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wfindnext - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wfindnexti64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_finite"> _finite </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;float.h&gt;</tt>
<br><tt>int _finite( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _finite</tt> function determines whether the double precision floating-point argument is a valid number (i.e., not
 infinite and not a NAN).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _finite</tt> function returns 0 if the number is not valid and non-zero otherwise.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_clear87">_clear87</a>, <a href="#_control87">_control87</a>, <a href="#_controlfp">_controlfp</a>, <a href="#_fpreset">_fpreset</a>,
 <a href="#printf">printf</a>, <a href="#_status87">_status87</a>, <a href="#isfinite">isfinite</a>, <a href="#fpclassify">fpclassify</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;float.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, (_finite( 1.797693134862315e+308 ) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? &quot;Valid&quot; : &quot;Invalid&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, (_finite( 1.797693134862320e+308 ) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? &quot;Valid&quot; : &quot;Invalid&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Valid</tt>
<br><tt>Invalid</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="_floodfill"> _floodfill, _floodfill_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _floodfill( short x, short y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; short stop_color );</tt>
<br><br><tt>short _FAR _floodfill_w( double x, double y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short stop_color );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _floodfill</tt> functions fill an area of the screen.&nbsp; The<tt> _floodfill</tt> function uses the view coordinate
 system.&nbsp; The<tt> _floodfill_w</tt> function uses the window coordinate system.
<br>The filling starts at the point<tt> (x,y)</tt> and continues in all directions:&nbsp; when a pixel is filled, the neighbouring
 pixels (horizontally and vertically) are then considered for filling.&nbsp; Filling is done using the current color and fill
 mask.&nbsp; No filling will occur if the point<tt> (x,y)</tt> lies outside the clipping region.
<br><br>If the argument<b> stop_color</b> is a valid pixel value, filling will occur in each direction until a pixel is encountered
 with a pixel value of<b> stop_color</b>.&nbsp; The filled area will be the area around<tt> (x,y),</tt> bordered by<b> stop_color</b>.
&nbsp; No filling will occur if the point<tt> (x,y)</tt> has the pixel value<b> stop_color</b>.
<br><br>If<b> stop_color</b> has the value (-1), filling occurs until a pixel is encountered with a pixel value different
 from the pixel value of the starting point<tt> (x,y).</tt>&nbsp; No filling will occur if the pixel value of the point<tt>
 (x,y)</tt> is the current color.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _floodfill</tt> functions return zero when no filling takes place; a non-zero value is returned to indicate that filling
 has occurred.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setcliprgn">_setcliprgn</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_setfillmask">_setfillmask</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setcolor( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _ellipse( _GBORDER, 120, 90, 520, 390 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setcolor( 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _floodfill( 320, 240, 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>_floodfill is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _floodfill - DOS, QNX</tt>
<br><tt>_floodfill_w - DOS, QNX</tt>
</dl>
<h2 id="floor"> floor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double floor( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> floor</tt> function computes the largest integer not greater than<b> x</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> floor</tt> function computes the largest integer not greater than<b> x</b>, expressed as a<tt> double.</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#ceil">ceil</a>, <a href="#fmod">fmod</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, floor( -3.14 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, floor( -3. ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, floor( 0. ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, floor( 3.14 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, floor( 3. ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>-4.000000</tt>
<br><tt>-3.000000</tt>
<br><tt>0.000000</tt>
<br><tt>3.000000</tt>
<br><tt>3.000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="flushall"> flushall </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int flushall( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> flushall</tt> function clears all buffers associated with input streams and writes any buffers associated with output
 streams.&nbsp; A subsequent read operation on an input file causes new data to be read from the associated file or device.
<br>Calling the<tt> flushall</tt> function is equivalent to calling the <tt> fflush</tt> for all open stream files.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> flushall</tt> function returns the number of open streams.&nbsp; When an output error occurs while writing to a file,
 the <tt> errno</tt> global variable will be set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#fflush">fflush</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The number of open files is %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flushall() );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>The number of open files is 4</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="fmod"> fmod </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double fmod( double x, double y );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fmod</tt> function computes the floating-point remainder of<b> x/y</b>, even if the quotient<b> x/y</b> is not representable.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fmod</tt> function returns the value<b> x - (i * y)</b>, for some integer<b> i</b> such that, if<b> y</b> is non-zero,
 the result has the same sign as<b> x</b> and magnitude less than the magnitude of<b> y</b>.&nbsp; If the value of<b> y</b>
 is zero, then the value returned is zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#ceil">ceil</a>, <a href="#fabs">fabs</a>, <a href="#floor">floor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, fmod(&nbsp; 4.5,&nbsp; 2.0 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, fmod( -4.5,&nbsp; 2.0 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, fmod(&nbsp; 4.5, -2.0 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, fmod( -4.5, -2.0 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.500000</tt>
<br><tt>-0.500000</tt>
<br><tt>0.500000</tt>
<br><tt>-0.500000</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="_fmsbintoieee"> _fmsbintoieee </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>extern int _fmsbintoieee( float *src, float *dest );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _fmsbintoieee</tt> function loads the float pointed to by<b> src</b> in Microsoft binary format and converts it to
 IEEE format, storing the result &amp;into the float pointed to by<b> dest</b>.
<br>The range of Microsoft binary format floats is 2.938736e-39 to 1.701412e+38.&nbsp; The range of Microsoft binary format
 doubles is 2.938735877056e-39 to 1.701411834605e+38.
<br><br>Microsoft Binary Format was used by early versions of Microsoft QuickBASIC before coprocessors became standard.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _fmsbintoieee</tt> function returns 0 if the conversion was successful.&nbsp; Otherwise, it returns 1 if conversion
 would cause an overflow.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dieeetomsbin">_dieeetomsbin</a>, <a href="#_dmsbintoieee">_dmsbintoieee</a>, <a href="#_fieeetomsbin">_fieeetomsbin</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; float fieee, fmsb;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; double dieee, dmsb;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fieee = 0.5;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; dieee = -2.0;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Convert IEEE format to Microsoft binary format */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _fieeetomsbin( &amp;fieee, &amp;fmsb );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dieeetomsbin( &amp;dieee, &amp;dmsb );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Convert Microsoft binary format back to IEEE format */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _fmsbintoieee( &amp;fmsb, &amp;fieee );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _dmsbintoieee( &amp;dmsb, &amp;dieee );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Display results */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;fieee = %f, dieee = %f\n&quot;, fieee, dieee );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>fieee = 0.500000, dieee = -2.000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="fnmatch"> fnmatch </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fnmatch.h&gt;</tt>
<br><tt>int fnmatch( const char *pattern,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *string, int flags );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fnmatch</tt> function checks the string specified by the<b> string</b> argument to see if it matches the pattern specified
 by the<b> pattern</b> argument.
<br>The<b> flag</b> argument is a bitwise inclusive OR of the bits described below.&nbsp; It modifies the interpretation of<b>
 pattern</b> and<b> string</b>.
<dl>
<dt>Flag&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>FNM_PATHNAME
<dd>If set, a path separator in<b> string</b> is explicitly matched by a slash in<b> pattern</b>.&nbsp; It isn't matched by either
 the asterisk or question mark special characters, or by a bracket expression.
<dt><br>FNM_PERIOD
<dd>If set, a leading period in<b> string</b> matches a period in<b> pattern</b>, where the definition of &quot;leading&quot;
 depends on FNM_PATHNAME:
<ul>
<li>If FNM_PATHNAME is set, a period is leading if it's the first character in<b> string</b>, or if it immediately follows
 a path separator.
<li>If FNM_PATHNAME isn't set, a period is leading only if it's the first character in<b> string</b>.
</ul>
<dt><br>FNM_NOESCAPE
<dd>If set, disables backslash escaping:
<ul>
<li>If FNM_NOESCAPE isn't set in<b> flags</b>, a backslash character (\) in<b> pattern</b> followed by any other character
 matches that second character in<b> string</b>.&nbsp; In particular, \\ matches a backslash in<b> string</b>.
<li>If FNM_NOESCAPE is set, a backslash character is treated as an ordinary character.
</ul>
<dt><br>FNM_IGNORECASE
<dd>If set, the matching is case-insensitive.
<dt><br>FNM_CASEFOLD
<dd>A synonym for FNM_IGNORECASE.
<dt><br>FNM_LEADING_DIR
<dd>If set, the final path separator and any following characters in<b> string</b> are ignored during matching.
</dl>
<br>A pattern-matching special character that is quoted is a pattern that matches the special character itself.&nbsp; When
 not quoted, such special characters have special meaning in the specification of patterns.&nbsp; The pattern-matching special
 characters and the contexts in which they have their special meaning are as follows:
<dl>
<dt>?
<dd>a ?&nbsp; is a pattern that matches any printable or nonprintable character except &lt;newline&gt;.
<dt><br>*
<dd>the * matches any string, including the null string.
<dt><br>&#91;br_exp&#93;
<dd>a pattern that matches a single character as per Regular Expression Bracket Expressions (1003.2 2.9.1.2) except that
<ul>
<li>The exclamation point character (!) replaces the circumflex character (^) in its role as a nonmatching list in the regular
 expression notation.
<li>The backslash is used as an escape character within bracket expressions.
</ul>
</dl>
<br>The<tt> ?, *</tt> and<tt> &#91;</tt> characters aren't special when used inside a bracket expression.
<br>The concatenation of patterns matching a single character is a valid pattern that matches the concatenation of the single
 characters matched by each of the concatenated patterns.&nbsp; For example, the pattern<tt> a&#91;bc&#93;</tt> matches the
 strings<tt> ab</tt> and<tt> ac.</tt>
<br><br>The concatenation of one or more patterns matching a single character with one or more asterisks (*) is a valid pattern.
&nbsp; In such patterns, each asterisk matches a string of zero or more characters, up to the first character that matches
 the character following the asterisk in the pattern.&nbsp; For example, the pattern<tt> a*d</tt> matches the strings<tt>
 ad, abd,</tt> and<tt> abcd,</tt> but not the string<tt> abc.</tt>
<br><br>When asterisk is the first or last character in a pattern, it matches zero or more characters that precede or follow
 the characters matched by the remainded of the pattern.&nbsp; For example, the pattern<tt> a*d*</tt> matches the strings<tt>
 ad, abcd, abcdef, aaaad</tt> and<tt> adddd.</tt>&nbsp; The pattern<tt> *a*d</tt> matches the strings<tt> ad, abcd, efabcd,
 aaaad</tt> and<tt> adddd.</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fnmatch</tt> function returns zero when<b> string</b> matches the pattern specified by<b> pattern</b>.&nbsp; If there
 is no match, FNM_NOMATCH is returned.&nbsp; If an error occurs,<tt> fnmatch</tt> returns another non-zero value.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;fnmatch.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;limits.h&gt;</tt>
<br><br><tt>int main( int argc, char **argv )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; buffer&#91;PATH_MAX+1&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; while( gets( buffer ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; argc; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fnmatch( argv&#91;i&#93;, buffer, 0 ) == 0
 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;'%s' matches
 pattern '%s'\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; buffer, argv&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( EXIT_SUCCESS );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>POSIX 1003.2
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="fopen"> fopen, _wfopen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>FILE *fopen( const char *filename, const char *mode );</tt>
<br><tt>FILE *_wfopen( const wchar_t *filename,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *mode );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#fopen_s">fopen_s</a> function which is a safer alternative to<tt> fopen</tt>.
&nbsp; This newer<tt> fopen_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> fopen</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> fopen</tt> function opens the file whose name is the string pointed to by<b> filename</b>, and associates a stream
 with it.&nbsp; The argument<b> mode</b> points to a string beginning with one of the following sequences:
<dl>
<dt>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>&quot;r&quot;
<dd>open file for reading
<dt><br>&quot;w&quot;
<dd>create file for writing, or truncate to zero length
<dt><br>&quot;a&quot;
<dd>append:&nbsp; open file or create for writing at end-of-file
<dt><br>&quot;r+&quot;
<dd>open file for update (reading and/or writing)
<dt><br>&quot;w+&quot;
<dd>create file for update, or truncate to zero length
<dt><br>&quot;a+&quot;
<dd>append:&nbsp; open file or create for update, writing at end-of-file
</dl>
<br>In addition to the above characters, you can also include one of the following characters in<b> mode</b> to specify the
 translation mode for newline characters:
<dl>
<dt>t
<dd>The letter &quot;t&quot; may be added to any of the above sequences in the second or later position to indicate that the file
 is (or must be) a text file.&nbsp; It also overrides the global translation mode flag if you link your program with<tt> BINMODE.OBJ.</tt>
&nbsp; The global translation mode flag default is &quot;text&quot; unless you explicitly link your program with<tt> BINMODE.OBJ.</tt>
<br>When neither &quot;t&quot; nor &quot;b&quot; is specified, the value of the global variable <tt> _fmode</tt> establishes
 whether the file is to treated as a binary or a text file.&nbsp; Unless this value is changed by the program or you have
 linked your program with<tt> BINMODE.OBJ,</tt> the default will be text mode.
<dt><br>b
<dd>The letter &quot;b&quot; may be added to any of the above sequences in the second or later position to indicate that the file
 is (or must be) a binary file (an ANSI requirement for portability to systems that make a distinction between text and binary
 files).
</dl>
<br>You can also include one of the following characters to enable or disable the &quot;commit&quot; flag for the associated
 file.
<dl>
<dt>c
<dd>The letter &quot;c&quot; may be added to any of the above sequences in the second or later position to indicate that any output
 is committed by the operating system whenever a flush ( <tt> fflush</tt> or <tt> flushall</tt>) is done.
<br>This option is not supported under Netware.
<dt><br>n
<dd>The letter &quot;n&quot; may be added to any of the above sequences in the second or later position to indicate that the operating
 system need not commit any output whenever a flush is done.&nbsp; It also overrides the global commit flag if you link your
 program with<tt> COMMODE.OBJ.</tt>&nbsp; The global commit flag default is &quot;no-commit&quot; unless you explicitly link
 your program with<tt> COMMODE.OBJ.</tt>
<br>This option is not supported under Netware.
</dl>
<br>The &quot;t&quot;, &quot;c&quot;, and &quot;n&quot; mode options are extensions for<tt> fopen</tt> and <tt> _fdopen</tt>
 and should not be used where ANSI portability is desired.
<br><br>Opening a file with read mode (<tt>r</tt> as the first character in the<b> mode</b> argument) fails if the file does
 not exist or it cannot be read.&nbsp; Opening a file with append mode (<tt>a</tt> as the first character in the<b> mode</b>
 argument) causes all subsequent writes to the file to be forced to the current end-of-file, regardless of previous calls
 to the <tt> fseek</tt> function.&nbsp; When a file is opened with update mode (<tt>+</tt> as the second or later character
 of the<b> mode</b> argument), both input and output may be performed on the associated stream.
<br><br>When a stream is opened in update mode, both reading and writing may be performed.&nbsp; However, writing may not
 be followed by reading without an intervening call to the <tt> fflush</tt> function or to a file positioning function (<tt>
 fseek</tt>, <tt> fsetpos</tt>, <tt> rewind</tt>).&nbsp; Similarly, reading may not be followed by writing without an intervening
 call to a file positioning function, unless the read resulted in end-of-file.
<br><br>The<tt> _wfopen</tt> function is identical to<tt> fopen</tt> except that it accepts wide-character string arguments
 for<b> filename</b> and<b> mode</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fopen</tt> function returns a pointer to the object controlling the stream.&nbsp; This pointer must be passed as a
 parameter to subsequent functions for performing operations on the file.&nbsp; If the open operation fails,<tt> fopen</tt>
 returns<tt> NULL.</tt>&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that
 has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_open">_dos_open</a>, <a href="#fclose">fclose</a>, <a href="#fcloseall">fcloseall</a>, <a href="#fdopen">fdopen</a>,
 <a href="#fopen_s">fopen_s</a>, <a href="#freopen">freopen</a>, <a href="#freopen_s">freopen_s</a>, <a href="#_fsopen">_fsopen</a>,
 <a href="#_grow_handles">_grow_handles</a>, <a href="#_hdopen">_hdopen</a>, <a href="#open">open</a>, <a href="#_open_osfhandle">_open_osfhandle</a>,
 <a href="#_popen">_popen</a>, <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rest of code goes here */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI, ('t', 'c', 'n' are Watcom extensions)
</dl>
<dl>
<dt>Systems:
<dd><tt> fopen - All, Netware</tt>
<br><tt>_wfopen - All</tt>
</dl>
<h2 id="fopen_s"> fopen_s, _wfopen_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>errno_t fopen_s( FILE * restrict * restrict streamptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict
 filename,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict
 mode);</tt>
<br><tt>errno_t _wfopen_s( FILE * restrict * restrict streamptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 wchar_t * restrict filename,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 wchar_t * restrict mode);</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 fopen_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>None of<b> streamptr</b>,<b> filename</b>, or<b> mode</b> shall be a null pointer.&nbsp; If there is a runtime-constraint
 violation,<tt> fopen_s</tt> does not attempt to open a file.&nbsp; Furthermore, if<b> streamptr</b> is not a null pointer,<tt>
 fopen_s</tt> sets<b> *streamptr</b> to the null pointer.
</dl>
<dl>
<dt>Description:
<dd>The<tt> fopen_s</tt> function opens the file whose name is the string pointed to by<b> filename</b>, and associates a stream
 with it.&nbsp; The<b> mode</b> string shall be as described for fopen, with the addition that modes starting with the character
 'w' or 'a' may be preceded by the character 'u', see below:
<dl>
<dt>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>&quot;uw&quot;
<dd>truncate to zero length or create text file for writing, default permissions
<dt><br>&quot;ua&quot;
<dd>append; open or create text file for writing at end-of-file, default permissions
<dt><br>&quot;uwb&quot;
<dd>truncate to zero length or create binary file for writing, default permissions
<dt><br>&quot;uab&quot;
<dd>append; open or create binary file for writing at end-of-file, default permissions
<dt><br>&quot;uw+&quot;
<dd>truncate to zero length or create text file for update, default permissions
<dt><br>&quot;ua+&quot;
<dd>append; open or create text file for update, writing at end-of-file, default permissions
<dt><br>&quot;uw+b or uwb+&quot;
<dd>truncate to zero length or create binary file for update, default permissions
<dt><br>&quot;ua+b or uab+&quot;
<dd>append; open or create binary file for update, writing at end-of-file, default permissions
</dl>
<br>To the extent that the underlying system supports the concepts, files opened for writing shall be opened with exclusive
 (also known as non-shared) access.&nbsp; If the file is being created, and the first character of the<b> mode</b> string
 is not 'u', to the extent that the underlying system supports it, the file shall have a file permission that prevents other
 users on the system from accessing the file.&nbsp; If the file is being created and first character of the mode string is
 'u', then by the time the file has been closed, it shall have the system default file access permissions.&nbsp; If the file
 was opened successfully, then the pointer to FILE pointed to by<b> streamptr</b> will be set to the pointer to the object
 controlling the opened file.&nbsp; Otherwise, the pointer to FILE pointed to by<b> streamptr</b> will be set to a null pointer.
<br><br>In addition to the above characters, you can also include one of the following characters in<b> mode</b> to specify
 the translation mode for newline characters:
<dl>
<dt>t
<dd>The letter &quot;t&quot; may be added to any of the above sequences in the second or later position to indicate that the file
 is (or must be) a text file.&nbsp; It also overrides the global translation mode flag if you link your program with<tt> BINMODE.OBJ.</tt>
&nbsp; The global translation mode flag default is &quot;text&quot; unless you explicitly link your program with<tt> BINMODE.OBJ.</tt>
<br>When neither &quot;t&quot; nor &quot;b&quot; is specified, the value of the global variable <tt> _fmode</tt> establishes
 whether the file is to treated as a binary or a text file.&nbsp; Unless this value is changed by the program or you have
 linked your program with<tt> BINMODE.OBJ,</tt> the default will be text mode.
<dt><br>b
<dd>The letter &quot;b&quot; may be added to any of the above sequences in the second or later position to indicate that the file
 is (or must be) a binary file (an ANSI requirement for portability to systems that make a distinction between text and binary
 files).
</dl>
<br>You can also include one of the following characters to enable or disable the &quot;commit&quot; flag for the associated
 file.
<dl>
<dt>c
<dd>The letter &quot;c&quot; may be added to any of the above sequences in the second or later position to indicate that any output
 is committed by the operating system whenever a flush ( <tt> fflush</tt> or <tt> flushall</tt>) is done.
<br>This option is not supported under Netware.
<dt><br>n
<dd>The letter &quot;n&quot; may be added to any of the above sequences in the second or later position to indicate that the operating
 system need not commit any output whenever a flush is done.&nbsp; It also overrides the global commit flag if you link your
 program with<tt> COMMODE.OBJ.</tt>&nbsp; The global commit flag default is &quot;no-commit&quot; unless you explicitly link
 your program with<tt> COMMODE.OBJ.</tt>
<br>This option is not supported under Netware.
</dl>
<br>The &quot;t&quot;, &quot;c&quot;, and &quot;n&quot; mode options are extensions for<tt> fopen_s</tt> and should not be
 used where ANSI portability is desired.
<br><br>Opening a file with read mode (<tt>r</tt> as the first character in the<b> mode</b> argument) fails if the file does
 not exist or it cannot be read.&nbsp; Opening a file with append mode (<tt>a</tt> as the first character in the<b> mode</b>
 argument) causes all subsequent writes to the file to be forced to the current end-of-file, regardless of previous calls
 to the <tt> fseek</tt> function.&nbsp; When a file is opened with update mode (<tt>+</tt> as the second or later character
 of the<b> mode</b> argument), both input and output may be performed on the associated stream.
<br><br>When a stream is opened in update mode, both reading and writing may be performed.&nbsp; However, writing may not
 be followed by reading without an intervening call to the <tt> fflush</tt> function or to a file positioning function (<tt>
 fseek</tt>, <tt> fsetpos</tt>, <tt> rewind</tt>).&nbsp; Similarly, reading may not be followed by writing without an intervening
 call to a file positioning function, unless the read resulted in end-of-file.
<br><br>The<tt> _wfopen_s</tt> function is identical to<tt> fopen_s</tt> except that it accepts wide-character string arguments
 for<b> filename</b> and<b> mode</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fopen_s</tt> function returns zero if it opened the file.&nbsp; If it did not open the file or if there was a runtime-constraint
 violation,<tt> fopen_s</tt> returns a non-zero value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_open">_dos_open</a>, <a href="#fclose">fclose</a>, <a href="#fcloseall">fcloseall</a>, <a href="#fdopen">fdopen</a>,
 <a href="#fopen">fopen</a>, <a href="#freopen">freopen</a>, <a href="#freopen_s">freopen_s</a>, <a href="#_fsopen">_fsopen</a>,
 <a href="#_grow_handles">_grow_handles</a>, <a href="#_hdopen">_hdopen</a>, <a href="#open">open</a>, <a href="#_open_osfhandle">_open_osfhandle</a>,
 <a href="#_popen">_popen</a>, <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errno_t rc;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = fopen_s( &amp;fp, &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rest of code goes here */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>fopen_s is TR 24731
<br>_wfopen_s is WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> fopen_s - All, Netware</tt>
<br><tt>_wfopen_s - All</tt>
</dl>
<h2 id="FP_OFF"> FP_OFF </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>unsigned FP_OFF( void __far *far_ptr );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> FP_OFF</tt> macro can be used to obtain the offset portion of the far pointer value given in<b> far_ptr</b>.
</dl>
<dl>
<dt>Returns:
<dd>The macro returns an unsigned integer value which is the offset portion of the pointer value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#FP_SEG">FP_SEG</a>, <a href="#MK_FP">MK_FP</a>, <a href="#segread">segread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>char ColourTable&#91;256&#93;&#91;3&#93;;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; union REGPACK r;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* read block of colour registers */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.h.ah = 0x10;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.h.al = 0x17;</tt>
<br><tt>#if defined(__386__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.x.ebx = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.x.ecx = 256;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.x.edx = FP_OFF( ColourTable );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.w.ds = r.w.fs = r.w.gs = FP_SEG( &amp;r );</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.w.bx = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.w.cx = 256;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.w.dx = FP_OFF( ColourTable );</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.w.es = FP_SEG( ColourTable );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; intr( 0x10, &amp;r );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 256; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Colour index = %d &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;{ Red=%d, Green=%d, Blue=%d }\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColourTable&#91;i&#93;&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColourTable&#91;i&#93;&#91;1&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColourTable&#91;i&#93;&#91;2&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="FP_SEG"> FP_SEG </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>unsigned FP_SEG( void __far *far_ptr );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> FP_SEG</tt> macro can be used to obtain the segment portion of the far pointer value given in<b> far_ptr</b>.
</dl>
<dl>
<dt>Returns:
<dd>The macro returns an unsigned integer value which is the segment portion of the pointer value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#FP_OFF">FP_OFF</a>, <a href="#MK_FP">MK_FP</a>, <a href="#segread">segread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>char ColourTable&#91;256&#93;&#91;3&#93;;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; union REGPACK r;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* read block of colour registers */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.h.ah = 0x10;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.h.al = 0x17;</tt>
<br><tt>#if defined(__386__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.x.ebx = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.x.ecx = 256;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.x.edx = FP_OFF( ColourTable );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.w.ds = r.w.fs = r.w.gs = FP_SEG( &amp;r );</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.w.bx = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.w.cx = 256;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.w.dx = FP_OFF( ColourTable );</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.w.es = FP_SEG( ColourTable );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; intr( 0x10, &amp;r );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 256; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Colour index = %d &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;{ Red=%d, Green=%d, Blue=%d }\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColourTable&#91;i&#93;&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColourTable&#91;i&#93;&#91;1&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ColourTable&#91;i&#93;&#91;2&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="fpclassify"> fpclassify </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>int fpclassify( x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fpclassify</tt> macro classifies its argument<b> x</b> as NaN, infinite, normal, subnormal, or zero.&nbsp; First,
 an argument represented in a format wider than its semantic type is converted to its semantic type.&nbsp; Then classification
 is based on the type of the argument.
<br>The argument<b> x</b> must be an expression of real floating type.
<br><br>The possible return values of<tt> fpclassify</tt> and their meanings are listed below.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>FP_INFINITE
<dd>positive or negative infinity
<dt><br>FP_NAN
<dd>NaN (not-a-number)
<dt><br>FP_NORMAL
<dd>normal number (neither zero, subnormal, NaN, nor infinity)
<dt><br>FP_SUBNORMAL
<dd>subnormal number
<dt><br>FP_ZERO
<dd>positive or negative zero
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fpclassify</tt> macro returns the value of the number classification macro appropriate to the value of its argument<b>
 x</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isfinite">isfinite</a>, <a href="#isinf">isinf</a>, <a href="#isnan">isnan</a>, <a href="#isnormal">isnormal</a>,
 <a href="#signbit">signbit</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;infinity %s a normal number\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fpclassify( INFINITY ) == FP_NORMAL ?</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;is&quot; : &quot;is not&quot; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>infinity is not a normal number</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_fpreset"> _fpreset </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;float.h&gt;</tt>
<br><tt>void _fpreset( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _fpreset</tt> function resets the floating-point unit to the default state that the math library requires for correct
 function.&nbsp; After a floating-point exception, it may be necessary to call the<tt> _fpreset</tt> function before any further
 floating-point operations are attempted.
<br>In multi-threaded environments,<tt> _fpreset</tt> only affects the current thread.
</dl>
<dl>
<dt>Returns:
<dd>No value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_clear87">_clear87</a>, <a href="#_control87">_control87</a>, <a href="#_controlfp">_controlfp</a>, <a href="#_finite">_finite</a>,
 <a href="#_status87">_status87</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;float.h&gt;</tt>
<br><br><tt>char *status&#91;2&#93; = { &quot;No&quot;, &quot;&nbsp; &quot; };</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int fp_status;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp_status = _status87();</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;80x87 status\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s invalid operation\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (fp_status &amp; SW_INVALID) == 0 &#93;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s denormalized operand\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (fp_status &amp; SW_DENORMAL) == 0
 &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s divide by zero\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (fp_status &amp; SW_ZERODIVIDE) ==
 0 &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s overflow\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (fp_status &amp; SW_OVERFLOW) == 0
 &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s underflow\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (fp_status &amp; SW_UNDERFLOW) == 0
 &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s inexact result\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; status&#91; (fp_status &amp; SW_INEXACT) == 0 &#93;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _fpreset();</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="fprintf"> fprintf, fwprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fprintf( FILE *fp, const char *format, ... );</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int fwprintf( FILE *fp, const wchar_t *format, ... );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#fprintf_s">fprintf_s</a> function which is a safer alternative to<tt>
 fprintf</tt>.&nbsp; This newer<tt> fprintf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 fprintf</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> fprintf</tt> function writes output to the file pointed to by<b> fp</b> under control of the argument<b> format</b>.
&nbsp; The<b> format</b> string is described under the description of the <tt> printf</tt> function.
<br>The<tt> fwprintf</tt> function is identical to<tt> fprintf</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fprintf</tt> function returns the number of characters written, or a negative value if an output error occurred.&nbsp;
 The<tt> fwprintf</tt> function returns the number of wide characters written, or a negative value if an output error occurred.
&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#printf">printf</a>, <a href="#sprintf">sprintf</a>,
 <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vprintf">vprintf</a>,
 <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>char *weekday = { &quot;Saturday&quot; };</tt>
<br><tt>char *month = { &quot;April&quot; };</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( stdout, &quot;%s, %s %d, %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, 18, 1987 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Saturday, April 18, 1987</tt>
</dl>
<dl>
<dt>Classification:
<dd>fprintf is ANSI
<br>fwprintf is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> fprintf - All, Netware</tt>
<br><tt>fwprintf - All</tt>
</dl>
<h2 id="fprintf_s"> fprintf_s, fwprintf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fprintf_s( FILE * restrict stream,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, ... );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int fwprintf_s( FILE * restrict stream.</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, ... );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 fprintf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> stream</b> nor<b> format</b> shall be a null pointer.&nbsp; The<tt> %n</tt> specifier (modified or not by flags,
 field width, or precision) shall not appear in the string pointed to by<b> format</b>.&nbsp; Any argument to<tt> fprintf_s</tt>
 corresponding to a<tt> %s</tt> specifier shall not be a null pointer.
<br><br>If there is a runtime-constraint violation, the<tt> fprintf_s</tt> function does not attempt to produce further output,
 and it is unspecified to what extent<tt> fprintf_s</tt> produced output before discovering the runtime-constraint violation.
</dl>
<dl>
<dt>Description:
<dd>The<tt> fprintf_s</tt> function is equivalent to the <tt> fprintf</tt> function except for the explicit runtime-constraints
 listed above.
<br>The<tt> fwprintf_s</tt> function is identical to<tt> fprintf_s</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fprintf_s</tt> function returns the number of characters written, or a negative value if an output error or runtime-constraint
 violation occurred.
<br>The<tt> fwprintf_s</tt> function returns the number of wide characters written, or a negative value if an output error
 or runtime-constraint violation occurred.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>,
 <a href="#vprintf">vprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>char *weekday = { &quot;Friday&quot; };</tt>
<br><tt>char *month = { &quot;August&quot; };</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf_s( stdout, &quot;%s, %s %d, %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, 13, 2004 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Friday, August 13, 2004</tt>
</dl>
<dl>
<dt>Classification:
<dd>fprintf_s is TR 24731
<br>fwprintf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> fprintf_s - All, Netware</tt>
<br><tt>fwprintf_s - All</tt>
</dl>
<h2 id="fputc"> fputc, fputwc </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fputc( int c, FILE *fp );</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wint_t fputwc( wint_t c, FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fputc</tt> function writes the character specified by the argument<b> c</b> to the output stream designated by<b>
 fp</b>.
<br>The<tt> fputwc</tt> function is identical to<tt> fputc</tt> except that it converts the wide character specified by<b>
 c</b> to a multibyte character and writes it to the output stream.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fputc</tt> function returns the character written or, if a write error occurs, the error indicator is set and<tt>
 fputc</tt> returns <tt> EOF</tt>.
<br>The<tt> fputwc</tt> function returns the wide character written or, if a write error occurs, the error indicator is set
 and<tt> fputwc</tt> returns <tt> WEOF</tt>.&nbsp; If an encoding error occurs, <tt> errno</tt> is set to <tt> EILSEQ</tt>
 and<tt> fputwc</tt> returns <tt> WEOF</tt>.
<br><br>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#fputchar">fputchar</a>, <a href="#fputs">fputs</a>, <a href="#putc">putc</a>, <a href="#putchar">putchar</a>,
 <a href="#puts">puts</a>, <a href="#ferror">ferror</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetc( fp )) != EOF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputc( c, stdout );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>fputc is ANSI
<br>fputwc is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> fputc - All, Netware</tt>
<br><tt>fputwc - All</tt>
</dl>
<h2 id="fputchar"> fputchar, _fputchar, _fputwchar </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fputchar( int c );</tt>
<br><tt>int _fputchar( int c );</tt>
<br><tt>wint_t _fputwchar( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fputchar</tt> function writes the character specified by the argument<b> c</b> to the output stream <tt> stdout</tt>.
&nbsp; This function is identical to the <tt> putchar</tt> function.
<br>The function is equivalent to:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputc( c, stdout );</tt>
<br><br>The<tt> _fputchar</tt> function is identical to<tt> fputchar</tt>.&nbsp; Use<tt> _fputchar</tt> for ANSI naming conventions.
<br><br>The<tt> _fputwchar</tt> function is identical to<tt> fputchar</tt> except that it converts the wide character specified
 by<b> c</b> to a multibyte character and writes it to the output stream.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fputchar</tt> function returns the character written or, if a write error occurs, the error indicator is set and<tt>
 fputchar</tt> returns <tt> EOF</tt>.
<br>The<tt> _fputwchar</tt> function returns the wide character written or, if a write error occurs, the error indicator is
 set and<tt> _fputwchar</tt> returns <tt> WEOF</tt>.
<br><br>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#fputc">fputc</a>, <a href="#fputs">fputs</a>, <a href="#putc">putc</a>, <a href="#putchar">putchar</a>,
 <a href="#puts">puts</a>, <a href="#ferror">ferror</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = fgetc( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( c != EOF ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fputchar( c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = fgetc( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> fputchar - All, Netware</tt>
<br><tt>_fputchar - All, Netware</tt>
<br><tt>_fputwchar - All</tt>
</dl>
<h2 id="fputs"> fputs, fputws </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fputs( const char *buf, FILE *fp );</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int fputws( const wchar_t *buf, FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fputs</tt> function writes the character string pointed to by<b> buf</b> to the output stream designated by<b> fp</b>.
&nbsp; The terminating null character is not written.
<br>The<tt> fputws</tt> function is identical to<tt> fputs</tt> except that it converts the wide character string specified
 by<b> buf</b> to a multibyte character string and writes it to the output stream.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fputs</tt> function returns <tt> EOF</tt> if an error occurs; otherwise, it returns a non-negative value (the number
 of characters written).&nbsp; The<tt> fputws</tt> function returns <tt> EOF</tt> if a write or encoding error occurs; otherwise,
 it returns a non-negative value (the number of characters written).&nbsp; When an error has occurred, <tt> errno</tt> contains
 a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#fputc">fputc</a>, <a href="#fputchar">fputchar</a>, <a href="#putc">putc</a>, <a href="#putchar">putchar</a>,
 <a href="#puts">puts</a>, <a href="#ferror">ferror</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( fgets( buffer, 80, fp ) != NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputs( buffer, stdout );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>fputs is ANSI
<br>fputws is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> fputs - All, Netware</tt>
<br><tt>fputws - All</tt>
</dl>
<h2 id="fread"> fread </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>size_t fread( void *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t elsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t nelem,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fread</tt> function reads<b> nelem</b> elements of<b> elsize</b> bytes each from the file specified by<b> fp</b> into
 the buffer specified by<b> buf</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fread</tt> function returns the number of complete elements successfully read.&nbsp; This value may be less than the
 requested number of elements.
<br>The <tt> feof</tt> and <tt> ferror</tt> functions can be used to determine whether the end of the file was encountered
 or if an input/output error has occurred.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the
 type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#feof">feof</a>, <a href="#ferror">ferror</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>The following example reads a simple student record containing binary data.&nbsp; The student record is described by the<tt>
 struct student_data</tt> declaration.
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>struct student_data {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp; student_id;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned char marks&#91;10&#93;;</tt>
<br><tt>};</tt>
<br><br><tt>size_t read_data( FILE *fp, struct student_data *p )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( fread( p, sizeof(*p), 1, fp ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct student_data std;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( read_data( fp, &amp;std ) != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;id=%d &quot;, std.student_id );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%3d &quot;, std.marks&#91; i &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="free"> free Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;&nbsp; For ANSI compatibility (free only)</tt>
<br><tt>#include &lt;malloc.h&gt;&nbsp; Required for other function prototypes</tt>
<br><tt>void free( void *ptr );</tt>
<br><tt>void _bfree( __segment seg, void __based(void) *ptr );</tt>
<br><tt>void _ffree( void __far&nbsp; *ptr );</tt>
<br><tt>void _nfree( void __near *ptr );</tt>
</dl>
<dl>
<dt>Description:
<dd>When the value of the argument<b> ptr</b> is<tt> NULL,</tt> the<tt> free</tt> function does nothing otherwise, the<tt> free</tt>
 function deallocates the memory block located by the argument<b> ptr</b> which points to a memory block previously allocated
 through a call to the appropriate version of <tt> calloc</tt>, <tt> malloc</tt> or <tt> realloc</tt>.&nbsp; After the call,
 the freed block is available for allocation.
<br>Each function deallocates memory from a particular heap, as listed below:
<dl>
<dt>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap
<dt>free
<dd>Depends on data model of the program
<dt><br>_bfree
<dd>Based heap specified by<b> seg</b> value
<dt><br>_ffree
<dd>Far heap (outside the default data segment)
<dt><br>_nfree
<dd>Near heap (inside the default data segment)
</dl>
<br>In a large data memory model, the<tt> free</tt> function is equivalent to the <tt> _ffree</tt> function; in a small data
 memory model, the<tt> free</tt> function is equivalent to the <tt> _nfree</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> free</tt> functions return no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#calloc">calloc</a> Functions, <a href="#_expand">_expand</a> Functions, <a href="#halloc">halloc</a>, <a href="#hfree">hfree</a>,
 <a href="#malloc">malloc</a> Functions, <a href="#_msize">_msize</a> Functions, <a href="#realloc">realloc</a> Functions,
 <a href="#sbrk">sbrk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *buffer;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; buffer = (char *)malloc( 80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( buffer == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to allocate memory\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rest of code goes here */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( buffer );&nbsp; /* deallocate buffer */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>free is ANSI
<br>_ffree is not ANSI
<br>_bfree is not ANSI
<br>_nfree is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> free - All, Netware</tt>
<br><tt>_bfree - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_ffree - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_nfree - DOS, Windows, Win386, Win32, QNX, OS/2 1.x, OS/2 1.x(MT), OS/2-32</tt>
</dl>
<h2 id="_freect"> _freect </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>unsigned int _freect( size_t size );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _freect</tt> function returns the number of times that <tt> _nmalloc</tt> (or <tt> malloc</tt> in small data models)
 can be called to allocate a item of<b> size</b> bytes.&nbsp; In the tiny, small and medium memory models, the default data
 segment is only extended as needed to satisfy requests for memory allocation.&nbsp; Therefore, you will need to call <tt>
 _nheapgrow</tt> in these memory models before calling<tt> _freect</tt> in order to get a meaningful result.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _freect</tt> function returns the number of calls as an unsigned integer.
</dl>
<dl>
<dt>See Also:
<dd><a href="#calloc">calloc</a>, <a href="#_heapgrow">_heapgrow</a> Functions, <a href="#malloc">malloc</a> Functions, <a href="#_memavl">_memavl</a>,
 <a href="#_memmax">_memmax</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Can allocate %u longs before _nheapgrow\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _freect( sizeof(long) ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _nheapgrow();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Can allocate %u longs after _nheapgrow\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _freect( sizeof(long) ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; 1000; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _nmalloc( sizeof(long) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;After allocating 1000 longs:\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Can still allocate %u longs\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _freect( sizeof(long) ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Can allocate 0 longs before _nheapgrow</tt>
<br><tt>Can allocate 10447 longs after _nheapgrow</tt>
<br><tt>After allocating 1000 longs:</tt>
<br><tt>Can still allocate 9447 longs</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="freopen"> freopen, _wfreopen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>FILE *freopen( const char *filename,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *mode,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *fp );</tt>
<br><tt>FILE *_wfreopen( const wchar_t *filename,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *mode,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *fp );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#freopen_s">freopen_s</a> function which is a safer alternative to<tt>
 freopen</tt>.&nbsp; This newer<tt> freopen_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 freopen</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The stream located by the <tt> fp</tt> pointer is closed.&nbsp; The<tt> freopen</tt> function opens the file whose name is
 the string pointed to by<b> filename</b>, and associates a stream with it.&nbsp; The stream information is placed in the
 structure located by the<b> fp</b> pointer.
<br>The argument<b> mode</b> is described in the description of the <tt> fopen</tt> function.
<br><br>The<tt> _wfreopen</tt> function is identical to<tt> freopen</tt> except that it accepts wide-character string arguments
 for<b> filename</b> and<b> mode</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> freopen</tt> function returns a pointer to the object controlling the stream.&nbsp; This pointer must be passed as
 a parameter to subsequent functions for performing operations on the file.&nbsp; If the open operation fails,<tt> freopen</tt>
 returns<tt> NULL.</tt>&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that
 has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_open">_dos_open</a>, <a href="#fclose">fclose</a>, <a href="#fcloseall">fcloseall</a>, <a href="#fdopen">fdopen</a>,
 <a href="#fopen">fopen</a>, <a href="#fopen_s">fopen_s</a>, <a href="#freopen_s">freopen_s</a>, <a href="#_fsopen">_fsopen</a>,
 <a href="#_grow_handles">_grow_handles</a>, <a href="#_hdopen">_hdopen</a>, <a href="#open">open</a>, <a href="#_open_osfhandle">_open_osfhandle</a>,
 <a href="#_popen">_popen</a>, <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = freopen( &quot;file&quot;, &quot;r&quot;, stdin );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetchar()) != EOF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputchar(c);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>freopen is ANSI
<br>_wfreopen is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> freopen - All, Netware</tt>
<br><tt>_wfreopen - All</tt>
</dl>
<h2 id="freopen_s"> freopen_s, _wfreopen_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>errno_t&nbsp; freopen_s( FILE * restrict * restrict newstreamptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const char * filename,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const char * restrict mode,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 FILE * restrict stream );</tt>
<br><tt>errno_t _wfreopen_s( FILE * restrict * restrict newstreamptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const wchar_t * restrict filename,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const wchar_t * restrict mode,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; FILE * restrict stream );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 freopen_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>None of<b> newstreamptr</b>,<b> mode</b>, and<b> stream</b> shall be a null pointer.&nbsp; If there is a runtime-constraint
 violation,<tt> freopen_s</tt> neither attempts to close any file associated with<b> stream</b> nor attempts to open a file.
&nbsp; Furthermore, if<b> newstreamptr</b> is not a null pointer,<tt> freopen_s</tt> sets<b> *newstreamptr</b> to the null
 pointer.
</dl>
<dl>
<dt>Description:
<dd>The<tt> freopen_s</tt> function opens the file whose name is the string pointed to by<b> filename</b> and associates the stream
 pointed to by<b> stream</b> with it.&nbsp; The<b> mode</b> argument has the same meaning as in the fopen_s function (including
 the mode's effect on exclusive access and file permissions).&nbsp; If<b> filename</b> is a null pointer,the<tt> freopen_s</tt>
 function attempts to change the mode of the<b> stream</b> to that specified by<b> mode</b> ,as if the name of the file currently
 associated with the stream had been used.&nbsp; It is implementation-defined which changes of mode are permitted (if any),
 and under what circumstances.&nbsp; The<tt> freopen_s</tt> function first attempts to close any file that is associated with<b>
 stream</b>.&nbsp; Failure to close the file is ignored.&nbsp; The error and end-of-file indicators for the stream are cleared.
&nbsp; If the file was opened successfully, then the pointer to FILE pointed to by<b> newstreamptr</b> will be set to the
 value of stream.&nbsp; Otherwise, the pointer to FILE pointed to by<b> newstreamptr</b> will be set to a null pointer.
<br>The<tt> _wfreopen_s</tt> function is identical to<tt> freopen_s</tt> except that it accepts wide-character string arguments
 for<b> filename</b> and<b> mode</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> freopen_s</tt> function returns zero if it opened the file.&nbsp; If it did not open the file or there was a runtime-constraint
 violation,<tt> freopen_s</tt> returns a non-zero value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_open">_dos_open</a>, <a href="#fclose">fclose</a>, <a href="#fcloseall">fcloseall</a>, <a href="#fdopen">fdopen</a>,
 <a href="#fopen">fopen</a>, <a href="#fopen_s">fopen_s</a>, <a href="#freopen">freopen</a>, <a href="#_fsopen">_fsopen</a>,
 <a href="#_grow_handles">_grow_handles</a>, <a href="#_hdopen">_hdopen</a>, <a href="#open">open</a>, <a href="#_open_osfhandle">_open_osfhandle</a>,
 <a href="#_popen">_popen</a>, <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errno_t rc;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = freopen_s( &amp;fp, &quot;file&quot;, &quot;r&quot;, stdin );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( rc == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetc( fp )) != EOF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fputchar(c);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>freopen_s is TR 24731
<br>_wfreopen_s is WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> freopen_s - All, Netware</tt>
<br><tt>_wfreopen_s - All</tt>
</dl>
<h2 id="frexp"> frexp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double frexp( double value, int *exp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> frexp</tt> function breaks a floating-point number into a normalized fraction and an integral power of 2.&nbsp; It
 stores the integral power of 2 in the<b> int</b> object pointed to by<b> exp</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> frexp</tt> function returns the value of<b> x</b>, such that<b> x</b> is a<tt> double</tt> with magnitude in the interval
 &#91;0.5,1) or zero, and<b> value</b> equals<b> x</b> times 2 raised to the power<b> *exp</b>.&nbsp; If<b> value</b> is zero,
 then both parts of the result are zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#ldexp">ldexp</a>, <a href="#modf">modf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp; expon;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; double value;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; value = frexp(&nbsp; 4.25, &amp;expon );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f %d\n&quot;, value, expon );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; value = frexp( -4.25, &amp;expon );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f %d\n&quot;, value, expon );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.531250 3</tt>
<br><tt>-0.531250 3</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="fscanf"> fscanf, fwscanf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fscanf( FILE *fp, const char *format, ... );</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int fwscanf( FILE *fp, const wchar_t *format, ... );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#fscanf_s">fscanf_s</a> function which is a safer alternative to<tt> fscanf</tt>.
&nbsp; This newer<tt> fscanf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> fscanf</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> fscanf</tt> function scans input from the file designated by<b> fp</b> under control of the argument<b> format</b>.
&nbsp; Following the format string is a list of addresses to receive values.&nbsp; The<b> format</b> string is described under
 the description of the <tt> scanf</tt> function.
<br>The<tt> fwscanf</tt> function is identical to<tt> fscanf</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fscanf</tt> function returns <tt> EOF</tt> if an input failure occurred before any conversion.&nbsp; Otherwise, the
 number of input arguments for which values were successfully scanned and stored is returned.&nbsp; When a file input error
 occurs, the <tt> errno</tt> global variable may be set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cscanf">cscanf</a>, <a href="#scanf">scanf</a>, <a href="#sscanf">sscanf</a>, <a href="#vcscanf">vcscanf</a>, <a href="#vfscanf">vfscanf</a>,
 <a href="#vscanf">vscanf</a>, <a href="#vsscanf">vsscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>To scan a date in the form &quot;Saturday April 18 1987&quot;:
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *in_data;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; in_data = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( in_data != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fscanf( in_data, &quot;%s %s %d %d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day,
 &amp;year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Weekday=%s Month=%s Day=%d Year=%d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( in_data );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>fscanf is ISO C90
<br>fwscanf is ISO C95
</dl>
<dl>
<dt>Systems:
<dd><tt> fscanf - All, Netware</tt>
<br><tt>fwscanf - All</tt>
</dl>
<h2 id="fscanf_s"> fscanf_s, fwscanf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fscanf_s( FILE * restrict stream,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, ... );</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int fwscanf_s( FILE * restrict stream,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, ... );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 fscanf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> stream</b> nor<b> format</b> shall be a null pointer.&nbsp; Any argument indirected through in order to store
 converted input shall not be a null pointer.
<br><br>If there is a runtime-constraint violation, the<tt> fscanf_s</tt> function does not attempt to perform further input,
 and it is unspecified to what extent<tt> fscanf_s</tt> performed input before discovering the runtime-constraint violation.
</dl>
<dl>
<dt>Description:
<dd>The<tt> fscanf_s</tt> function is equivalent to <tt> fscanf</tt> except that the<tt> c, s,</tt> and<tt> &#91;</tt> conversion
 specifiers apply to a pair of arguments (unless assignment suppression is indicated by a<tt> *</tt>).&nbsp; The first of
 these arguments is the same as for <tt> fscanf</tt>.&nbsp; That argument is immediately followed in the argument list by
 the second argument, which has type <tt> size_t</tt> and gives the number of elements in the array pointed to by the first
 argument of the pair.&nbsp; If the first argument points to a scalar object, it is considered to be an array of one element.
<br>A matching failure occurs if the number of elements in a receiving object is insufficient to hold the converted input
 (including any trailing null character).
<br><br>The<tt> fwscanf_s</tt> function is identical to<tt> fscanf_s</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fscanf_s</tt> function returns <tt> EOF</tt> if an input failure occurred before any conversion or if there was a
 runtime-constraint violation.&nbsp; Otherwise, the<tt> fscanf_s</tt> function returns the number of input items successfully
 assigned, which can be fewer than provided for, or even zero.
<br>When a file input error occurs, the <tt> errno</tt> global variable may be set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cscanf">cscanf</a>, <a href="#fscanf">fscanf</a>, <a href="#scanf">scanf</a>, <a href="#sscanf">sscanf</a>, <a href="#vcscanf">vcscanf</a>,
 <a href="#vfscanf">vfscanf</a>, <a href="#vscanf">vscanf</a>, <a href="#vsscanf">vsscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>To scan a date in the form &quot;Friday August 13 2004&quot;:
<br><br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *in_data;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; in_data = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( in_data != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fscanf_s( in_data, &quot;%s %s %d %d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, sizeof( weekday
 ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; month, sizeof( month ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;day, &amp;year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf_s( &quot;Weekday=%s Month=%s Day=%d Year=%d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( in_data );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>fscanf_s is TR 24731
<br>fwscanf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> fscanf_s - All, Netware</tt>
<br><tt>fwscanf_s - All</tt>
</dl>
<h2 id="fseek"> fseek </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fseek( FILE *fp, long int offset, int where );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fseek</tt> function changes the read/write position of the file specified by<b> fp</b>.&nbsp; This position defines
 the character that will be read or written on the next I/O operation on the file.&nbsp; The argument<b> fp</b> is a file
 pointer returned by <tt> fopen</tt> or <tt> freopen</tt>.&nbsp; The argument<b> offset</b> is the position to seek to relative
 to one of three positions specified by the argument<b> where</b>.&nbsp; Allowable values for<b> where</b> are:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>SEEK_SET
<dd>The new file position is computed relative to the start of the file.&nbsp; The value of<b> offset</b> must not be negative.
<dt><br>SEEK_CUR
<dd>The new file position is computed relative to the current file position.&nbsp; The value of<b> offset</b> may be positive,
 negative or zero.
<dt><br>SEEK_END
<dd>The new file position is computed relative to the end of the file.
</dl>
<br>The<tt> fseek</tt> function clears the end-of-file indicator and undoes any effects of the <tt> ungetc</tt> function on
 the same file.
<br><br>The <tt> ftell</tt> function can be used to obtain the current position in the file before changing it.&nbsp; The
 position can be restored by using the value returned by <tt> ftell</tt> in a subsequent call to<tt> fseek</tt> with the<b>
 where</b> parameter set to <tt> SEEK_SET</tt>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fseek</tt> function returns zero if successful, non-zero otherwise.&nbsp; When an error has occurred, <tt> errno</tt>
 contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fgetpos">fgetpos</a>, <a href="#fopen">fopen</a>, <a href="#fsetpos">fsetpos</a>, <a href="#ftell">ftell</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>The size of a file can be determined by the following example which saves and restores the current position of the file.
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>long int filesize( FILE *fp )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long int save_pos, size_of_file;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; save_pos = ftell( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fseek( fp, 0L, SEEK_END );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_of_file = ftell( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fseek( fp, save_pos, SEEK_SET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( size_of_file );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File size=%ld\n&quot;, filesize( fp ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="fsetpos"> fsetpos </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int fsetpos( FILE *fp, fpos_t *pos );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fsetpos</tt> function positions the file<b> fp</b> according to the value of the object pointed to by<b> pos</b>,
 which shall be a value returned by an earlier call to the <tt> fgetpos</tt> function on the same file.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fsetpos</tt> function returns zero if successful, otherwise, the<tt> fsetpos</tt> function returns a non-zero value.
&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fgetpos">fgetpos</a>, <a href="#fopen">fopen</a>, <a href="#fseek">fseek</a>, <a href="#ftell">ftell</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fpos_t position;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgetpos( fp, &amp;position ); /* get position&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets( buffer, 80, fp );&nbsp; /* read record&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fsetpos( fp, &amp;position ); /* set position&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fgets( buffer, 80, fp );&nbsp; /* read same record */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_fsopen"> _fsopen, _wfsopen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>FILE *_fsopen( const char *filename,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *mode, int share );</tt>
<br><tt>FILE *_wfsopen( const wchar_t *filename,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *mode, int
 share );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _fsopen</tt> function opens the file whose name is the string pointed to by<b> filename</b>, and associates a stream
 with it.&nbsp; The arguments<b> mode</b> and<b> share</b> control shared reading or writing.&nbsp; The argument<b> mode</b>
 points to a string beginning with one of the following sequences:
<dl>
<dt>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>&quot;r&quot;
<dd>open file for reading; use default file translation
<dt><br>&quot;w&quot;
<dd>create file for writing, or truncate to zero length; use default file translation
<dt><br>&quot;a&quot;
<dd>append:&nbsp; open text file or create for writing at end-of-file; use default file translation
<dt><br>&quot;rb&quot;
<dd>open binary file for reading
<dt><br>&quot;rt&quot;
<dd>open text file for reading
<dt><br>&quot;wb&quot;
<dd>create binary file for writing, or truncate to zero length
<dt><br>&quot;wt&quot;
<dd>create text file for writing, or truncate to zero length
<dt><br>&quot;ab&quot;
<dd>append; open binary file or create for writing at end-of-file
<dt><br>&quot;at&quot;
<dd>append; open text file or create for writing at end-of-file
<dt><br>&quot;r+&quot;
<dd>open file for update (reading and/or writing); use default file translation
<dt><br>&quot;w+&quot;
<dd>create file for update, or truncate to zero length; use default file translation
<dt><br>&quot;a+&quot;
<dd>append; open file or create for update, writing at end-of-file; use default file translation
<dt><br>&quot;r+b&quot;, &quot;rb+&quot;
<dd>open binary file for update (reading and/or writing)
<dt><br>&quot;r+t&quot;, &quot;rt+&quot;
<dd>open text file for update (reading and/or writing)
<dt><br>&quot;w+b&quot;, &quot;wb+&quot;
<dd>create binary file for update, or truncate to zero length
<dt><br>&quot;w+t&quot;, &quot;wt+&quot;
<dd>create text file for update, or truncate to zero length
<dt><br>&quot;a+b&quot;, &quot;ab+&quot;
<dd>append; open binary file or create for update, writing at end-of-file
<dt><br>&quot;a+t&quot;, &quot;at+&quot;
<dd>append; open text file or create for update, writing at end-of-file
</dl>
<br>When default file translation is specified, the value of the global variable <tt> _fmode</tt> establishes whether the
 file is to treated as a binary or a text file.&nbsp; Unless this value is changed by the program, the default will be text
 mode.
<br><br>Opening a file with read mode (<tt>'r'</tt> as the first character in the<b> mode</b> argument) fails if the file
 does not exist or it cannot be read.&nbsp; Opening a file with append mode (<tt>'a'</tt> as the first character in the<b>
 mode</b> argument) causes all subsequent writes to the file to be forced to the current end-of-file, regardless of previous
 calls to the <tt> fseek</tt> function.&nbsp; When a file is opened with update mode (<tt>'+'</tt> as the second or third
 character of the<b> mode</b> argument), both input and output may be performed on the associated stream.
<br><br>When a stream is opened in update mode, both reading and writing may be performed.&nbsp; However, writing may not
 be followed by reading without an intervening call to the <tt> fflush</tt> function or to a file positioning function (<tt>
 fseek</tt> , <tt> fsetpos</tt> , <tt> rewind</tt>).&nbsp; Similarly, reading may not be followed by writing without an intervening
 call to a file positioning function, unless the read resulted in end-of-file.
<br><br>The shared access for the file,<b> share</b>, is established by a combination of bits defined in the<tt> &lt;share.h&gt;</tt>
 header file.&nbsp; The following values may be set:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>SH_COMPAT
<dd>Set compatibility mode.
<dt><br>SH_DENYRW
<dd>Prevent read or write access to the file.
<dt><br>SH_DENYWR
<dd>Prevent write access of the file.
<dt><br>SH_DENYRD
<dd>Prevent read access to the file.
<dt><br>SH_DENYNO
<dd>Permit both read and write access to the file.
</dl>
<br>You should consult the technical documentation for the DOS system that you are using for more detailed information about
 these sharing modes.
<br><br>The<tt> _wfsopen</tt> function is identical to<tt> _fsopen</tt> except that it accepts wide-character string arguments
 for<b> filename</b> and<b> mode</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _fsopen</tt> function returns a pointer to the object controlling the stream.&nbsp; This pointer must be passed as
 a parameter to subsequent functions for performing operations on the file.&nbsp; If the open operation fails,<tt> _fsopen</tt>
 returns<tt> NULL.</tt>&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that
 has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_open">_dos_open</a>, <a href="#fclose">fclose</a>, <a href="#fcloseall">fcloseall</a>, <a href="#fdopen">fdopen</a>,
 <a href="#fopen">fopen</a>, <a href="#freopen">freopen</a>, <a href="#_grow_handles">_grow_handles</a>, <a href="#_hdopen">_hdopen</a>,
 <a href="#open">open</a>, <a href="#_open_osfhandle">_open_osfhandle</a>, <a href="#_popen">_popen</a>, <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;share.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /*</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; open a file and prevent others from writing to it</tt>
<br><tt>&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fp = _fsopen( &quot;report.dat&quot;, &quot;w&quot;, SH_DENYWR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rest of code goes here */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _fsopen - All, Netware</tt>
<br><tt>_wfsopen - All</tt>
</dl>
<h2 id="fstat"> fstat, _fstat, _fstati64, _wfstat, _wfstati64 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>int fstat( int handle, struct stat *buf );</tt>
<br><tt>int _fstat( int handle, struct stat *buf );</tt>
<br><tt>int _fstati64( int handle, struct _stati64 *buf );</tt>
<br><tt>int _wfstat( int handle, struct _stat *buf );</tt>
<br><tt>int _wfstati64( int handle, struct _stati64 *buf );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fstat</tt> functions obtain information about an open file whose file handle is<b> handle</b>.&nbsp; This information
 is placed in the structure located at the address indicated by<b> buf</b>.
<br>The file<tt> &lt;sys\stat.h&gt;</tt> contains definitions for the structure <tt> stat</tt>.
<dl>
<dt>Field&nbsp;&nbsp;&nbsp;&nbsp; Type/Meaning
<dt>st_dev
<dd>(dev_t) the disk drive the file resides on
<dt><br>st_ino
<dd>(ino_t) this inode's number (not used for DOS)
<dt><br>st_mode
<dd>(unsigned short) file mode
<dt><br>st_nlink
<dd>(short) number of hard links
<dt><br>st_uid
<dd>(unsigned long) user-id (always 'root' for DOS)
<dt><br>st_gid
<dd>(short) group-id (always 'root' for DOS)
<dt><br>st_rdev
<dd>(dev_t) this should be the device type but it is the same as st_dev for the time being
<dt><br>st_size
<dd>(off_t) total file size
<dt><br>st_atime
<dd>(time_t) this should be the file &quot;last accessed&quot; time if the file system supports it
<dt><br>st_mtime
<dd>(time_t) the file &quot;last modified&quot; time
<dt><br>st_ctime
<dd>(time_t) this should be the file &quot;last status change&quot; time if the file system supports it
<br><b>The following fields are Netware only:</b>
<dt><br>st_btime
<dd>(time_t) the file &quot;last archived&quot; time
<dt><br>st_attr
<dd>(unsigned long) the file's attributes
<dt><br>st_archivedID
<dd>(unsigned long) the user/object ID that last archived file
<dt><br>st_updatedID
<dd>(unsigned long) the user/object ID that last updated file
<dt><br>st_inheritedRightsMask
<dd>(unsigned short) the inherited rights mask
<dt><br>st_originatingNameSpace
<dd>(unsigned char) the originating name space
</dl>
<br>The structure <tt> _stati64</tt> differs from <tt> stat</tt> in the following way:
<dl>
<dt>st_size
<dd>(__int64) total file size (as a 64-bit value)
</dl>
<br>At least the following macros are defined in the<tt> &lt;sys\stat.h&gt;</tt> header file.
<dl>
<dt>Macro&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_ISFIFO(m)
<dd>Test for FIFO.
<dt><br>S_ISCHR(m)
<dd>Test for character special file.
<dt><br>S_ISDIR(m)
<dd>Test for directory file.
<dt><br>S_ISBLK(m)
<dd>Test for block special file.
<dt><br>S_ISREG(m)
<dd>Test for regular file.
</dl>
<br>The value<b> m</b> supplied to the macros is the value of the <tt> st_mode</tt> field of a <tt> stat</tt> structure.&nbsp;
 The macro evaluates to a non-zero value if the test is true and zero if the test is false.
<br><br>The following bits are encoded within the <tt> st_mode</tt> field of a <tt> stat</tt> structure.
<dl>
<dt>Mask&nbsp;&nbsp;&nbsp;&nbsp; Owner Permissions
<dt>S_IRWXU
<dd>Read, write, search (if a directory), or execute (otherwise)
<dt><br>S_IRUSR
<dd>Read permission bit
<dt><br>S_IWUSR
<dd>Write permission bit
<dt><br>S_IXUSR
<dd>Search/execute permission bit
<dt><br>S_IREAD
<dd>== <tt> S_IRUSR</tt> (for Microsoft compatibility)
<dt><br>S_IWRITE
<dd>== <tt> S_IWUSR</tt> (for Microsoft compatibility)
<dt><br>S_IEXEC
<dd>== <tt> S_IXUSR</tt> (for Microsoft compatibility)
</dl>
<br><tt> S_IRWXU</tt> is the bitwise inclusive OR of <tt> S_IRUSR</tt>, <tt> S_IWUSR</tt>, and <tt> S_IXUSR</tt>.
<dl>
<dt>Mask&nbsp;&nbsp;&nbsp;&nbsp; Group Permissions (same as owner's on DOS, OS/2 or Windows)
<dt>S_IRWXG
<dd>Read, write, search (if a directory), or execute (otherwise)
<dt><br>S_IRGRP
<dd>Read permission bit
<dt><br>S_IWGRP
<dd>Write permission bit
<dt><br>S_IXGRP
<dd>Search/execute permission bit
</dl>
<br><tt> S_IRWXG</tt> is the bitwise inclusive OR of <tt> S_IRGRP</tt>, <tt> S_IWGRP</tt>, and <tt> S_IXGRP</tt>.
<dl>
<dt>Mask&nbsp;&nbsp;&nbsp;&nbsp; Other Permissions (same as owner's on DOS, OS/2 or Windows)
<dt>S_IRWXO
<dd>Read, write, search (if a directory), or execute (otherwise)
<dt><br>S_IROTH
<dd>Read permission bit
<dt><br>S_IWOTH
<dd>Write permission bit
<dt><br>S_IXOTH
<dd>Search/execute permission bit
</dl>
<br><tt> S_IRWXO</tt> is the bitwise inclusive OR of <tt> S_IROTH</tt>, <tt> S_IWOTH</tt>, and <tt> S_IXOTH</tt>.
<dl>
<dt>Mask&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_ISUID
<dd>(Not supported by DOS, OS/2 or Windows) Set user ID on execution.&nbsp; The process's effective user ID shall be set to that
 of the owner of the file when the file is run as a program.&nbsp; On a regular file, this bit should be cleared on any write.
<dt><br>S_ISGID
<dd>(Not supported by DOS, OS/2 or Windows) Set group ID on execution.&nbsp; Set effective group ID on the process to the file's
 group when the file is run as a program.&nbsp; On a regular file, this bit should be cleared on any write.
</dl>
<br>The<tt> _fstat</tt> function is identical to<tt> fstat</tt>.&nbsp; Use<tt> _fstat</tt> for ANSI/ISO naming conventions.
&nbsp; The <tt> _fstati64</tt>, <tt> _wfstat</tt>, and <tt> _wfstati64</tt> functions differ from<tt> fstat</tt> in the type
 of structure that they are asked to fill in.&nbsp; The <tt> _wfstat</tt> and <tt> _wfstati64</tt> functions deal with wide
 character strings.&nbsp; The differences in the structures are described above.
</dl>
<dl>
<dt>Returns:
<dd>All forms of the<tt> fstat</tt> function return zero when the information is successfully obtained.&nbsp; Otherwise, -1 is
 returned.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EBADF
<dd>The<b> handle</b> argument is not a valid file handle.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#creat">creat</a>, <a href="#dup">dup</a>, <a href="#dup2">dup2</a>, <a href="#open">open</a>, <a href="#sopen">sopen</a>,
 <a href="#stat">stat</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle, rc;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct stat buf;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = fstat( handle, &amp;buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc != -1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File size = %d\n&quot;, buf.st_size
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>fstat is POSIX
<br>_fstat is not POSIX
<br>_fstati64 is not POSIX
<br>_wfstat is not POSIX
<br>_wfstati64 is not POSIX
<br>_fstat conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> fstat - All, Netware</tt>
<br><tt>_fstat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fstati64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wfstat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wfstati64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="fsync"> fsync </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int fsync( int fd );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fsync</tt> function writes to disk all the currently queued data for the open file specified by<b> fd</b>.&nbsp; All
 necessary file system information required to retrieve the data is also written to disk.&nbsp; The file access times are
 also updated.
<br>The<tt> fsync</tt> function is used when you wish to ensure that both the file data and file system information required
 to recover the complete file have been written to the disk.
<br><br>The<tt> fsync</tt> function does not return until the transfer is completed.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fsync</tt> function returns zero if successful.&nbsp; Otherwise, it returns -1 and <tt> errno</tt> is set to indicate
 the error.&nbsp; If the<tt> fsync</tt> function fails, outstanding i/o operations are not guaranteed to have been completed.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EBADF
<dd>The<b> fd</b> argument is not a valid file handle.
<dt><br>EINVAL
<dd>Synchronized i/o is not supported for this file.
<dt><br>EIO
<dd>A physical I/O error occurred (e.g., a bad block).&nbsp; The precise meaning is device dependent.
<dt><br>ENOSYS
<dd>The<tt> fsync</tt> function is not supported.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#fstat">fstat</a>, <a href="#open">open</a>, <a href="#stat">stat</a>, <a href="#write">write</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>/*</tt>
<br><tt> *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Write a file and make sure it is on disk.</tt>
<br><tt> */</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>char buf&#91;512&#93;;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = creat( &quot;file&quot;, S_IWRITE | S_IREAD );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;Error creating file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 255; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset( buf, i, sizeof( buf ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( write( handle, buf, sizeof(buf) ) != sizeof(buf) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;Error writing file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( fsync( handle ) == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;Error sync'ing file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; exit( EXIT_SUCCESS );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>POSIX 1003.4
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="ftell"> ftell </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>long int ftell( FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ftell</tt> function returns the current read/write position of the file specified by<b> fp</b>.&nbsp; This position
 defines the character that will be read or written by the next I/O operation on the file.&nbsp; The value returned by<tt>
 ftell</tt> can be used in a subsequent call to <tt> fseek</tt> to set the file to the same position.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ftell</tt> function returns the current read/write position of the file specified by<b> fp</b>.&nbsp; When an error
 is detected,<tt> -1L</tt> is returned.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the
 type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fgetpos">fgetpos</a>, <a href="#fopen">fopen</a>, <a href="#fsetpos">fsetpos</a>, <a href="#fseek">fseek</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>long int filesize( FILE *fp )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long int save_pos, size_of_file;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; save_pos = ftell( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fseek( fp, 0L, SEEK_END );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_of_file = ftell( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fseek( fp, save_pos, SEEK_SET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( size_of_file );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File size=%ld\n&quot;, filesize( fp ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="ftime"> ftime </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;sys/timeb.h&gt;</tt>
<br><tt>int ftime( struct timeb *timeptr );</tt>
<br><br><tt>struct timeb {</tt>
<br><tt> time_t time;&nbsp; /* time in seconds since Jan 1, 1970 UTC */</tt>
<br><tt> unsigned short millitm; /* milliseconds */</tt>
<br><tt> short timezone; /* difference in minutes from UTC */</tt>
<br><tt> short dstflag;&nbsp; /* nonzero if in daylight savings time */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ftime</tt> function gets the current time and stores it in the structure pointed to by<b> timeptr</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ftime</tt> function fills in the fields of the structure pointed to by<b> timeptr</b>.&nbsp; The<tt> ftime</tt> function
 returns -1 if not successful, and no useful value otherwise.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#asctime_s">asctime_s</a>, <a href="#clock">clock</a>, <a href="#ctime">ctime</a>
 Functions, <a href="#ctime_s">ctime_s</a>, <a href="#difftime">difftime</a>, <a href="#gmtime">gmtime</a>, <a href="#gmtime_s">gmtime_s</a>,
 <a href="#localtime">localtime</a>, <a href="#localtime_s">localtime_s</a>, <a href="#mktime">mktime</a>, <a href="#strftime">strftime</a>,
 <a href="#time">time</a>, <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>#include &lt;sys/timeb.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct timeb timebuf;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp; *tod;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; ftime( &amp;timebuf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tod = ctime( &amp;timebuf.time );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The time is %.19s.%hu %s&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tod, timebuf.millitm, &amp;tod&#91;20&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>The time is Tue Dec 25 15:58:42.870 1990</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="_fullpath"> _fullpath, _wfullpath </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>char *_fullpath( char *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</tt>
<br><tt>wchar_t *_wfullpath( wchar_t *buffer ,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const wchar_t *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; size_t size );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _fullpath</tt> function returns the full pathname of the file specification in<b> path</b> in the specified buffer<b>
 buffer</b> of length<b> size</b>.
<br>The maximum size that might be required for<b> buffer</b> is <tt> _MAX_PATH</tt>.&nbsp; If the buffer provided is too
 small,<tt> NULL</tt> is returned and <tt> errno</tt> is set.
<br><br>If<b> buffer</b> is<tt> NULL</tt> then a buffer of size <tt> _MAX_PATH</tt> is allocated using <tt> malloc</tt>.&nbsp;
 This buffer may be freed using the <tt> free</tt> function.
<br><br>If<b> path</b> is<tt> NULL</tt> or points to a null string (&quot;&quot;) then the current working directory is returned
 in<b> buffer</b>.
<br><br>The<tt> _wfullpath</tt> function is a wide-character version of<tt> _fullpath</tt> that operates with wide-character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _fullpath</tt> function returns a pointer to the full path specification if no error occurred.&nbsp; Otherwise,<tt>
 NULL</tt> is returned.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>ENOENT
<dd>The current working directory could not be obtained.
<dt><br>ENOMEM
<dd>The buffer could not be allocated.
<dt><br>ERANGE
<dd>The buffer passed was too small.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_makepath">_makepath</a>, <a href="#_splitpath">_splitpath</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main( int argc, char *argv&#91;&#93; )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buff&#91; PATH_MAX &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; argc; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( argv&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _fullpath( buff, argv&#91;i&#93;, PATH_MAX ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( buff );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;FAIL!&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _fullpath - All, Netware</tt>
<br><tt>_wfullpath - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="fwide"> fwide </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int fwide( FILE *fp, int mode );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fwide</tt> function determines the orientation of the stream pointed to by<b> fp</b>.&nbsp; If<b> mode</b> is greater
 than zero, the function first attempts to make the stream wide oriented.&nbsp; If<b> mode</b> is less than zero, the function
 first attempts to make the stream byte oriented.&nbsp; Otherwise,<b> mode</b> is zero and the<tt> fwide</tt> function does
 not alter the orientation of the stream.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fwide</tt> function returns a value greater than zero if, after the call, the stream has wide orientation, a value
 less than zero if the stream has byte orientation, or zero if the stream has no orientation.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#freopen">freopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; mode;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = fwide( fp, -33 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;orientation: %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode &gt; 0 ? &quot;wide&quot; :</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode &lt; 0 ? &quot;byte&quot; : &quot;none&quot;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>orientation: byte</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="fwrite"> fwrite </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>size_t fwrite( const void *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t elsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t nelem,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> fwrite</tt> function writes<b> nelem</b> elements of<b> elsize</b> bytes each to the file specified by<b> fp</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> fwrite</tt> function returns the number of complete elements successfully written.&nbsp; This value will be less than
 the requested number of elements only if a write error occurs.&nbsp; When an error has occurred, <tt> errno</tt> contains
 a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#ferror">ferror</a>, <a href="#fopen">fopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>struct student_data {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp; student_id;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned char marks&#91;10&#93;;</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct student_data std;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;w&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std.student_id = 1001;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std.marks&#91; i &#93; = (unsigned char) (85 + i);</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* write student record with marks */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = fwrite( &amp;std, sizeof(std), 1, fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d record written\n&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="gcvt"> gcvt, _gcvt, _wgcvt </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>char *gcvt( double value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer );</tt>
<br><tt>char *_gcvt( double value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer );</tt>
<br><tt>wchar_t *_wgcvt( double value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int ndigits,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *buffer );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> gcvt</tt> function converts the floating-point number<b> value</b> into a character string and stores the result in<b>
 buffer</b>.&nbsp; The parameter<b> ndigits</b> specifies the number of significant digits desired.&nbsp; The converted number
 will be rounded to this position.
<br>If the exponent of the number is less than -4 or is greater than or equal to the number of significant digits wanted,
 then the number is converted into E-format, otherwise the number is formatted using F-format.
<br><br>The<tt> _gcvt</tt> function is identical to<tt> gcvt</tt>.&nbsp; Use<tt> _gcvt</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _wgcvt</tt> function is identical to<tt> gcvt</tt> except that it produces a wide-character string (which
 is twice as long).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> gcvt</tt> function returns a pointer to the string of digits.
</dl>
<dl>
<dt>See Also:
<dd><a href="#ecvt">ecvt</a>, <a href="#fcvt">fcvt</a>, <a href="#printf">printf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, gcvt( -123.456789, 5, buffer ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, gcvt( 123.456789E+12, 5, buffer ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>-123.46</tt>
<br><tt>1.2346E+014</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_gcvt conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> gcvt - Math</tt>
<br><tt>_gcvt - Math</tt>
<br><tt>_wgcvt - Math</tt>
</dl>
<h2 id="_getactivepage"> _getactivepage </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _getactivepage( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getactivepage</tt> function returns the number of the currently selected active graphics page.
<br>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple pages
 are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
 what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
 can be constructed without affecting the screen by setting the active page to be different than the visual page.
<br><br>The number of available video pages can be determined by using the <tt> _getvideoconfig</tt> function.&nbsp; The default
 video page is 0.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getactivepage</tt> function returns the number of the currently selected active graphics page.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setactivepage">_setactivepage</a>, <a href="#_setvisualpage">_setvisualpage</a>, <a href="#_getvisualpage">_getvisualpage</a>,
 <a href="#_getvideoconfig">_getvideoconfig</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_apage;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_vpage;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _HRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_apage = _getactivepage();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* draw an ellipse on page 0 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setactivepage( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvisualpage( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 50, 540, 150 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* draw a rectangle on page 1 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setactivepage( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 50, 540, 150 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* display page 1 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvisualpage( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setactivepage( old_apage );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvisualpage( old_vpage );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>_getactivepage is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getarcinfo"> _getarcinfo </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _getarcinfo( struct xycoord _FAR *start_pt,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; struct xycoord _FAR *end_pt,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; struct xycoord _FAR *inside_pt );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getarcinfo</tt> function returns information about the arc most recently drawn by the <tt> _arc</tt> or <tt> _pie</tt>
 functions.&nbsp; The arguments<b> start_pt</b> and<b> end_pt</b> are set to contain the endpoints of the arc.&nbsp; The argument<b>
 inside_pt</b> will contain the coordinates of a point within the pie.&nbsp; The points are all specified in the view coordinate
 system.
<br>The endpoints of the arc can be used to connect other lines to the arc.&nbsp; The interior point can be used to fill the
 pie.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getarcinfo</tt> function returns a non-zero value when successful.&nbsp; If the previous arc or pie was not successfully
 drawn, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_arc">_arc</a>, <a href="#_pie">_pie</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct xycoord start_pt, end_pt, inside_pt;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _arc( 120, 90, 520, 390, 520, 90, 120, 390 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _getarcinfo( &amp;start_pt, &amp;end_pt, &amp;inside_pt );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _moveto( start_pt.xcoord, start_pt.ycoord );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _lineto( end_pt.xcoord, end_pt.ycoord );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_getai.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getbkcolor"> _getbkcolor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>long _FAR _getbkcolor( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getbkcolor</tt> function returns the current background color.&nbsp; In text modes, the background color controls
 the area behind each individual character.&nbsp; In graphics modes, the background refers to the entire screen.&nbsp; The
 default background color is 0.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getbkcolor</tt> function returns the current background color.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setbkcolor">_setbkcolor</a>, <a href="#_remappalette">_remappalette</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>long colors&#91; 16 &#93; = {</tt>
<br><tt>&nbsp;&nbsp; _BLACK, _BLUE, _GREEN, _CYAN,</tt>
<br><tt>&nbsp;&nbsp; _RED, _MAGENTA, _BROWN, _WHITE,</tt>
<br><tt>&nbsp;&nbsp; _GRAY, _LIGHTBLUE, _LIGHTGREEN, _LIGHTCYAN,</tt>
<br><tt>&nbsp;&nbsp; _LIGHTRED, _LIGHTMAGENTA, _YELLOW, _BRIGHTWHITE</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long old_bk;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int bk;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( bk = 0; bk &lt; 16; ++bk ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setbkcolor( colors&#91; bk &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setbkcolor( old_bk );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="getc"> getc, getwc </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int getc( FILE *fp );</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wint_t getwc( FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> getc</tt> function gets the next character from the file designated by<b> fp</b>.&nbsp; The character is returned
 as an<tt> int</tt> value.&nbsp; The<tt> getc</tt> function is equivalent to <tt> fgetc</tt>, except that it may be implemented
 as a macro.
<br>The<tt> getwc</tt> function is identical to<tt> getc</tt> except that it gets the next multibyte character (if present)
 from the input stream pointed to by<b> fp</b> and converts it to a wide character.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> getc</tt> function returns the next character from the input stream pointed to by<b> fp</b>.&nbsp; If the stream is
 at end-of-file, the end-of-file indicator is set and<tt> getc</tt> returns <tt> EOF</tt>.&nbsp; If a read error occurs, the
 error indicator is set and<tt> getc</tt> returns <tt> EOF</tt>.
<br>The<tt> getwc</tt> function returns the next wide character from the input stream pointed to by<b> fp</b>.&nbsp; If the
 stream is at end-of-file, the end-of-file indicator is set and<tt> getwc</tt> returns <tt> WEOF</tt>.&nbsp; If a read error
 occurs, the error indicator is set and<tt> getwc</tt> returns <tt> WEOF</tt>.&nbsp; If an encoding error occurs, <tt> errno</tt>
 is set to <tt> EILSEQ</tt> and<tt> getwc</tt> returns <tt> WEOF</tt>.
<br><br>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fgetc">fgetc</a>, <a href="#fgetchar">fgetchar</a>, <a href="#fgets">fgets</a>, <a href="#fopen">fopen</a>, <a href="#getchar">getchar</a>,
 <a href="#gets">gets</a>, <a href="#ungetc">ungetc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = getc( fp )) != EOF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar(c);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>getc is ANSI
<br>getwc is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> getc - All, Netware</tt>
<br><tt>getwc - All</tt>
</dl>
<h2 id="getch"> getch </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>int getch( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> getch</tt> function obtains the next available keystroke from the console.&nbsp; Nothing is echoed on the screen (the
 function <tt> getche</tt> will echo the keystroke, if possible).&nbsp; When no keystroke is available, the function waits
 until a key is depressed.
<br>The <tt> kbhit</tt> function can be used to determine if a keystroke is available.
</dl>
<dl>
<dt>Returns:
<dd>A value of<tt> EOF</tt> is returned when an error is detected; otherwise the<tt> getch</tt> function returns the value of
 the keystroke (or character).
<br>When the keystroke represents an extended function key (for example, a function key, a cursor-movement key or the ALT
 key with a letter or a digit), zero is returned and the next call to<tt> getch</tt> returns a value for the extended function.
</dl>
<dl>
<dt>See Also:
<dd><a href="#getche">getche</a>, <a href="#kbhit">kbhit</a>, <a href="#putch">putch</a>, <a href="#ungetch">ungetch</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Press any key\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; c = getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;You pressed %c(%d)\n&quot;, c, c );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="getchar"> getchar, getwchar </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int getchar( void );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wint_t getwchar( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> getchar</tt> function is equivalent to <tt> getc</tt> with the argument <tt> stdin</tt>.
<br>The<tt> getwchar</tt> function is similar to<tt> getchar</tt> except that it is equivalent to <tt> getwc</tt> with the
 argument <tt> stdin</tt>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> getchar</tt> function returns the next character from the input stream pointed to by <tt> stdin</tt>.&nbsp; If the
 stream is at end-of-file, the end-of-file indicator is set and<tt> getchar</tt> returns <tt> EOF</tt>.&nbsp; If a read error
 occurs, the error indicator is set and<tt> getchar</tt> returns <tt> EOF</tt>.
<br>The<tt> getwchar</tt> function returns the next wide character from the input stream pointed to by <tt> stdin</tt>.&nbsp;
 If the stream is at end-of-file, the end-of-file indicator is set and<tt> getwchar</tt> returns <tt> WEOF</tt>.&nbsp; If
 a read error occurs, the error indicator is set and<tt> getwchar</tt> returns <tt> WEOF</tt>.&nbsp; If an encoding error
 occurs, <tt> errno</tt> is set to <tt> EILSEQ</tt> and<tt> getwchar</tt> returns <tt> WEOF</tt>.
<br><br>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fgetc">fgetc</a>, <a href="#fgetchar">fgetchar</a>, <a href="#fgets">fgets</a>, <a href="#fopen">fopen</a>, <a href="#getc">getc</a>,
 <a href="#gets">gets</a>, <a href="#ungetc">ungetc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = freopen( &quot;file&quot;, &quot;r&quot;, stdin );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( (c = getchar()) != EOF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar(c);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>getchar is ANSI
<br>getwchar is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> getchar - All, Netware</tt>
<br><tt>getwchar - All</tt>
</dl>
<h2 id="getche"> getche </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>int getche( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> getche</tt> function obtains the next available keystroke from the console.&nbsp; The function will wait until a keystroke
 is available.&nbsp; That character is echoed on the screen at the position of the cursor (use <tt> getch</tt> when it is
 not desired to echo the keystroke).
<br>The <tt> kbhit</tt> function can be used to determine if a keystroke is available.
</dl>
<dl>
<dt>Returns:
<dd>A value of<tt> EOF</tt> is returned when an error is detected; otherwise, the<tt> getche</tt> function returns the value of
 the keystroke (or character).
<br>When the keystroke represents an extended function key (for example, a function key, a cursor-movement key or the ALT
 key with a letter or a digit), zero is returned and the next call to<tt> getche</tt> returns a value for the extended function.
</dl>
<dl>
<dt>See Also:
<dd><a href="#getch">getch</a>, <a href="#kbhit">kbhit</a>, <a href="#putch">putch</a>, <a href="#ungetch">ungetch</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Press any key\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; c = getche();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;You pressed %c(%d)\n&quot;, c, c );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_getcliprgn"> _getcliprgn </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _getcliprgn( short _FAR *x1, short _FAR *y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; short _FAR *x2, short _FAR *y2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getcliprgn</tt> function returns the location of the current clipping region.&nbsp; A clipping region is defined
 with the <tt> _setcliprgn</tt> or <tt> _setviewport</tt> functions.&nbsp; By default, the clipping region is the entire screen.
<br>The current clipping region is a rectangular area of the screen to which graphics output is restricted.&nbsp; The top
 left corner of the clipping region is placed in the arguments<tt> (x1,y1).</tt>&nbsp; The bottom right corner of the clipping
 region is placed in<tt> (x2,y2).</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getcliprgn</tt> function returns the location of the current clipping region.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setcliprgn">_setcliprgn</a>, <a href="#_setviewport">_setviewport</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; short x1, y1, x2, y2;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _getcliprgn( &amp;x1, &amp;y1, &amp;x2, &amp;y2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setcliprgn( 130, 100, 510, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _ellipse( _GBORDER, 120, 90, 520, 390 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setcliprgn( x1, y1, x2, y2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="getcmd"> getcmd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;process.h&gt;</tt>
<br><tt>char *getcmd( char *cmd_line );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> getcmd</tt> function causes the command line information, with the program name removed, to be copied to<b> cmd_line</b>.
&nbsp; The information is terminated with a<tt> '\0'</tt> character.&nbsp; This provides a method of obtaining the original
 parameters to a program unchanged (with the white space intact).
<br>This information can also be obtained by examining the vector of program parameters passed to the main function in the
 program.
</dl>
<dl>
<dt>Returns:
<dd>The address of the target<b> cmd_line</b> is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abort">abort</a>, <a href="#atexit">atexit</a>, <a href="#_bgetcmd">_bgetcmd</a>, <a href="#exec___">exec...</a>,
 <a href="#exit">exit</a>, <a href="#_Exit">_Exit</a>, <a href="#_exit">_exit</a>, <a href="#getenv">getenv</a>, <a href="#main">main</a>,
 <a href="#onexit">onexit</a>, <a href="#putenv">putenv</a>, <a href="#spawn___">spawn...</a>, <a href="#system">system</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>Suppose a program were invoked with the command line
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; myprog arg-1 ( my&nbsp;&nbsp; stuff ) here</tt>
<br><br>where that program contains
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;process.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char cmds&#91;128&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, getcmd( cmds ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>&nbsp; arg-1 ( my&nbsp;&nbsp; stuff ) here</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_getcolor"> _getcolor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _getcolor( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getcolor</tt> function returns the pixel value for the current color.&nbsp; This is the color used for displaying
 graphics output.&nbsp; The default color value is one less than the maximum number of colors in the current video mode.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getcolor</tt> function returns the pixel value for the current color.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setcolor">_setcolor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int col, old_col;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_col = _getcolor();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( col = 0; col &lt; 16; ++col ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setcolor( col );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setcolor( old_col );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getcurrentposition"> _getcurrentposition, _getcurrentposition_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>struct xycoord _FAR _getcurrentposition( void );</tt>
<br><br><tt>struct _wxycoord _FAR _getcurrentposition_w( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getcurrentposition</tt> functions return the current output position for graphics.&nbsp; The<tt> _getcurrentposition</tt>
 function returns the point in view coordinates.&nbsp; The<tt> _getcurrentposition_w</tt> function returns the point in window
 coordinates.
<br>The current position defaults to the origin,<tt> (0,0),</tt> when a new video mode is selected.&nbsp; It is changed by
 successful calls to the <tt> _arc</tt>, <tt> _moveto</tt> and <tt> _lineto</tt> functions as well as the <tt> _setviewport</tt>
 function.
<br><br>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
 text output can be set by use of the <tt> _settextposition</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getcurrentposition</tt> functions return the current output position for graphics.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_moveto">_moveto</a>, <a href="#_settextposition">_settextposition</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct xycoord old_pos;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_pos = _getcurrentposition();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _lineto( 540, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _lineto( 320, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _lineto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _moveto( old_pos.xcoord, old_pos.ycoord );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _getcurrentposition - DOS, QNX</tt>
<br><tt>_getcurrentposition_w - DOS, QNX</tt>
</dl>
<h2 id="getcwd"> getcwd, _wgetcwd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><tt>char *getcwd( char *buffer, size_t size );</tt>
<br><tt>wchar_t *_wgetcwd( wchar_t *buffer, size_t size );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> getcwd</tt> function returns the name of the current working directory.&nbsp; The<b> buffer</b> address is either<tt>
 NULL</tt> or is the location at which a string containing the name of the current working directory is placed.&nbsp; In the
 latter case, the value of<b> size</b> is the length (including the delimiting<tt> '\0'</tt> character) which can be be used
 to store this name.
<br>The maximum size that might be required for<b> buffer</b> is <tt> PATH_MAX</tt> + 1 bytes.
<br><br><b>Extension:</b>&nbsp; When<b> buffer</b> has a value of<tt> NULL,</tt> a string is allocated using <tt> malloc</tt>
 to contain the name of the current working directory.&nbsp; This string may be freed using the <tt> free</tt> function.&nbsp;
 The<tt> _wgetcwd</tt> function is identical to<tt> getcwd</tt> except that it returns the name of the current working directory
 as a wide-character string (which is twice as long).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> getcwd</tt> function returns the address of the string containing the name of the current working directory, unless
 an error occurs, in which case<tt> NULL</tt> is returned.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EINVAL
<dd>The argument<b> size</b> is negative.
<dt><br>ENOMEM
<dd>Not enough memory to allocate a buffer.
<dt><br>ERANGE
<dd>The buffer is too small (specified by<b> size</b>) to contain the name of the current working directory.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#chdir">chdir</a>, <a href="#chmod">chmod</a>, <a href="#_getdcwd">_getdcwd</a>, <a href="#mkdir">mkdir</a>, <a href="#rmdir">rmdir</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *cwd;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; cwd = getcwd( NULL, 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( cwd != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;My working directory is %s\n&quot;, cwd );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( cwd );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>My working directory is C:\PROJECT\C</tt>
</dl>
<dl>
<dt>Classification:
<dd>getcwd is POSIX 1003.1 with extensions
<br>_wgetcwd is not POSIX
</dl>
<dl>
<dt>Systems:
<dd><tt> getcwd - All, Netware</tt>
<br><tt>_wgetcwd - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_getdcwd"> _getdcwd, _wgetdcwd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><tt>char *_getdcwd( int drive, char *buffer, size_t maxlen );</tt>
<br><tt>wchar_t *_wgetdcwd( int drive, wchar_t *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 size_t maxlen );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getdcwd</tt> function gets the full path of the current working directory on the specified drive.&nbsp; The<b> drive</b>
 argument specifies the drive (0 = default drive, 1 = A, 2 = B, etc.).&nbsp; The<b> buffer</b> address is either<tt> NULL</tt>
 or is the location at which a string containing the name of the current working directory is placed.&nbsp; In the latter
 case, the value of<b> maxlen</b> is the length (including the terminating<tt> '\0'</tt> character) which can be be used to
 store this name.&nbsp; An error occurs if the length of the path (including the terminating<tt> '\0'</tt> character) exceeds<b>
 maxlen</b>.
<br>The maximum size that might be required for<b> buffer</b> is <tt> PATH_MAX</tt> + 1 bytes.
<br><br>When<b> buffer</b> has a value of<tt> NULL,</tt> a string is allocated using <tt> malloc</tt> to contain the name
 of the current working directory.&nbsp; This string may be freed using the <tt> free</tt> function.&nbsp; The<tt> _wgetdcwd</tt>
 function is identical to<tt> _getdcwd</tt> except that it returns the name of the current working directory as a wide-character
 string (which is twice as long).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getdcwd</tt> function returns the address of the string containing the name of the current working directory on the
 specified drive, unless an error occurs, in which case<tt> NULL</tt> is returned.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>ENODEV
<dd>The drive cannot be accessed.
<dt><br>ENOMEM
<dd>Not enough memory to allocate a buffer.
<dt><br>ERANGE
<dd>The buffer is too small (specified by<b> size</b>) to contain the name of the current working directory.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#chdir">chdir</a>, <a href="#chmod">chmod</a>, <a href="#getcwd">getcwd</a>, <a href="#mkdir">mkdir</a>, <a href="#rmdir">rmdir</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *cwd;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; cwd = _getdcwd( 3, NULL, 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( cwd != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;The current directory on drive C is %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cwd );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( cwd );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>The current directory on drive C is C:\PROJECT\C</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _getdcwd - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wgetdcwd - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_getdiskfree"> _getdiskfree </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><tt>unsigned _getdiskfree( unsigned drive,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; struct diskfree_t *diskspace );</tt>
<br><tt>struct diskfree_t {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short total_clusters;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short avail_clusters;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short sectors_per_cluster;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short bytes_per_sector;</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getdiskfree</tt> function uses system call 0x36 to obtain useful information on the disk drive specified by<b> drive</b>.
&nbsp; Specify 0 for the default drive, 1 for drive A, 2 for drive B, etc.&nbsp; The information about the drive is returned
 in the structure <tt> diskfree_t</tt> pointed to by<b> diskspace</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getdiskfree</tt> function returns zero if successful.&nbsp; Otherwise, it returns a non-zero value and sets <tt>
 errno</tt> to <tt> EINVAL</tt> indicating an invalid drive was specified.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_getdiskfree">_dos_getdiskfree</a>, <a href="#_dos_getdrive">_dos_getdrive</a>, <a href="#_dos_setdrive">_dos_setdrive</a>,
 <a href="#_getdrive">_getdrive</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct diskfree_t disk_data;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* get information about drive 3 (the C drive) */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( _getdiskfree( 3, &amp;disk_data ) == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;total clusters: %u\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; disk_data.total_clusters );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;available clusters: %u\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; disk_data.avail_clusters );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;sectors/cluster: %u\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; disk_data.sectors_per_cluster );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;bytes per sector: %u\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; disk_data.bytes_per_sector );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Invalid drive specified\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>total clusters: 16335</tt>
<br><tt>available clusters: 510</tt>
<br><tt>sectors/cluster: 4</tt>
<br><tt>bytes per sector: 512</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_getdrive"> _getdrive </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><tt>int _getdrive( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getdrive</tt> function returns the current (default) drive number.
</dl>
<dl>
<dt>Returns:
<dd>A value of 1 is drive A, 2 is drive B, 3 is drive C, etc.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_getdiskfree">_dos_getdiskfree</a>, <a href="#_dos_getdrive">_dos_getdrive</a>, <a href="#_dos_setdrive">_dos_setdrive</a>,
 <a href="#_getdiskfree">_getdiskfree</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The current drive is %c\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'A' + _getdrive() - 1 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>The current drive is C</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="getenv"> getenv, _wgetenv </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>char *getenv( const char *name );</tt>
<br><tt>wchar_t *_wgetenv( const wchar_t *name );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#getenv_s">getenv_s</a> function which is a safer alternative to<tt> getenv</tt>.
&nbsp; This newer<tt> getenv_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> getenv</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> getenv</tt> function searches the environment list for an entry matching the string pointed to by<b> name</b>.&nbsp;
 The matching is case-insensitive; all lowercase letters are treated as if they were in upper case.
<br>Entries can be added to the environment list with the DOS<tt> set</tt> command or with the <tt> putenv</tt> or <tt> setenv</tt>
 functions.&nbsp; All entries in the environment list can be displayed by using the DOS<tt> set</tt> command with no arguments.
<br><br>To assign a string to a variable and place it in the environment list:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET INCLUDE=C:\WATCOM\H</tt>
<br><br>To see what variables are in the environment list, and their current assignments:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMSPEC=C:\COMMAND.COM</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PATH=C:\;C:\WATCOM</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE=C:\WATCOM\H</tt>
<br><br><tt>_wgetenv</tt> is a wide-character version of<tt> getenv</tt> the argument and return value of<tt> _wgetenv</tt>
 are wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> getenv</tt> function returns a pointer to the string assigned to the environment variable if found, and NULL if no
 match was found.&nbsp; Note:&nbsp; the value returned should be duplicated if you intend to modify the contents of the string.
</dl>
<dl>
<dt>See Also:
<dd><a href="#clearenv">clearenv</a>, <a href="#exec___">exec...</a>, <a href="#getenv_s">getenv_s</a>, <a href="#putenv">putenv</a>,
 <a href="#_searchenv">_searchenv</a>, <a href="#setenv">setenv</a>, <a href="#spawn___">spawn...</a>, <a href="#system">system</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *path;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; path = getenv( &quot;INCLUDE&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( path != NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;INCLUDE=%s\n&quot;, path );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>getenv is ANSI
<br>_wgetenv is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> getenv - All, Netware</tt>
<br><tt>_wgetenv - All</tt>
</dl>
<h2 id="getenv_s"> getenv_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>errno_t getenv_s( size_t * restrict len,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char * restrict
 value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t maxsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char
 * restrict name );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 getenv_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br><b>name</b> shall not be a null pointer.<b>&nbsp; maxsize</b> shall neither be equal to zero nor be greater than <tt>
 RSIZE_MAX</tt>.&nbsp; If<b> maxsize</b> is not equal to zero, then<b> value</b> shall not be a null pointer.
<br><br>If there is a runtime-constraint violation, the integer pointed to by<b> len</b> (if<b> len</b> is not null) is set
 to zero, and the environment list is not searched.
</dl>
<dl>
<dt>Description:
<dd>The<tt> getenv_s</tt> function searches the environment list for an entry matching the string pointed to by<b> name</b>.
<br>If that entry is found,<tt> getenv_s</tt> performs the following actions.&nbsp; If<b> len</b> is not a null pointer, the
 length of the string associated with the matched entry is stored in the integer pointed to by<b> len</b>.&nbsp; If the length
 of the associated string is less than<b> maxsize</b>, then the associated string is copied to the array pointed to by<b>
 value</b>.
<br><br>If that entry is not found,<tt> getenv_s</tt> performs the following actions.&nbsp; If<b> len</b> is not a null pointer,
 zero is stored in the integer pointed to by<b> len</b>.&nbsp; If<b> maxsize</b> is greater than zero, then<b> value&#91;0&#93;</b>
 is set to the null character.
<br><br>The matching is case-insensitive; all lowercase letters are treated as if they were in upper case.
<br><br>Entries can be added to the environment list with the DOS<tt> set</tt> command or with the <tt> putenv</tt> or <tt>
 setenv</tt> functions.&nbsp; All entries in the environment list can be displayed by using the DOS<tt> set</tt> command with
 no arguments.
<br><br>To assign a string to a variable and place it in the environment list:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET INCLUDE=C:\WATCOM\H</tt>
<br><br>To see what variables are in the environment list, and their current assignments:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMSPEC=C:\COMMAND.COM</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PATH=C:\;C:\WATCOM</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE=C:\WATCOM\H</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> getenv_s</tt> function returns zero if the environment string specified by<b> name</b> was found and successfully
 stored in the buffer pointed to by<b> value</b>.&nbsp; Otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#clearenv">clearenv</a>, <a href="#exec___">exec...</a>, <a href="#getenv">getenv</a>, <a href="#putenv">putenv</a>,
 <a href="#_searchenv">_searchenv</a>, <a href="#setenv">setenv</a>, <a href="#spawn___">spawn...</a>, <a href="#system">system</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; buffer&#91;128&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t&nbsp; len;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( getenv_s( &amp;len, buffer, sizeof( buffer ), &quot;INCLUDE&quot; ) == 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;INCLUDE=%s\n&quot;, buffer );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>TR 24731
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_getfillmask"> _getfillmask </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>unsigned char _FAR * _FAR</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _getfillmask( unsigned char _FAR *mask );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getfillmask</tt> function copies the current fill mask into the area located by the argument<b> mask</b>.&nbsp; The
 fill mask is used by the <tt> _ellipse</tt>, <tt> _floodfill</tt>, <tt> _pie</tt>, <tt> _polygon</tt> and <tt> _rectangle</tt>
 functions that fill an area of the screen.
<br>The fill mask is an eight-byte array which is interpreted as a square pattern (8 by 8) of 64 bits.&nbsp; Each bit in the
 mask corresponds to a pixel.&nbsp; When a region is filled, each point in the region is mapped onto the fill mask.&nbsp;
 When a bit from the mask is one, the pixel value of the corresponding point is set using the current plotting action with
 the current color; when the bit is zero, the pixel value of that point is not affected.
<br><br>When the fill mask is not set, a fill operation will set all points in the fill region to have a pixel value of the
 current color.
</dl>
<dl>
<dt>Returns:
<dd>If no fill mask has been set,<tt> NULL</tt> is returned; otherwise, the<tt> _getfillmask</tt> function returns<b> mask</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_floodfill">_floodfill</a>, <a href="#_setfillmask">_setfillmask</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>char old_mask&#91; 8 &#93;;</tt>
<br><tt>char new_mask&#91; 8 &#93; = { 0x81, 0x42, 0x24, 0x18,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 0x18, 0x24, 0x42, 0x81 };</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _getfillmask( old_mask );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setfillmask( new_mask );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setfillmask( old_mask );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getfontinfo"> _getfontinfo </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _getfontinfo( struct _fontinfo _FAR *info );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getfontinfo</tt> function returns information about the currently selected font.&nbsp; Fonts are selected with the
 <tt> _setfont</tt> function.&nbsp; The font information is returned in the<tt> _fontinfo</tt> structure indicated by the
 argument<b> info</b>.&nbsp; The structure contains the following fields:
<dl>
<dt>type
<dd>1 for a vector font, 0 for a bit-mapped font
<dt><br>ascent
<dd>distance from top of character to baseline in pixels
<dt><br>pixwidth
<dd>character width in pixels (0 for a proportional font)
<dt><br>pixheight
<dd>character height in pixels
<dt><br>avgwidth
<dd>average character width in pixels
<dt><br>filename
<dd>name of the file containing the current font
<dt><br>facename
<dd>name of the current font
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getfontinfo</tt> function returns zero if the font information is returned successfully; otherwise a negative value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_setfont">_setfont</a>,
 <a href="#_outgtext">_outgtext</a>, <a href="#_getgtextextent">_getgtextextent</a>, <a href="#_setgtextvector">_setgtextvector</a>,
 <a href="#_getgtextvector">_getgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int width;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct _fontinfo info;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _getfontinfo( &amp;info );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; width = _getgtextextent( &quot;WATCOM Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100 + width, 100 + info.pixheight
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getgtextextent"> _getgtextextent </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _getgtextextent( char _FAR *text );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getgtextextent</tt> function returns the length in pixels of the argument<b> text</b> as it would be displayed in
 the current font by the function <tt> _outgtext</tt>.&nbsp; Note that the text is not displayed on the screen, only its length
 is determined.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getgtextextent</tt> function returns the length in pixels of a string.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_setfont">_setfont</a>,
 <a href="#_getfontinfo">_getfontinfo</a>, <a href="#_outgtext">_outgtext</a>, <a href="#_setgtextvector">_setgtextvector</a>,
 <a href="#_getgtextvector">_getgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int width;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct _fontinfo info;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _getfontinfo( &amp;info );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; width = _getgtextextent( &quot;WATCOM Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100 + width, 100 + info.pixheight
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getgtextvector"> _getgtextvector </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>struct xycoord _FAR _getgtextvector( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getgtextvector</tt> function returns the current value of the text orientation vector.&nbsp; This is the direction
 used when text is displayed by the <tt> _outgtext</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getgtextvector</tt> function returns, as an<tt> xycoord</tt> structure, the current value of the text orientation
 vector.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_setfont">_setfont</a>,
 <a href="#_getfontinfo">_getfontinfo</a>, <a href="#_outgtext">_outgtext</a>, <a href="#_getgtextextent">_getgtextextent</a>,
 <a href="#_setgtextvector">_setgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct xycoord old_vec;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_vec = _getgtextvector();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setgtextvector( 0, -1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setgtextvector( old_vec.xcoord, old_vec.ycoord );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getimage"> _getimage, _getimage_w, _getimage_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _getimage( short x1, short y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; short x2, short y2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; char _HUGE *image );</tt>
<br><br><tt>void _FAR _getimage_w( double x1, double y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double x2, double y2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char _HUGE *image );</tt>
<br><br><tt>void _FAR _getimage_wxy( struct _wxycoord _FAR *p1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *p2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _HUGE *image );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getimage</tt> functions store a copy of an area of the screen into the buffer indicated by the<b> image</b> argument.
&nbsp; The<tt> _getimage</tt> function uses the view coordinate system.&nbsp; The<tt> _getimage_w</tt> and<tt> _getimage_wxy</tt>
 functions use the window coordinate system.
<br>The screen image is the rectangular area defined by the points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>&nbsp; The buffer<b>
 image</b> must be large enough to contain the image (the size of the image can be determined by using the <tt> _imagesize</tt>
 function).&nbsp; The image may be displayed upon the screen at some later time by using the <tt> _putimage</tt> functions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getimage</tt> functions do not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_imagesize">_imagesize</a>, <a href="#_putimage">_putimage</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *buf;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int y;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 100, 200, 200 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; buf = (char*) malloc(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _imagesize(
 100, 100, 201, 201 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( buf != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _getimage( 100, 100, 201, 201, buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 260, 200, buf, _GPSET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, 100, buf, _GPSET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( y = 100; y &lt; 300; ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, y, buf, _GXOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += 20;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, y, buf, _GXOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _getimage - DOS, QNX</tt>
<br><tt>_getimage_w - DOS, QNX</tt>
<br><tt>_getimage_wxy - DOS, QNX</tt>
</dl>
<h2 id="_getlinestyle"> _getlinestyle </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>unsigned short _FAR _getlinestyle( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getlinestyle</tt> function returns the current line-style mask.
<br>The line-style mask determines the style by which lines and arcs are drawn.&nbsp; The mask is treated as an array of 16
 bits.&nbsp; As a line is drawn, a pixel at a time, the bits in this array are cyclically tested.&nbsp; When a bit in the
 array is 1, the pixel value for the current point is set using the current color according to the current plotting action;
 otherwise, the pixel value for the point is left unchanged.&nbsp; A solid line would result from a value of<tt> 0xFFFF</tt>
 and a dashed line would result from a value of<tt> 0xF0F0</tt>
<br><br>The default line style mask is<tt> 0xFFFF</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getlinestyle</tt> function returns the current line-style mask.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_lineto">_lineto</a>, <a href="#_pie">_pie</a>, <a href="#_rectangle">_rectangle</a>, <a href="#_polygon">_polygon</a>,
 <a href="#_setlinestyle">_setlinestyle</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>#define DASHED 0xf0f0</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned old_style;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_style = _getlinestyle();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setlinestyle( DASHED );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setlinestyle( old_style );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getmbcp"> _getmbcp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>int _getmbcp( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getmbcp</tt> function returns the current multibyte code page number.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getmbcp</tt> function returns the current multibyte code page.&nbsp; A return value of zero indicates that a single
 byte code page is in use.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbctombb">_mbctombb</a>,
 <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>, <a href="#_ismbbkalnum">_ismbbkalnum</a>,
 <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>, <a href="#_ismbbkprint">_ismbbkprint</a>,
 <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>, <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>,
 <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, _setmbcp( 932 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, _getmbcp() );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0</tt>
<br><tt>932</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="getopt"> getopt </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;unistd.h&gt;</tt>
<br><tt>int getopt( int argc, char * const argv&#91;&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *optstring );</tt>
<br><br><tt>char&nbsp;&nbsp; *optarg;</tt>
<br><tt>int&nbsp;&nbsp;&nbsp; optind, opterr, optopt;</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> getopt</tt> function is a command-line parser that can be used by applications that follow Utility Syntax Guidelines
 3, 4, 5, 6, 7, 9 and 10 in the Base Definitions volume of IEEE Std 1003.1-2001, Section 12.2, Utility Syntax Guidelines.
<br>The parameters<b> argc</b> and<b> argv</b> are the argument count and argument array as passed to <tt> main</tt>.&nbsp;
 The argument<b> optstring</b> is a string of recognised option characters; if a character is followed by a colon, the option
 takes an argument.&nbsp; All option characters allowed by Utility Syntax Guideline 3 are allowed in<b> optstring</b>.
<br><br>The global variable <tt> optind</tt> is the index of the next element of the<b> argv&#91;&#93;</b> vector to be processed.
&nbsp; It is initialised to 1 by the system, and<tt> getopt</tt> updates it when it finishes with each element of<b> argv&#91;&#93;</b>.
&nbsp; When an element of<b> argv&#91;&#93;</b> contains multiple option characters,<tt> getopt</tt> uses a static variable
 to determine which options have already been processed.
<br><br>The<tt> getopt</tt> function returns the next option character (if one is found) from<b> argv</b> that matches a character
 in<b> optstring</b>, if there is one that matches.&nbsp; If the option takes an argument,<tt> getopt</tt> sets the variable
 <tt> optarg</tt> to point to the option-argument as follows:
<br><br>If the option was the last character in the string pointed to by an element of<b> argv</b>, then <tt> optarg</tt>
 contains the next element of<b> argv</b>, and <tt> optind</tt> is incremented by 2.&nbsp; If the resulting value of <tt>
 optind</tt> is not less than<b> argc</b>, this indicates a missing option-argument, and<tt> getopt</tt> returns an error
 indication.
<br><br>Otherwise, <tt> optarg</tt> points to the string following the option character in that element of<b> argv</b>, and
 <tt> optind</tt> is incremented by 1.
<br><br>If, when<tt> getopt</tt> is called:
<ul>
<li><b> argv&#91;optind&#93;</b> is a null pointer
<li><b> *argv&#91;optind&#93;</b> is not the character '-'
<li><b> argv&#91;optind&#93;</b> points to the string &quot;-&quot;
</ul>
<br><tt>getopt</tt> returns -1 without changing <tt> optind</tt>.&nbsp; If<b> argv&#91;optind&#93;</b> points to the string
 &quot;--&quot;,<tt> getopt</tt> returns -1 after incrementing <tt> optind</tt>.
<br><br>If<tt> getopt</tt> encounters an option character that is not contained in<b> optstring</b>, it returns the question-mark
 (?) character.&nbsp; If it detects a missing option-argument, it returns the colon character (:) if the first character of<b>
 optstring</b> was a colon, or a question-mark character (?) otherwise.&nbsp; In either case,<tt> getopt</tt> will set the
 global variable <tt> optopt</tt> to the option character that caused the error.&nbsp; If the application has not set the
 global variable <tt> opterr</tt> to 0 and the first character of<b> optstring</b> is not a colon,<tt> getopt</tt> also prints
 a diagnostic message to <tt> stderr</tt>.
<br><br>The<tt> getopt</tt> function is not re-entrant and hence not thread-safe.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> getopt</tt> function returns the next option character specified on the command line.
<br>A colon (:) is returned if<tt> getopt</tt> detects a missing argument and the first character of<b> optstring</b> was
 a colon (:).
<br><br>A question mark (?) is returned if<tt> getopt</tt> encounters an option character not in<b> optstring</b> or detects
 a missing argument and the first character of<b> optstring</b> was not a colon (:).
<br><br>Otherwise,<tt> getopt</tt> returns -1 when all command line options are parsed.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abort">abort</a>, <a href="#atexit">atexit</a>, <a href="#_bgetcmd">_bgetcmd</a>, <a href="#exec___">exec...</a>,
 <a href="#exit">exit</a>, <a href="#_Exit">_Exit</a>, <a href="#_exit">_exit</a>, <a href="#getcmd">getcmd</a>, <a href="#getenv">getenv</a>,
 <a href="#main">main</a>, <a href="#onexit">onexit</a>, <a href="#putenv">putenv</a>, <a href="#spawn___">spawn...</a>, <a href="#system">system</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;unistd.h&gt;</tt>
<br><br><tt>int main( int argc, char **argv )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; c;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *ifile;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *ofile;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; while( (c = getopt( argc, argv, &quot;:abf:o:&quot; )) != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( c ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'a':</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;option a is set\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'b':</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;option b is set\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'f':</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ifile = optarg;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;input filename is '%s'\n&quot;, ifile
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'o':</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ofile = optarg;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;output filename is '%s'\n&quot;,
 ofile );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case ':':</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;-%c without filename\n&quot;, optopt
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case '?':</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;usage: %s -ab -f &lt;filename&gt;
 -o &lt;filename&gt;\n&quot;, argv&#91;0&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>option a is set</tt>
<br><tt>input filename is 'in'</tt>
<br><tt>output filename is 'out'</tt>
<br><br>when the program is executed with the command
<br><br><tt>&lt;program name&gt; -afin -o out</tt>
</dl>
<dl>
<dt>Classification:
<dd>POSIX
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="_get_osfhandle"> _get_osfhandle </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>long _get_osfhandle( int posixhandle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _get_osfhandle</tt> function returns the operating system's internal file handle that corresponds to the POSIX-level
 file handle specified by<b> posixhandle</b>.
<br>The value returned by<tt> _get_osfhandle</tt> can be used as an argument to the <tt> _open_osfhandle</tt> function which
 can be used to connect a second POSIX-level handle to an open file.
<br><br>The example below demonstrates the use of these two functions.&nbsp; Note that the example shows how the <tt> dup2</tt>
 function can be used to obtain almost identical functionality.
<br><br>When the POSIX-level file handles associated with one OS file handle are closed, the first one closes successfully
 but the others return an error (since the first call close the file and released the OS file handle).&nbsp; So it is important
 to call <tt> close</tt> at the right time, i.e., after all I/O operations are completed to the file.
</dl>
<dl>
<dt>Returns:
<dd>If successful,<tt> _get_osfhandle</tt> returns an operating system file handle corresponding to<b> posixhandle</b>.&nbsp;
 Otherwise, it returns -1 and sets <tt> errno</tt> to <tt> EBADF</tt>, indicating an invalid file handle.
</dl>
<dl>
<dt>See Also:
<dd><a href="#close">close</a>, <a href="#dup2">dup2</a>, <a href="#fdopen">fdopen</a>, <a href="#_hdopen">_hdopen</a>, <a href="#open">open</a>,
 <a href="#_open_osfhandle">_open_osfhandle</a>, <a href="#_os_handle">_os_handle</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long os_handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int fh1, fh2, rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fh1 = open( &quot;file&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC
 | O_BINARY,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
 | S_IWGRP );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fh1 == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Could not open output file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;First POSIX handle %d\n&quot;, fh1 );</tt>
<br><br><tt>#if defined(USE_DUP2)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fh2 = 6;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( dup2( fh1, fh2 ) == -1 ) fh2 = -1;</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; os_handle = _get_osfhandle( fh1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;OS Handle %ld\n&quot;, os_handle );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fh2 = _open_osfhandle( os_handle, O_WRONLY |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_BINARY );</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fh2 == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Could not open with second handle\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Second POSIX handle %d\n&quot;, fh2 );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = write( fh2, &quot;trash\x0d\x0a&quot;, 7 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Write file using second handle %d\n&quot;, rc );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = close( fh2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Closing second handle %d\n&quot;, rc );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = close( fh1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Closing first handle %d\n&quot;, rc );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Netware
</dl>
<h2 id="_getphyscoord"> _getphyscoord </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>struct xycoord _FAR _getphyscoord( short x, short y );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getphyscoord</tt> function returns the physical coordinates of the position with view coordinates<tt> (x,y).</tt>
&nbsp; View coordinates are defined by the <tt> _setvieworg</tt> and <tt> _setviewport</tt> functions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getphyscoord</tt> function returns the physical coordinates, as an<tt> xycoord</tt> structure, of the given point.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getviewcoord">_getviewcoord</a>, <a href="#_setvieworg">_setvieworg</a>, <a href="#_setviewport">_setviewport</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct xycoord pos;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvieworg( rand() % 640, rand() % 480 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pos = _getphyscoord( 0, 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, - pos.xcoord, - pos.ycoord,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 639 - pos.xcoord, 479 - pos.ycoord );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>_getphyscoord is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="getpid"> getpid </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;process.h&gt;</tt>
<br><tt>int getpid(void);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> getpid</tt> function returns the process id for the current process.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> getpid</tt> function returns the process id for the current process.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;process.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int process_id;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char filename&#91;13&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; process_id = getpid();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* use this to create a unique file name */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; sprintf( filename, &quot;TMP%4.4x.TMP&quot;, process_id );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>POSIX 1003.1
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="_getpixel"> _getpixel, _getpixel_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _getpixel( short x, short y );</tt>
<br><br><tt>short _FAR _getpixel_w( double x, double y );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getpixel</tt> functions return the pixel value for the point with coordinates<tt> (x,y).</tt>&nbsp; The<tt> _getpixel</tt>
 function uses the view coordinate system.&nbsp; The<tt> _getpixel_w</tt> function uses the window coordinate system.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getpixel</tt> functions return the pixel value for the given point when the point lies within the clipping region;
 otherwise, (-1) is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setpixel">_setpixel</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int x, y;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt;= 60000; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 101 + rand() % 439;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 101 + rand() % 279;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setcolor( _getpixel( x, y ) + 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setpixel( x, y );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _getpixel - DOS, QNX</tt>
<br><tt>_getpixel_w - DOS, QNX</tt>
</dl>
<h2 id="_getplotaction"> _getplotaction </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _getplotaction( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getplotaction</tt> function returns the current plotting action.
<br>The drawing functions cause pixels to be set with a pixel value.&nbsp; By default, the value to be set is obtained by
 replacing the original pixel value with the supplied pixel value.&nbsp; Alternatively, the replaced value may be computed
 as a function of the original and the supplied pixel values.
<br><br>The plotting action can have one of the following values:
<dl>
<dt>_GPSET
<dd>replace the original screen pixel value with the supplied pixel value
<dt><br>_GAND
<dd>replace the original screen pixel value with the<b> bitwise and</b> of the original pixel value and the supplied pixel value
<dt><br>_GOR
<dd>replace the original screen pixel value with the<b> bitwise or</b> of the original pixel value and the supplied pixel value
<dt><br>_GXOR
<dd>replace the original screen pixel value with the<b> bitwise exclusive-or</b> of the original pixel value and the supplied
 pixel value.&nbsp; Performing this operation twice will restore the original screen contents, providing an efficient method
 to produce animated effects.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getplotaction</tt> function returns the current plotting action.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_act;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_act = _getplotaction();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setplotaction( _GPSET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setplotaction( _GXOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setplotaction( old_act );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="gets"> gets, _getws </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>char *gets( char *buf );</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>wchar_t *_getws( wchar_t *buf );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> gets</tt> function gets a string of characters from the file designated by <tt> stdin</tt> and stores them in the
 array pointed to by<b> buf</b> until end-of-file is encountered or a new-line character is read.&nbsp; Any new-line character
 is discarded, and a null character is placed immediately after the last character read into the array.
<br>The<tt> _getws</tt> function is identical to<tt> gets</tt> except that it gets a string of multibyte characters (if present)
 from the input stream pointed to by <tt> stdin</tt>, converts them to wide characters, and stores them in the wide-character
 array pointed to by<b> buf</b> until end-of-file is encountered or a wide-character new-line character is read.
<br><br>It is recommended that <tt> fgets</tt> be used instead of<tt> gets</tt> because data beyond the array<b> buf</b> will
 be destroyed if a new-line character is not read from the input stream <tt> stdin</tt> before the end of the array<b> buf</b>
 is reached.
<br><br>A common programming error is to assume the presence of a new-line character in every string that is read into the
 array.&nbsp; A new-line character may not appear as the last character in a file, just before end-of-file.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> gets</tt> function returns<b> buf</b> if successful.<tt>&nbsp; NULL</tt> is returned if end-of-file is encountered,
 or if a read error occurs.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error
 that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fgetc">fgetc</a>, <a href="#fgetchar">fgetchar</a>, <a href="#fgets">fgets</a>, <a href="#fopen">fopen</a>, <a href="#getc">getc</a>,
 <a href="#getchar">getchar</a>, <a href="#ungetc">ungetc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; while( gets( buffer ) != NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( buffer );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>gets is ANSI
<br>_getws is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> gets - All, Netware</tt>
<br><tt>_getws - All</tt>
</dl>
<h2 id="gets_s"> gets_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>char *gets_s( char *s, rsize_t n );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 gets_s</tt> will set<b> s&#91;0&#93;</b> to be the null character, and characters are read and discarded from <tt> stdin</tt>
 until a new-line character is read, or end-of-file or a read error occurs.
<br><b>s</b> shall not be a null pointer.<b>&nbsp; n</b> shall neither be equal to zero nor be greater than <tt> RSIZE_MAX</tt>
 .&nbsp; A new-line character, end-of-file, or read error shall occur within reading<b> n-1</b> characters from <tt> stdin</tt>
 .
</dl>
<dl>
<dt>Description:
<dd>The<tt> gets_s</tt> function gets a string of characters from the file designated by <tt> stdin</tt> and stores them in the
 array pointed to by<b> s</b> until end-of-file is encountered or a new-line character is read.&nbsp; Size of the array<b>
 s</b> is specified by the argument<b> n</b> , this information is used to protect buffer from overflow.&nbsp; If buffer<b>
 s</b> is about to be overflown, runtime-constraint is activated.&nbsp; Any new-line character is discarded, and a null character
 is placed immediately after the last character read into the array.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> gets_s</tt> function returns<b> s</b> if successful.<tt>&nbsp; NULL</tt> is returned if there was a runtime-constraint
 violation, or if end-of-file is encountered and no caracters have been read into the array, or if a read error occurs.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fgetc">fgetc</a>, <a href="#fgetchar">fgetchar</a>, <a href="#fgets">fgets</a>, <a href="#fopen">fopen</a>, <a href="#getc">getc</a>,
 <a href="#getchar">getchar</a>, <a href="#gets">gets</a>, <a href="#ungetc">ungetc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>int main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; while( gets_s( buffer, sizeof( buffer ) ) != NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( buffer );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>TR 24731
</dl>
<h2 id="_gettextcolor"> _gettextcolor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _gettextcolor( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _gettextcolor</tt> function returns the pixel value of the current text color.&nbsp; This is the color used for displaying
 text with the <tt> _outtext</tt> and <tt> _outmem</tt> functions.&nbsp; The default text color value is set to 7 whenever
 a new video mode is selected.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _gettextcolor</tt> function returns the pixel value of the current text color.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextcolor">_settextcolor</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_col;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long old_bk;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_col = _gettextcolor();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextcolor( 7 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setbkcolor( _BLUE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( &quot; WATCOM \nGraphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextcolor( old_col );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setbkcolor( old_bk );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_gettextcursor"> _gettextcursor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _gettextcursor( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _gettextcursor</tt> function returns the current cursor attribute, or shape.&nbsp; The cursor shape is set with the
 <tt> _settextcursor</tt> function.&nbsp; See the <tt> _settextcursor</tt> function for a description of the value returned
 by the<tt> _gettextcursor</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _gettextcursor</tt> function returns the current cursor shape when successful; otherwise, (-1) is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextcursor">_settextcursor</a>, <a href="#_displaycursor">_displaycursor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_shape;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; old_shape = _gettextcursor();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextcursor( 0x0007 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( &quot;\nBlock cursor&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextcursor( 0x0407 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( &quot;\nHalf height cursor&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextcursor( 0x2000 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( &quot;\nNo cursor&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextcursor( old_shape );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_gettextextent"> _gettextextent </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _gettextextent( short x, short y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR *text,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct xycoord _FAR *concat,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct xycoord _FAR *extent );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _gettextextent</tt> function simulates the effect of using the <tt> _grtext</tt> function to display the text string<b>
 text</b> at the position<tt> (x,y),</tt> using the current text settings.&nbsp; The concatenation point is returned in the
 argument<b> concat</b>.&nbsp; The text extent parallelogram is returned in the array<b> extent</b>.
<br>The concatenation point is the position to use to output text after the given string.&nbsp; The text extent parallelogram
 outlines the area where the text string would be displayed.&nbsp; The four points are returned in counter-clockwise order,
 starting at the upper-left corner.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _gettextextent</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_gettextsettings">_gettextsettings</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct xycoord concat;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct xycoord extent&#91; 4 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 100, 100, &quot;hot&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _gettextextent( 100, 100, &quot;hot&quot;, &amp;concat, extent );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _polygon( _GBORDER, 4, extent );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( concat.xcoord, concat.ycoord, &quot;dog&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_gette.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_gettextposition"> _gettextposition </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>struct rccoord _FAR _gettextposition( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _gettextposition</tt> function returns the current output position for text.&nbsp; This position is in terms of characters,
 not pixels.
<br>The current position defaults to the top left corner of the screen,<tt> (1,1),</tt> when a new video mode is selected.
&nbsp; It is changed by successful calls to the <tt> _outtext</tt>, <tt> _outmem</tt>, <tt> _settextposition</tt> and <tt>
 _settextwindow</tt> functions.
<br><br>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
 graphics output can be set by use of the <tt> _moveto</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _gettextposition</tt> function returns, as an<tt> rccoord</tt> structure, the current output position for text.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_settextposition">_settextposition</a>, <a href="#_settextwindow">_settextwindow</a>,
 <a href="#_moveto">_moveto</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct rccoord old_pos;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_pos = _gettextposition();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextposition( 10, 40 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( &quot;WATCOM Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextposition( old_pos.row, old_pos.col );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_gettextsettings"> _gettextsettings </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>struct textsettings _FAR * _FAR _gettextsettings</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ( struct textsettings _FAR *settings );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _gettextsettings</tt> function returns information about the current text settings used when text is displayed by
 the <tt> _grtext</tt> function.&nbsp; The information is stored in the<tt> textsettings</tt> structure indicated by the argument<b>
 settings</b>.&nbsp; The structure contains the following fields (all are<tt> short</tt> fields):
<dl>
<dt>basevectorx
<dd>x-component of the current base vector
<dt><br>basevectory
<dd>y-component of the current base vector
<dt><br>path
<dd>current text path
<dt><br>height
<dd>current text height (in pixels)
<dt><br>width
<dd>current text width (in pixels)
<dt><br>spacing
<dd>current text spacing (in pixels)
<dt><br>horizalign
<dd>horizontal component of the current text alignment
<dt><br>vertalign
<dd>vertical component of the current text alignment
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _gettextsettings</tt> function returns information about the current graphics text settings.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_setcharsize">_setcharsize</a>, <a href="#_setcharspacing">_setcharspacing</a>,
 <a href="#_settextalign">_settextalign</a>, <a href="#_settextpath">_settextpath</a>, <a href="#_settextorient">_settextorient</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct textsettings ts;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _gettextsettings( &amp;ts );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 100, 100, &quot;WATCOM&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setcharsize( 2 * ts.height, 2 * ts.width );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 100, 300, &quot;Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setcharsize( ts.height, ts.width );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_gettextwindow"> _gettextwindow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _gettextwindow(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short _FAR *row1, short
 _FAR *col1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short _FAR *row2, short
 _FAR *col2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _gettextwindow</tt> function returns the location of the current text window.&nbsp; A text window is defined with
 the <tt> _settextwindow</tt> function.&nbsp; By default, the text window is the entire screen.
<br>The current text window is a rectangular area of the screen.&nbsp; Text display is restricted to be within this window.
&nbsp; The top left corner of the text window is placed in the arguments<tt> (row1,col1).</tt>&nbsp; The bottom right corner
 of the text window is placed in<tt> (row2,col2).</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _gettextwindow</tt> function returns the location of the current text window.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextwindow">_settextwindow</a>, <a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_settextposition">_settextposition</a>,
 <a href="#_scrolltextwindow">_scrolltextwindow</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; short r1, c1, r2, c2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 80 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _gettextwindow( &amp;r1, &amp;c1, &amp;r2, &amp;c2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextwindow( 5, 20, 20, 40 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 20; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Line %d\n&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextwindow( r1, c1, r2, c2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getvideoconfig"> _getvideoconfig </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>struct videoconfig _FAR * _FAR _getvideoconfig</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ( struct videoconfig _FAR *config );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getvideoconfig</tt> function returns information about the current video mode and the hardware configuration.&nbsp;
 The information is returned in the<tt> videoconfig</tt> structure indicated by the argument<b> config</b>.&nbsp; The structure
 contains the following fields (all are<tt> short</tt> fields):
<dl>
<dt>numxpixels
<dd>number of pixels in x-axis
<dt><br>numypixels
<dd>number of pixels in y-axis
<dt><br>numtextcols
<dd>number of text columns
<dt><br>numtextrows
<dd>number of text rows
<dt><br>numcolors
<dd>number of actual colors
<dt><br>bitsperpixel
<dd>number of bits in a pixel value
<dt><br>numvideopages
<dd>number of video pages
<dt><br>mode
<dd>current video mode
<dt><br>adapter
<dd>adapter type
<dt><br>monitor
<dd>monitor type
<dt><br>memory
<dd>number of kilobytes (1024 characters) of video memory
</dl>
<br>The<tt> adapter</tt> field will contain one of the following values:
<dl>
<dt>_NODISPLAY
<dd>no display adapter attached
<dt><br>_UNKNOWN
<dd>unknown adapter/monitor type
<dt><br>_MDPA
<dd>Monochrome Display/Printer Adapter
<dt><br>_CGA
<dd>Color Graphics Adapter
<dt><br>_HERCULES
<dd>Hercules Monochrome Adapter
<dt><br>_MCGA
<dd>Multi-Color Graphics Array
<dt><br>_EGA
<dd>Enhanced Graphics Adapter
<dt><br>_VGA
<dd>Video Graphics Array
<dt><br>_SVGA
<dd>SuperVGA Adapter
</dl>
<br>The<tt> monitor</tt> field will contain one of the following values:
<dl>
<dt>_MONO
<dd>regular monochrome
<dt><br>_COLOR
<dd>regular color
<dt><br>_ENHANCED
<dd>enhanced color
<dt><br>_ANALOGMONO
<dd>analog monochrome
<dt><br>_ANALOGCOLOR
<dd>analog color
</dl>
<br>The amount of memory reported by<tt> _getvideoconfig</tt> will not always be correct for SuperVGA adapters.&nbsp; Since
 it is not always possible to determine the amount of memory,<tt> _getvideoconfig</tt> will always report 256K, the minimum
 amount.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getvideoconfig</tt> function returns information about the current video mode and the hardware configuration.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setvideomode">_setvideomode</a>, <a href="#_setvideomoderows">_setvideomoderows</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int mode;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct videoconfig vc;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 80 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _getvideoconfig( &amp;vc );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* select &quot;best&quot; video mode */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; switch( vc.adapter ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _VGA :</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _SVGA :</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _VRES16COLOR;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _MCGA :</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES256COLOR;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _EGA :</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( vc.monitor == _MONO ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESNOCOLOR;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESCOLOR;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _CGA :</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES4COLOR;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HERCULES :</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _HERCMONO;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; default :</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;No graphics adapter&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( _setvideomode( mode ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _getvideoconfig( &amp;vc );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;%d x %d x %d\n&quot;, vc.numxpixels,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vc.numypixels, vc.numcolors );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getviewcoord"> _getviewcoord, _getviewcoord_w, _getviewcoord_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>struct xycoord _FAR _getviewcoord( short x, short y );</tt>
<br><br><tt>struct xycoord _FAR _getviewcoord_w( double x, double y );</tt>
<br><br><tt>struct xycoord _FAR _getviewcoord_wxy(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 struct _wxycoord _FAR *p );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getviewcoord</tt> functions translate a point from one coordinate system to viewport coordinates.&nbsp; The<tt> _getviewcoord</tt>
 function translates the point<tt> (x,y)</tt> from physical coordinates.&nbsp; The<tt> _getviewcoord_w</tt> and<tt> _getviewcoord_wxy</tt>
 functions translate the point from the window coordinate system.
<br>Viewport coordinates are defined by the <tt> _setvieworg</tt> and <tt> _setviewport</tt> functions.&nbsp; Window coordinates
 are defined by the <tt> _setwindow</tt> function.
<br><br><b>Note:</b>&nbsp; In previous versions of the software, the<tt> _getviewcoord</tt> function was called<tt> _getlogcoord.</tt>
&nbsp; uindex=2 
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getviewcoord</tt> functions return the viewport coordinates, as an<tt> xycoord</tt> structure, of the given point.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getphyscoord">_getphyscoord</a>, <a href="#_setvieworg">_setvieworg</a>, <a href="#_setviewport">_setviewport</a>,
 <a href="#_setwindow">_setwindow</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct xycoord pos1, pos2;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvieworg( rand() % 640, rand() % 480 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pos1 = _getviewcoord( 0, 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pos2 = _getviewcoord( 639, 479 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, pos1.xcoord, pos1.ycoord,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos2.xcoord, pos2.ycoord );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _getviewcoord - DOS, QNX</tt>
<br><tt>_getviewcoord_w - DOS, QNX</tt>
<br><tt>_getviewcoord_wxy - DOS, QNX</tt>
</dl>
<h2 id="_getvisualpage"> _getvisualpage </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _getvisualpage( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getvisualpage</tt> function returns the number of the currently selected visual graphics page.
<br>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple pages
 are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
 what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
 can be constructed without affecting the screen by setting the active page to be different than the visual page.
<br><br>The number of available video pages can be determined by using the <tt> _getvideoconfig</tt> function.&nbsp; The default
 video page is 0.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getvisualpage</tt> function returns the number of the currently selected visual graphics page.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setvisualpage">_setvisualpage</a>, <a href="#_setactivepage">_setactivepage</a>, <a href="#_getactivepage">_getactivepage</a>,
 <a href="#_getvideoconfig">_getvideoconfig</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_apage;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_vpage;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _HRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_apage = _getactivepage();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* draw an ellipse on page 0 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setactivepage( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvisualpage( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 50, 540, 150 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* draw a rectangle on page 1 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setactivepage( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 50, 540, 150 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* display page 1 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvisualpage( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setactivepage( old_apage );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvisualpage( old_vpage );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getw"> _getw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int _getw( int binint, FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getw</tt> function reads a binary value of type<b> int</b> from the current position of the stream<b> fp</b> and
 increments the associated file pointer to point to the next unread character in the input stream.<tt>&nbsp; _getw</tt> does
 not assume any special alignment of items in the stream.
<br><tt>_getw</tt> is provided primarily for compatibility with previous libraries.&nbsp; Portability problems may occur with<tt>
 _getw</tt> because the size of an<b> int</b> and the ordering of bytes within an<b> int</b> differ across systems.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getw</tt> function returns the integer value read or, if a read error or end-of-file occurs, the error indicator
 is set and<tt> _getw</tt> returns <tt> EOF</tt>.&nbsp; Since <tt> EOF</tt> is a legitimate value to read from<b> fp</b>,
 use <tt> ferror</tt> to verify that an error has occurred.
</dl>
<dl>
<dt>See Also:
<dd><a href="#ferror">ferror</a>, <a href="#fgetc">fgetc</a>, <a href="#fgetchar">fgetchar</a>, <a href="#fgets">fgets</a>, <a href="#fopen">fopen</a>,
 <a href="#getc">getc</a>, <a href="#getchar">getchar</a>, <a href="#gets">gets</a>, <a href="#_putw">_putw</a>, <a href="#ungetc">ungetc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = _getw( fp )) != EOF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putw( c, stdout );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_getwindowcoord"> _getwindowcoord </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>struct _wxycoord _FAR _getwindowcoord( short x, short y );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getwindowcoord</tt> function returns the window coordinates of the position with view coordinates<tt> (x,y).</tt>
&nbsp; Window coordinates are defined by the <tt> _setwindow</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getwindowcoord</tt> function returns the window coordinates, as a<tt> _wxycoord</tt> structure, of the given point.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setwindow">_setwindow</a>, <a href="#_getviewcoord">_getviewcoord</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct xycoord centre;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct _wxycoord pos1, pos2;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* draw a box 50 pixels square */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* in the middle of the screen */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _MAXRESMODE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; centre = _getviewcoord_w( 0.5, 0.5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pos1 = _getwindowcoord( centre.xcoord - 25,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; centre.ycoord - 25 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pos2 = _getwindowcoord( centre.xcoord + 25,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; centre.ycoord + 25 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle_wxy( _GBORDER, &amp;pos1, &amp;pos2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>_getwindowcoord is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="gmtime"> gmtime Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>struct tm * gmtime( const time_t *timer );</tt>
<br><tt>struct tm *_gmtime( const time_t *timer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 struct tm *tmbuf );</tt>
<br><br><tt>struct&nbsp; tm {</tt>
<br><tt>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- &#91;0,61&#93; */</tt>
<br><tt>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- &#91;0,59&#93; */</tt>
<br><tt>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,23&#93; */</tt>
<br><tt>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;1,31&#93; */</tt>
<br><tt>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,11&#93; */</tt>
<br><tt>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,6&#93;&nbsp; */</tt>
<br><tt>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,365&#93;*/</tt>
<br><tt>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#gmtime_s">gmtime_s</a> function which is a safer alternative to<tt> gmtime</tt>.
&nbsp; This newer<tt> gmtime_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> gmtime</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> gmtime</tt> functions convert the calendar time pointed to by<b> timer</b> into a broken-down time, expressed as Coordinated
 Universal Time (UTC) (formerly known as Greenwich Mean Time, or GMT).
<br>The function <tt> _gmtime</tt> places the converted time in the <tt> tm</tt> structure pointed to by<b> tmbuf</b>, and
 the<tt> gmtime</tt> function places the converted time in a static structure that is re-used each time<tt> gmtime</tt> is
 called.
<br><br>The time set on the computer with the DOS<tt> time</tt> command and the DOS<tt> date</tt> command reflects the local
 time.&nbsp; The environment variable<tt> TZ</tt> is used to establish the time zone to which this local time applies.&nbsp;
 See the section<b> The TZ Environment Variable</b> for a discussion of how to set the time zone.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> gmtime</tt> functions return a pointer to a structure containing the broken-down time.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#asctime_s">asctime_s</a>, <a href="#clock">clock</a>, <a href="#ctime">ctime</a>
 Functions, <a href="#ctime_s">ctime_s</a>, <a href="#difftime">difftime</a>, <a href="#gmtime_s">gmtime_s</a>, <a href="#localtime">localtime</a>,
 <a href="#localtime_s">localtime_s</a>, <a href="#mktime">mktime</a>, <a href="#strftime">strftime</a>, <a href="#time">time</a>,
 <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t time_of_day;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buf&#91;26&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto struct tm tmbuf;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _gmtime( &amp;time_of_day, &amp;tmbuf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %.24s GMT\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asctime( &amp;tmbuf, buf ) );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>It is now: Fri Dec 25 15:58:27 1987 GMT</tt>
</dl>
<dl>
<dt>Classification:
<dd>gmtime is ANSI
<br>_gmtime is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> gmtime - All, Netware</tt>
<br><tt>_gmtime - All</tt>
</dl>
<h2 id="gmtime_s"> gmtime_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>struct tm * gmtime_s( const time_t * restrict timer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; struct tm * restrict result );</tt>
<br><br><tt>struct&nbsp; tm {</tt>
<br><tt>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- &#91;0,61&#93; */</tt>
<br><tt>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- &#91;0,59&#93; */</tt>
<br><tt>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,23&#93; */</tt>
<br><tt>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;1,31&#93; */</tt>
<br><tt>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,11&#93; */</tt>
<br><tt>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,6&#93;&nbsp; */</tt>
<br><tt>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,365&#93;*/</tt>
<br><tt>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 gmtime_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> timer</b> nor<b> result</b> shall be a null pointer.&nbsp; If there is a runtime-constraint violation, there
 is no attempt to convert the time.
</dl>
<dl>
<dt>Description:
<dd>The<tt> gmtime_s</tt> function converts the calendar time pointed to by<b> timer</b> into a broken-down time, expressed as
 UTC.&nbsp; The broken-down time is stored in the structure pointed to by<b> result</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> gmtime_s</tt> function returns<b> result</b>, or a null pointer if the specified time cannot be converted to UTC or
 there is a runtime-constraint violation.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#asctime_s">asctime_s</a>, <a href="#clock">clock</a>, <a href="#ctime">ctime</a>
 Functions, <a href="#ctime_s">ctime_s</a>, <a href="#difftime">difftime</a>, <a href="#gmtime">gmtime</a>, <a href="#localtime">localtime</a>,
 <a href="#localtime_s">localtime_s</a>, <a href="#mktime">mktime</a>, <a href="#strftime">strftime</a>, <a href="#time">time</a>,
 <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t time_of_day;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buf&#91;26&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto struct tm tmbuf;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; gmtime_s( &amp;time_of_day, &amp;tmbuf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; asctime_s( buf, sizeof( buf ), &amp;tmbuf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %.24s GMT\n&quot;, buf );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>It is now: Thu Jan 31 15:12:27 2006 GMT</tt>
</dl>
<dl>
<dt>Classification:
<dd>TR 24731
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Netware
</dl>
<h2 id="_grow_handles"> _grow_handles </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int _grow_handles( int new_count );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _grow_handles</tt> function increases the number of POSIX level files that are allowed to be open at one time.&nbsp;
 The parameter<b> new_count</b> is the new requested number of files that are allowed to be opened.&nbsp; The return value
 is the number that is allowed to be opened after the call.&nbsp; This may be less than, equal to, or greater than the number
 requested.&nbsp; If the number is less than, an error has occurred and the errno variable should be consulted for the reason.
&nbsp; If the number returned is greater than or equal to the number requested, the call was successful.
<br>Note that even if<tt> _grow_handles</tt> returns successfully, you still might not be able to open the requested number
 of files due to some system limit (e.g.&nbsp; FILES= in the CONFIG.SYS file under DOS) or because some file handles are already
 in use (stdin, stdout, stderr, etc.).
<br><br>The number of file handles that the run-time system can open by default is described by <tt> _NFILES</tt> in<tt> &lt;stdio.h&gt;</tt>
 but this can be changed by the application developer.&nbsp; To change the number of file handles available during execution,
 follow the steps outlined below.
<ol>
<li>Let<tt> n</tt> represent the number of files to be opened concurrently.&nbsp; Ensure that the <b> stdin,</b> <b> stdout,</b>
 and <b> stderr</b> files are included in the count.&nbsp; Also include <b> stdaux</b> and <b> stdprn</b> files in the count
 for some versions of DOS.&nbsp; The<b> stdaux</b> and<b> stdprn</b> files are not available for Win32.
<li>For DOS-based systems, change the<tt> CONFIG.SYS</tt> file to include &quot;FILES=n&quot; where &quot;n&quot; is the number
 of file handles required by the application plus an additional 5 handles for the standard files.&nbsp; The number of standard
 files that are opened by DOS varies from 3 to 5 depending on the version of DOS that you are using.
<br><br>If you are running a network such as Novell's NetWare, this will also affect the number of available file handles.
&nbsp; In this case, you may have to increase the number specified in the &quot;FILES=n&quot; statement.
<li>Add a call to<tt> _grow_handles</tt> in your application similar to that shown in the example below.
</ol>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _grow_handles</tt> function returns the maximum number of file handles which the run-time system can accommodate.
&nbsp; This number can exceed an operating system limit such as that imposed by the &quot;FILES=&quot; statement under DOS.
&nbsp; This limit will be the determining factor in how many files can be open concurrently.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_dos_open">_dos_open</a>, <a href="#fdopen">fdopen</a>, <a href="#fileno">fileno</a>, <a href="#fopen">fopen</a>,
 <a href="#freopen">freopen</a>, <a href="#_fsopen">_fsopen</a>, <a href="#_hdopen">_hdopen</a>, <a href="#open">open</a>,
 <a href="#_open_osfhandle">_open_osfhandle</a>, <a href="#_popen">_popen</a>, <a href="#sopen">sopen</a>, <a href="#tmpfile">tmpfile</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>FILE *fp&#91; 50 &#93;;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int hndl_count;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; hndl_count = _NFILES;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( hndl_count &lt; 50 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hndl_count = _grow_handles( 50 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; hndl_count; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp&#91; i &#93; = tmpfile();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fp&#91; i &#93; == NULL ) break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File %d successfully opened\n&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d files were successfully opened\n&quot;, i );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="_grstatus"> _grstatus </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _grstatus( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _grstatus</tt> function returns the status of the most recently called graphics library function.&nbsp; The function
 can be called after any graphics function to determine if any errors or warnings occurred.&nbsp; The function returns 0 if
 the previous function was successful.&nbsp; Values less than 0 indicate an error occurred; values greater than 0 indicate
 a warning condition.
<br>The following values can be returned:&nbsp; uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2
 uindex=2 
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Constant&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value
&nbsp; Explanation</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GROK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; no error</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 -1&nbsp;&nbsp;&nbsp; graphics error</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRMODENOTSUPPORTED&nbsp;&nbsp;&nbsp; -2&nbsp;&nbsp;&nbsp; video mode not supported</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRNOTINPROPERMODE&nbsp;&nbsp;&nbsp;&nbsp; -3&nbsp;&nbsp;&nbsp; function n/a in this mode</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRINVALIDPARAMETER&nbsp;&nbsp;&nbsp; -4&nbsp;&nbsp;&nbsp; invalid parameter(s)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRINSUFFICIENTMEMORY&nbsp; -5&nbsp;&nbsp;&nbsp; out of memory</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRFONTFILENOTFOUND&nbsp;&nbsp;&nbsp; -6&nbsp;&nbsp;&nbsp; can't open font file</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRINVALIDFONTFILE&nbsp;&nbsp;&nbsp;&nbsp; -7&nbsp;&nbsp;&nbsp; font file has invalid format</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRNOOUTPUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;
&nbsp;&nbsp; nothing was done</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRCLIPPED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 2&nbsp;&nbsp;&nbsp; output clipped</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _grstatus</tt> function returns the status of the most recently called graphics library function.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int x, y;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( _grstatus() == _GROK ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = rand() % 700;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = rand() % 500;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setpixel( x, y );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>_grstatus is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_grtext"> _grtext, _grtext_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _grtext( short x, short y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 char _FAR *text );</tt>
<br><br><tt>short _FAR _grtext_w( double x, double y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char _FAR *text );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _grtext</tt> functions display a character string.&nbsp; The<tt> _grtext</tt> function uses the view coordinate system.
&nbsp; The<tt> _grtext_w</tt> function uses the window coordinate system.
<br>The character string<b> text</b> is displayed at the point<tt> (x,y).</tt>&nbsp; The string must be terminated by a null
 character ('\0').&nbsp; The text is displayed in the current color using the current text settings.
<br><br>The graphics library can display text in three different ways.
<ol>
<li>The <tt> _outtext</tt> and <tt> _outmem</tt> functions can be used in any video mode.&nbsp; However, this variety of text
 can be displayed in only one size.
<li>The <tt> _grtext</tt> function displays text as a sequence of line segments, and can be drawn in different sizes, with
 different orientations and alignments.
<li>The <tt> _outgtext</tt> function displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts
 are supported; the size and type of text depends on the fonts that are available.
</ol>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _grtext</tt> functions return a non-zero value when the text was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_outgtext">_outgtext</a>, <a href="#_setcharsize">_setcharsize</a>,
 <a href="#_settextalign">_settextalign</a>, <a href="#_settextpath">_settextpath</a>, <a href="#_settextorient">_settextorient</a>,
 <a href="#_setcharspacing">_setcharspacing</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 200, 100, &quot; WATCOM&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 200, 200, &quot;Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_grtxt.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _grtext - DOS, QNX</tt>
<br><tt>_grtext_w - DOS, QNX</tt>
</dl>
<h2 id="halloc"> halloc </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>void __huge *halloc( long int numb, size_t size );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> halloc</tt> function allocates space for an array of<b> numb</b> objects of<b> size</b> bytes each and initializes
 each object to 0.&nbsp; When the size of the array is greater than 64K bytes, then the size of an array element must be a
 power of 2 since an object could straddle a segment boundary.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> halloc</tt> function returns a far pointer (of type<tt> void huge *</tt>) to the start of the allocated memory.&nbsp;
 The<tt> NULL</tt> value is returned if there is insufficient memory available.&nbsp; The<tt> NULL</tt> value is also returned
 if the size of the array is greater than 64K bytes and the size of an array element is not a power of 2.
</dl>
<dl>
<dt>See Also:
<dd><a href="#calloc">calloc</a> Functions, <a href="#_expand">_expand</a> Functions, <a href="#free">free</a> Functions, <a href="#hfree">hfree</a>,
 <a href="#malloc">malloc</a> Functions, <a href="#_msize">_msize</a> Functions, <a href="#realloc">realloc</a> Functions,
 <a href="#sbrk">sbrk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long int __huge *big_buffer;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; big_buffer = (long int __huge *)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; halloc( 1024L,
 sizeof(long) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( big_buffer == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to allocate memory\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rest of code goes here */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hfree( big_buffer );&nbsp; /* deallocate */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS/16, Windows, QNX/16, OS/2 1.x(all)
</dl>
<h2 id="_harderr"> _harderr, _hardresume, _hardretn </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>void _harderr( int (__far *handler)() );</tt>
<br><tt>void _hardresume( int action );</tt>
<br><tt>void _hardretn( int error );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _harderr</tt> routine installs a critical error handler (for INT 0x24) to handle hardware errors.&nbsp; This critical
 error handler will call the user-defined function specified by<b> handler</b> when a critical error occurs (for example,
 attempting to open a file on a floppy disk when the drive door is open).&nbsp; The parameters to this function are as follows:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; int handler( unsigned deverror,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned errcode,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned __far
 *devhdr );</tt>
<br><br>The low-order byte of<b> errcode</b> can be one of the following values:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>0x00
<dd>Attempt to write to a write-protected disk
<dt><br>0x01
<dd>Unknown unit
<dt><br>0x02
<dd>Drive not ready
<dt><br>0x03
<dd>Unknown command
<dt><br>0x04
<dd>CRC error in data
<dt><br>0x05
<dd>Bad drive-request structure length
<dt><br>0x06
<dd>Seek error
<dt><br>0x07
<dd>Unknown media type
<dt><br>0x08
<dd>Sector not found
<dt><br>0x09
<dd>Printer out of paper
<dt><br>0x0A
<dd>Write fault
<dt><br>0x0B
<dd>Read fault
<dt><br>0x0C
<dd>General failure
</dl>
<br>The<b> devhdr</b> argument points to a device header control-block that contains information about the device on which
 the error occurred.&nbsp; Your error handler may inspect the information in this control-block but must not change it.
<br><br>If the error occurred on a disk device, bit 15 of the<b> deverror</b> argument will be 0 and the<b> deverror</b> argument
 will indicate the following:
<dl>
<dt>Bit&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>bit 15
<dd>0 indicates disk error
<dt><br>bit 14
<dd>not used
<dt><br>bit 13
<dd>0 indicates &quot;Ignore&quot; response not allowed
<dt><br>bit 12
<dd>0 indicates &quot;Retry&quot; response not allowed
<dt><br>bit 11
<dd>0 indicates &quot;Fail&quot; response not allowed
<dt><br>bit 9,10
<dd>location of error
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>00
<dd>MS-DOS
<dt><br>01
<dd>File Allocation Table (FAT)
<dt><br>10
<dd>Directory
<dt><br>11
<dd>Data area
</dl>
<dt><br>bit 8
<dd>0 indicates read error, 1 indicates write error
</dl>
<br>The low-order byte of<b> deverror</b> indicates the drive where the error occurred; (0 = drive A, 1 = drive B, etc.).
<br><br>The handler is very restricted in the type of system calls that it can perform.&nbsp; System calls 0x01 through 0x0C,
 and 0x59 are the only system calls allowed to be issued by the handler.&nbsp; Therefore, many of the standard C run-time
 functions such as stream I/O and low-level I/O cannot be used by the handler.&nbsp; Console I/O is allowed (e.g., cprintf,
 cputs).
<br><br>The handler must indicate what action to take by returning one of the following values or calling <tt> _hardresume</tt>
 with one of the following values:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_HARDERR_IGNORE
<dd>Ignore the error
<dt><br>_HARDERR_RETRY
<dd>Retry the operation
<dt><br>_HARDERR_ABORT
<dd>Abort the program issuing INT 0x23
<dt><br>_HARDERR_FAIL
<dd>Fail the system call that is in progress (DOS 3.0 or higher)
</dl>
<br>Alternatively, the handler can return directly to the application program rather than returning to DOS by using the <tt>
 _hardretn</tt> function.&nbsp; The application program resumes at the point just after the failing I/O function request.
&nbsp; The <tt> _hardretn</tt> function should be called only from within a user-defined hardware error-handler function.
<br><br>The<b> error</b> argument of <tt> _hardretn</tt> should be a DOS error code.&nbsp; See<b> The MS-DOS Encyclopedia</b>
 or<b> Programmer's PC Sourcebook, 2nd Edition,</b> for more detailed information on DOS error codes that may be returned
 by a given DOS function call.
<br><br>If the failing I/O function request is an INT 0x21 function greater than or equal to function 0x38, <tt> _hardretn</tt>
 will return to the application with the carry flag set and the AX register set to the <tt> _hardretn</tt><b> error</b> argument.
&nbsp; If the failing INT 0x21 function request is less than function 0x38 abd the function can return an error, the AL register
 will be set to 0xFF on return to the application.&nbsp; If the failing INT 0x21 function does not have a way of returning
 an error condition (which is true of certain INT 0x21 functions below 0x38), the<b> error</b> argument of <tt> _hardretn</tt>
 is not used, and no error code is returned to the application.
</dl>
<dl>
<dt>Returns:
<dd>These functions do not return a value.&nbsp; The <tt> _hardresume</tt> and <tt> _hardretn</tt> functions do not return to
 the caller.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_chain_intr">_chain_intr</a>, <a href="#_dos_getvect">_dos_getvect</a>, <a href="#_dos_setvect">_dos_setvect</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>#if defined(__DOS__) &amp;&amp; defined(__386__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define FAR __far</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #if defined(__386__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define FAR</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define FAR __far</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #endif</tt>
<br><tt>#endif</tt>
<br><br><tt>int FAR critical_error_handler( unsigned deverr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned errcode,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned FAR *devhdr )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cprintf( &quot;Critical error: &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cprintf( &quot;deverr=%4.4X errcode=%d\r\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deverr, errcode );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cprintf( &quot;devhdr = %Fp\r\n&quot;, devhdr );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( _HARDERR_IGNORE );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _harderr( critical_error_handler );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;a:tmp.tmp&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;fp = %p\n&quot;, fp );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Critical error: deverr=1A00 errcode=2</tt>
<br><tt>devhdr = 0070:01b6</tt>
<br><tt>fp = 0000</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd><tt> _harderr - DOS</tt>
<br><tt>_hardresume - DOS</tt>
<br><tt>_hardretn - DOS/16</tt>
</dl>
<h2 id="_hdopen"> _hdopen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int _hdopen( int os_handle, int mode );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _hdopen</tt> function takes a previously opened operating system file handle specified by<b> os_handle</b> and opened
 with access and sharing specified by<b> mode</b>, and creates a POSIX-style file handle.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _hdopen</tt> function returns the new POSIX-style file handle if successful.&nbsp; Otherwise, it returns -1.
</dl>
<dl>
<dt>See Also:
<dd><a href="#close">close</a>, <a href="#_dos_open">_dos_open</a>, <a href="#fdopen">fdopen</a>, <a href="#fopen">fopen</a>,
 <a href="#freopen">freopen</a>, <a href="#_fsopen">_fsopen</a>, <a href="#_grow_handles">_grow_handles</a>, <a href="#open">open</a>,
 <a href="#_open_osfhandle">_open_osfhandle</a>, <a href="#_os_handle">_os_handle</a>, <a href="#_popen">_popen</a>, <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>#include &lt;windows.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; HANDLE os_handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; DWORD desired_access, share_mode;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; os_handle = CreateFileA( &quot;file&quot;, GENERIC_WRITE,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, NULL, CREATE_ALWAYS,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FILE_ATTRIBUTE_NORMAL, NULL );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( os_handle == INVALID_HANDLE_VALUE ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle = _hdopen( os_handle, O_RDONLY );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( handle, &quot;hello\n&quot;, 6 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseHandle( os_handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_heapchk"> _heapchk Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>int&nbsp; _heapchk( void );</tt>
<br><tt>int _bheapchk( __segment seg );</tt>
<br><tt>int _fheapchk( void );</tt>
<br><tt>int _nheapchk( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _heapchk</tt> functions along with <tt> _heapset</tt> and <tt> _heapwalk</tt> are provided for debugging heap related
 problems in programs.
<br>The<tt> _heapchk</tt> functions perform a consistency check on the unallocated memory space or &quot;heap&quot;.&nbsp;
 The consistency check determines whether all the heap entries are valid.&nbsp; Each function checks a particular heap, as
 listed below:
<dl>
<dt>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap Checked
<dt>_heapchk
<dd>Depends on data model of the program
<dt><br>_bheapchk
<dd>Based heap specified by<b> seg</b> value; <tt> _NULLSEG</tt> specifies all based heaps
<dt><br>_fheapchk
<dd>Far heap (outside the default data segment)
<dt><br>_nheapchk
<dd>Near heap (inside the default data segment)
</dl>
<br>In a small data memory model, the<tt> _heapchk</tt> function is equivalent to the <tt> _nheapchk</tt> function; in a large
 data memory model, the<tt> _heapchk</tt> function is equivalent to the <tt> _fheapchk</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>All four functions return one of the following manifest constants which are defined in<tt> &lt;malloc.h&gt;.</tt>
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_HEAPOK
<dd>The heap appears to be consistent.
<dt><br>_HEAPEMPTY
<dd>The heap is empty.
<dt><br>_HEAPBADBEGIN
<dd>The heap has been damaged.
<dt><br>_HEAPBADNODE
<dd>The heap contains a bad node, or is damaged.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_heapenable">_heapenable</a>, <a href="#_heapgrow">_heapgrow</a>, <a href="#_heapmin">_heapmin</a>, <a href="#_heapset">_heapset</a>,
 <a href="#_heapshrink">_heapshrink</a>, <a href="#_heapwalk">_heapwalk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *buffer;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; buffer = (char *)malloc( 80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; malloc( 1024 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; free( buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; switch( _heapchk() ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HEAPOK:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK - heap is good\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HEAPEMPTY:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK - heap is empty\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HEAPBADBEGIN:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - heap is damaged\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HEAPBADNODE:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - bad node in heap\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _heapchk - All</tt>
<br><tt>_bheapchk - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_fheapchk - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_nheapchk - DOS, Windows, Win386, Win32, QNX, OS/2 1.x, OS/2 1.x(MT), OS/2-32</tt>
</dl>
<h2 id="_heapenable"> _heapenable </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>int _heapenable( int enabled );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _heapenable</tt> function is used to control attempts by the heap allocation manager to request more memory from the
 operating system's memory pool.&nbsp; If<b> enabled</b> is 0 then all further allocations which would normally go to the
 operating system for more memory will instead fail and return NULL.&nbsp; If<b> enabled</b> is 1 then requests for more memory
 from the operating system's memory pool are re-enabled.
<br>This function can be used to impose a limit on the amount of system memory that is allocated by an application.&nbsp;
 For example, if an application wishes to allocate no more than 200K bytes of memory, it could allocate 200K and immediately
 free it.&nbsp; It can then call<tt> _heapenable</tt> to disable any further requests from the system memory pool.&nbsp; After
 this, the application can allocate memory from the 200K pool that it has already obtained.
</dl>
<dl>
<dt>Returns:
<dd>The return value is the previous state of the system allocation flag.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_heapchk">_heapchk</a>, <a href="#_heapgrow">_heapgrow</a>, <a href="#_heapmin">_heapmin</a>, <a href="#_heapset">_heapset</a>,
 <a href="#_heapshrink">_heapshrink</a>, <a href="#_heapwalk">_heapwalk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *p;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; p = malloc( 200*1024 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( p != NULL ) free( p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _heapenable( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /*</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate memory from a pool that</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; has been capped at 200K</tt>
<br><tt>&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="_heapgrow"> _heapgrow Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>void&nbsp; _heapgrow( void );</tt>
<br><tt>void _nheapgrow( void );</tt>
<br><tt>void _fheapgrow( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The <tt> _nheapgrow</tt> function attempts to grow the near heap to the maximum size of 64K.&nbsp; You will want to do this
 in the small data models if you are using both <tt> malloc</tt> and <tt> _fmalloc</tt> or <tt> halloc</tt>.&nbsp; Once a
 call to <tt> _fmalloc</tt> or <tt> halloc</tt> has been made, you may not be able to allocate any memory with <tt> malloc</tt>
 unless space has been reserved for the near heap using either <tt> malloc</tt>, <tt> sbrk</tt> or <tt> _nheapgrow</tt>.
<br>The <tt> _fheapgrow</tt> function doesn't do anything to the heap because the far heap will be extended automatically
 when needed.&nbsp; If the current far heap cannot be extended, then another far heap will be started.
<br><br>In a small data memory model, the<tt> _heapgrow</tt> function is equivalent to the <tt> _nheapgrow</tt> function;
 in a large data memory model, the<tt> _heapgrow</tt> function is equivalent to the <tt> _fheapgrow</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>These functions do not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_heapchk">_heapchk</a>, <a href="#_heapenable">_heapenable</a>, <a href="#_heapmin">_heapmin</a>, <a href="#_heapset">_heapset</a>,
 <a href="#_heapshrink">_heapshrink</a>, <a href="#_heapwalk">_heapwalk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *p, *fmt_string;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fmt_string = &quot;Amount of memory available is %u\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( fmt_string, _memavl() );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _nheapgrow();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( fmt_string, _memavl() );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p = (char *) malloc( 2000 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( fmt_string, _memavl() );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Amount of memory available is 0</tt>
<br><tt>Amount of memory available is 62732</tt>
<br><tt>Amount of memory available is 60730</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _heapgrow - All</tt>
<br><tt>_fheapgrow - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_nheapgrow - DOS, Windows, Win386, Win32, QNX, OS/2 1.x, OS/2 1.x(MT), OS/2-32</tt>
</dl>
<h2 id="_heapmin"> _heapmin Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>int&nbsp; _heapmin( void );</tt>
<br><tt>int _bheapmin( __segment seg );</tt>
<br><tt>int _fheapmin( void );</tt>
<br><tt>int _nheapmin( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _heapmin</tt> functions attempt to shrink the specified heap to its smallest possible size by returning all free entries
 at the end of the heap back to the system.&nbsp; This can be used to free up as much memory as possible before using the
 <tt> system</tt> function or one of the <tt> spawn</tt> functions.
<br>The various<tt> _heapmin</tt> functions shrink the following heaps:
<dl>
<dt>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap Minimized
<dt>_heapmin
<dd>Depends on data model of the program
<dt><br>_bheapmin
<dd>Based heap specified by<b> seg</b> value;<tt> _NULLSEG</tt> specifies all based heaps
<dt><br>_fheapmin
<dd>Far heap (outside the default data segment)
<dt><br>_nheapmin
<dd>Near heap (inside the default data segment)
</dl>
<br>In a small data memory model, the<tt> _heapmin</tt> function is equivalent to the <tt> _nheapmin</tt> function; in a large
 data memory model, the<tt> _heapmin</tt> function is equivalent to the <tt> _fheapmin</tt> function.&nbsp; It is identical
 to the <tt> _heapshrink</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>These functions return zero if successful, and non-zero if some error occurred.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_heapchk">_heapchk</a>, <a href="#_heapenable">_heapenable</a>, <a href="#_heapgrow">_heapgrow</a>, <a href="#_heapset">_heapset</a>,
 <a href="#_heapshrink">_heapshrink</a>, <a href="#_heapwalk">_heapwalk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _heapmin();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; system( &quot;chdir c:\\watcomc&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _heapmin - All</tt>
<br><tt>_bheapmin - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_fheapmin - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_nheapmin - DOS, Windows, Win386, Win32, QNX, OS/2 1.x, OS/2 1.x(MT), OS/2-32</tt>
</dl>
<h2 id="_heapset"> _heapset Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>int&nbsp; _heapset( unsigned char fill_char );</tt>
<br><tt>int _bheapset( __segment seg, unsigned char fill_char );</tt>
<br><tt>int _fheapset( unsigned char fill_char );</tt>
<br><tt>int _nheapset( unsigned char fill_char );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _heapset</tt> functions along with <tt> _heapchk</tt> and <tt> _heapwalk</tt> are provided for debugging heap related
 problems in programs.
<br>The<tt> _heapset</tt> functions perform a consistency check on the unallocated memory space or &quot;heap&quot; just as
 <tt> _heapchk</tt> does, and sets the heap's free entries with the<b> fill_char</b> value.
<br><br>Each function checks and sets a particular heap, as listed below:
<dl>
<dt>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap Filled
<dt>_heapset
<dd>Depends on data model of the program
<dt><br>_bheapset
<dd>Based heap specified by<b> seg</b> value;<tt> _NULLSEG</tt> specifies all based heaps
<dt><br>_fheapset
<dd>Far heap (outside the default data segment)
<dt><br>_nheapset
<dd>Near heap (inside the default data segment)
</dl>
<br>In a small data memory model, the<tt> _heapset</tt> function is equivalent to the <tt> _nheapset</tt> function; in a large
 data memory model, the<tt> _heapset</tt> function is equivalent to the <tt> _fheapset</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _heapset</tt> functions return one of the following manifest constants which are defined in<tt> &lt;malloc.h&gt;.</tt>
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_HEAPOK
<dd>The heap appears to be consistent.
<dt><br>_HEAPEMPTY
<dd>The heap is empty.
<dt><br>_HEAPBADBEGIN
<dd>The heap has been damaged.
<dt><br>_HEAPBADNODE
<dd>The heap contains a bad node, or is damaged.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_heapchk">_heapchk</a>, <a href="#_heapenable">_heapenable</a>, <a href="#_heapgrow">_heapgrow</a>, <a href="#_heapmin">_heapmin</a>,
 <a href="#_heapshrink">_heapshrink</a>, <a href="#_heapwalk">_heapwalk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int heap_status;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *buffer;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; buffer = (char *)malloc( 80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; malloc( 1024 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; free( buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; heap_status = _heapset( 0xff );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; switch( heap_status ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HEAPOK:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK - heap is good\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HEAPEMPTY:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK - heap is empty\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HEAPBADBEGIN:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - heap is damaged\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HEAPBADNODE:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - bad node in heap\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _heapset - All</tt>
<br><tt>_bheapset - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_fheapset - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_nheapset - DOS, Windows, Win386, Win32, QNX, OS/2 1.x, OS/2 1.x(MT), OS/2-32</tt>
</dl>
<h2 id="_heapshrink"> _heapshrink Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>int&nbsp; _heapshrink( void );</tt>
<br><tt>int _bheapshrink( __segment seg );</tt>
<br><tt>int _fheapshrink( void );</tt>
<br><tt>int _nheapshrink( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _heapshrink</tt> functions attempt to shrink the heap to its smallest possible size by returning all free entries
 at the end of the heap back to the system.&nbsp; This can be used to free up as much memory as possible before using the
 <tt> system</tt> function or one of the <tt> spawn</tt> functions.
<br>The various<tt> _heapshrink</tt> functions shrink the following heaps:
<dl>
<dt>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap Shrinked
<dt>_heapshrink
<dd>Depends on data model of the program
<dt><br>_bheapshrink
<dd>Based heap specified by<b> seg</b> value; <tt> _NULLSEG</tt> specifies all based heaps
<dt><br>_fheapshrink
<dd>Far heap (outside the default data segment)
<dt><br>_nheapshrink
<dd>Near heap (inside the default data segment)
</dl>
<br>In a small data memory model, the<tt> _heapshrink</tt> function is equivalent to the <tt> _nheapshrink</tt> function;
 in a large data memory model, the<tt> _heapshrink</tt> function is equivalent to the <tt> _fheapshrink</tt> function.&nbsp;
 It is identical to the <tt> _heapmin</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>These functions return zero if successful, and non-zero if some error occurred.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_heapchk">_heapchk</a>, <a href="#_heapenable">_heapenable</a>, <a href="#_heapgrow">_heapgrow</a>, <a href="#_heapmin">_heapmin</a>,
 <a href="#_heapset">_heapset</a>, <a href="#_heapwalk">_heapwalk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _heapshrink();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; system( &quot;chdir c:\\watcomc&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _heapshrink - All</tt>
<br><tt>_bheapshrink - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_fheapshrink - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_nheapshrink - DOS, Windows, Win386, Win32, QNX, OS/2 1.x, OS/2 1.x(MT), OS/2-32</tt>
</dl>
<h2 id="_heapwalk"> _heapwalk Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>int&nbsp; _heapwalk( struct _heapinfo *entry );</tt>
<br><tt>int _bheapwalk( __segment seg, struct _heapinfo *entry );</tt>
<br><tt>int _fheapwalk( struct _heapinfo *entry );</tt>
<br><tt>int _nheapwalk( struct _heapinfo *entry );</tt>
<br><br><tt>struct _heapinfo {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; void __far *_pentry;&nbsp;&nbsp; /* heap pointer */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp; _size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* heap entry size */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _useflag;&nbsp;&nbsp; /* heap entry 'in-use' flag
 */</tt>
<br><tt>};</tt>
<br><tt>#define _USEDENTRY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</tt>
<br><tt>#define _FREEENTRY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _heapwalk</tt> functions along with <tt> _heapchk</tt> and <tt> _heapset</tt> are provided for debugging heap related
 problems in programs.
<br>The<tt> _heapwalk</tt> functions walk through the heap, one entry per call, updating the <tt> _heapinfo</tt> structure
 with information on the next heap entry.&nbsp; The structure is defined in<tt> &lt;malloc.h&gt;.</tt>&nbsp; You must initialize
 the<b> _pentry</b> field with<tt> NULL</tt> to start the walk through the heap.
<br><br>Each function walks a particular heap, as listed below:
<dl>
<dt>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap Walked
<dt>_heapwalk
<dd>Depends on data model of the program
<dt><br>_bheapwalk
<dd>Based heap specified by<b> seg</b> value;<tt> _NULLSEG</tt> specifies all based heaps
<dt><br>_fheapwalk
<dd>Far heap (outside the default data segment)
<dt><br>_nheapwalk
<dd>Near heap (inside the default data segment)
</dl>
<br>In a small data memory model, the<tt> _heapwalk</tt> function is equivalent to the <tt> _nheapwalk</tt> function; in a
 large data memory model, the<tt> _heapwalk</tt> function is equivalent to the <tt> _fheapwalk</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>These functions return one of the following manifest constants which are defined in<tt> &lt;malloc.h&gt;.</tt>
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_HEAPOK
<dd>The heap is OK so far, and the <tt> _heapinfo</tt> structure contains information about the next entry in the heap.
<dt><br>_HEAPEMPTY
<dd>The heap is empty.
<dt><br>_HEAPBADPTR
<dd>The <tt> _pentry</tt> field of the<b> entry</b> structure does not contain a valid pointer into the heap.
<dt><br>_HEAPBADBEGIN
<dd>The header information for the heap was not found or has been damaged.
<dt><br>_HEAPBADNODE
<dd>The heap contains a bad node, or is damaged.
<dt><br>_HEAPEND
<dd>The end of the heap was reached successfully.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_heapchk">_heapchk</a>, <a href="#_heapenable">_heapenable</a>, <a href="#_heapgrow">_heapgrow</a>, <a href="#_heapmin">_heapmin</a>,
 <a href="#_heapset">_heapset</a>, <a href="#_heapshrink">_heapshrink</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>heap_dump()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct _heapinfo h_info;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int heap_status;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; h_info._pentry = NULL;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for(;;) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; heap_status = _heapwalk( &amp;h_info );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( heap_status != _HEAPOK ) break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; %s block at %Fp of size %4.4X\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (h_info._useflag == _USEDENTRY ? &quot;USED&quot; : &quot;FREE&quot;),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; h_info._pentry, h_info._size );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; switch( heap_status ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HEAPEND:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK - end of heap\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HEAPEMPTY:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;OK - heap is empty\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HEAPBADBEGIN:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - heap is damaged\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HEAPBADPTR:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - bad pointer to heap\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HEAPBADNODE:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;ERROR - bad node in heap\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *p;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; heap_dump();&nbsp;&nbsp; p = (char *) malloc( 80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; heap_dump();&nbsp;&nbsp; free( p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; heap_dump();</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br>On 16-bit 80x86 systems, the following output is produced:
<br><br><tt>OK - heap is empty</tt>
<br><tt>&nbsp; USED block at 23f8:0ab6 of size 0202</tt>
<br><tt>&nbsp; USED block at 23f8:0cb8 of size 0052</tt>
<br><tt>&nbsp; FREE block at 23f8:0d0a of size 1DA2</tt>
<br><tt>OK - end of heap</tt>
<br><tt>&nbsp; USED block at 23f8:0ab6 of size 0202</tt>
<br><tt>&nbsp; FREE block at 23f8:0cb8 of size 1DF4</tt>
<br><tt>OK - end of heap</tt>
<br><br>On 32-bit 80386/486 systems, the following output is produced:
<br><br><tt>OK - heap is empty</tt>
<br><tt>&nbsp; USED block at 0014:00002a7c of size 0204</tt>
<br><tt>&nbsp; USED block at 0014:00002c80 of size 0054</tt>
<br><tt>&nbsp; FREE block at 0014:00002cd4 of size 1D98</tt>
<br><tt>OK - end of heap</tt>
<br><tt>&nbsp; USED block at 0014:00002a7c of size 0204</tt>
<br><tt>&nbsp; FREE block at 0014:00002c80 of size 1DEC</tt>
<br><tt>OK - end of heap</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _heapwalk - All</tt>
<br><tt>_bheapwalk - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_fheapwalk - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_nheapwalk - DOS, Windows, Win386, Win32, QNX, OS/2 1.x, OS/2 1.x(MT), OS/2-32</tt>
</dl>
<h2 id="hfree"> hfree </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>void hfree( void __huge *ptr );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> hfree</tt> function deallocates a memory block previously allocated by the <tt> halloc</tt> function.&nbsp; The argument<b>
 ptr</b> points to a memory block to be deallocated.&nbsp; After the call, the freed block is available for allocation.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> hfree</tt> function returns no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#calloc">calloc</a> Functions, <a href="#_expand">_expand</a> Functions, <a href="#free">free</a> Functions, <a href="#halloc">halloc</a>,
 <a href="#malloc">malloc</a> Functions, <a href="#_msize">_msize</a> Functions, <a href="#realloc">realloc</a> Functions,
 <a href="#sbrk">sbrk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long int __huge *big_buffer;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; big_buffer = (long int __huge *)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; halloc( 1024L,
 sizeof(long) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( big_buffer == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to allocate memory\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* rest of code goes here */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hfree( big_buffer );&nbsp; /* deallocate */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS/16, Windows, QNX/16, OS/2 1.x(all)
</dl>
<h2 id="hypot"> hypot </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double hypot( double x, double y );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> hypot</tt> function computes the length of the hypotenuse of a right triangle whose sides are<b> x</b> and<b> y</b>
 adjacent to that right angle.&nbsp; The calculation is equivalent to
<br><tt>&nbsp;&nbsp;&nbsp; sqrt( x*x + y*y )</tt>
<br><br>The computation may cause an overflow, in which case the <tt> matherr</tt> function will be invoked.
</dl>
<dl>
<dt>Returns:
<dd>The value of the hypotenuse is returned.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the
 type of error that has been detected.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, hypot( 3.0, 4.0 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>5.000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="ignore_handler_s"> ignore_handler_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void ignore_handler_s(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict msg,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void * restrict ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errno_t error );</tt>
</dl>
<dl>
<dt>Description:
<dd>A pointer to the<tt> ignore_handler_s</tt> function may be passed as an argument to the<tt> set_constraint_handler_s</tt>
 function.&nbsp; The<tt> ignore_handler_s</tt> function simply returns to its caller.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ignore_handler_s</tt> function does not returns no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abort_handler_s">abort_handler_s</a>, <a href="#set_constraint_handler_s">set_constraint_handler_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; constraint_handler_t&nbsp;&nbsp;&nbsp; old_handler;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; old_handler =</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_constraint_handler_s( ignore_handler_s );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( getenv_s( NULL, NULL, 0, NULL ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;getenv_s failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; set_constraint_handler_s( old_handler );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>getenv_s failed</tt>
</dl>
<dl>
<dt>Classification:
<dd>TR 24731
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_imagesize"> _imagesize, _imagesize_w, _imagesize_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>long _FAR _imagesize( short x1, short y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; short x2, short y2 );</tt>
<br><br><tt>long _FAR _imagesize_w( double x1, double y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; double x2, double y2 );</tt>
<br><br><tt>long _FAR _imagesize_wxy( struct _wxycoord _FAR *p1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *p2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _imagesize</tt> functions compute the number of bytes required to store a screen image.&nbsp; The<tt> _imagesize</tt>
 function uses the view coordinate system.&nbsp; The<tt> _imagesize_w</tt> and<tt> _imagesize_wxy</tt> functions use the window
 coordinate system.
<br>The screen image is the rectangular area defined by the points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>&nbsp; The storage
 area used by the <tt> _getimage</tt> functions must be at least this large (in bytes).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _imagesize</tt> functions return the size of a screen image.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getimage">_getimage</a>, <a href="#_putimage">_putimage</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *buf;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int y;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 100, 200, 200 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; buf = (char*) malloc(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _imagesize(
 100, 100, 201, 201 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( buf != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _getimage( 100, 100, 201, 201, buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 260, 200, buf, _GPSET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, 100, buf, _GPSET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( y = 100; y &lt; 300; ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, y, buf, _GXOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += 20;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, y, buf, _GXOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _imagesize - DOS, QNX</tt>
<br><tt>_imagesize_w - DOS, QNX</tt>
<br><tt>_imagesize_wxy - DOS, QNX</tt>
</dl>
<h2 id="imaxabs"> imaxabs </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;inttypes.h&gt;</tt>
<br><tt>intmax_t imaxabs( intmax_t j );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> imaxabs</tt> function returns the absolute value of its maximum-size integer argument<b> j</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> imaxabs</tt> function returns the absolute value of its argument.
</dl>
<dl>
<dt>See Also:
<dd><a href="#labs">labs</a>, <a href="#llabs">llabs</a>, <a href="#abs">abs</a>, <a href="#fabs">fabs</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;inttypes.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; intmax_t&nbsp;&nbsp;&nbsp; x, y;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; x = -500000000000;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; y = imaxabs( x );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;imaxabs(%jd) = %jd\n&quot;, x, y );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>imaxabs(-500000000000) = 500000000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>ISO C99
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="imaxdiv"> imaxdiv </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>imaxdiv_t imaxdiv( intmax_t numer, intmax_t denom );</tt>
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; intmax_t&nbsp;&nbsp;&nbsp; quot;&nbsp; /* quotient */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; intmax_t&nbsp;&nbsp;&nbsp; rem;&nbsp;&nbsp; /* remainder */</tt>
<br><tt>} imaxdiv_t;</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> imaxdiv</tt> function calculates the quotient and remainder of the division of the numerator<b> numer</b> by the denominator<b>
 denom</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> imaxdiv</tt> function returns a structure of type <tt> imaxdiv_t</tt> that contains the fields <tt> quot</tt> and
 <tt> rem</tt>, which are both of type<tt> intmax_t.</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#div">div</a>, <a href="#ldiv">ldiv</a>, <a href="#lldiv">lldiv</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;inttypes.h&gt;</tt>
<br><br><tt>void print_time( intmax_t ticks )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; imaxdiv_t sec_ticks;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; imaxdiv_t min_sec;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; sec_ticks = imaxdiv( ticks, 1000000 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; min_sec&nbsp;&nbsp; = imaxdiv( sec_ticks.quot, 60 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;It took %jd minutes and %jd seconds\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_sec.quot, min_sec.rem );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_time( 9876543210 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>It took 164 minutes and 36 seconds</tt>
</dl>
<dl>
<dt>Classification:
<dd>ISO C99
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="inp"> inp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>unsigned int inp( int port );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> inp</tt> function reads one byte from the 80x86 hardware port whose number is given by<b> port</b>.
<br>A hardware port is used to communicate with a device.&nbsp; One or two bytes can be read and/or written from each port,
 depending upon the hardware.&nbsp; Consult the technical documentation for your computer to determine the port numbers for
 a device and the expected usage of each port for a device.
</dl>
<dl>
<dt>Returns:
<dd>The value returned is the byte that was read.
</dl>
<dl>
<dt>See Also:
<dd><a href="#inpd">inpd</a>, <a href="#inpw">inpw</a>, <a href="#outp">outp</a>, <a href="#outpd">outpd</a>, <a href="#outpw">outpw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* turn off speaker */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; outp( 0x61, inp( 0x61 ) &amp; 0xFC );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="inpd"> inpd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>unsigned long inpd( int port );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> inpd</tt> function reads a double-word (four bytes) from the 80x86 hardware port whose number is given by<b> port</b>.
<br>A hardware port is used to communicate with a device.&nbsp; One or two bytes can be read and/or written from each port,
 depending upon the hardware.&nbsp; Consult the technical documentation for your computer to determine the port numbers for
 a device and the expected usage of each port for a device.
</dl>
<dl>
<dt>Returns:
<dd>The value returned is the double-word that was read.
</dl>
<dl>
<dt>See Also:
<dd><a href="#inp">inp</a>, <a href="#inpw">inpw</a>, <a href="#outp">outp</a>, <a href="#outpd">outpd</a>, <a href="#outpw">outpw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#define DEVICE 34</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned long transmitted;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; transmitted = inpd( DEVICE );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>DOS/32, Win386, Win32, QNX/32, OS/2-32, Netware
</dl>
<h2 id="inpw"> inpw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>unsigned int inpw( int port );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> inpw</tt> function reads a word (two bytes) from the 80x86 hardware port whose number is given by<b> port</b>.
<br>A hardware port is used to communicate with a device.&nbsp; One or two bytes can be read and/or written from each port,
 depending upon the hardware.&nbsp; Consult the technical documentation for your computer to determine the port numbers for
 a device and the expected usage of each port for a device.
</dl>
<dl>
<dt>Returns:
<dd>The value returned is the word that was read.
</dl>
<dl>
<dt>See Also:
<dd><a href="#inp">inp</a>, <a href="#inpd">inpd</a>, <a href="#outp">outp</a>, <a href="#outpd">outpd</a>, <a href="#outpw">outpw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#define DEVICE 34</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int transmitted;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; transmitted = inpw( DEVICE );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="int386"> int386 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>int int386( int inter_no,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const union REGS *in_regs,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS *out_regs );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> int386</tt> function causes the computer's central processor (CPU) to be interrupted with an interrupt whose number
 is given by<b> inter_no</b>.&nbsp; This function is present in the 386 C libraries and may be executed on 80386/486 systems.
&nbsp; Before the interrupt, the CPU registers are loaded from the structure located by<b> in_regs</b>.&nbsp; Following the
 interrupt, the structure located by<b> out_regs</b> is filled with the contents of the CPU registers.&nbsp; These structures
 may be located at the same location in memory.
<br>You should consult the technical documentation for the computer that you are using to determine the expected register
 contents before and after the interrupt in question.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> int386</tt> function returns the value of the CPU EAX register after the interrupt.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bdos">bdos</a>, <a href="#int386x">int386x</a>, <a href="#int86">int86</a>, <a href="#int86x">int86x</a>, <a href="#intdos">intdos</a>,
 <a href="#intdosx">intdosx</a>, <a href="#intr">intr</a>, <a href="#segread">segread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>/*</tt>
<br><tt> * This example clears the screen on DOS</tt>
<br><tt> */</tt>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; union REGS&nbsp; regs;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; regs.w.cx = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; regs.w.dx = 0x1850;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; regs.h.bh = 7;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; regs.w.ax = 0x0600;</tt>
<br><tt>#if defined(__386__) &amp;&amp; defined(__DOS__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int386( 0x10, &amp;regs, &amp;regs );</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int86( 0x10, &amp;regs, &amp;regs );</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>DOS/32, QNX/32, Netware
</dl>
<h2 id="int386x"> int386x </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>int int386x( int inter_no,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const union REGS *in_regs,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS *out_regs,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct SREGS *seg_regs );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> int386x</tt> function causes the computer's central processor (CPU) to be interrupted with an interrupt whose number
 is given by<b> inter_no</b>.&nbsp; This function is present in the 32-bit C libraries and may be executed on Intel 386 compatible
 systems.&nbsp; Before the interrupt, the CPU registers are loaded from the structure located by<b> in_regs</b> and the DS,
 ES, FS and GS segment registers are loaded from the structure located by<b> seg_regs</b>.&nbsp; All of the segment registers
 must contain valid values.&nbsp; Failure to do so will cause a segment violation when running in protect mode.&nbsp; If you
 don't care about a particular segment register, then it can be set to 0 which will not cause a segment violation.&nbsp; The
 function <tt> segread</tt> can be used to initialize<b> seg_regs</b> to their current values.
<br>Following the interrupt, the structure located by<b> out_regs</b> is filled with the contents of the CPU registers.&nbsp;
 The<b> in_regs</b> and<b> out_regs</b> structures may be located at the same location in memory.&nbsp; The original values
 of the DS, ES, FS and GS registers are restored.&nbsp; The structure<b> seg_regs</b> is updated with the values of the segment
 registers following the interrupt.
<br><br>You should consult the technical documentation for the computer that you are using to determine the expected register
 contents before and after the interrupt in question.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> int386x</tt> function returns the value of the CPU EAX register after the interrupt.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bdos">bdos</a>, <a href="#int386">int386</a>, <a href="#int86">int86</a>, <a href="#int86x">int86x</a>, <a href="#intdos">intdos</a>,
 <a href="#intdosx">intdosx</a>, <a href="#intr">intr</a>, <a href="#segread">segread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>/* get current mouse interrupt handler address */</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; union REGS r;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct SREGS s;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; s.ds = s.es = s.fs = s.gs = FP_SEG( &amp;s );</tt>
<br><br><tt>#if defined(__PHARLAP__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.w.ax = 0x2503;&nbsp;&nbsp;&nbsp; /* get real-mode vector */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.h.cl = 0x33;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* interrupt vector 0x33 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int386( 0x21, &amp;r, &amp;r );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;mouse handler real-mode address=&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%lx\n&quot;, r.x.ebx );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.w.ax = 0x2502;&nbsp;&nbsp;&nbsp; /* get protected-mode vector */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.h.cl = 0x33;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* interrupt vector 0x33 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int386x( 0x21, &amp;r, &amp;r, &amp;s );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;mouse handler protected-mode address=&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%x:%lx\n&quot;, s.es, r.x.ebx );</tt>
<br><br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.h.ah = 0x35;&nbsp; /* get vector */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.h.al = 0x33;&nbsp; /* vector 0x33 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int386x( 0x21, &amp;r, &amp;r, &amp;s );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;mouse handler protected-mode address=&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%x:%lx\n&quot;, s.es, r.x.ebx );</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>DOS/32, QNX/32, Netware
</dl>
<h2 id="int86"> int86 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>int int86( int inter_no,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const union REGS *in_regs,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS *out_regs );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> int86</tt> function causes the computer's central processor (CPU) to be interrupted with an interrupt whose number
 is given by<b> inter_no</b>.&nbsp; Before the interrupt, the CPU registers are loaded from the structure located by<b> in_regs</b>.
&nbsp; Following the interrupt, the structure located by<b> out_regs</b> is filled with the contents of the CPU registers.
&nbsp; These structures may be located at the same location in memory.
<br>You should consult the technical documentation for the computer that you are using to determine the expected register
 contents before and after the interrupt in question.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> int86</tt> function returns the value of the CPU AX register after the interrupt.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bdos">bdos</a>, <a href="#int386">int386</a>, <a href="#int386x">int386x</a>, <a href="#int86x">int86x</a>, <a href="#intdos">intdos</a>,
 <a href="#intdosx">intdosx</a>, <a href="#intr">intr</a>, <a href="#segread">segread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>/*</tt>
<br><tt> * This example clears the screen on DOS</tt>
<br><tt> */</tt>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; union REGS&nbsp; regs;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; regs.w.cx = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; regs.w.dx = 0x1850;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; regs.h.bh = 7;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; regs.w.ax = 0x0600;</tt>
<br><tt>#if defined(__386__) &amp;&amp; defined(__DOS__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int386( 0x10, &amp;regs, &amp;regs );</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int86( 0x10, &amp;regs, &amp;regs );</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>DOS/16, Windows, Win386, QNX/16, DOS/PM
</dl>
<h2 id="int86x"> int86x </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>int int86x( int inter_no,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const union REGS *in_regs,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS *out_regs,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct SREGS *seg_regs );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> int86x</tt> function causes the computer's central processor (CPU) to be interrupted with an interrupt whose number
 is given by<b> inter_no</b>.&nbsp; Before the interrupt, the CPU registers are loaded from the structure located by<b> in_regs</b>
 and the DS and ES segment registers are loaded from the structure located by<b> seg_regs</b>.&nbsp; All of the segment registers
 must contain valid values.&nbsp; Failure to do so will cause a segment violation when running in protect mode.&nbsp; If you
 don't care about a particular segment register, then it can be set to 0 which will not cause a segment violation.&nbsp; The
 function <tt> segread</tt> can be used to initialize<b> seg_regs</b> to their current values.
<br>Following the interrupt, the structure located by<b> out_regs</b> is filled with the contents of the CPU registers.&nbsp;
 The<b> in_regs</b> and<b> out_regs</b> structures may be located at the same location in memory.&nbsp; The original values
 of the DS and ES registers are restored.&nbsp; The structure<b> seg_regs</b> is updated with the values of the segment registers
 following the interrupt.
<br><br>You should consult the technical documentation for the computer that you are using to determine the expected register
 contents before and after the interrupt in question.
</dl>
<dl>
<dt>Returns:
<dd>The function returns the value of the CPU AX register after the interrupt.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bdos">bdos</a>, <a href="#int386">int386</a>, <a href="#int386x">int386x</a>, <a href="#int86">int86</a>, <a href="#intdos">intdos</a>,
 <a href="#intdosx">intdosx</a>, <a href="#intr">intr</a>, <a href="#segread">segread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>/* get current mouse interrupt handler address */</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; union REGS r;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct SREGS s;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; r.h.ah = 0x35;&nbsp; /* DOS get vector */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.h.al = 0x33;&nbsp; /* interrupt vector 0x33 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int86x( 0x21, &amp;r, &amp;r, &amp;s );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;mouse handler address=%4.4x:%4.4x\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s.es, r.w.bx );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>DOS/16, Windows, Win386, QNX/16, DOS/PM
</dl>
<h2 id="intdos"> intdos </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>int intdos( const union REGS *in_regs,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS *out_regs );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> intdos</tt> function causes the computer's central processor (CPU) to be interrupted with an interrupt number hexadecimal
 21 (<tt>0x21</tt>), which is a request to invoke a specific DOS function.&nbsp; Before the interrupt, the CPU registers are
 loaded from the structure located by<b> in_regs</b>.&nbsp; The AH register contains a number indicating the function requested.
&nbsp; Following the interrupt, the structure located by<b> out_regs</b> is filled with the contents of the CPU registers.
&nbsp; These structures may be located at the same location in memory.
<br>You should consult the technical documentation for the DOS operating system that you are using to determine the expected
 register contents before and after the interrupt in question.
</dl>
<dl>
<dt>Returns:
<dd>The function returns the value of the AX (EAX in 386 library) register after the interrupt has completed.&nbsp; The CARRY
 flag (when set, an error has occurred) is copied into the structure located by<b> out_regs</b>.&nbsp; When an error has occurred,
 <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bdos">bdos</a>, <a href="#int386">int386</a>, <a href="#int386x">int386x</a>, <a href="#int86">int86</a>, <a href="#int86x">int86x</a>,
 <a href="#intdosx">intdosx</a>, <a href="#intr">intr</a>, <a href="#segread">segread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>#define DISPLAY_OUTPUT&nbsp; 2</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; union REGS&nbsp; in_regs, out_regs;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; in_regs.h.ah = DISPLAY_OUTPUT;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; in_regs.h.al = 0;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; in_regs.w.dx = 'I';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = intdos( &amp;in_regs, &amp;out_regs );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; in_regs.w.dx = 'N';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = intdos( &amp;in_regs, &amp;out_regs );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; in_regs.w.dx = 'T';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = intdos( &amp;in_regs, &amp;out_regs );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; in_regs.w.dx = 'D';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = intdos( &amp;in_regs, &amp;out_regs );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; in_regs.w.dx = 'O';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = intdos( &amp;in_regs, &amp;out_regs );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; in_regs.w.dx = 'S';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = intdos( &amp;in_regs, &amp;out_regs );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, DOS/PM
</dl>
<h2 id="intdosx"> intdosx </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>int intdosx( const union REGS *in_regs,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; union REGS *out_regs,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct SREGS *seg_regs );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> intdosx</tt> function causes the computer's central processor (CPU) to be interrupted with an interrupt number hexadecimal
 21 (<tt>0x21</tt>), which is a request to invoke a specific DOS function.&nbsp; Before the interrupt, the CPU registers are
 loaded from the structure located by<b> in_regs</b> and the segment registers DS and ES are loaded from the structure located
 by<b> seg_regs</b>.&nbsp; The AH register contains a number indicating the function requested.&nbsp; All of the segment registers
 must contain valid values.&nbsp; Failure to do so will cause a segment violation when running in protect mode.&nbsp; If you
 don't care about a particular segment register, then it can be set to 0 which will not cause a segment violation.&nbsp; The
 function <tt> segread</tt> can be used to initialize<b> seg_regs</b> to their current values.
<br>Following the interrupt, the structure located by<b> out_regs</b> is filled with the contents of the CPU registers.&nbsp;
 The<b> in_regs</b> and<b> out_regs</b> structures may be located at the same location in memory.&nbsp; The original values
 for the DS and ES registers are restored.&nbsp; The structure<b> seg_regs</b> is updated with the values of the segment registers
 following the interrupt.
<br><br>You should consult the technical documentation for the DOS operating system that you are using to determine the expected
 register contents before and after the interrupt in question.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> intdosx</tt> function returns the value of the AX (EAX in 32-bit library) register after the interrupt has completed.
&nbsp; The CARRY flag (when set, an error has occurred) is copied into the structure located by<b> out_regs</b>.&nbsp; When
 an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bdos">bdos</a>, <a href="#int386">int386</a>, <a href="#int386x">int386x</a>, <a href="#int86">int86</a>, <a href="#int86x">int86x</a>,
 <a href="#intdos">intdos</a>, <a href="#intr">intr</a>, <a href="#segread">segread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>/* get current mouse interrupt handler address */</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; union REGS r;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct SREGS s;</tt>
<br><br><tt>#if defined(__386__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; s.ds = s.es = s.fs = s.gs = FP_SEG( &amp;s );</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.h.ah = 0x35;&nbsp; /* get vector */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; r.h.al = 0x33;&nbsp; /* vector 0x33 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; intdosx( &amp;r, &amp;r, &amp;s );</tt>
<br><tt>#if defined(__386__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;mouse handler address=%4.4x:%lx\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s.es, r.x.ebx );</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;mouse handler address=%4.4x:%4.4x\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s.es, r.x.bx );</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>DOS
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, DOS/PM
</dl>
<h2 id="intr"> intr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>void intr( int inter_no, union REGPACK *regs );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> intr</tt> function causes the computer's central processor (CPU) to be interrupted with an interrupt whose number
 is given by<b> inter_no</b>.&nbsp; Before the interrupt, the CPU registers are loaded from the structure located by<b> regs</b>.
&nbsp; All of the segment registers must contain valid values.&nbsp; Failure to do so will cause a segment violation when
 running in protect mode.&nbsp; If you don't care about a particular segment register, then it can be set to 0 which will
 not cause a segment violation.&nbsp; Following the interrupt, the structure located by<b> regs</b> is filled with the contents
 of the CPU registers.
<br>This function is similar to the <tt> int86x</tt> function, except that only one structure is used for the register values
 and that the BP (EBP in 386 library) register is included in the set of registers that are passed and saved.
<br><br>You should consult the technical documentation for the computer that you are using to determine the expected register
 contents before and after the interrupt in question.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> intr</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bdos">bdos</a>, <a href="#int386">int386</a>, <a href="#int386x">int386x</a>, <a href="#int86">int86</a>, <a href="#int86x">int86x</a>,
 <a href="#intdos">intdos</a>, <a href="#intdosx">intdosx</a>, <a href="#segread">segread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>void main() /* Print location of Break Key Vector */</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; union REGPACK regs;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; memset( &amp;regs, 0, sizeof(union REGPACK) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; regs.w.ax = 0x3523;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; intr( 0x21, &amp;regs );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Break Key vector is &quot;</tt>
<br><tt>#if defined(__386__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%x:%lx\n&quot;, regs.w.es, regs.x.ebx );</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%x:%x\n&quot;, regs.w.es, regs.x.bx );</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Break Key vector is eef:13c</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, QNX, DOS/PM, Netware
</dl>
<h2 id="isalnum"> isalnum, iswalnum </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int isalnum( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int iswalnum( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isalnum</tt> function tests if the argument<b> c</b> is an alphanumeric character ('a' to 'z', 'A' to 'Z', or '0'
 to '9').&nbsp; An alphanumeric character is any character for which <tt> isalpha</tt> or <tt> isdigit</tt> is true.
<br>The<tt> iswalnum</tt> function is similar to<tt> isalnum</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isalnum</tt> function returns zero if the argument is neither an alphabetic character (A-Z or a-z) nor a digit (0-9).
&nbsp; Otherwise, a non-zero value is returned.&nbsp; The<tt> iswalnum</tt> function returns a non-zero value if either <tt>
 iswalpha</tt> or <tt> iswdigit</tt> is true for<b> c</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>, <a href="#isdigit">isdigit</a>,
 <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>, <a href="#isprint">isprint</a>,
 <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>, <a href="#iswctype">iswctype</a>,
 <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( isalnum( getchar() ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;is alpha-numeric\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>isalnum is ANSI
<br>iswalnum is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> isalnum - All, Netware</tt>
<br><tt>iswalnum - All, Netware</tt>
</dl>
<h2 id="isalpha"> isalpha, iswalpha </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int isalpha( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int iswalpha( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isalpha</tt> function tests if the argument<b> c</b> is an alphabetic character ('a' to 'z' and 'A' to 'Z').&nbsp;
 An alphabetic character is any character for which <tt> isupper</tt> or <tt> islower</tt> is true.
<br>The<tt> iswalpha</tt> function is similar to<tt> isalpha</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isalpha</tt> function returns zero if the argument is not an alphabetic character (A-Z or a-z); otherwise, a non-zero
 value is returned.&nbsp; The<tt> iswalpha</tt> function returns a non-zero value only for wide characters for which <tt>
 iswupper</tt> or <tt> iswlower</tt> is true, or any wide character that is one of an implementation-defined set for which
 none of <tt> iswcntrl</tt>, <tt> iswdigit</tt>, <tt> iswpunct</tt>, or <tt> iswspace</tt> is true.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>, <a href="#isdigit">isdigit</a>,
 <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>, <a href="#isprint">isprint</a>,
 <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>, <a href="#iswctype">iswctype</a>,
 <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( isalpha( getchar() ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;is alphabetic\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>isalpha is ANSI
<br>iswalpha is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> isalpha - All, Netware</tt>
<br><tt>iswalpha - All, Netware</tt>
</dl>
<h2 id="isascii"> isascii, __isascii, iswascii </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int isascii( int c );</tt>
<br><tt>int __isascii( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int iswascii( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isascii</tt> function tests for a character in the range from 0 to 127.
<br>The<tt> __isascii</tt> function is identical to<tt> isascii</tt>.&nbsp; Use<tt> __isascii</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> iswascii</tt> function is similar to<tt> isascii</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isascii</tt> function returns a non-zero value when the character is in the range 0 to 127; otherwise, zero is returned.
&nbsp; The<tt> iswascii</tt> function returns a non-zero value when<b> c</b> is a wide-character representation of an ASCII
 character.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>,
 <a href="#isprint">isprint</a>, <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>,
 <a href="#iswctype">iswctype</a>, <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>,
 <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x80,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'Z'</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %san ASCII character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isascii( chars&#91;i&#93;
 ) ) ? &quot;&quot; : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Char A is an ASCII character</tt>
<br><tt>Char&nbsp;&nbsp; is not an ASCII character</tt>
<br><tt>Char Z is an ASCII character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>__isascii conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> isascii - All, Netware</tt>
<br><tt>__isascii - All, Netware</tt>
<br><tt>iswascii - All, Netware</tt>
</dl>
<h2 id="isatty"> isatty, _isatty </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int isatty( int handle );</tt>
<br><tt>int _isatty( int handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isatty</tt> function tests if the opened file or device referenced by the file handle<b> handle</b> is a character
 device (for example, a console, printer or port).
<br>The<tt> _isatty</tt> function is identical to<tt> isatty</tt>.&nbsp; Use<tt> _isatty</tt> for ANSI/ISO naming conventions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isatty</tt> function returns zero if the device or file is not a character device; otherwise, a non-zero value is
 returned.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#open">open</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;stdin is a %stty\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isatty( fileno( stdin ) ) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? &quot;&quot; : &quot;not &quot; );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>isatty is POSIX 1003.1
<br>_isatty is not POSIX
<br>_isatty conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> isatty - All, Netware</tt>
<br><tt>_isatty - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="isblank"> isblank, iswblank </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int isblank( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int iswblank( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isblank</tt> function tests for the following blank characters:
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Character
<dt>' '
<dd>space
<dt><br>'\t'
<dd>horizontal tab
</dl>
<br>The<tt> iswblank</tt> function is similar to<tt> isblank</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isblank</tt> function returns a non-zero character when the argument is one of the indicated blank characters.&nbsp;
 The<tt> iswblank</tt> function returns a non-zero value when the argument is a wide character that corresponds to a standard
 blank character or is one of an implementation-defined set of wide characters for which <tt> iswalnum</tt> is false.&nbsp;
 Otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#iscntrl">iscntrl</a>, <a href="#isdigit">isdigit</a>,
 <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>, <a href="#isprint">isprint</a>,
 <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>, <a href="#iswctype">iswctype</a>,
 <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x09,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x7d</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa blank character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isblank( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Char A is not a blank character</tt>
<br><tt>Char&nbsp;&nbsp;&nbsp;&nbsp; is a blank character</tt>
<br><tt>Char&nbsp;&nbsp; is a blank character</tt>
<br><tt>Char } is not a blank character</tt>
</dl>
<dl>
<dt>Classification:
<dd>isblank is ANSI
<br>iswblank is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> isblank - All, Netware</tt>
<br><tt>iswblank - All, Netware</tt>
</dl>
<h2 id="iscntrl"> iscntrl, iswcntrl </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int iscntrl( int c );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int iswcntrl( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> iscntrl</tt> function tests for any control character.&nbsp; A control character is any character whose value is from
 0 through 31.
<br>The<tt> iswcntrl</tt> function is similar to<tt> iscntrl</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> iscntrl</tt> function returns a non-zero value when the argument is a control character.&nbsp; The<tt> iswcntrl</tt>
 function returns a non-zero value when the argument is a control wide character.&nbsp; Otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#isdigit">isdigit</a>,
 <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>, <a href="#isprint">isprint</a>,
 <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>, <a href="#iswctype">iswctype</a>,
 <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x09,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'Z'</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa Control character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( iscntrl( chars&#91;i&#93;
 ) ) ? &quot;&quot; : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Char A is not a Control character</tt>
<br><tt>Char&nbsp;&nbsp;&nbsp;&nbsp; is a Control character</tt>
<br><tt>Char Z is not a Control character</tt>
</dl>
<dl>
<dt>Classification:
<dd>iscntrl is ANSI
<br>iswcntrl is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> iscntrl - All, Netware</tt>
<br><tt>iswcntrl - All, Netware</tt>
</dl>
<h2 id="iscsym"> iscsym, __iscsym, __iswcsym </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int iscsym( int c );</tt>
<br><tt>int __iscsym( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int __iswcsym( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> iscsym</tt> function tests for a letter, underscore or digit.
<br>The<tt> __iscsym</tt> function is identical to<tt> iscsym</tt>.&nbsp; Use<tt> __iscsym</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> __iswcsym</tt> function is similar to<tt> iscsym</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>A non-zero value is returned when the character is a letter, underscore or digit; otherwise, zero is returned.&nbsp; The<tt>
 __iswcsym</tt> function returns a non-zero value when<b> c</b> is a wide-character representation of a letter, underscore
 or digit character.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>,
 <a href="#isprint">isprint</a>, <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>,
 <a href="#iswctype">iswctype</a>, <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>,
 <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x80,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '_',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '9',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '+'</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa C symbol character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( __iscsym( chars&#91;i&#93;
 ) ) ? &quot;&quot; : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Char A is a C symbol character</tt>
<br><tt>Char&nbsp;&nbsp; is not a C symbol character</tt>
<br><tt>Char _ is a C symbol character</tt>
<br><tt>Char 9 is a C symbol character</tt>
<br><tt>Char + is not a C symbol character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>__iscsym conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> iscsym - All, Netware</tt>
<br><tt>__iscsym - All, Netware</tt>
<br><tt>__iswcsym - All, Netware</tt>
</dl>
<h2 id="iscsymf"> iscsymf, __iscsymf, __iswcsymf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int iscsymf( int c );</tt>
<br><tt>int __iscsymf( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int __iswcsymf( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> iscsymf</tt> function tests for a letter or underscore.
<br>The<tt> __iscsymf</tt> function is identical to<tt> iscsymf</tt>.&nbsp; Use<tt> __iscsymf</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> __iswcsymf</tt> function is similar to<tt> iscsymf</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>A non-zero value is returned when the character is a letter or underscore; otherwise, zero is returned.&nbsp; The<tt> __iswcsymf</tt>
 function returns a non-zero value when<b> c</b> is a wide-character representation of a letter or underscore character.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalpha">isalpha</a>, <a href="#isalnum">isalnum</a>, <a href="#iscntrl">iscntrl</a>, <a href="#isdigit">isdigit</a>,
 <a href="#isgraph">isgraph</a>, <a href="#islower">islower</a>, <a href="#isprint">isprint</a>, <a href="#ispunct">ispunct</a>,
 <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>, <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>,
 <a href="#toupper">toupper</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x80,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '_',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '9',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '+'</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa csymf character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( __iscsymf( chars&#91;i&#93;
 ) ) ? &quot;&quot; : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Char A is a csymf character</tt>
<br><tt>Char&nbsp;&nbsp; is not a csymf character</tt>
<br><tt>Char _ is a csymf character</tt>
<br><tt>Char 9 is not a csymf character</tt>
<br><tt>Char + is not a csymf character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>__iscsymf conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> iscsymf - All, Netware</tt>
<br><tt>__iscsymf - All, Netware</tt>
<br><tt>__iswcsymf - All, Netware</tt>
</dl>
<h2 id="isdigit"> isdigit, iswdigit </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int isdigit( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int iswdigit( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isdigit</tt> function tests for any decimal-digit character '0' through '9'.
<br>The<tt> iswdigit</tt> function is similar to<tt> isdigit</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isdigit</tt> function returns a non-zero value when the argument is a decimal-digit character.&nbsp; The<tt> iswdigit</tt>
 function returns a non-zero value when the argument is a wide character corresponding to a decimal-digit character.&nbsp;
 Otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>, <a href="#isprint">isprint</a>,
 <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>, <a href="#iswctype">iswctype</a>,
 <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '5',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '$'</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa digit character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isdigit( chars&#91;i&#93;
 ) ) ? &quot;&quot; : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Char A is not a digit character</tt>
<br><tt>Char 5 is a digit character</tt>
<br><tt>Char $ is not a digit character</tt>
</dl>
<dl>
<dt>Classification:
<dd>isdigit is ANSI
<br>iswdigit is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> isdigit - All, Netware</tt>
<br><tt>iswdigit - All, Netware</tt>
</dl>
<h2 id="isfinite"> isfinite </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>int isfinite( x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isfinite</tt> macro determines whether its argument<b> x</b> has a finite value (zero, subnormal, or normal, and not
 infinite or NaN).&nbsp; First, an argument represented in a format wider than its semantic type is converted to its semantic
 type.&nbsp; Then determination is based on the type of the argument.
<br>The argument<b> x</b> must be an expression of real floating type.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isfinite</tt> macro returns a nonzero value if and only if its argument has a finite value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fpclassify">fpclassify</a>, <a href="#isinf">isinf</a>, <a href="#isnan">isnan</a>, <a href="#isnormal">isnormal</a>,
 <a href="#signbit">signbit</a>, <a href="#_finite">_finite</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;zero %s a finite number\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isfinite( 0.0 ) ? &quot;is&quot; : &quot;is not&quot; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>zero is a finite number</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="isgraph"> isgraph, iswgraph </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int isgraph( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int iswgraph( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isgraph</tt> function tests for any printable character except space (' ').&nbsp; The <tt> isprint</tt> function is
 similar, except that the space character is also included in the character set being tested.
<br>The<tt> iswgraph</tt> function is similar to<tt> isgraph</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isgraph</tt> function returns non-zero when the argument is a printable character (except a space).&nbsp; The<tt>
 iswgraph</tt> function returns a non-zero value when the argument is a printable wide character (except a wide-character
 space).&nbsp; Otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>, <a href="#isprint">isprint</a>,
 <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>, <a href="#iswctype">iswctype</a>,
 <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x09,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x7d</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa printable character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isgraph( chars&#91;i&#93;
 ) ) ? &quot;&quot; : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Char A is a printable character</tt>
<br><tt>Char&nbsp;&nbsp;&nbsp;&nbsp; is not a printable character</tt>
<br><tt>Char&nbsp;&nbsp; is not a printable character</tt>
<br><tt>Char } is a printable character</tt>
</dl>
<dl>
<dt>Classification:
<dd>isgraph is ANSI
<br>iswgraph is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> isgraph - All, Netware</tt>
<br><tt>iswgraph - All, Netware</tt>
</dl>
<h2 id="isinf"> isinf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>int isinf( x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isinf</tt> macro determines whether its argument value is an infinity (positive or negative).&nbsp; First, an argument
 represented in a format wider than its semantic type is converted to its semantic type.&nbsp; Then determination is based
 on the type of the argument.
<br>The argument<b> x</b> must be an expression of real floating type.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isinf</tt> macro returns a nonzero value if and only if its argument has an infinite value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fpclassify">fpclassify</a>, <a href="#isfinite">isfinite</a>, <a href="#isnan">isnan</a>, <a href="#isnormal">isnormal</a>,
 <a href="#signbit">signbit</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;zero %s an infinite number\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isinf( 0.0 ) ? &quot;is&quot; : &quot;is not&quot; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>zero is not an infinite number</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="isleadbyte"> isleadbyte </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int isleadbyte( int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isleadbyte</tt> function tests if the argument<b> ch</b> is a valid first byte of a multibyte character in the current
 code page.
<br>For example, in code page 932, a valid lead byte is any byte in the range 0x81 through 0x9F or 0xE0 through 0xFC.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isleadbyte</tt> function returns a non-zero value when the argument is a valid lead byte.&nbsp; Otherwise, zero is
 returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#islower">islower</a>, <a href="#isprint">isprint</a>,
 <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>, <a href="#iswctype">iswctype</a>,
 <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>const unsigned char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x is %sa valid lead byte\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isleadbyte( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>20 is not a valid lead byte</tt>
<br><tt>2e is not a valid lead byte</tt>
<br><tt>31 is not a valid lead byte</tt>
<br><tt>41 is not a valid lead byte</tt>
<br><tt>81 is a valid lead byte</tt>
<br><tt>40 is not a valid lead byte</tt>
<br><tt>82 is a valid lead byte</tt>
<br><tt>60 is not a valid lead byte</tt>
<br><tt>82 is a valid lead byte</tt>
<br><tt>a6 is not a valid lead byte</tt>
<br><tt>83 is a valid lead byte</tt>
<br><tt>42 is not a valid lead byte</tt>
<br><tt>a1 is not a valid lead byte</tt>
<br><tt>a6 is not a valid lead byte</tt>
<br><tt>df is not a valid lead byte</tt>
<br><tt>e0 is a valid lead byte</tt>
<br><tt>a1 is not a valid lead byte</tt>
<br><tt>00 is not a valid lead byte</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="islower"> islower, iswlower </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int islower( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int iswlower( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> islower</tt> function tests for any lowercase letter 'a' through 'z'.
<br>The<tt> iswlower</tt> function is similar to<tt> islower</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> islower</tt> function returns a non-zero value when argument is a lowercase letter.&nbsp; The<tt> iswlower</tt> function
 returns a non-zero value when the argument is a wide character that corresponds to a lowercase letter, or if it is one of
 an implementation-defined set of wide characters for which none of <tt> iswcntrl</tt>, <tt> iswdigit</tt>, <tt> iswpunct</tt>,
 or <tt> iswspace</tt> is true.&nbsp; Otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#isprint">isprint</a>,
 <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>, <a href="#iswctype">iswctype</a>,
 <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'a',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'z',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'Z'</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa lowercase character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( islower( chars&#91;i&#93;
 ) ) ? &quot;&quot; : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Char A is not a lowercase character</tt>
<br><tt>Char a is a lowercase character</tt>
<br><tt>Char z is a lowercase character</tt>
<br><tt>Char Z is not a lowercase character</tt>
</dl>
<dl>
<dt>Classification:
<dd>islower is ANSI
<br>iswlower is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> islower - All, Netware</tt>
<br><tt>iswlower - All, Netware</tt>
</dl>
<h2 id="_ismbbalnum"> _ismbbalnum </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>int _ismbbalnum( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbbalnum</tt> function tests if the argument<b> ch</b> satisfies the condition that one of <tt> isalnum</tt> or
 <tt> _ismbbkalnum</tt> is true.
<br><b>Note:</b>&nbsp; The argument<b> ch</b> must represent a single-byte value (i.e., 0 &lt;=<b> ch</b> &lt;= 255 ).&nbsp;
 Incorrect results occur if the argument is a double-byte character.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbbalnum</tt> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>, <a href="#_ismbbkalnum">_ismbbkalnum</a>,
 <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>, <a href="#_ismbbkprint">_ismbbkprint</a>,
 <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>, <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>,
 <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte alphanumeric\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; or Katakana non-punctuation
 character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbalnum( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0020 is not a single-byte alphanumeric</tt>
<br><tt> or Katakana non-punctuation character</tt>
<br><tt>0x002e is not a single-byte alphanumeric</tt>
<br><tt> or Katakana non-punctuation character</tt>
<br><tt>0x0031 is a single-byte alphanumeric</tt>
<br><tt> or Katakana non-punctuation character</tt>
<br><tt>0x0041 is a single-byte alphanumeric</tt>
<br><tt> or Katakana non-punctuation character</tt>
<br><tt>0x8140 is not a single-byte alphanumeric</tt>
<br><tt> or Katakana non-punctuation character</tt>
<br><tt>0x8260 is not a single-byte alphanumeric</tt>
<br><tt> or Katakana non-punctuation character</tt>
<br><tt>0x82a6 is a single-byte alphanumeric</tt>
<br><tt> or Katakana non-punctuation character</tt>
<br><tt>0x8342 is a single-byte alphanumeric</tt>
<br><tt> or Katakana non-punctuation character</tt>
<br><tt>0x00a1 is not a single-byte alphanumeric</tt>
<br><tt> or Katakana non-punctuation character</tt>
<br><tt>0x00a6 is a single-byte alphanumeric</tt>
<br><tt> or Katakana non-punctuation character</tt>
<br><tt>0x00df is a single-byte alphanumeric</tt>
<br><tt> or Katakana non-punctuation character</tt>
<br><tt>0xe0a1 is not a single-byte alphanumeric</tt>
<br><tt> or Katakana non-punctuation character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbbalpha"> _ismbbalpha </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>int _ismbbalpha( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbbalpha</tt> function tests if the argument<b> ch</b> satisfies the condition that one of <tt> isalpha</tt> or
 <tt> _ismbbkalpha</tt> is true.
<br>For example, in code page 932,<tt> _ismbbalpha</tt> tests if the argument<b> ch</b> is a single-byte alphabetic character
 (&quot;a&quot; to &quot;z&quot; or &quot;A&quot; to &quot;Z&quot;) or single-byte Katakana non-punctuation character.
<br><br><b>Note:</b>&nbsp; The argument<b> ch</b> must represent a single-byte value (i.e., 0 &lt;=<b> ch</b> &lt;= 255 ).
&nbsp; Incorrect results occur if the argument is a double-byte character.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbbalpha</tt> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbgraph">_ismbbgraph</a>, <a href="#_ismbbkalnum">_ismbbkalnum</a>,
 <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>, <a href="#_ismbbkprint">_ismbbkprint</a>,
 <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>, <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>,
 <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte alphabetic\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; or Katakana alphabetic character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbalpha( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0020 is not a single-byte alphabetic</tt>
<br><tt> or Katakana alphabetic character</tt>
<br><tt>0x002e is not a single-byte alphabetic</tt>
<br><tt> or Katakana alphabetic character</tt>
<br><tt>0x0031 is not a single-byte alphabetic</tt>
<br><tt> or Katakana alphabetic character</tt>
<br><tt>0x0041 is a single-byte alphabetic</tt>
<br><tt> or Katakana alphabetic character</tt>
<br><tt>0x8140 is not a single-byte alphabetic</tt>
<br><tt> or Katakana alphabetic character</tt>
<br><tt>0x8260 is not a single-byte alphabetic</tt>
<br><tt> or Katakana alphabetic character</tt>
<br><tt>0x82a6 is a single-byte alphabetic</tt>
<br><tt> or Katakana alphabetic character</tt>
<br><tt>0x8342 is a single-byte alphabetic</tt>
<br><tt> or Katakana alphabetic character</tt>
<br><tt>0x00a1 is not a single-byte alphabetic</tt>
<br><tt> or Katakana alphabetic character</tt>
<br><tt>0x00a6 is a single-byte alphabetic</tt>
<br><tt> or Katakana alphabetic character</tt>
<br><tt>0x00df is a single-byte alphabetic</tt>
<br><tt> or Katakana alphabetic character</tt>
<br><tt>0xe0a1 is not a single-byte alphabetic</tt>
<br><tt> or Katakana alphabetic character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbbgraph"> _ismbbgraph </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>int _ismbbgraph( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbbgraph</tt> function tests if the argument<b> ch</b> satisfies the condition that one of <tt> isgraph</tt> or
 <tt> _ismbbkprint</tt> is true.
<br>For example, in code page 932,<tt> _ismbbgraph</tt> tests if the argument<b> ch</b> is a single-byte printable character
 excluding space (&quot; &quot;) or single-byte Katakana character.
<br><br><b>Note:</b>&nbsp; The argument<b> ch</b> must represent a single-byte value (i.e., 0 &lt;=<b> ch</b> &lt;= 255 ).
&nbsp; Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbbgraph</tt> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbkalnum">_ismbbkalnum</a>,
 <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>, <a href="#_ismbbkprint">_ismbbkprint</a>,
 <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>, <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>,
 <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte printable &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;non-space character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbgraph( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0020 is not a single-byte printable non-space character</tt>
<br><tt>0x002e is a single-byte printable non-space character</tt>
<br><tt>0x0031 is a single-byte printable non-space character</tt>
<br><tt>0x0041 is a single-byte printable non-space character</tt>
<br><tt>0x8140 is a single-byte printable non-space character</tt>
<br><tt>0x8260 is a single-byte printable non-space character</tt>
<br><tt>0x82a6 is a single-byte printable non-space character</tt>
<br><tt>0x8342 is a single-byte printable non-space character</tt>
<br><tt>0x00a1 is a single-byte printable non-space character</tt>
<br><tt>0x00a6 is a single-byte printable non-space character</tt>
<br><tt>0x00df is a single-byte printable non-space character</tt>
<br><tt>0xe0a1 is a single-byte printable non-space character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbbkalnum"> _ismbbkalnum </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>int _ismbbkalnum( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbbkalnum</tt> function tests if the argument<b> ch</b> is a non-ASCII text symbol other than punctuation.
<br>For example, in code page 932,<tt> _ismbbkalnum</tt> tests for a single-byte Katakana character (excluding the Katakana
 punctuation characters).&nbsp; Note that there are no Katakana digit characters.&nbsp; A single-byte Katakana non-punctuation
 character is any character for which the following expression is true:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0xA6 &lt;= ch &lt;= 0xDF</tt>
<br><br><b>Note:</b>&nbsp; The argument<b> ch</b> must represent a single-byte value (i.e., 0 &lt;=<b> ch</b> &lt;= 255 ).
&nbsp; Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbbkalnum</tt> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>,
 <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>, <a href="#_ismbbkprint">_ismbbkprint</a>,
 <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>, <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>,
 <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Katakana non-punctuation character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbkalnum( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0020 is not a single-byte Katakana non-punctuation character</tt>
<br><tt>0x002e is not a single-byte Katakana non-punctuation character</tt>
<br><tt>0x0031 is not a single-byte Katakana non-punctuation character</tt>
<br><tt>0x0041 is not a single-byte Katakana non-punctuation character</tt>
<br><tt>0x8140 is not a single-byte Katakana non-punctuation character</tt>
<br><tt>0x8260 is not a single-byte Katakana non-punctuation character</tt>
<br><tt>0x82a6 is a single-byte Katakana non-punctuation character</tt>
<br><tt>0x8342 is not a single-byte Katakana non-punctuation character</tt>
<br><tt>0x00a1 is not a single-byte Katakana non-punctuation character</tt>
<br><tt>0x00a6 is a single-byte Katakana non-punctuation character</tt>
<br><tt>0x00df is a single-byte Katakana non-punctuation character</tt>
<br><tt>0xe0a1 is not a single-byte Katakana non-punctuation character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbbkana"> _ismbbkana </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>int _ismbbkana( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbbkana</tt> function tests if the argument<b> ch</b> is a single-byte Katakana character.&nbsp; A single-byte
 Katakana character is any character for which the following expression is true:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0xA1 &lt;= ch &lt;= 0xDF</tt>
<br><br><b>Note:</b>&nbsp; The argument<b> ch</b> must represent a single-byte value (i.e., 0 &lt;=<b> ch</b> &lt;= 255 ).
&nbsp; Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbbkana</tt> function returns non-zero if the argument is a single-byte Katakana character; otherwise, a zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>,
 <a href="#_ismbbkalnum">_ismbbkalnum</a>, <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkprint">_ismbbkprint</a>,
 <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>, <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>,
 <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Katakana character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbkana( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0020 is not a single-byte Katakana character</tt>
<br><tt>0x002e is not a single-byte Katakana character</tt>
<br><tt>0x0031 is not a single-byte Katakana character</tt>
<br><tt>0x0041 is not a single-byte Katakana character</tt>
<br><tt>0x8140 is not a single-byte Katakana character</tt>
<br><tt>0x8260 is not a single-byte Katakana character</tt>
<br><tt>0x82a6 is a single-byte Katakana character</tt>
<br><tt>0x8342 is not a single-byte Katakana character</tt>
<br><tt>0x00a1 is a single-byte Katakana character</tt>
<br><tt>0x00a6 is a single-byte Katakana character</tt>
<br><tt>0x00df is a single-byte Katakana character</tt>
<br><tt>0xe0a1 is a single-byte Katakana character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbbkalpha"> _ismbbkalpha </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>int _ismbbkalpha( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbbkalpha</tt> function tests if the argument<b> ch</b> is a non-ASCII text symbol other than digits or punctuation.
<br>For example, in code page 932,<tt> _ismbbkalpha</tt> tests for a single-byte Katakana character (excluding the Katakana
 punctuation characters).&nbsp; Note that there are no Katakana digit characters.&nbsp; A single-byte Katakana non-punctuation
 character is any character for which the following expression is true:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0xA6 &lt;= ch &lt;= 0xDF</tt>
<br><br><b>Note:</b>&nbsp; The argument<b> ch</b> must represent a single-byte value (i.e., 0 &lt;=<b> ch</b> &lt;= 255 ).
&nbsp; Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbbkalpha</tt> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>,
 <a href="#_ismbbkalnum">_ismbbkalnum</a>, <a href="#_ismbbkana">_ismbbkana</a>, <a href="#_ismbbkprint">_ismbbkprint</a>,
 <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>, <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>,
 <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Katakana alphabetic character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbkalpha( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0020 is not a single-byte Katakana alphabetic character</tt>
<br><tt>0x002e is not a single-byte Katakana alphabetic character</tt>
<br><tt>0x0031 is not a single-byte Katakana alphabetic character</tt>
<br><tt>0x0041 is not a single-byte Katakana alphabetic character</tt>
<br><tt>0x8140 is not a single-byte Katakana alphabetic character</tt>
<br><tt>0x8260 is not a single-byte Katakana alphabetic character</tt>
<br><tt>0x82a6 is a single-byte Katakana alphabetic character</tt>
<br><tt>0x8342 is not a single-byte Katakana alphabetic character</tt>
<br><tt>0x00a1 is not a single-byte Katakana alphabetic character</tt>
<br><tt>0x00a6 is a single-byte Katakana alphabetic character</tt>
<br><tt>0x00df is a single-byte Katakana alphabetic character</tt>
<br><tt>0xe0a1 is not a single-byte Katakana alphabetic character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbbkprint"> _ismbbkprint </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>int _ismbbkprint( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbbkprint</tt> function tests if the argument<b> ch</b> is a non-ASCII text or non-ASCII punctuation symbol.
<br>For example, in code page 932,<tt> _ismbbkprint</tt> tests if the argument<b> ch</b> is a single-byte Katakana character.
&nbsp; A single-byte Katakana character is any character for which the following expression is true:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0xA1 &lt;= ch &lt;= 0xDF</tt>
<br><br><b>Note:</b>&nbsp; The argument<b> ch</b> must represent a single-byte value (i.e., 0 &lt;=<b> ch</b> &lt;= 255 ).
&nbsp; Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbbkprint</tt> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>,
 <a href="#_ismbbkalnum">_ismbbkalnum</a>, <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>,
 <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>, <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>,
 <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Katakana printable character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbkprint( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0020 is not a single-byte Katakana printable character</tt>
<br><tt>0x002e is not a single-byte Katakana printable character</tt>
<br><tt>0x0031 is not a single-byte Katakana printable character</tt>
<br><tt>0x0041 is not a single-byte Katakana printable character</tt>
<br><tt>0x8140 is not a single-byte Katakana printable character</tt>
<br><tt>0x8260 is not a single-byte Katakana printable character</tt>
<br><tt>0x82a6 is a single-byte Katakana printable character</tt>
<br><tt>0x8342 is not a single-byte Katakana printable character</tt>
<br><tt>0x00a1 is a single-byte Katakana printable character</tt>
<br><tt>0x00a6 is a single-byte Katakana printable character</tt>
<br><tt>0x00df is a single-byte Katakana printable character</tt>
<br><tt>0xe0a1 is a single-byte Katakana printable character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbbkpunct"> _ismbbkpunct </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>int _ismbbkpunct( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbbkpunct</tt> function tests if the argument<b> ch</b> is a non-ASCII punctuation character.
<br>For example, in code page 932,<tt> _ismbbkpunct</tt> tests if the argument<b> ch</b> is a single-byte Katakana punctuation
 character.&nbsp; A single-byte Katakana punctuation character is any character for which the following expression is true:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0xA1 &lt;= ch &lt;= 0xA5</tt>
<br><br><b>Note:</b>&nbsp; The argument<b> ch</b> must represent a single-byte value (i.e., 0 &lt;=<b> ch</b> &lt;= 255 ).
&nbsp; Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbbkpunct</tt> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>,
 <a href="#_ismbbkalnum">_ismbbkalnum</a>, <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>,
 <a href="#_ismbbkprint">_ismbbkprint</a>, <a href="#_ismbblead">_ismbblead</a>, <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>,
 <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Katakana punctuation character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbkpunct( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0020 is not a single-byte Katakana punctuation character</tt>
<br><tt>0x002e is not a single-byte Katakana punctuation character</tt>
<br><tt>0x0031 is not a single-byte Katakana punctuation character</tt>
<br><tt>0x0041 is not a single-byte Katakana punctuation character</tt>
<br><tt>0x8140 is not a single-byte Katakana punctuation character</tt>
<br><tt>0x8260 is not a single-byte Katakana punctuation character</tt>
<br><tt>0x82a6 is not a single-byte Katakana punctuation character</tt>
<br><tt>0x8342 is not a single-byte Katakana punctuation character</tt>
<br><tt>0x00a1 is a single-byte Katakana punctuation character</tt>
<br><tt>0x00a6 is not a single-byte Katakana punctuation character</tt>
<br><tt>0x00df is not a single-byte Katakana punctuation character</tt>
<br><tt>0xe0a1 is a single-byte Katakana punctuation character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbblead"> _ismbblead </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>int _ismbblead( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbblead</tt> function tests if the argument<b> ch</b> is a valid first byte of a multibyte character.
<br>For example, in code page 932, valid ranges are 0x81 through 0x9F and 0xE0 through 0xFC.
<br><br><b>Note:</b>&nbsp; The argument<b> ch</b> must represent a single-byte value (i.e., 0 &lt;=<b> ch</b> &lt;= 255 ).
&nbsp; Incorrect results occur if the argument is a double-byte character.
</dl>
<dl>
<dt>Returns:
<dd><tt> _ismbblead</tt> returns a non-zero value if the argument is valid as the first byte of a multibyte character; otherwise
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>,
 <a href="#_ismbbkalnum">_ismbbkalnum</a>, <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>,
 <a href="#_ismbbkprint">_ismbbkprint</a>, <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbbprint">_ismbbprint</a>,
 <a href="#_ismbbpunct">_ismbbpunct</a>, <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x does %shave a valid first byte\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbblead( chars&#91;i&#93;&gt;&gt;8 ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0020 does not have a valid first byte</tt>
<br><tt>0x002e does not have a valid first byte</tt>
<br><tt>0x0031 does not have a valid first byte</tt>
<br><tt>0x0041 does not have a valid first byte</tt>
<br><tt>0x8140 does have a valid first byte</tt>
<br><tt>0x8260 does have a valid first byte</tt>
<br><tt>0x82a6 does have a valid first byte</tt>
<br><tt>0x8342 does have a valid first byte</tt>
<br><tt>0x00a1 does not have a valid first byte</tt>
<br><tt>0x00a6 does not have a valid first byte</tt>
<br><tt>0x00df does not have a valid first byte</tt>
<br><tt>0xe0a1 does have a valid first byte</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbbprint"> _ismbbprint </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>int _ismbbprint( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbbprint</tt> function tests if the argument<b> ch</b> is a single-byte printable character including space (&quot;
 &quot;).
<br>For example, in code page 932,<tt> _ismbbprint</tt> tests if the argument<b> ch</b> is a single-byte printable character
 including space (&quot; &quot;) or a single-byte Katakana character.&nbsp; These are any characters for which the following
 expression is true:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; isprint(ch) || _ismbbkprint(ch)</tt>
<br><br><b>Note:</b>&nbsp; The argument<b> ch</b> must represent a single-byte value (i.e., 0 &lt;=<b> ch</b> &lt;= 255 ).
&nbsp; Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbbprint</tt> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>,
 <a href="#_ismbbkalnum">_ismbbkalnum</a>, <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>,
 <a href="#_ismbbkprint">_ismbbkprint</a>, <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>,
 <a href="#_ismbbpunct">_ismbbpunct</a>, <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0D,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;printable character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbprint( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x000d is not a single-byte printable character</tt>
<br><tt>0x002e is a single-byte printable character</tt>
<br><tt>0x0031 is a single-byte printable character</tt>
<br><tt>0x0041 is a single-byte printable character</tt>
<br><tt>0x8140 is a single-byte printable character</tt>
<br><tt>0x8260 is a single-byte printable character</tt>
<br><tt>0x82a6 is a single-byte printable character</tt>
<br><tt>0x8342 is a single-byte printable character</tt>
<br><tt>0x00a1 is a single-byte printable character</tt>
<br><tt>0x00a6 is a single-byte printable character</tt>
<br><tt>0x00df is a single-byte printable character</tt>
<br><tt>0xe0a1 is a single-byte printable character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbbpunct"> _ismbbpunct </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>int _ismbbpunct( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbbpunct</tt> function tests if the argument<b> ch</b> is a single-byte punctuation character.
<br>For example, in code page 932,<tt> _ismbbpunct</tt> tests if the argument<b> ch</b> is a single-byte punctuation character
 or a single-byte Katakana punctuation character.&nbsp; These are any characters for which the following expression is true:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ispunct(ch) || _ismbbkpunct(ch)</tt>
<br><br><b>Note:</b>&nbsp; The argument<b> ch</b> must represent a single-byte value (i.e., 0 &lt;=<b> ch</b> &lt;= 255 ).
&nbsp; Incorrect results occur if the argument is a double-byte character.&nbsp; This is shown by the example below.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbbpunct</tt> function returns a non-zero value if the argument satisfies the condition; otherwise a zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>,
 <a href="#_ismbbkalnum">_ismbbkalnum</a>, <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>,
 <a href="#_ismbbkprint">_ismbbkprint</a>, <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>,
 <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa single-byte &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;punctuation character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbpunct( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0020 is not a single-byte punctuation character</tt>
<br><tt>0x002e is a single-byte punctuation character</tt>
<br><tt>0x0031 is not a single-byte punctuation character</tt>
<br><tt>0x0041 is not a single-byte punctuation character</tt>
<br><tt>0x8140 is a single-byte punctuation character</tt>
<br><tt>0x8260 is a single-byte punctuation character</tt>
<br><tt>0x82a6 is not a single-byte punctuation character</tt>
<br><tt>0x8342 is not a single-byte punctuation character</tt>
<br><tt>0x00a1 is a single-byte punctuation character</tt>
<br><tt>0x00a6 is not a single-byte punctuation character</tt>
<br><tt>0x00df is not a single-byte punctuation character</tt>
<br><tt>0xe0a1 is a single-byte punctuation character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbbtrail"> _ismbbtrail </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbbtrail( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbbtrail</tt> function tests if<b> ch</b> is a valid second byte of a multibyte character.
<br>For example, in code page 932, valid ranges are 0x40 through 0x7E and 0x80 through 0xFC.
<br><br><b>Note:</b>&nbsp; Only the least significant (trailing) byte of the argument<b> ch</b> is tested.&nbsp; If the argument
 is a double-byte character, the leading byte is ignored and may be invalid.&nbsp; This is shown by the example below.
</dl>
<dl>
<dt>Returns:
<dd><tt> _ismbbtrail</tt> returns a non-zero value if the argument is valid as the second byte of a multibyte character; otherwise
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>,
 <a href="#_ismbbkalnum">_ismbbkalnum</a>, <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>,
 <a href="#_ismbbkprint">_ismbbkprint</a>, <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>,
 <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82A6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8342, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0A1&nbsp; /* double-byte Kanji */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x does %shave a valid second byte\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbbtrail(chars&#91;i&#93;&amp;0xff) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0020 does not have a valid second byte</tt>
<br><tt>0x002e does not have a valid second byte</tt>
<br><tt>0x0031 does not have a valid second byte</tt>
<br><tt>0x0041 does have a valid second byte</tt>
<br><tt>0x8140 does have a valid second byte</tt>
<br><tt>0x8260 does have a valid second byte</tt>
<br><tt>0x82a6 does have a valid second byte</tt>
<br><tt>0x8342 does have a valid second byte</tt>
<br><tt>0x00a1 does have a valid second byte</tt>
<br><tt>0x00a6 does have a valid second byte</tt>
<br><tt>0x00df does have a valid second byte</tt>
<br><tt>0xe0a1 does have a valid second byte</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbcalnum"> _ismbcalnum </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbcalnum( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbcalnum</tt> function tests if the multibyte character argument<b> ch</b> is an alphanumeric character.&nbsp;
 For example, in code page 932, 'A' through 'Z', 'a' through 'z', or '0' through '9' and its corresponding double-byte versions
 are alphanumeric (among others).&nbsp; An alphanumeric character is any character for which <tt> _ismbcalpha</tt> or <tt>
 _ismbcdigit</tt> is true.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbcalnum</tt> function returns zero if the argument is not an alphanumeric character; otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>, <a href="#_ismbcdigit">_ismbcdigit</a>,
 <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>, <a href="#_ismbcl0">_ismbcl0</a>,
 <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>, <a href="#_ismbclower">_ismbclower</a>,
 <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x889E, /* double-byte L0 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x889F, /* double-byte L1 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte alphanumeric character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcalnum( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x002e is not a valid multibyte alphanumeric character</tt>
<br><tt>0x0031 is a valid multibyte alphanumeric character</tt>
<br><tt>0x0041 is a valid multibyte alphanumeric character</tt>
<br><tt>0x8143 is not a valid multibyte alphanumeric character</tt>
<br><tt>0x8254 is a valid multibyte alphanumeric character</tt>
<br><tt>0x8260 is a valid multibyte alphanumeric character</tt>
<br><tt>0x8279 is a valid multibyte alphanumeric character</tt>
<br><tt>0x8281 is a valid multibyte alphanumeric character</tt>
<br><tt>0x829a is a valid multibyte alphanumeric character</tt>
<br><tt>0x829f is a valid multibyte alphanumeric character</tt>
<br><tt>0x8340 is a valid multibyte alphanumeric character</tt>
<br><tt>0x837f is not a valid multibyte alphanumeric character</tt>
<br><tt>0x889e is not a valid multibyte alphanumeric character</tt>
<br><tt>0x889f is a valid multibyte alphanumeric character</tt>
<br><tt>0x989f is a valid multibyte alphanumeric character</tt>
<br><tt>0x00a6 is a valid multibyte alphanumeric character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbcalpha"> _ismbcalpha </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbcalpha( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbcalpha</tt> function tests if the multibyte character argument<b> ch</b> is an alphabetic character.&nbsp; For
 example, in code page 932, 'A' through 'Z' or 'a' through 'z' and its corresponding double-byte versions and the Katakana
 letters (0xA6 through 0xDF) are alphabetic.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbcalpha</tt> function returns zero if the argument is not an alphabetic character; otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbccntrl">_ismbccntrl</a>, <a href="#_ismbcdigit">_ismbcdigit</a>,
 <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>, <a href="#_ismbcl0">_ismbcl0</a>,
 <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>, <a href="#_ismbclower">_ismbclower</a>,
 <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x889E, /* double-byte L0 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x889F, /* double-byte L1 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte alphabetic character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcalpha( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x002e is not a valid multibyte alphabetic character</tt>
<br><tt>0x0031 is not a valid multibyte alphabetic character</tt>
<br><tt>0x0041 is a valid multibyte alphabetic character</tt>
<br><tt>0x8143 is not a valid multibyte alphabetic character</tt>
<br><tt>0x8254 is not a valid multibyte alphabetic character</tt>
<br><tt>0x8260 is a valid multibyte alphabetic character</tt>
<br><tt>0x8279 is a valid multibyte alphabetic character</tt>
<br><tt>0x8281 is a valid multibyte alphabetic character</tt>
<br><tt>0x829a is a valid multibyte alphabetic character</tt>
<br><tt>0x829f is a valid multibyte alphabetic character</tt>
<br><tt>0x8340 is a valid multibyte alphabetic character</tt>
<br><tt>0x837f is not a valid multibyte alphabetic character</tt>
<br><tt>0x889e is not a valid multibyte alphabetic character</tt>
<br><tt>0x889f is a valid multibyte alphabetic character</tt>
<br><tt>0x989f is a valid multibyte alphabetic character</tt>
<br><tt>0x00a6 is a valid multibyte alphabetic character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbccntrl"> _ismbccntrl </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbccntrl( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbccntrl</tt> function tests for any multibyte control character.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbccntrl</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbcdigit">_ismbcdigit</a>,
 <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>, <a href="#_ismbcl0">_ismbcl0</a>,
 <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>, <a href="#_ismbclower">_ismbclower</a>,
 <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0D,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte control character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbccntrl( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x000d is a valid multibyte control character</tt>
<br><tt>0x002e is not a valid multibyte control character</tt>
<br><tt>0x0020 is not a valid multibyte control character</tt>
<br><tt>0x0031 is not a valid multibyte control character</tt>
<br><tt>0x0041 is not a valid multibyte control character</tt>
<br><tt>0x8140 is a valid multibyte control character</tt>
<br><tt>0x8143 is a valid multibyte control character</tt>
<br><tt>0x8254 is not a valid multibyte control character</tt>
<br><tt>0x8260 is not a valid multibyte control character</tt>
<br><tt>0x8279 is not a valid multibyte control character</tt>
<br><tt>0x8281 is not a valid multibyte control character</tt>
<br><tt>0x829a is not a valid multibyte control character</tt>
<br><tt>0x989f is not a valid multibyte control character</tt>
<br><tt>0x00a6 is not a valid multibyte control character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbcdigit"> _ismbcdigit </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbcdigit( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbcdigit</tt> function tests for any multibyte decimal-digit character '0' through '9'.&nbsp; In code page 932,
 this includes the corresponding double-byte versions of these characters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbcdigit</tt> function returns a non-zero value when the argument is a decimal-digit character.&nbsp; Otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>, <a href="#_ismbcl0">_ismbcl0</a>,
 <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>, <a href="#_ismbclower">_ismbclower</a>,
 <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8183, /* double-byte &lt; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8277, /* double-byte X */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte digit character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcdigit( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x002e is not a valid multibyte digit character</tt>
<br><tt>0x0031 is a valid multibyte digit character</tt>
<br><tt>0x0041 is not a valid multibyte digit character</tt>
<br><tt>0x8143 is not a valid multibyte digit character</tt>
<br><tt>0x8183 is not a valid multibyte digit character</tt>
<br><tt>0x8254 is a valid multibyte digit character</tt>
<br><tt>0x8277 is not a valid multibyte digit character</tt>
<br><tt>0x00a6 is not a valid multibyte digit character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbcgraph"> _ismbcgraph </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbcgraph( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbcgraph</tt> function tests for any printable multibyte character except space (' ').&nbsp; The <tt> _ismbcprint</tt>
 function is similar, except that the space character is also included in the character set being tested.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbcgraph</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>, <a href="#_ismbcl0">_ismbcl0</a>,
 <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>, <a href="#_ismbclower">_ismbclower</a>,
 <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte graph character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcgraph( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x002e is a valid multibyte graph character</tt>
<br><tt>0x0020 is not a valid multibyte graph character</tt>
<br><tt>0x0031 is a valid multibyte graph character</tt>
<br><tt>0x0041 is a valid multibyte graph character</tt>
<br><tt>0x8140 is not a valid multibyte graph character</tt>
<br><tt>0x8143 is a valid multibyte graph character</tt>
<br><tt>0x8254 is a valid multibyte graph character</tt>
<br><tt>0x8260 is a valid multibyte graph character</tt>
<br><tt>0x8279 is a valid multibyte graph character</tt>
<br><tt>0x8281 is a valid multibyte graph character</tt>
<br><tt>0x829a is a valid multibyte graph character</tt>
<br><tt>0x989f is a valid multibyte graph character</tt>
<br><tt>0x00a6 is a valid multibyte graph character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbchira"> _ismbchira </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbchira( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbchira</tt> function tests for a double-byte Hiragana character.&nbsp; A double-byte Hiragana character is any
 character for which the following expression is true:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x829F &lt;= ch &lt;= 0x82F1</tt>
<br><br><b>Note:</b>&nbsp; The Japanese double-byte character set includes Kanji, Hiragana, and Katakana characters - both
 alphabetic and numeric.&nbsp; Kanji is the ideogram character set of the Japanese character set.&nbsp; Hiragana and Katakana
 are two types of phonetic character sets of the Japanese character set.&nbsp; The Hiragana code set includes 83 characters
 and the Katakana code set includes 86 characters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbchira</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbckata">_ismbckata</a>, <a href="#_ismbcl0">_ismbcl0</a>,
 <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>, <a href="#_ismbclower">_ismbclower</a>,
 <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Hiragana character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbchira( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0041 is not a valid Hiragana character</tt>
<br><tt>0x8140 is not a valid Hiragana character</tt>
<br><tt>0x8143 is not a valid Hiragana character</tt>
<br><tt>0x8260 is not a valid Hiragana character</tt>
<br><tt>0x829f is a valid Hiragana character</tt>
<br><tt>0x8340 is not a valid Hiragana character</tt>
<br><tt>0x837f is not a valid Hiragana character</tt>
<br><tt>0x989f is not a valid Hiragana character</tt>
<br><tt>0x00a6 is not a valid Hiragana character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbckata"> _ismbckata </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbckata( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbckata</tt> function tests for a double-byte Katakana character.&nbsp; A double-byte Katakana character is any
 character for which the following expression is true:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x8340 &lt;= ch &lt;= 0x8396&nbsp; &amp;&amp;&nbsp; ch != 0x837F</tt>
<br><br><b>Note:</b>&nbsp; The Japanese double-byte character set includes Kanji, Hiragana, and Katakana characters - both
 alphabetic and numeric.&nbsp; Kanji is the ideogram character set of the Japanese character set.&nbsp; Hiragana and Katakana
 are two types of phonetic character sets of the Japanese character set.&nbsp; The Hiragana code set includes 83 characters
 and the Katakana code set includes 86 characters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbckata</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbcl0">_ismbcl0</a>,
 <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>, <a href="#_ismbclower">_ismbclower</a>,
 <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Katakana character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbckata( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0041 is not a valid Katakana character</tt>
<br><tt>0x8140 is not a valid Katakana character</tt>
<br><tt>0x8143 is not a valid Katakana character</tt>
<br><tt>0x8260 is not a valid Katakana character</tt>
<br><tt>0x829f is not a valid Katakana character</tt>
<br><tt>0x8340 is a valid Katakana character</tt>
<br><tt>0x837f is not a valid Katakana character</tt>
<br><tt>0x989f is not a valid Katakana character</tt>
<br><tt>0x00a6 is not a valid Katakana character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbcl0"> _ismbcl0 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbcl0( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbcl0</tt> function tests if the argument<b> ch</b> is in the set of double-byte characters that include Hiragana,
 Katakana, punctuation symbols, graphical symbols, Roman and Cyrillic alphabets, etc.&nbsp; Double-byte Kanji characters are
 not in this set.&nbsp; These are any characters for which the following expression is true:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x8140 &lt;= ch &lt;= 0x889E&nbsp; &amp;&amp;&nbsp; ch != 0x837F</tt>
<br><br>The<tt> _ismbcl0</tt> function tests if the argument is a valid double-byte character (i.e., it checks that the lower
 byte is not in the ranges 0x00 - 0x3F, 0x7F, or 0xFD - 0xFF).
<br><br><b>Note:</b>&nbsp; The Japanese double-byte character set includes Kanji, Hiragana, and Katakana characters - both
 alphabetic and numeric.&nbsp; Kanji is the ideogram character set of the Japanese character set.&nbsp; Hiragana and Katakana
 are two types of phonetic character sets of the Japanese character set.&nbsp; The Hiragana code set includes 83 characters
 and the Katakana code set includes 86 characters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbcl0</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>,
 <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>, <a href="#_ismbclower">_ismbclower</a>,
 <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x889E, /* double-byte L0 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x889F, /* double-byte L1 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;JIS L0 character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcl0( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0041 is not a valid JIS L0 character</tt>
<br><tt>0x8140 is a valid JIS L0 character</tt>
<br><tt>0x8143 is a valid JIS L0 character</tt>
<br><tt>0x8260 is a valid JIS L0 character</tt>
<br><tt>0x829f is a valid JIS L0 character</tt>
<br><tt>0x8340 is a valid JIS L0 character</tt>
<br><tt>0x837f is not a valid JIS L0 character</tt>
<br><tt>0x889e is a valid JIS L0 character</tt>
<br><tt>0x889f is not a valid JIS L0 character</tt>
<br><tt>0x989f is not a valid JIS L0 character</tt>
<br><tt>0x00a6 is not a valid JIS L0 character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbcl1"> _ismbcl1 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbcl1( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbcl1</tt> function tests if the argument<b> ch</b> is a JIS (Japan Industrial Standard) level 1 double-byte character
 code.&nbsp; These are any valid double-byte characters for which the following expression is true:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x889F &lt;= ch &lt;= 0x9872</tt>
<br><br>The<tt> _ismbcl1</tt> function tests if the argument is a valid double-byte character (i.e., it checks that the lower
 byte is not in the ranges 0x00 - 0x3F, 0x7F, or 0xFD - 0xFF).
<br><br><b>Note:</b>&nbsp; JIS establishes two levels of the Kanji double-byte character set.&nbsp; One is called double-byte
 Kanji code set level 1 and the other is called double-byte Kanji code set level 2.&nbsp; Usually Japanese personal computers
 have font ROM/RAM support for both levels.
<br><br>Valid double-byte characters are those in which the first byte falls in the range 0x81 - 0x9F or 0xE0 - 0xFC and whose
 second byte falls in the range 0x40 - 0x7E or 0x80 - 0xFC.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbcl1</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>,
 <a href="#_ismbcl0">_ismbcl0</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>, <a href="#_ismbclower">_ismbclower</a>,
 <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x889E, /* double-byte L0 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x889F, /* double-byte L1 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;JIS L1 character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcl1( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0041 is not a valid JIS L1 character</tt>
<br><tt>0x8140 is not a valid JIS L1 character</tt>
<br><tt>0x8143 is not a valid JIS L1 character</tt>
<br><tt>0x8260 is not a valid JIS L1 character</tt>
<br><tt>0x829f is not a valid JIS L1 character</tt>
<br><tt>0x8340 is not a valid JIS L1 character</tt>
<br><tt>0x837f is not a valid JIS L1 character</tt>
<br><tt>0x889e is not a valid JIS L1 character</tt>
<br><tt>0x889f is a valid JIS L1 character</tt>
<br><tt>0x989f is not a valid JIS L1 character</tt>
<br><tt>0x00a6 is not a valid JIS L1 character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbcl2"> _ismbcl2 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbcl2( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbcl2</tt> function tests if the argument<b> ch</b> is a JIS (Japan Industrial Standard) level 2 double-byte character
 code.&nbsp; These are any valid double-byte characters for which the following expression is true:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x989F &lt;= ch &lt;= 0xEA9E</tt>
<br><br>The<tt> _ismbcl2</tt> function tests if the argument is a valid double-byte character (i.e., it checks that the lower
 byte is not in the ranges 0x00 - 0x3F, 0x7F, or 0xFD - 0xFF).
<br><br><b>Note:</b>&nbsp; JIS establishes two levels of the Kanji double-byte character set.&nbsp; One is called double-byte
 Kanji code set level 1 and the other is called double-byte Kanji code set level 2.&nbsp; Usually Japanese personal computers
 have font ROM/RAM support for both levels.
<br><br>Valid double-byte characters are those in which the first byte falls in the range 0x81 - 0x9F or 0xE0 - 0xFC and whose
 second byte falls in the range 0x40 - 0x7E or 0x80 - 0xFC.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbcl2</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>,
 <a href="#_ismbcl0">_ismbcl0</a>, <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbclegal">_ismbclegal</a>, <a href="#_ismbclower">_ismbclower</a>,
 <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x889E, /* double-byte L0 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x889F, /* double-byte L1 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xEA9E, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;JIS L2 character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcl2( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0041 is not a valid JIS L2 character</tt>
<br><tt>0x8140 is not a valid JIS L2 character</tt>
<br><tt>0x8143 is not a valid JIS L2 character</tt>
<br><tt>0x8260 is not a valid JIS L2 character</tt>
<br><tt>0x829f is not a valid JIS L2 character</tt>
<br><tt>0x8340 is not a valid JIS L2 character</tt>
<br><tt>0x837f is not a valid JIS L2 character</tt>
<br><tt>0x889e is not a valid JIS L2 character</tt>
<br><tt>0x889f is not a valid JIS L2 character</tt>
<br><tt>0x989f is a valid JIS L2 character</tt>
<br><tt>0xea9e is a valid JIS L2 character</tt>
<br><tt>0x00a6 is not a valid JIS L2 character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbclegal"> _ismbclegal </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbclegal( unsigned int dbch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbclegal</tt> function tests for a valid multibyte character.&nbsp; Multibyte characters include both single-byte
 and double-byte characters.&nbsp; For example, in code page 932, a legal double-byte character is one in which the first
 byte is within the ranges 0x81 - 0x9F or 0xE0 - 0xFC, while the second byte is within the ranges 0x40 - 0x7E or 0x80 - 0xFC.
&nbsp; This is summarized in the following diagram.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#91; 1st byte &#93;&nbsp;&nbsp;&nbsp; &#91; 2nd byte &#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x81-0x9F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x40-0xFC</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; except 0x7F</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xE0-0xFC</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbclegal</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>,
 <a href="#_ismbcl0">_ismbcl0</a>, <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclower">_ismbclower</a>,
 <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8131, /* illegal double-byte character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829F, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8340, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x837F, /* illegal double-byte character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x889E, /* double-byte L0 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x889F, /* double-byte L1 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xEA9E, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa legal &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;double-byte character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbclegal( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0041 is not a legal double-byte character</tt>
<br><tt>0x8131 is not a legal double-byte character</tt>
<br><tt>0x8140 is a legal double-byte character</tt>
<br><tt>0x8143 is a legal double-byte character</tt>
<br><tt>0x8260 is a legal double-byte character</tt>
<br><tt>0x829f is a legal double-byte character</tt>
<br><tt>0x8340 is a legal double-byte character</tt>
<br><tt>0x837f is not a legal double-byte character</tt>
<br><tt>0x889e is a legal double-byte character</tt>
<br><tt>0x889f is a legal double-byte character</tt>
<br><tt>0x989f is a legal double-byte character</tt>
<br><tt>0xea9e is a legal double-byte character</tt>
<br><tt>0x00a6 is not a legal double-byte character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbclower"> _ismbclower </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbclower( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbclower</tt> function tests for a valid lowercase multibyte character.&nbsp; Multibyte characters include both
 single-byte and double-byte characters.&nbsp; For example, in code page 932, a lowercase double-byte character is one for
 which the following expression is true:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x8281 &lt;= c &lt;= 0x829A</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbclower</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>,
 <a href="#_ismbcl0">_ismbcl0</a>, <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>,
 <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'a',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte lowercase character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbclower( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0031 is not a valid multibyte lowercase character</tt>
<br><tt>0x0041 is not a valid multibyte lowercase character</tt>
<br><tt>0x0061 is a valid multibyte lowercase character</tt>
<br><tt>0x8140 is not a valid multibyte lowercase character</tt>
<br><tt>0x8143 is not a valid multibyte lowercase character</tt>
<br><tt>0x8254 is not a valid multibyte lowercase character</tt>
<br><tt>0x8260 is not a valid multibyte lowercase character</tt>
<br><tt>0x8279 is not a valid multibyte lowercase character</tt>
<br><tt>0x8281 is a valid multibyte lowercase character</tt>
<br><tt>0x829a is a valid multibyte lowercase character</tt>
<br><tt>0x989f is not a valid multibyte lowercase character</tt>
<br><tt>0x00a6 is not a valid multibyte lowercase character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbcprint"> _ismbcprint </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbcprint( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbcprint</tt> function tests for any printable multibyte character including space (' ').&nbsp; The <tt> _ismbcgraph</tt>
 function is similar, except that the space character is not included in the character set being tested.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbcprint</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>,
 <a href="#_ismbcl0">_ismbcl0</a>, <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>,
 <a href="#_ismbclower">_ismbclower</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte print character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcprint( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x002e is a valid multibyte print character</tt>
<br><tt>0x0020 is a valid multibyte print character</tt>
<br><tt>0x0031 is a valid multibyte print character</tt>
<br><tt>0x0041 is a valid multibyte print character</tt>
<br><tt>0x8140 is a valid multibyte print character</tt>
<br><tt>0x8143 is a valid multibyte print character</tt>
<br><tt>0x8254 is a valid multibyte print character</tt>
<br><tt>0x8260 is a valid multibyte print character</tt>
<br><tt>0x8279 is a valid multibyte print character</tt>
<br><tt>0x8281 is a valid multibyte print character</tt>
<br><tt>0x829a is a valid multibyte print character</tt>
<br><tt>0x989f is a valid multibyte print character</tt>
<br><tt>0x00a6 is a valid multibyte print character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbcpunct"> _ismbcpunct </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbcpunct( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbcpunct</tt> function tests for any multibyte punctuation character.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbcpunct</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>,
 <a href="#_ismbcl0">_ismbcl0</a>, <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>,
 <a href="#_ismbclower">_ismbclower</a>, <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcspace">_ismbcspace</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte punctuation character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcpunct( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x002e is a valid multibyte punctuation character</tt>
<br><tt>0x0020 is not a valid multibyte punctuation character</tt>
<br><tt>0x0031 is not a valid multibyte punctuation character</tt>
<br><tt>0x0041 is not a valid multibyte punctuation character</tt>
<br><tt>0x8140 is not a valid multibyte punctuation character</tt>
<br><tt>0x8143 is a valid multibyte punctuation character</tt>
<br><tt>0x8254 is not a valid multibyte punctuation character</tt>
<br><tt>0x8260 is not a valid multibyte punctuation character</tt>
<br><tt>0x8279 is not a valid multibyte punctuation character</tt>
<br><tt>0x8281 is not a valid multibyte punctuation character</tt>
<br><tt>0x829a is not a valid multibyte punctuation character</tt>
<br><tt>0x989f is not a valid multibyte punctuation character</tt>
<br><tt>0x00a1 is a valid multibyte punctuation character</tt>
<br><tt>0x00a6 is not a valid multibyte punctuation character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbcspace"> _ismbcspace </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbcspace( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbcspace</tt> function tests for any multibyte space character.&nbsp; Multibyte characters include both single-byte
 and double-byte characters.&nbsp; For example, in code page 932, the double-byte space character is 0x8140.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbcspace</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>,
 <a href="#_ismbcl0">_ismbcl0</a>, <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>,
 <a href="#_ismbclower">_ismbclower</a>, <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcsymbol">_ismbcsymbol</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x09,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte space character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcspace( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0009 is a valid multibyte space character</tt>
<br><tt>0x002e is not a valid multibyte space character</tt>
<br><tt>0x0020 is a valid multibyte space character</tt>
<br><tt>0x0031 is not a valid multibyte space character</tt>
<br><tt>0x0041 is not a valid multibyte space character</tt>
<br><tt>0x8140 is a valid multibyte space character</tt>
<br><tt>0x8143 is not a valid multibyte space character</tt>
<br><tt>0x8254 is not a valid multibyte space character</tt>
<br><tt>0x8260 is not a valid multibyte space character</tt>
<br><tt>0x8279 is not a valid multibyte space character</tt>
<br><tt>0x8281 is not a valid multibyte space character</tt>
<br><tt>0x829a is not a valid multibyte space character</tt>
<br><tt>0x989f is not a valid multibyte space character</tt>
<br><tt>0x00a6 is not a valid multibyte space character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbcsymbol"> _ismbcsymbol </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbcsymbol( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbcsymbol</tt> function tests for a valid multibyte symbol character (punctuation and other special graphical symbols).
&nbsp; For example, in code page 932,<tt> _ismbcsymbol</tt> tests for a double-byte Kigou character and returns true if and
 only if
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x8141 &lt;= ch &lt;= 0x81AC&nbsp; &amp;&amp;&nbsp; ch != 0x817F</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbcsymbol</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>,
 <a href="#_ismbcl0">_ismbcl0</a>, <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>,
 <a href="#_ismbclower">_ismbclower</a>, <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>,
 <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte symbol character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcsymbol( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x002e is not a valid multibyte symbol character</tt>
<br><tt>0x0020 is not a valid multibyte symbol character</tt>
<br><tt>0x0031 is not a valid multibyte symbol character</tt>
<br><tt>0x0041 is not a valid multibyte symbol character</tt>
<br><tt>0x8140 is not a valid multibyte symbol character</tt>
<br><tt>0x8143 is a valid multibyte symbol character</tt>
<br><tt>0x8254 is not a valid multibyte symbol character</tt>
<br><tt>0x8260 is not a valid multibyte symbol character</tt>
<br><tt>0x8279 is not a valid multibyte symbol character</tt>
<br><tt>0x8281 is not a valid multibyte symbol character</tt>
<br><tt>0x829a is not a valid multibyte symbol character</tt>
<br><tt>0x989f is not a valid multibyte symbol character</tt>
<br><tt>0x00a6 is not a valid multibyte symbol character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbcupper"> _ismbcupper </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbcupper( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbcupper</tt> function tests for a valid uppercase multibyte character.&nbsp; Multibyte characters include both
 single-byte and double-byte characters.&nbsp; For example, in code page 932, an uppercase double-byte character is one for
 which the following expression is true:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x8260 &lt;= c &lt;= 0x8279</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbcupper</tt> function returns a non-zero value when the argument is a member of this set of characters; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>,
 <a href="#_ismbcl0">_ismbcl0</a>, <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>,
 <a href="#_ismbclower">_ismbclower</a>, <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>,
 <a href="#_ismbcsymbol">_ismbcsymbol</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'a',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8140, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte , */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte 5 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8279, /* double-byte Z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8281, /* double-byte a */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829A, /* double-byte z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x989F, /* double-byte L2 character */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte uppercase character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcupper( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0031 is not a valid multibyte uppercase character</tt>
<br><tt>0x0041 is a valid multibyte uppercase character</tt>
<br><tt>0x0061 is not a valid multibyte uppercase character</tt>
<br><tt>0x8140 is not a valid multibyte uppercase character</tt>
<br><tt>0x8143 is not a valid multibyte uppercase character</tt>
<br><tt>0x8254 is not a valid multibyte uppercase character</tt>
<br><tt>0x8260 is a valid multibyte uppercase character</tt>
<br><tt>0x8279 is a valid multibyte uppercase character</tt>
<br><tt>0x8281 is not a valid multibyte uppercase character</tt>
<br><tt>0x829a is not a valid multibyte uppercase character</tt>
<br><tt>0x989f is not a valid multibyte uppercase character</tt>
<br><tt>0x00a6 is not a valid multibyte uppercase character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_ismbcxdigit"> _ismbcxdigit </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _ismbcxdigit( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ismbcxdigit</tt> function tests for any multibyte hexadecimal-digit character '0' through '9' or 'A' through 'F'.
&nbsp; In code page 932, this includes the corresponding double-byte versions of these characters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ismbcxdigit</tt> function returns a non-zero value when the argument is a hexadecimal-digit character.&nbsp; Otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>,
 <a href="#_ismbcl0">_ismbcl0</a>, <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>,
 <a href="#_ismbclower">_ismbclower</a>, <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>,
 <a href="#_ismbcsymbol">_ismbcsymbol</a>, <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8143, /* double-byte &quot;,&quot; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8183, /* double-byte &quot;&lt;&quot; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8254, /* double-byte &quot;5&quot; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8265, /* double-byte &quot;F&quot; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x is %sa valid &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;multibyte hexadecimal digit character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( _ismbcxdigit( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x002e is not a valid multibyte hexadecimal digit character</tt>
<br><tt>0x0031 is a valid multibyte hexadecimal digit character</tt>
<br><tt>0x0041 is a valid multibyte hexadecimal digit character</tt>
<br><tt>0x8143 is not a valid multibyte hexadecimal digit character</tt>
<br><tt>0x8183 is not a valid multibyte hexadecimal digit character</tt>
<br><tt>0x8254 is a valid multibyte hexadecimal digit character</tt>
<br><tt>0x8265 is a valid multibyte hexadecimal digit character</tt>
<br><tt>0x00a6 is not a valid multibyte hexadecimal digit character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="isnan"> isnan </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>int isnan( x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isnan</tt> macro determines whether its argument<b> x</b> is a NaN.&nbsp; First, an argument represented in a format
 wider than its semantic type is converted to its semantic type.&nbsp; Then determination is based on the type of the argument.
<br>The argument<b> x</b> must be an expression of real floating type.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isnan</tt> macro returns a nonzero value if and only if its argument has a NaN value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fpclassify">fpclassify</a>, <a href="#isfinite">isfinite</a>, <a href="#isinf">isinf</a>, <a href="#isnormal">isnormal</a>,
 <a href="#signbit">signbit</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;NAN %s a NaN\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isnan( NAN ) ? &quot;is&quot; : &quot;is not&quot; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>NAN is a NaN</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="isnormal"> isnormal </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>int isnormal( x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isnormal</tt> macro determines whether its argument value is normal (neither zero, subnormal, infinite, nor NaN).
&nbsp; First, an argument represented in a format wider than its semantic type is converted to its semantic type.&nbsp; Then
 determination is based on the type of the argument.
<br>The argument<b> x</b> must be an expression of real floating type.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isnormal</tt> macro returns a nonzero value if and only if its argument has a normal value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fpclassify">fpclassify</a>, <a href="#isfinite">isfinite</a>, <a href="#isinf">isinf</a>, <a href="#isnan">isnan</a>,
 <a href="#signbit">signbit</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;zero %s a normal number\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isnormal( 0.0 ) ? &quot;is&quot; : &quot;is not&quot; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>zero is not a normal number</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="isprint"> isprint, iswprint </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int isprint( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int iswprint( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isprint</tt> function tests for any printable character including space (' ').&nbsp; The <tt> isgraph</tt> function
 is similar, except that the space character is excluded from the character set being tested.
<br>The<tt> iswprint</tt> function is similar to<tt> isprint</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isprint</tt> function returns a non-zero value when the argument is a printable character.&nbsp; The<tt> iswprint</tt>
 function returns a non-zero value when the argument is a printable wide character.&nbsp; Otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>,
 <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>, <a href="#iswctype">iswctype</a>,
 <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x09,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x7d</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa printable character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isprint( chars&#91;i&#93;
 ) ) ? &quot;&quot; : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Char A is a printable character</tt>
<br><tt>Char&nbsp;&nbsp;&nbsp;&nbsp; is not a printable character</tt>
<br><tt>Char&nbsp;&nbsp; is a printable character</tt>
<br><tt>Char } is a printable character</tt>
</dl>
<dl>
<dt>Classification:
<dd>isprint is ANSI
<br>iswprint is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> isprint - All, Netware</tt>
<br><tt>iswprint - All, Netware</tt>
</dl>
<h2 id="ispunct"> ispunct, iswpunct </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int ispunct( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int iswpunct( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ispunct</tt> function tests for any punctuation character such as a comma (,) or a period (.).
<br>The<tt> iswpunct</tt> function is similar to<tt> ispunct</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ispunct</tt> function returns a non-zero value when the argument is a punctuation character.&nbsp; The<tt> iswpunct</tt>
 function returns a non-zero value when the argument is a printable wide character that is neither the space wide character
 nor a wide character for which <tt> iswalnum</tt> is true.&nbsp; Otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>,
 <a href="#isprint">isprint</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>, <a href="#iswctype">iswctype</a>,
 <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '!',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ',',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ':',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ';'</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa punctuation character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( ispunct( chars&#91;i&#93;
 ) ) ? &quot;&quot; : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Char A is not a punctuation character</tt>
<br><tt>Char ! is a punctuation character</tt>
<br><tt>Char . is a punctuation character</tt>
<br><tt>Char , is a punctuation character</tt>
<br><tt>Char : is a punctuation character</tt>
<br><tt>Char ; is a punctuation character</tt>
</dl>
<dl>
<dt>Classification:
<dd>ispunct is ANSI
<br>iswpunct is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> ispunct - All, Netware</tt>
<br><tt>iswpunct - All, Netware</tt>
</dl>
<h2 id="isspace"> isspace, iswspace </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int isspace( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int iswspace( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isspace</tt> function tests for the following white-space characters:
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Character
<dt>' '
<dd>space
<dt><br>'\f'
<dd>form feed
<dt><br>'\n'
<dd>new-line or linefeed
<dt><br>'\r'
<dd>carriage return
<dt><br>'\t'
<dd>horizontal tab
<dt><br>'\v'
<dd>vertical tab
</dl>
<br>The<tt> iswspace</tt> function is similar to<tt> isspace</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isspace</tt> function returns a non-zero character when the argument is one of the indicated white-space characters.
&nbsp; The<tt> iswspace</tt> function returns a non-zero value when the argument is a wide character that corresponds to a
 standard white-space character or is one of an implementation-defined set of wide characters for which <tt> iswalnum</tt>
 is false.&nbsp; Otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>,
 <a href="#isprint">isprint</a>, <a href="#ispunct">ispunct</a>, <a href="#isupper">isupper</a>, <a href="#iswctype">iswctype</a>,
 <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x09,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x7d</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa space character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isspace( chars&#91;i&#93;
 ) ) ? &quot;&quot; : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Char A is not a space character</tt>
<br><tt>Char&nbsp;&nbsp;&nbsp;&nbsp; is a space character</tt>
<br><tt>Char&nbsp;&nbsp; is a space character</tt>
<br><tt>Char } is not a space character</tt>
</dl>
<dl>
<dt>Classification:
<dd>isspace is ANSI
<br>iswspace is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> isspace - All, Netware</tt>
<br><tt>iswspace - All, Netware</tt>
</dl>
<h2 id="isupper"> isupper, iswupper </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int isupper( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int iswupper( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isupper</tt> function tests for any uppercase letter 'A' through 'Z'.
<br>The<tt> iswupper</tt> function is similar to<tt> isupper</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isupper</tt> function returns a non-zero value when the argument is an uppercase letter.&nbsp; The<tt> iswupper</tt>
 function returns a non-zero value when the argument is a wide character that corresponds to an uppercase letter, or if it
 is one of an implementation-defined set of wide characters for which none of <tt> iswcntrl</tt>, <tt> iswdigit</tt>, <tt>
 iswpunct</tt>, or <tt> iswspace</tt> is true.&nbsp; Otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>,
 <a href="#isprint">isprint</a>, <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#iswctype">iswctype</a>,
 <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'a',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'z',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'Z'</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %san uppercase character\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isupper( chars&#91;i&#93;
 ) ) ? &quot;&quot; : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Char A is an uppercase character</tt>
<br><tt>Char a is not an uppercase character</tt>
<br><tt>Char z is not an uppercase character</tt>
<br><tt>Char Z is an uppercase character</tt>
</dl>
<dl>
<dt>Classification:
<dd>isupper is ANSI
<br>iswupper is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> isupper - All, Netware</tt>
<br><tt>iswupper - All, Netware</tt>
</dl>
<h2 id="iswctype"> iswctype </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>int iswctype( wint_t wc, wctype_t desc );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> iswctype</tt> function determines whether the wide character<b> wc</b> has the property described by<b> desc</b>.
&nbsp; Valid values of<b> desc</b> are defined by the use of the <tt> wctype</tt> function.
<br>The twelve expressions listed below have a truth-value equivalent to a call to the wide character testing function shown.
<dl>
<dt>Expression&nbsp;&nbsp;&nbsp;&nbsp; Equivalent
<dt>iswctype(wc, wctype(&quot;alnum&quot;))
<dd>iswalnum(wc)
<dt><br>iswctype(wc, wctype(&quot;alpha&quot;))
<dd>iswalpha(wc)
<dt><br>iswctype(wc, wctype(&quot;blank&quot;))
<dd>iswblank(wc)
<dt><br>iswctype(wc, wctype(&quot;cntrl&quot;))
<dd>iswcntrl(wc)
<dt><br>iswctype(wc, wctype(&quot;digit&quot;))
<dd>iswdigit(wc)
<dt><br>iswctype(wc, wctype(&quot;graph&quot;))
<dd>iswgraph(wc)
<dt><br>iswctype(wc, wctype(&quot;lower&quot;))
<dd>iswlower(wc)
<dt><br>iswctype(wc, wctype(&quot;print&quot;))
<dd>iswprint(wc)
<dt><br>iswctype(wc, wctype(&quot;punct&quot;))
<dd>iswpunct(wc)
<dt><br>iswctype(wc, wctype(&quot;space&quot;))
<dd>iswspace(wc)
<dt><br>iswctype(wc, wctype(&quot;upper&quot;))
<dd>iswupper(wc)
<dt><br>iswctype(wc, wctype(&quot;xdigit&quot;))
<dd>iswxdigit(wc)
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> iswctype</tt> function returns non-zero (true) if and only if the value of the wide character<b> wc</b> has the property
 described by<b> desc</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>,
 <a href="#isprint">isprint</a>, <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>,
 <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><br><tt>char *types&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;alnum&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;alpha&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;blank&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;cntrl&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;digit&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;graph&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;lower&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;print&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;punct&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;space&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;upper&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;xdigit&quot;</tt>
<br><tt>};</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wint_t&nbsp; wc = 'A';</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 12; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( iswctype( wc, wctype( types&#91;i&#93; ) ) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, types&#91;i&#93; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>alnum</tt>
<br><tt>alpha</tt>
<br><tt>graph</tt>
<br><tt>print</tt>
<br><tt>upper</tt>
<br><tt>xdigit</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="isxdigit"> isxdigit, iswxdigit </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int isxdigit( int c );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int iswxdigit( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> isxdigit</tt> function tests for any hexadecimal-digit character.&nbsp; These characters are the digits ('0' through
 '9') and the letters ('a' through 'f') and ('A' through 'F').
<br>The<tt> iswxdigit</tt> function is similar to<tt> isxdigit</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> isxdigit</tt> function returns a non-zero value when the argument is a hexadecimal-digit character.&nbsp; The<tt>
 iswxdigit</tt> function returns a non-zero value when the argument is a wide character that corresponds to a hexadecimal-digit
 character.&nbsp; Otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>,
 <a href="#isprint">isprint</a>, <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>,
 <a href="#iswctype">iswctype</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '5',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '$'</tt>
<br><tt>};</tt>
<br><tt> .exmp break</tt>
<br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Char %c is %sa hexadecimal digit&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot; character\n&quot;, chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( isxdigit( chars&#91;i&#93; ) ) ? &quot;&quot;
 : &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Char A is a hexadecimal digit character</tt>
<br><tt>Char 5 is a hexadecimal digit character</tt>
<br><tt>Char $ is not a hexadecimal digit character</tt>
</dl>
<dl>
<dt>Classification:
<dd>isxdigit is ANSI
<br>iswxdigit is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> isxdigit - All, Netware</tt>
<br><tt>iswxdigit - All, Netware</tt>
</dl>
<h2 id="itoa"> itoa, _itoa, _itow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>char *itoa( int value, char *buffer, int radix );</tt>
<br><tt>char *_itoa( int value, char *buffer, int radix );</tt>
<br><tt>wchar_t *_itow( int value, wchar_t *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> itoa</tt> function converts the binary integer<b> value</b> into the equivalent string in base<b> radix</b> notation
 storing the result in the character array pointed to by<b> buffer</b>.&nbsp; A null character is appended to the result.
&nbsp; The size of<b> buffer</b> must be at least (8 * sizeof(int) + 1) bytes when converting values in base 2.&nbsp; That
 makes the size 17 bytes on 16-bit machines, and 33 bytes on 32-bit machines.&nbsp; The value of<b> radix</b> must satisfy
 the condition:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2 &lt;= radix &lt;= 36</tt>
<br><br>If<b> radix</b> is 10 and<b> value</b> is negative, then a minus sign is prepended to the result.
<br><br>The<tt> _itoa</tt> function is identical to<tt> itoa</tt>.&nbsp; Use<tt> _itoa</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _itow</tt> function is identical to<tt> itoa</tt> except that it produces a wide-character string (which is
 twice as long).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> itoa</tt> function returns the pointer to the result.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#atoll">atoll</a>, <a href="#ltoa">ltoa</a>, <a href="#lltoa">lltoa</a>,
 <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoul">strtoul</a>,
 <a href="#strtoull">strtoull</a>, <a href="#strtoimax">strtoimax</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ultoa">ultoa</a>,
 <a href="#ulltoa">ulltoa</a>, <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;20&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int base;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( base = 2; base &lt;= 16; base = base + 2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2d %s\n&quot;, base,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; itoa( 12765, buffer, base
 ) );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt> 2 11000111011101</tt>
<br><tt> 4 3013131</tt>
<br><tt> 6 135033</tt>
<br><tt> 8 30735</tt>
<br><tt>10 12765</tt>
<br><tt>12 7479</tt>
<br><tt>14 491b</tt>
<br><tt>16 31dd</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_itoa conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> itoa - All, Netware</tt>
<br><tt>_itoa - All, Netware</tt>
<br><tt>_itow - All</tt>
</dl>
<h2 id="kbhit"> kbhit, _kbhit </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>int kbhit( void );</tt>
<br><tt>int _kbhit( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> kbhit</tt> function tests whether or not a keystroke is currently available.&nbsp; When one is available, the function
 <tt> getch</tt> or <tt> getche</tt> may be used to obtain the keystroke in question.
<br>With a stand-alone program, the<tt> kbhit</tt> function may be called continuously until a keystroke is available.
<br><br>The<tt> _kbhit</tt> function is identical to<tt> kbhit</tt>.&nbsp; Use<tt> _kbhit</tt> for ANSI/ISO naming conventions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> kbhit</tt> function returns zero when no keystroke is available; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#getch">getch</a>, <a href="#getche">getche</a>, <a href="#putch">putch</a>, <a href="#ungetch">ungetch</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>/*</tt>
<br><tt> * This program loops until a key is pressed</tt>
<br><tt> * or a count is exceeded.</tt>
<br><tt> */</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned long i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Program looping. Press any key.\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10000; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( kbhit() ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_kbhit conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> kbhit - All, Netware</tt>
<br><tt>_kbhit - All, Netware</tt>
</dl>
<h2 id="labs"> labs </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>long int labs( long int j );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> labs</tt> function returns the absolute value of its long-integer argument<b> j</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> labs</tt> function returns the absolute value of its argument.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abs">abs</a>, <a href="#llabs">llabs</a>, <a href="#imaxabs">imaxabs</a>, <a href="#fabs">fabs</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long x, y;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; x = -50000L;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; y = labs( x );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;labs(%ld) = %ld\n&quot;, x, y );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>labs(-50000) = 50000</tt>
</dl>
<dl>
<dt>Classification:
<dd>ISO C90
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="ldexp"> ldexp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double ldexp( double x, int exp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ldexp</tt> function multiplies a floating-point number by an integral power of 2.&nbsp; A range error may occur.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ldexp</tt> function returns the value of<b> x</b> times 2 raised to the power<b> exp</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#frexp">frexp</a>, <a href="#modf">modf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; double value;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; value = ldexp( 4.7072345, 5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, value );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>150.631504</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="ldiv"> ldiv </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>ldiv_t ldiv( long int numer, long int denom );</tt>
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long int quot;&nbsp;&nbsp;&nbsp;&nbsp; /* quotient */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long int rem;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* remainder */</tt>
<br><tt>} ldiv_t;</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ldiv</tt> function calculates the quotient and remainder of the division of the numerator<b> numer</b> by the denominator<b>
 denom</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ldiv</tt> function returns a structure of type <tt> ldiv_t</tt> that contains the fields <tt> quot</tt> and <tt> rem</tt>,
 which are both of type<tt> long int.</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#div">div</a>, <a href="#lldiv">lldiv</a>, <a href="#imaxdiv">imaxdiv</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void print_time( long int ticks )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ldiv_t sec_ticks;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ldiv_t min_sec;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; sec_ticks = ldiv( ticks, 100L );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; min_sec&nbsp;&nbsp; = ldiv( sec_ticks.quot, 60L );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;It took %ld minutes and %ld seconds\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_sec.quot, min_sec.rem );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_time( 86712L );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>It took 14 minutes and 27 seconds</tt>
</dl>
<dl>
<dt>Classification:
<dd>ISO C90
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="lfind"> lfind </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;search.h&gt;</tt>
<br><tt>void *lfind( const void *key, /* object to search for&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *base,/* base of search data&nbsp;
&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned *num,&nbsp;&nbsp; /* number of elements
&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned width,&nbsp; /* width of each element
 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*compare)( const void *element1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *element2 ) );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> lfind</tt> function performs a linear search for the value<b> key</b> in the array of<b> num</b> elements pointed
 to by<b> base</b>.&nbsp; Each element of the array is<b> width</b> bytes in size.&nbsp; The argument<b> compare</b> is a
 pointer to a user-supplied routine that will be called by<tt> lfind</tt> to determine the relationship of an array element
 with the<b> key</b>.&nbsp; One of the arguments to the<b> compare</b> function will be an array element, and the other will
 be<b> key</b>.
<br>The<b> compare</b> function should return 0 if<b> element1</b> is identical to<b> element2</b> and non-zero if the elements
 are not identical.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> lfind</tt> function returns a pointer to the array element in<b> base</b> that matches<b> key</b> if it is found,
 otherwise<tt> NULL</tt> is returned indicating that the<b> key</b> was not found.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bsearch">bsearch</a>, <a href="#lsearch">lsearch</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;search.h&gt;</tt>
<br><br><tt>static const char *keywords&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;auto&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;break&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;case&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;char&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;while&quot;</tt>
<br><tt>};</tt>
<br><br><tt>void main( int argc, const char *argv&#91;&#93; )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned num = 5;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; extern int compare( const void *, const void * );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( argc &lt;= 1 ) exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( lfind( &amp;argv&#91;1&#93;, keywords, &amp;num, sizeof(char **),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 compare ) == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;'%s' is not a C keyword\n&quot;, argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;'%s' is a C keyword\n&quot;, argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_SUCCESS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>int compare( const void *op1, const void *op2 )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char **p1 = (const char **) op1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char **p2 = (const char **) op2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( strcmp( *p1, *p2 ) );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_lineto"> _lineto, _lineto_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _lineto( short x, short y );</tt>
<br><br><tt>short _FAR _lineto_w( double x, double y );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _lineto</tt> functions draw straight lines.&nbsp; The<tt> _lineto</tt> function uses the view coordinate system.&nbsp;
 The<tt> _lineto_w</tt> function uses the window coordinate system.
<br>The line is drawn from the current position to the point at the coordinates<tt> (x,y).</tt>&nbsp; The point<tt> (x,y)</tt>
 becomes the new current position.&nbsp; The line is drawn with the current plotting action using the current line style and
 the current color.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _lineto</tt> functions return a non-zero value when the line was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_moveto">_moveto</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_setlinestyle">_setlinestyle</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _lineto( 540, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _lineto( 320, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _lineto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_movto.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _lineto - DOS, QNX</tt>
<br><tt>_lineto_w - DOS, QNX</tt>
</dl>
<h2 id="llabs"> llabs </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>long long int llabs( long long int j );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> llabs</tt> function returns the absolute value of its long long integer argument<b> j</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> llabs</tt> function returns the absolute value of its argument.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abs">abs</a>, <a href="#imaxabs">imaxabs</a>, <a href="#fabs">fabs</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long long x, y;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; x = -5000000000;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; y = llabs( x );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;llabs(%lld) = %lld\n&quot;, x, y );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>llabs(-5000000000) = 5000000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>ISO C99
</dl>
<h2 id="lldiv"> lldiv </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>lldiv_t lldiv( long long int numer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long long int denom );</tt>
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long long int quot; /* quotient */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long long int rem;&nbsp; /* remainder */</tt>
<br><tt>} lldiv_t;</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> lldiv</tt> function calculates the quotient and remainder of the division of the numerator<b> numer</b> by the denominator<b>
 denom</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> lldiv</tt> function returns a structure of type <tt> lldiv_t</tt> that contains the fields <tt> quot</tt> and <tt>
 rem</tt>, which are both of type<tt> long long int.</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#div">div</a>, <a href="#imaxdiv">imaxdiv</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void print_time( long long int ticks )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; lldiv_t sec_ticks;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; lldiv_t min_sec;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; sec_ticks = lldiv( ticks, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; min_sec&nbsp;&nbsp; = lldiv( sec_ticks.quot, 60 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;It took %lld minutes and %lld seconds\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; min_sec.quot, min_sec.rem );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_time( 73495132 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>It took 12249 minutes and 11 seconds</tt>
</dl>
<dl>
<dt>Classification:
<dd>ISO C99
</dl>
<h2 id="localeconv"> localeconv </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;locale.h&gt;</tt>
<br><tt>struct lconv *localeconv( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> localeconv</tt> function sets the components of an object of type <tt> struct lconv</tt> with values appropriate for
 the formatting of numeric quantities according to the current locale.&nbsp; The components of the <tt> struct lconv</tt>
 and their meanings are as follows:
<dl>
<dt>Component&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>char *decimal_point
<dd>The decimal-point character used to format non-monetary quantities.
<dt><br>char *thousands_sep
<dd>The character used to separate groups of digits to the left of the decimal-point character in formatted non-monetary quantities.
<dt><br>char *grouping
<dd>A string whose elements indicate the size of each group of digits in formatted non-monetary quantities.
<dt><br>char *int_curr_symbol
<dd>The international currency symbol applicable to the current locale.&nbsp; The first three characters contain the alphabetic
 international currency symbol in accordance with those specified in<b> ISO 4217 Codes for the Representation of Currency
 and Funds.</b>&nbsp; The fourth character (immediately preceding the null character) is the character used to separate the
 international currency symbol from the monetary quantity.
<dt><br>char *currency_symbol
<dd>The local currency symbol applicable to the current locale.
<dt><br>char *mon_decimal_point
<dd>The decimal-point character used to format monetary quantities.
<dt><br>char *mon_thousands_sep
<dd>The character used to separate groups of digits to the left of the decimal-point character in formatted monetary quantities.
<dt><br>char *mon_grouping
<dd>A string whose elements indicate the size of each group of digits in formatted monetary quantities.
<dt><br>char *positive_sign
<dd>The string used to indicate a nonnegative-valued monetary quantity.
<dt><br>char *negative_sign
<dd>The string used to indicate a negative-valued monetary quantity.
<dt><br>char int_frac_digits
<dd>The number of fractional digits (those to the right of the decimal-point) to be displayed in an internationally formatted
 monetary quantity.
<dt><br>char frac_digits
<dd>The number of fractional digits (those to the right of the decimal-point) to be displayed in a formatted monetary quantity.
<dt><br>char p_cs_precedes
<dd>Set to 1 or 0 if the <tt> currency_symbol</tt> respectively precedes or follows the value for a nonnegative formatted monetary
 quantity.
<dt><br>char p_sep_by_space
<dd>Set to 1 or 0 if the <tt> currency_symbol</tt> respectively is or is not separated by a space from the value for a nonnegative
 formatted monetary quantity.
<dt><br>char n_cs_precedes
<dd>Set to 1 or 0 if the <tt> currency_symbol</tt> respectively precedes or follows the value for a negative formatted monetary
 quantity.
<dt><br>char n_sep_by_space
<dd>Set to 1 or 0 if the <tt> currency_symbol</tt> respectively is or is not separated by a space from the value for a negative
 formatted monetary quantity.
<dt><br>char p_sign_posn
<dd>The position of the <tt> positive_sign</tt> for a nonnegative formatted monetary quantity.
<dt><br>char n_sign_posn
<dd>The position of the <tt> positive_sign</tt> for a negative formatted monetary quantity.
</dl>
<br>The elements of <tt> grouping</tt> and <tt> mon_grouping</tt> are interpreted according to the following:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>CHAR_MAX
<dd>No further grouping is to be performed.
<dt><br>0
<dd>The previous element is to be repeatedly used for the remainder of the digits.
<dt><br>other
<dd>The value is the number of digits that comprise the current group.&nbsp; The next element is examined to determine the size
 of the next group of digits to the left of the current group.
</dl>
<br>The value of <tt> p_sign_posn</tt> and <tt> n_sign_posn</tt> is interpreted as follows:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>0
<dd>Parentheses surround the quantity and <tt> currency_symbol</tt>.
<dt><br>1
<dd>The sign string precedes the quantity and <tt> currency_symbol</tt>.
<dt><br>2
<dd>The sign string follows the quantity and <tt> currency_symbol</tt>.
<dt><br>3
<dd>The sign string immediately precedes the quantity and <tt> currency_symbol</tt>.
<dt><br>4
<dd>The sign string immediately follows the quantity and <tt> currency_symbol</tt>.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> localeconv</tt> function returns a pointer to the filled-in object.
</dl>
<dl>
<dt>See Also:
<dd><a href="#setlocale">setlocale</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;locale.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct lconv *lc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; lc = localeconv();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;*decimal_point (%s)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;decimal_point );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;*thousands_sep (%s)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;thousands_sep );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;*int_curr_symbol (%s)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;int_curr_symbol );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;*currency_symbol (%s)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;currency_symbol );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;*mon_decimal_point (%s)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;mon_decimal_point );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;*mon_thousands_sep (%s)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;mon_thousands_sep );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;*mon_grouping (%s)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;mon_grouping );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;*grouping (%s)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;grouping );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;*positive_sign (%s)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;positive_sign );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;*negative_sign (%s)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;negative_sign );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;int_frac_digits (%d)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;int_frac_digits );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;frac_digits (%d)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;frac_digits );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;p_cs_precedes (%d)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;p_cs_precedes );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;p_sep_by_space (%d)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;p_sep_by_space );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;n_cs_precedes (%d)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;n_cs_precedes );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;n_sep_by_space (%d)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;n_sep_by_space );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;p_sign_posn (%d)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;p_sign_posn );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;n_sign_posn (%d)\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lc-&gt;n_sign_posn );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="localtime"> localtime Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>struct tm * localtime( const time_t *timer );</tt>
<br><tt>struct tm *_localtime( const time_t *timer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; struct tm *tmbuf );</tt>
<br><br><tt>struct&nbsp; tm {</tt>
<br><tt>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- &#91;0,61&#93; */</tt>
<br><tt>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- &#91;0,59&#93; */</tt>
<br><tt>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,23&#93; */</tt>
<br><tt>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;1,31&#93; */</tt>
<br><tt>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,11&#93; */</tt>
<br><tt>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,6&#93;&nbsp; */</tt>
<br><tt>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,365&#93;*/</tt>
<br><tt>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#localtime_s">localtime_s</a> function which is a safer alternative to<tt>
 localtime</tt>.&nbsp; This newer<tt> localtime_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 localtime</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> localtime</tt> functions convert the calendar time pointed to by<b> timer</b> into a structure of type <tt> tm</tt>,
 of time information, expressed as local time.&nbsp; Whenever<tt> localtime</tt> is called, the <tt> tzset</tt> function is
 also called.
<br>The calendar time is usually obtained by using the <tt> time</tt> function.&nbsp; That time is Coordinated Universal Time
 (UTC) (formerly known as Greenwich Mean Time (GMT)).
<br><br>The <tt> _localtime</tt> function places the converted time in the <tt> tm</tt> structure pointed to by<b> tmbuf</b>,
 and the<tt> localtime</tt> function places the converted time in a static structure that is re-used each time<tt> localtime</tt>
 is called.
<br><br>The time set on the computer with the DOS<tt> time</tt> command and the DOS<tt> date</tt> command reflects the local
 time.&nbsp; The environment variable<tt> TZ</tt> is used to establish the time zone to which this local time applies.&nbsp;
 See the section<b> The TZ Environment Variable</b> for a discussion of how to set the time zone.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> localtime</tt> functions return a pointer to a <tt> tm</tt> structure containing the time information.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#asctime_s">asctime_s</a>, <a href="#clock">clock</a>, <a href="#ctime">ctime</a>
 Functions, <a href="#ctime_s">ctime_s</a>, <a href="#difftime">difftime</a>, <a href="#gmtime">gmtime</a>, <a href="#gmtime_s">gmtime_s</a>,
 <a href="#localtime_s">localtime_s</a>, <a href="#mktime">mktime</a>, <a href="#strftime">strftime</a>, <a href="#time">time</a>,
 <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t time_of_day;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buf&#91;26&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto struct tm tmbuf;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _localtime( &amp;time_of_day, &amp;tmbuf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %s&quot;, _asctime( &amp;tmbuf, buf ) );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>It is now: Sat Mar 21 15:58:27 1987</tt>
</dl>
<dl>
<dt>Classification:
<dd>localtime is ANSI
<br>_localtime is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> localtime - All, Netware</tt>
<br><tt>_localtime - All</tt>
</dl>
<h2 id="localtime_s"> localtime_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>struct tm * localtime_s( const time_t * restrict timer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct tm * restrict result);</tt>
<br><br><tt>struct&nbsp; tm {</tt>
<br><tt>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- &#91;0,61&#93; */</tt>
<br><tt>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- &#91;0,59&#93; */</tt>
<br><tt>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,23&#93; */</tt>
<br><tt>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;1,31&#93; */</tt>
<br><tt>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,11&#93; */</tt>
<br><tt>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,6&#93;&nbsp; */</tt>
<br><tt>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,365&#93;*/</tt>
<br><tt>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 localtime_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> timer</b> nor<b> result</b> shall be a null pointer.&nbsp; If there is a runtime-constraint violation, there
 is no attempt to convert the time.
</dl>
<dl>
<dt>Description:
<dd>The<tt> localtime_s</tt> function converts the calendar time pointed to by<b> timer</b> into a broken-down time, expressed
 as local time.&nbsp; The broken-down time is stored in the structure pointed to by<b> result</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> localtime_s</tt> function returns<b> result</b>, or a null pointer if the specified time cannot be converted to local
 time or there is a runtime-constraint violation.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#asctime_s">asctime_s</a>, <a href="#clock">clock</a>, <a href="#ctime">ctime</a>
 Functions, <a href="#ctime_s">ctime_s</a>, <a href="#difftime">difftime</a>, <a href="#gmtime">gmtime</a>, <a href="#gmtime_s">gmtime_s</a>,
 <a href="#localtime">localtime</a>, <a href="#mktime">mktime</a>, <a href="#strftime">strftime</a>, <a href="#time">time</a>,
 <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t time_of_day;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buf&#91;26&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto struct tm tmbuf;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; localtime_s( &amp;time_of_day, &amp;tmbuf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; asctime_s( buf, sizeof( buf ), &amp;tmbuf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %s&quot;, buf );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>It is now: Mon Jan 30 15:28:33 2006</tt>
</dl>
<dl>
<dt>Classification:
<dd>TR 24731
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Netware
</dl>
<h2 id="lock"> lock </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int lock( int handle,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long offset,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long nbytes );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> lock</tt> function locks<b> nbytes</b> amount of data in the file designated by<b> handle</b> starting at byte<b>
 offset</b> in the file.&nbsp; This prevents other processes from reading or writing into the locked region until an <tt>
 unlock</tt> has been done for this locked region of the file.
<br>Multiple regions of a file can be locked, but no overlapping regions are allowed.&nbsp; You cannot unlock multiple regions
 in the same call, even if the regions are contiguous.&nbsp; All locked regions of a file should be unlocked before closing
 a file or exiting the program.
<br><br>With DOS, locking is supported by version 3.0 or later.&nbsp; Note that<tt> SHARE.COM</tt> or<tt> SHARE.EXE</tt> must
 be installed.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> lock</tt> function returns zero if successful, and -1 when an error occurs.&nbsp; When an error has occurred, <tt>
 errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#locking">locking</a>, <a href="#open">open</a>, <a href="#sopen">sopen</a>, <a href="#unlock">unlock</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;20&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDWR | O_TEXT );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( lock( handle, 0L, 20L ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Lock failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read( handle, buffer, 20 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* update the buffer here */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lseek( handle, 0L, SEEK_SET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( handle, buffer, 20 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unlock( handle, 0L, 20L );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="locking"> locking, _locking </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;sys/locking.h&gt;</tt>
<br><tt>int locking( int handle, int mode, long nbyte );</tt>
<br><tt>int _locking( int handle, int mode, long nbyte );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> locking</tt> function locks or unlocks<b> nbyte</b> bytes of the file specified by<b> handle</b>.&nbsp; Locking a
 region of a file prevents other processes from reading or writing the locked region until the region has been unlocked.&nbsp;
 The locking and unlocking takes place at the current file position.&nbsp; The argument<b> mode</b> specifies the action to
 be performed.&nbsp; The possible values for mode are:
<dl>
<dt>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_LK_LOCK, LK_LOCK
<dd>Locks the specified region.&nbsp; The function will retry to lock the region after 1 second intervals until successful or
 until 10 attempts have been made.
<dt><br>_LK_RLCK, LK_RLCK
<dd>Same action as <tt> _LK_LOCK</tt>.
<dt><br>_LK_NBLCK, LK_NBLCK
<dd>Non-blocking lock:&nbsp; makes only 1 attempt to lock the specified region.
<dt><br>_LK_NBRLCK, LK_NBRLCK
<dd>Same action as <tt> _LK_NBLCK</tt>.
<dt><br>_LK_UNLCK, LK_UNLCK
<dd>Unlocks the specified region.&nbsp; The region must have been previously locked.
</dl>
<br>Multiple regions of a file can be locked, but no overlapping regions are allowed.&nbsp; You cannot unlock multiple regions
 in the same call, even if the regions are contiguous.&nbsp; All locked regions of a file should be unlocked before closing
 a file or exiting the program.
<br><br>With DOS, locking is supported by version 3.0 or later.&nbsp; Note that<tt> SHARE.COM</tt> or<tt> SHARE.EXE</tt> must
 be installed.
<br><br>The<tt> _locking</tt> function is identical to<tt> locking</tt>.&nbsp; Use<tt> _locking</tt> for ANSI/ISO naming conventions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> locking</tt> function returns zero if successful.&nbsp; Otherwise, it returns -1 and <tt> errno</tt> is set to indicate
 the error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EACCES
<dd>Indicates a locking violation (file already locked or unlocked).
<dt><br>EBADF
<dd>Indicates an invalid file handle.
<dt><br>EDEADLOCK
<dd>Indicates a locking violation.&nbsp; This error is returned when<b> mode</b> is<tt> LK_LOCK</tt> or<tt> LK_RLCK</tt> and the
 file cannot be locked after 10 attempts.
<dt><br>EINVAL
<dd>Indicates that an invalid argument was given to the function.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#creat">creat</a>, <a href="#_dos_creat">_dos_creat</a>, <a href="#_dos_open">_dos_open</a>, <a href="#lock">lock</a>,
 <a href="#open">open</a>, <a href="#sopen">sopen</a>, <a href="#unlock">unlock</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;sys/locking.h&gt;</tt>
<br><tt>#include &lt;share.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned nbytes;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned long offset;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buffer&#91;512&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; nbytes = 512;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; offset = 1024;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; handle = sopen( &quot;db.fil&quot;, O_RDWR, SH_DENYNO );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lseek( handle, offset, SEEK_SET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; locking( handle, LK_LOCK, nbytes );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read( handle, buffer, nbytes );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* update data in the buffer */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lseek( handle, offset, SEEK_SET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( handle, buffer, nbytes );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lseek( handle, offset, SEEK_SET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; locking( handle, LK_UNLCK, nbytes );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_locking conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> locking - All</tt>
<br><tt>_locking - All</tt>
</dl>
<h2 id="log"> log </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double log( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> log</tt> function computes the natural logarithm (base e) of<b> x</b>.&nbsp; A domain error occurs if the argument
 is negative.&nbsp; A range error occurs if the argument is zero.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> log</tt> function returns the natural logarithm of the argument.&nbsp; When the argument is outside the permissible
 range, the <tt> matherr</tt> function is called.&nbsp; Unless the default <tt> matherr</tt> function is replaced, it will
 set the global variable <tt> errno</tt> to <tt> EDOM</tt>, and print a &quot;DOMAIN error&quot; diagnostic message using
 the <tt> stderr</tt> stream.
</dl>
<dl>
<dt>See Also:
<dd><a href="#exp">exp</a>, <a href="#log10">log10</a>, <a href="#log2">log2</a>, <a href="#pow">pow</a>, <a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, log(.5) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>-0.693147</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="log10"> log10 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double log10( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> log10</tt> function computes the logarithm (base 10) of<b> x</b>.&nbsp; A domain error occurs if the argument is negative.
&nbsp; A range error occurs if the argument is zero.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> log10</tt> function returns the logarithm (base 10) of the argument.&nbsp; When the argument is outside the permissible
 range, the <tt> matherr</tt> function is called.&nbsp; Unless the default <tt> matherr</tt> function is replaced, it will
 set the global variable <tt> errno</tt> to <tt> EDOM</tt>, and print a &quot;DOMAIN error&quot; diagnostic message using
 the <tt> stderr</tt> stream.
</dl>
<dl>
<dt>See Also:
<dd><a href="#exp">exp</a>, <a href="#log">log</a>, <a href="#log2">log2</a>, <a href="#pow">pow</a>, <a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, log10(.5) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>-0.301030</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="log2"> log2 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double log2( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> log2</tt> function computes the logarithm (base 2) of<b> x</b>.&nbsp; A domain error occurs if the argument is negative.
&nbsp; A range error occurs if the argument is zero.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> log2</tt> function returns the logarithm (base 2) of the argument.&nbsp; When the argument is outside the permissible
 range, the <tt> matherr</tt> function is called.&nbsp; Unless the default <tt> matherr</tt> function is replaced, it will
 set the global variable <tt> errno</tt> to <tt> EDOM</tt>, and print a &quot;DOMAIN error&quot; diagnostic message using
 the <tt> stderr</tt> stream.
</dl>
<dl>
<dt>See Also:
<dd><a href="#exp">exp</a>, <a href="#log">log</a>, <a href="#log10">log10</a>, <a href="#pow">pow</a>, <a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, log2(.25) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>-2.000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="longjmp"> longjmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;setjmp.h&gt;</tt>
<br><tt>void longjmp( jmp_buf env, int return_value );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> longjmp</tt> function restores the environment saved by the most recent call to the <tt> setjmp</tt> function with
 the corresponding <tt> jmp_buf</tt> argument.
<br>It is generally a bad idea to use<tt> longjmp</tt> to jump out of an interrupt function or a signal handler (unless the
 signal was generated by the <tt> raise</tt> function).
</dl>
<dl>
<dt>Returns:
<dd>After the<tt> longjmp</tt> function restores the environment, program execution continues as if the corresponding call to
 <tt> setjmp</tt> had just returned the value specified by<b> return_value</b>.&nbsp; If the value of<b> return_value</b>
 is 0, the value returned is 1.
</dl>
<dl>
<dt>See Also:
<dd><a href="#setjmp">setjmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;setjmp.h&gt;</tt>
<br><br><tt>jmp_buf env;</tt>
<br><br><tt>rtn()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;about to longjmp\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; longjmp( env, 14 );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int ret_val = 293;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( 0 == ( ret_val = setjmp( env ) ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;after setjmp %d\n&quot;, ret_val );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;back from rtn %d\n&quot;, ret_val );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;back from longjmp %d\n&quot;, ret_val );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>after setjmp 0</tt>
<br><tt>about to longjmp</tt>
<br><tt>back from longjmp 14</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_lrotl"> _lrotl </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>unsigned long _lrotl( unsigned long value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; unsigned int shift );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _lrotl</tt> function rotates the unsigned long integer, determined by<b> value</b>, to the left by the number of bits
 specified in<b> shift</b>.
</dl>
<dl>
<dt>Returns:
<dd>The rotated value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_lrotr">_lrotr</a>, <a href="#_rotl">_rotl</a>, <a href="#_rotr">_rotr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>unsigned long mask = 0x12345678;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mask = _lrotl( mask, 4 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%08lX\n&quot;, mask );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>23456781</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_lrotr"> _lrotr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>unsigned long _lrotr( unsigned long value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; unsigned int shift );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _lrotr</tt> function rotates the unsigned long integer, determined by<b> value</b>, to the right by the number of
 bits specified in<b> shift</b>.
</dl>
<dl>
<dt>Returns:
<dd>The rotated value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_lrotl">_lrotl</a>, <a href="#_rotl">_rotl</a>, <a href="#_rotr">_rotr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>unsigned long mask = 0x12345678;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mask = _lrotr( mask, 4 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%08lX\n&quot;, mask );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>81234567</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="lsearch"> lsearch </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;search.h&gt;</tt>
<br><tt>void *lsearch( const void *key, /* object to search for */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *base,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; /* base of search data&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned *num,&nbsp;&nbsp; /*
 number of elements&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned width,&nbsp; /* width
 of each element*/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*compare)( const void *element1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *element2 ) );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> lsearch</tt> function performs a linear search for the value<b> key</b> in the array of<b> num</b> elements pointed
 to by<b> base</b>.&nbsp; Each element of the array is<b> width</b> bytes in size.&nbsp; The argument<b> compare</b> is a
 pointer to a user-supplied routine that will be called by<tt> lsearch</tt> to determine the relationship of an array element
 with the<b> key</b>.&nbsp; One of the arguments to the<b> compare</b> function will be an array element, and the other will
 be<b> key</b>.
<br>The<b> compare</b> function should return 0 if<b> element1</b> is identical to<b> element2</b> and non-zero if the elements
 are not identical.
</dl>
<dl>
<dt>Returns:
<dd>If the<b> key</b> value is not found in the array, then it is added to the end of the array and the number of elements is
 incremented.&nbsp; The<tt> lsearch</tt> function returns a pointer to the array element in<b> base</b> that matches<b> key</b>
 if it is found, or the newly added key if it was not found.
</dl>
<dl>
<dt>See Also:
<dd><a href="#bsearch">bsearch</a>, <a href="#lfind">lfind</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;search.h&gt;</tt>
<br><br><tt>void main( int argc, const char *argv&#91;&#93; )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned num = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char **array = (char **)calloc( argc, sizeof(char **) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; extern int compare( const void *, const void * );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; argc; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lsearch( &amp;argv&#91;i&#93;, array, &amp;num, sizeof(char **),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; compare );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; num; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, array&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>int compare( const void *op1, const void *op2 )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char **p1 = (const char **) op1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char **p2 = (const char **) op2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( strcmp( *p1, *p2 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>/* With input: one two one three four */</tt>
<br><br>produces the following:
<br><br><tt>one</tt>
<br><tt>two</tt>
<br><tt>three</tt>
<br><tt>four</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="lseek"> lseek, _lseek, _lseeki64 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>off_t lseek( int handle, off_t offset, int origin );</tt>
<br><tt>off_t _lseek( int handle, off_t offset, int origin );</tt>
<br><tt>__int64 _lseeki64( int handle, __int64 offset, int origin );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> lseek</tt> function sets the current file position at the operating system level.&nbsp; The file is referenced using
 the file handle<b> handle</b> returned by a successful execution of one of the <tt> creat</tt>, <tt> dup</tt>, <tt> dup2</tt>,
 <tt> open</tt> or <tt> sopen</tt> functions.&nbsp; The value of<b> offset</b> is used as a relative offset from a file position
 determined by the value of the argument<b> origin</b>.
<br>The new file position is determined in a manner dependent upon the value of<b> origin</b> which may have one of three
 possible values (defined in the<tt> &lt;stdio.h&gt;</tt> header file):
<dl>
<dt>Origin&nbsp;&nbsp;&nbsp;&nbsp; Definition
<dt>SEEK_SET
<dd>The new file position is computed relative to the start of the file.&nbsp; The value of<b> offset</b> must not be negative.
<dt><br>SEEK_CUR
<dd>The new file position is computed relative to the current file position.&nbsp; The value of<b> offset</b> may be positive,
 negative or zero.
<dt><br>SEEK_END
<dd>The new file position is computed relative to the end of the file.
</dl>
<br>An error will occur if the requested file position is before the start of the file.
<br><br>The requested file position may be beyond the end of the file.&nbsp; On POSIX-conforming systems, if data is later
 written at this point, subsequent reads of data in the gap will return bytes whose value is equal to zero until data is actually
 written in the gap.&nbsp; On systems such DOS and OS/2 that are not POSIX-conforming, data that are read in the gap have
 arbitrary values.
<br><br>Some versions of MS-DOS allow seeking to a negative offset, but it is not recommended since it is not supported by
 other platforms and may not be supported in future versions of MS-DOS.
<br><br>The<tt> lseek</tt> function does not, in itself, extend the size of a file (see the description of the <tt> chsize</tt>
 function).
<br><br>The<tt> _lseek</tt> function is identical to<tt> lseek</tt>.&nbsp; Use<tt> _lseek</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _lseeki64</tt> function is identical to<tt> lseek</tt> except that it accepts a 64-bit value for the<b> offset</b>
 argument.
<br><br>The<tt> lseek</tt> function can be used to obtain the current file position (the <tt> tell</tt> function is implemented
 in terms of<tt> lseek</tt>).&nbsp; This value can then be used with the<tt> lseek</tt> function to reset the file position
 to that point in the file:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; off_t file_posn;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; /* get current file position */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; file_posn = lseek( handle, 0L, SEEK_CUR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* or */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; file_posn = tell( handle );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; /* return to previous file position */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; file_posn = lseek( handle, file_posn, SEEK_SET );</tt>
<br><br>If all records in the file are the same size, the position of the n'th record can be calculated and read, as illustrated
 in the example included below.&nbsp; The function in this example assumes records are numbered starting with zero and that<b>
 rec_size</b> contains the size of a record in the file (including the record-separator character).&nbsp; (including the carriage-return
 character in text files).
</dl>
<dl>
<dt>Returns:
<dd>If successful, the current file position is returned in a system-dependent manner.&nbsp; A value of 0 indicates the start
 of the file.
<br>If an error occurs in<tt> lseek</tt>, (-1L) is returned.
<br><br>If an error occurs in<tt> _lseeki64</tt>, (-1I64) is returned.
<br><br>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EBADF
<dd>The<b> handle</b> argument is not a valid file handle.
<dt><br>EINVAL
<dd>The<b> origin</b> argument is not a proper value, or the resulting file offset would be invalid.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#chsize">chsize</a>, <a href="#close">close</a>, <a href="#creat">creat</a>, <a href="#dup">dup</a>, <a href="#dup2">dup2</a>,
 <a href="#eof">eof</a>, <a href="#exec___">exec...</a>, <a href="#fdopen">fdopen</a>, <a href="#filelength">filelength</a>,
 <a href="#fileno">fileno</a>, <a href="#fstat">fstat</a>, <a href="#_grow_handles">_grow_handles</a>, <a href="#isatty">isatty</a>,
 <a href="#open">open</a>, <a href="#read">read</a>, <a href="#setmode">setmode</a>, <a href="#sopen">sopen</a>, <a href="#stat">stat</a>,
 <a href="#tell">tell</a>, <a href="#write">write</a>, <a href="#umask">umask</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>int read_record( int&nbsp; handle,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long rec_numb,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp; rec_size,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( lseek( handle, rec_numb * rec_size, SEEK_SET )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; == -1L ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( -1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( read( handle, buffer, rec_size ) );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp; handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp; size_read;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* open a file for input */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY | O_TEXT );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* read a piece of the text */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_read =</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read_record( handle, 1, 80, buffer );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* test for error */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( size_read == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error reading file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%.80s\n&quot;, buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* close the file */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>lseek is POSIX 1003.1
<br>_lseek is not POSIX
<br>_lseeki64 is not POSIX
<br>_lseek conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> lseek - All, Netware</tt>
<br><tt>_lseek - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_lseeki64 - All</tt>
</dl>
<h2 id="lltoa"> lltoa, _lltoa, _lltow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>char *lltoa( long long int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
<br><tt>char *_lltoa( long long int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
<br><tt>wchar_t *_lltow( long long int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> lltoa</tt> function converts the binary integer<b> value</b> into the equivalent string in base<b> radix</b> notation
 storing the result in the character array pointed to by<b> buffer</b>.&nbsp; A null character is appended to the result.
&nbsp; The size of<b> buffer</b> must be at least 65 bytes when converting values in base 2.&nbsp; The value of<b> radix</b>
 must satisfy the condition:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2 &lt;= radix &lt;= 36</tt>
<br><br>If<b> radix</b> is 10 and<b> value</b> is negative, then a minus sign is prepended to the result.
<br><br>The<tt> _lltoa</tt> function is identical to<tt> lltoa</tt>.&nbsp; Use<tt> _lltoa</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _lltow</tt> function is identical to<tt> lltoa</tt> except that it produces a wide-character string (which
 is twice as long).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> lltoa</tt> function returns a pointer to the result.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#atoll">atoll</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>,
 <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoul">strtoul</a>,
 <a href="#strtoull">strtoull</a>, <a href="#strtoimax">strtoimax</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ultoa">ultoa</a>,
 <a href="#ulltoa">ulltoa</a>, <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void print_value( long value )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int base;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;65&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( base = 2; base &lt;= 16; base = base + 2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2d %s\n&quot;, base,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lltoa( value, buffer, base
 ) );</tt>
<br><tt>}</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_value( 1234098765LL );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt> 2 1001001100011101101101001001101</tt>
<br><tt> 4 1021203231221031</tt>
<br><tt> 6 322243004113</tt>
<br><tt> 8 11143555115</tt>
<br><tt>10 1234098765</tt>
<br><tt>12 2a5369639</tt>
<br><tt>14 b9c8863b</tt>
<br><tt>16 498eda4d</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_lltoa conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> lltoa - All, Netware</tt>
<br><tt>_lltoa - All, Netware</tt>
<br><tt>_lltow - All</tt>
</dl>
<h2 id="ltoa"> ltoa, _ltoa, _ltow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>char *ltoa( long int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
<br><tt>char *_ltoa( long int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
<br><tt>wchar_t *_ltow( long int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ltoa</tt> function converts the binary integer<b> value</b> into the equivalent string in base<b> radix</b> notation
 storing the result in the character array pointed to by<b> buffer</b>.&nbsp; A null character is appended to the result.
&nbsp; The size of<b> buffer</b> must be at least 33 bytes when converting values in base 2.&nbsp; The value of<b> radix</b>
 must satisfy the condition:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2 &lt;= radix &lt;= 36</tt>
<br><br>If<b> radix</b> is 10 and<b> value</b> is negative, then a minus sign is prepended to the result.
<br><br>The<tt> _ltoa</tt> function is identical to<tt> ltoa</tt>.&nbsp; Use<tt> _ltoa</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _ltow</tt> function is identical to<tt> ltoa</tt> except that it produces a wide-character string (which is
 twice as long).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ltoa</tt> function returns a pointer to the result.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#atoll">atoll</a>, <a href="#itoa">itoa</a>, <a href="#lltoa">lltoa</a>,
 <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoul">strtoul</a>,
 <a href="#strtoull">strtoull</a>, <a href="#strtoimax">strtoimax</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ultoa">ultoa</a>,
 <a href="#ulltoa">ulltoa</a>, <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void print_value( long value )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int base;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;33&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( base = 2; base &lt;= 16; base = base + 2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2d %s\n&quot;, base,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ltoa( value, buffer, base
 ) );</tt>
<br><tt>}</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_value( 12765L );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt> 2 11000111011101</tt>
<br><tt> 4 3013131</tt>
<br><tt> 6 135033</tt>
<br><tt> 8 30735</tt>
<br><tt>10 12765</tt>
<br><tt>12 7479</tt>
<br><tt>14 491b</tt>
<br><tt>16 31dd</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_ltoa conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> ltoa - All, Netware</tt>
<br><tt>_ltoa - All, Netware</tt>
<br><tt>_ltow - All</tt>
</dl>
<h2 id="main"> main, wmain, WinMain, wWinMain </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>int main( void );</tt>
<br><tt>int main( int argc, char *argv&#91;&#93; );</tt>
<br><tt>int wmain( void );</tt>
<br><tt>int wmain( int argc, wchar_t *argv&#91;&#93; );</tt>
<br><tt>int PASCAL WinMain( HINSTANCE hInstance,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 HINSTANCE hPrevInstance,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 LPSTR lpszCmdLine,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 int nCmdShow );</tt>
<br><tt>int PASCAL wWinMain( HINSTANCE hInstance,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; HINSTANCE hPrevInstance,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; wcharT *lpszCmdLine,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; int nCmdShow );</tt>
</dl>
<dl>
<dt>Description:
<dd><tt> main</tt> is a user-supplied function where program execution begins.&nbsp; The command line to the program is broken
 into a sequence of tokens separated by blanks and are passed to<tt> main</tt> as an array of pointers to character strings
 in the parameter<b> argv</b>.&nbsp; The number of arguments found is passed in the parameter<b> argc</b>.&nbsp; The first
 element of<b> argv</b> will be a pointer to a character string containing the program name.&nbsp; The last element of the
 array pointed to by<b> argv</b> will be a NULL pointer (i.e.<b>&nbsp; argv&#91;argc&#93;</b> will be<tt> NULL</tt>).&nbsp;
 Arguments that contain blanks can be passed to<tt> main</tt> by enclosing them within double quote characters (which are
 removed from that element in the<b> argv</b> vector.&nbsp; A literal double quote character can be passed by preceding it
 with a backslash.&nbsp; A literal backslash followed by an enclosing double quote character can be passed as a pair of backslash
 characters and a double quote character.
<dl>
<dt>Example:
<dd>
<br><tt>echo &quot;he\&quot;l\lo world\\&quot;</tt>
</dl>
<br>passes the single argument<b> he&quot;l\lo world\</b>
<br>The command line arguments can also be obtained in its original format by using the <tt> getcmd</tt> function.
<br><br>Alternatively, the<tt> main</tt> function can be declared to return <tt> void</tt> (i.e., no return value).&nbsp;
 In this case, you will not be able to return an exit code from<tt> main</tt> using a <tt> return</tt> statement but must
 use the <tt> exit</tt> function to do so.
<br><br>The<tt> wmain</tt> function is a user-defined wide-character version of<tt> main</tt> that operates with wide-character
 strings.&nbsp; If this function is present in the application, then it will be called by the run-time system startup code
 (and the<tt> main</tt> function, if present, will not be called).
<br><br>As with<tt> main</tt>, the<tt> wmain</tt> function can be declared to return <tt> void</tt> and the same considerations
 will apply.
<br><br>The <tt> WinMain</tt> function is called by the system as the initial entry point for a Windows-based application.
&nbsp; The <tt> wWinMain</tt> function is a wide-character version of <tt> WinMain</tt>.
<dl>
<dt>Parameters&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>hInstance
<dd>Identifies the current instance of the application.
<dt><br>hPrevInstance
<dd>Identifies the previous instance of the application.&nbsp; For an application written for Win32, this parameter is always
 NULL.
<dt><br>lpszCmdLine
<dd>Points to a null-terminated string specifying the command line for the application.
<dt><br>nCmdShow
<dd>Specifies how the window is to be shown.&nbsp; This parameter can be one of the following values:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>SW_HIDE
<dd>Hides the window and activates another window.
<dt><br>SW_MINIMIZE
<dd>Minimizes the specified window and activates the top-level window in the system's list.
<dt><br>SW_RESTORE
<dd>Activates and displays a window.&nbsp; If the window is minimized or maximized, Windows restores it to its original size and
 position (same as <tt> SW_SHOWNORMAL</tt>).
<dt><br>SW_SHOW
<dd>Activates a window and displays it in its current size and position.
<dt><br>SW_SHOWMAXIMIZED
<dd>Activates a window and displays it as a maximized window.
<dt><br>SW_SHOWMINIMIZED
<dd>Activates a window and displays it as an icon.
<dt><br>SW_SHOWMINNOACTIVE
<dd>Displays a window as an icon.&nbsp; The active window remains active.
<dt><br>SW_SHOWNA
<dd>Displays a window in its current state.&nbsp; The active window remains active.
<dt><br>SW_SHOWNOACTIVATE
<dd>Displays a window in its most recent size and position.&nbsp; The active window remains active.
<dt><br>SW_SHOWNORMAL
<dd>Activates and displays a window.&nbsp; If the window is minimized or maximized, Windows restores it to its original size and
 position (same as <tt> SW_RESTORE</tt>).
</dl>
</dl>
<br>The <tt> WinMain</tt> function initializes an application, and then performs a message retrieval-and-dispatch loop that
 is the top-level control structure for the remainder of the application's execution.&nbsp; The loop terminates when a <tt>
 WM_QUIT</tt> message is received.&nbsp; At that point, <tt> WinMain</tt> exits the application, returning the value passed
 in the <tt> WM_QUIT</tt> message's <tt> wParam</tt> parameter.&nbsp; If <tt> WM_QUIT</tt> was received as a result of calling
 <tt> PostQuitMessage</tt>, the value of <tt> wParam</tt> is the value of the <tt> PostQuitMessage</tt> function's <tt> nExitCode</tt>
 parameter.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> main</tt> and<tt> wmain</tt> functions return an exit code to the calling program (usually the operating system).
<br>If the <tt> WinMain</tt> function terminates before entering the message loop, it should return 0.&nbsp; Otherwise, it
 should terminate when it receives a <tt> WM_QUIT</tt> message and return the exit value contained in that message's <tt>
 wParam</tt> parameter.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abort">abort</a>, <a href="#atexit">atexit</a>, <a href="#_bgetcmd">_bgetcmd</a>, <a href="#exec___">exec...</a>,
 <a href="#exit">exit</a>, <a href="#_Exit">_Exit</a>, <a href="#_exit">_exit</a>, <a href="#getcmd">getcmd</a>, <a href="#getenv">getenv</a>,
 <a href="#onexit">onexit</a>, <a href="#putenv">putenv</a>, <a href="#spawn___">spawn...</a>, <a href="#system">system</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>int main( int argc, char *argv&#91;&#93; )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; argc; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;argv&#91;%d&#93; = %s\n&quot;, i, argv&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>}</tt>
<br><tt>#ifdef _WIDE_</tt>
<br><tt>int wmain( int wargc, wchar_t *wargv&#91;&#93; )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; wargc; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wprintf( L&quot;wargv&#91;%d&#93; = %s\n&quot;, i, wargv&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>}</tt>
<br><tt>#endif</tt>
<br><br>produces the following:
<br><br><tt>argv&#91;0&#93; = C:\WATCOM\DEMO\MYPGM.EXE</tt>
<br><tt>argv&#91;1&#93; = hhhhh</tt>
<br><tt>argv&#91;2&#93; = another arg</tt>
<br><br>when the program<tt> mypgm</tt> is executed with the command
<br><br><tt>mypgm hhhhh&nbsp; &quot;another arg&quot;</tt>
<br><br>A sample Windows main program is shown below.
<br><br><tt>int PASCAL WinMain( HANDLE this_inst, HANDLE prev_inst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 LPSTR cmdline, int cmdshow )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; MSG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( !prev_inst ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !FirstInstance( this_inst ) ) return( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( !AnyInstance( this_inst, cmdshow ) ) return( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /*</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GetMessage returns FALSE when WM_QUIT is received</tt>
<br><tt>&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( GetMessage( &amp;msg, NULL, NULL, NULL ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TranslateMessage( &amp;msg );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DispatchMessage( &amp;msg );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( msg.wParam );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>main is ANSI
<br>wmain is not ANSI
<br>WinMain is not ANSI
<br>wWinMain is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> main - All, Netware</tt>
<br><tt>wmain - Win32, OS/2-32</tt>
<br><tt>WinMain - Windows, Win386, Win32</tt>
<br><tt>wWinMain - Win32</tt>
</dl>
<h2 id="_makepath"> _makepath, _wmakepath </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void _makepath( char *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *drive,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *dir,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *fname,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *ext );</tt>
<br><tt>void _wmakepath( wchar_t *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
 *drive,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
 *dir,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
 *fname,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
 *ext );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _makepath</tt> function constructs a full pathname from the components consisting of a drive letter, directory path,
 file name and file name extension.&nbsp; The full pathname is placed in the buffer pointed to by the argument<b> path</b>.
<br>The<tt> _wmakepath</tt> function is a wide-character version of<tt> _makepath</tt> that operates with wide-character strings.
<br><br>The maximum size required for each buffer is specified by the manifest constants <tt> _MAX_PATH</tt>, <tt> _MAX_DRIVE</tt>,
 <tt> _MAX_DIR</tt>, <tt> _MAX_FNAME</tt>, and <tt> _MAX_EXT</tt> which are defined in<tt> &lt;stdlib.h&gt;.</tt>
<dl>
<dt>drive
<dd>The<b> drive</b> argument points to a buffer containing the drive letter (A, B, C, etc.) followed by an optional colon.&nbsp;
 The<tt> _makepath</tt> function will automatically insert a colon in the full pathname if it is missing.&nbsp; If<b> drive</b>
 is a NULL pointer or points to an empty string, no drive letter or colon will be placed in the full pathname.
<dt><br>dir
<dd>The<b> dir</b> argument points to a buffer containing just the pathname.&nbsp; Either forward slashes (/) or backslashes (\)
 may be used.&nbsp; The trailing slash is optional.&nbsp; The<tt> _makepath</tt> function will automatically insert a trailing
 slash in the full pathname if it is missing.&nbsp; If<b> dir</b> is a NULL pointer or points to an empty string, no slash
 will be placed in the full pathname.
<dt><br>fname
<dd>The<b> fname</b> argument points to a buffer containing the base name of the file without any extension (suffix).
<dt><br>ext
<dd>The<b> ext</b> argument points to a buffer containing the filename extension or suffix.&nbsp; A leading period (.) is optional.
&nbsp; The<tt> _makepath</tt> routine will automatically insert a period in the full pathname if it is missing.&nbsp; If<b>
 ext</b> is a NULL pointer or points to an empty string, no period will be placed in the full pathname.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _makepath</tt> function returns no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_fullpath">_fullpath</a>, <a href="#_splitpath">_splitpath</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char full_path&#91; _MAX_PATH &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char drive&#91; _MAX_DRIVE &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char dir&#91; _MAX_DIR &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char fname&#91; _MAX_FNAME &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char ext&#91; _MAX_EXT &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _makepath(full_path,&quot;c&quot;,&quot;watcomc\\h\\&quot;,&quot;stdio&quot;,&quot;h&quot;);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Full path is: %s\n\n&quot;, full_path );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _splitpath( full_path, drive, dir, fname, ext );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Components after _splitpath\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;drive: %s\n&quot;, drive );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;dir:&nbsp;&nbsp; %s\n&quot;, dir );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;fname: %s\n&quot;, fname );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;ext:&nbsp;&nbsp; %s\n&quot;, ext );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Full path is: c:watcomc\h\stdio.h</tt>
<br><br><tt>Components after _splitpath</tt>
<br><tt>drive: c:</tt>
<br><tt>dir:&nbsp;&nbsp; watcomc\h\</tt>
<br><tt>fname: stdio</tt>
<br><tt>ext:&nbsp;&nbsp; .h</tt>
<br><br>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _makepath - All, Netware</tt>
<br><tt>_wmakepath - All</tt>
</dl>
<h2 id="malloc"> malloc Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;&nbsp; For ANSI compatibility (malloc only)</tt>
<br><tt>#include &lt;malloc.h&gt;&nbsp; Required for other function prototypes</tt>
<br><tt>void *malloc( size_t size );</tt>
<br><tt>void __based(void) *_bmalloc( __segment seg, size_t size );</tt>
<br><tt>void __far&nbsp; *_fmalloc( size_t size );</tt>
<br><tt>void __near *_nmalloc( size_t size );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> malloc</tt> functions allocate space for an object of<b> size</b> bytes.&nbsp; Nothing is allocated when the<b> size</b>
 argument has a value of zero.
<br>Each function allocates memory from a particular heap, as listed below:
<dl>
<dt>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap
<dt>malloc
<dd>Depends on data model of the program
<dt><br>_bmalloc
<dd>Based heap specified by<b> seg</b> value
<dt><br>_fmalloc
<dd>Far heap (outside the default data segment)
<dt><br>_nmalloc
<dd>Near heap (inside the default data segment)
</dl>
<br>In a small data memory model, the<tt> malloc</tt> function is equivalent to the <tt> _nmalloc</tt> function; in a large
 data memory model, the<tt> malloc</tt> function is equivalent to the <tt> _fmalloc</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> malloc</tt> functions return a pointer to the start of the allocated memory.&nbsp; The<tt> malloc</tt>, <tt> _fmalloc</tt>
 and <tt> _nmalloc</tt> functions return<tt> NULL</tt> if there is insufficient memory available or if the requested size
 is zero.&nbsp; The <tt> _bmalloc</tt> function returns <tt> _NULLOFF</tt> if there is insufficient memory available or if
 the requested size is zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#calloc">calloc</a> Functions, <a href="#_expand">_expand</a> Functions, <a href="#free">free</a> Functions, <a href="#halloc">halloc</a>,
 <a href="#hfree">hfree</a>, <a href="#_msize">_msize</a> Functions, <a href="#realloc">realloc</a> Functions, <a href="#sbrk">sbrk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *buffer;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; buffer = (char *)malloc( 80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( buffer != NULL ) {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* body of program */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>malloc is ANSI
<br>_fmalloc is not ANSI
<br>_bmalloc is not ANSI
<br>_nmalloc is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> malloc - All, Netware</tt>
<br><tt>_bmalloc - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_fmalloc - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_nmalloc - DOS, Windows, Win386, Win32, QNX, OS/2 1.x, OS/2 1.x(MT), OS/2-32</tt>
</dl>
<h2 id="matherr"> matherr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>int matherr( struct _exception *err_info );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> matherr</tt> function is invoked each time an error is detected by functions in the math library.&nbsp; The default<tt>
 matherr</tt> function supplied in the library returns zero which causes an error message to be displayed upon <tt> stderr</tt>
 and <tt> errno</tt> to be set with an appropriate error value.&nbsp; An alternative version of this function can be provided,
 instead of the library version, in order that the error handling for mathematical errors can be handled by an application.
<br>A program may contain a user-written version of<tt> matherr</tt> to take any appropriate action when an error is detected.
&nbsp; When zero is returned, an error message will be printed upon <tt> stderr</tt> and <tt> errno</tt> will be set as was
 the case with the default function.&nbsp; When a non-zero value is returned, no message is printed and <tt> errno</tt> is
 not changed.&nbsp; The value<tt> err_info-&gt;retval</tt> is used as the return value for the function in which the error
 was detected.
<br><br>The<tt> matherr</tt> function is passed a pointer to a structure of type<tt> struct _exception</tt> which contains
 information about the error that has been detected:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct _exception</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; { int type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* TYPE OF ERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *name;&nbsp;&nbsp;&nbsp; /* NAME OF FUNCTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double arg1;&nbsp;&nbsp; /* FIRST ARGUMENT TO FUNCTION&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double arg2;&nbsp;&nbsp; /* SECOND ARGUMENT TO FUNCTION&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double retval; /* DEFAULT RETURN VALUE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br>The<tt> type</tt> field will contain one of the following values:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>DOMAIN
<dd>A domain error has occurred, such as<tt> sqrt(-1e0).</tt>
<dt><br>SING
<dd>A singularity will result, such as<tt> pow(0e0,-2).</tt>
<dt><br>OVERFLOW
<dd>An overflow will result, such as<tt> pow(10e0,100).</tt>
<dt><br>UNDERFLOW
<dd>An underflow will result, such as<tt> pow(10e0,-100).</tt>
<dt><br>TLOSS
<dd>Total loss of significance will result, such as<tt> exp(1000).</tt>
<dt><br>PLOSS
<dd>Partial loss of significance will result, such as<tt> sin(10e70).</tt>
</dl>
<br>The<tt> name</tt> field points to a string containing the name of the function which detected the error.&nbsp; The fields<tt>
 arg1</tt> and<tt> arg2</tt> (if required) give the values which caused the error.&nbsp; The field<tt> retval</tt> contains
 the value which will be returned by the function.&nbsp; This value may be changed by a user-supplied version of the<tt> matherr</tt>
 function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> matherr</tt> function returns zero when an error message is to be printed and a non-zero value otherwise.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>/* Demonstrate error routine in which negative */</tt>
<br><tt>/* arguments to &quot;sqrt&quot; are treated as positive */</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%e\n&quot;, sqrt( -5e0 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; exit( 0 );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>int matherr( struct _exception *err )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( strcmp( err-&gt;name, &quot;sqrt&quot; ) == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( err-&gt;type == DOMAIN ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err-&gt;retval = sqrt( -(err-&gt;arg1) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="max"> max </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#define max(a,b)&nbsp; (((a) &gt; (b)) ? (a) : (b))</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> max</tt> macro will evaluate to be the greater of two values.&nbsp; It is implemented as follows.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; #define max(a,b)&nbsp; (((a) &gt; (b)) ? (a) : (b))</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> max</tt> macro will evaluate to the larger of the two values passed.
</dl>
<dl>
<dt>See Also:
<dd><a href="#min">min</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int a;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /*</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; * The following line will set the variable &quot;a&quot; to 10</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; * since 10 is greater than 1.</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = max( 1, 10 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The value is: %d\n&quot;, a );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_mbbtombc"> _mbbtombc </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned int _mbbtombc( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbbtombc</tt> function returns the double-byte character equivalent to the single-byte character<b> ch</b>.&nbsp;
 The single-byte character must be in the range 0x20 through 0x7E or 0xA1 through 0xDF.
<br><b>Note:</b>&nbsp; This function was called <tt> hantozen</tt> in earlier versions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbbtombc</tt> function returns<b> ch</b> if there is no equivalent double-byte character; otherwise<tt> _mbbtombc</tt>
 returns a double-byte character.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbctombb">_mbctombb</a>,
 <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>, <a href="#_ismbbkalnum">_ismbbkalnum</a>,
 <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>, <a href="#_ismbbkprint">_ismbbkprint</a>,
 <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>, <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>,
 <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>char alphabet&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; sizeof( alphabet ) - 1; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = _mbbtombc( alphabet&#91; i &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c%c&quot;, c&gt;&gt;8, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_mbbtype"> _mbbtype </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt; (for manifest constants)</tt>
<br><tt>int _mbbtype( unsigned char ch, int type );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbbtype</tt> function determines the type of a byte in a multibyte character.&nbsp; If the value of<b> type</b> is
 any value except 1,<tt> _mbbtype</tt> tests for a valid single-byte or lead byte of a multibyte character.&nbsp; If the value
 of<b> type</b> is 1,<tt> _mbbtype</tt> tests for a valid trail byte of a multibyte character.
<br><b>Note:</b>&nbsp; A similar function was called <tt> chkctype</tt> in earlier versions.
</dl>
<dl>
<dt>Returns:
<dd>If the value of<b> type</b> is not 1, the<tt> _mbbtype</tt> function returns one of the following values:
<dl>
<dt>_MBC_SINGLE
<dd>the character is a valid single-byte character (e.g., 0x20 - 0x7E, 0xA1 - 0xDF in code page 932)
<dt><br>_MBC_LEAD
<dd>the character is valid lead byte character (e.g., 0x81 - 0x9F, 0xE0 - 0xFC in code page 932)
<dt><br>_MBC_ILLEGAL
<dd>the character is an illegal character (e.g., any value except 0x20 - 0x7E, 0xA1 - 0xDF, 0x81 - 0x9F, 0xE0 - 0xFC in code page
 932)
</dl>
<br>If the value of<b> type</b> is 1, the<tt> _mbbtype</tt> function returns one of the following values:
<dl>
<dt>_MBC_TRAIL
<dd>the character is a valid trailing byte character (e.g., 0x40 - 0x7E, 0x80 - 0xFC in code page 932)
<dt><br>_MBC_ILLEGAL
<dd>the character is an illegal character (e.g., any character except a valid trailing byte character)
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>,
 <a href="#_ismbcl0">_ismbcl0</a>, <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>,
 <a href="#_ismbclower">_ismbclower</a>, <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>,
 <a href="#_ismbcsymbol">_ismbcsymbol</a>, <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>,
 <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>const char *types&#91;4&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;ILLEGAL&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;SINGLE&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;LEAD&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;TRAIL&quot;</tt>
<br><tt>};</tt>
<br><br><tt>const unsigned char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned char )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; k = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = _mbbtype( chars&#91;i&#93;, k );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, types&#91; 1 + j &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == _MBC_LEAD )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>SINGLE</tt>
<br><tt>SINGLE</tt>
<br><tt>SINGLE</tt>
<br><tt>SINGLE</tt>
<br><tt>LEAD</tt>
<br><tt>TRAIL</tt>
<br><tt>LEAD</tt>
<br><tt>TRAIL</tt>
<br><tt>LEAD</tt>
<br><tt>TRAIL</tt>
<br><tt>LEAD</tt>
<br><tt>TRAIL</tt>
<br><tt>SINGLE</tt>
<br><tt>SINGLE</tt>
<br><tt>SINGLE</tt>
<br><tt>LEAD</tt>
<br><tt>TRAIL</tt>
<br><tt>ILLEGAL</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_mbccmp"> _mbccmp, _fmbccmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbccmp( const unsigned char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2 );</tt>
<br><tt>int _fmbccmp( const unsigned char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbccmp</tt> function compares one multibyte character from<b> s1</b> to one multibyte character from<b> s2</b>.
<br>The<tt> _fmbccmp</tt> function is a data model independent form of the<tt> _mbccmp</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbccmp</tt> and<tt> _fmbccmp</tt> functions return the following values.
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>&lt; 0
<dd>multibyte character at<b> s1</b> less than multibyte character at<b> s2</b>
<dt><br>0
<dd>multibyte character at<b> s1</b> identical to multibyte character at<b> s2</b>
<dt><br>&gt; 0
<dd>multibyte character at<b> s1</b> greater than multibyte character at<b> s2</b>
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>, <a href="#_mbctolower">_mbctolower</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>, <a href="#mbrlen">mbrlen</a>,
 <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned char mb1&#91;2&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81, 0x43</tt>
<br><tt>};</tt>
<br><br><tt>unsigned char mb2&#91;2&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81, 0x42</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; i = _mbccmp( mb1, mb2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( i &lt; 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else if( i == 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Equal to\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Greater than\n&quot; );</tt>
<br><br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Greater than</tt>
</dl>
<dl>
<dt>Classification:
<dd>_mbccmp is ANSI
<br>_mbccmp is not ANSI
<br>_fmbccmp is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbccmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbccmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbccpy"> _mbccpy, _fmbccpy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>void _mbccpy( unsigned char *dest,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *ch );</tt>
<br><tt>void _fmbccpy( unsigned char __far *dest,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *ch
 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbccpy</tt> function copies one multibyte character from<b> ch</b> to<b> dest</b>.
<br>The<tt> _fmbccpy</tt> function is a data model independent form of the<tt> _mbccpy</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbccpy</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>, <a href="#_mbctolower">_mbctolower</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>, <a href="#mbrlen">mbrlen</a>,
 <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned char mb1&#91;2&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00, 0x00</tt>
<br><tt>};</tt>
<br><br><tt>unsigned char mb2&#91;4&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81, 0x42, 0x81, 0x41</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, mb1&#91;0&#93; &lt;&lt; 8 | mb1&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _mbccpy( mb1, mb2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, mb1&#91;0&#93; &lt;&lt; 8 | mb1&#91;1&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>&nbsp; 0000</tt>
<br><tt>0x8142</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbccpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbccpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbcicmp"> _mbcicmp, _fmbcicmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbcicmp( const unsigned char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2 );</tt>
<br><tt>int _fmbcicmp( const unsigned char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s2
 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbcicmp</tt> function compares one multibyte character from<b> s1</b> to one multibyte character from<b> s2</b> using
 a case-insensitive comparison.
<br>The<tt> _fmbcicmp</tt> function is a data model independent form of the<tt> _mbcicmp</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbcicmp</tt> and<tt> _fmbcicmp</tt> functions return the following values.
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>&lt; 0
<dd>multibyte character at<b> s1</b> less than multibyte character at<b> s2</b>
<dt><br>0
<dd>multibyte character at<b> s1</b> identical to multibyte character at<b> s2</b>
<dt><br>&gt; 0
<dd>multibyte character at<b> s1</b> greater than multibyte character at<b> s2</b>
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>, <a href="#_mbctolower">_mbctolower</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>, <a href="#mbrlen">mbrlen</a>,
 <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned char mb1&#91;2&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x41, 0x42</tt>
<br><tt>};</tt>
<br><br><tt>unsigned char mb2&#91;2&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x61, 0x43</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; i = _mbcicmp( mb1, mb2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( i &lt; 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else if( i == 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Equal to\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Greater than\n&quot; );</tt>
<br><br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Equal to</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbcicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbcicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbcjistojms"> _mbcjistojms </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned int _mbcjistojms( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbcjistojms</tt> converts a JIS character set code to a shift-JIS character set code.&nbsp; If the argument is out
 of range,<tt> _mbcjistojms</tt> returns 0.&nbsp; Valid JIS double-byte characters are those in which the first and second
 byte fall in the range 0x21 through 0x7E.&nbsp; This is summarized in the following diagram.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#91; 1st byte &#93;&nbsp;&nbsp;&nbsp; &#91; 2nd byte &#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x21-0x7E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x21-0x7E</tt>
<br><br><b>Note:</b>&nbsp; The JIS character set code is a double-byte character set defined by JIS, the Japan Industrial
 Standard Institutes.&nbsp; Shift-JIS is another double-byte character set.&nbsp; It is defined by Microsoft for personal
 computers and is based on the JIS code.&nbsp; The first byte and the second byte of JIS codes can have values less than 0x80.
&nbsp; Microsoft has designed shift-JIS code so that it can be mixed in strings with single-byte alphanumeric codes.&nbsp;
 Thus the double-byte shift-JIS codes are greater than or equal to 0x8140.
<br><br><b>Note:</b>&nbsp; This function was called <tt> jistojms</tt> in earlier versions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbcjistojms</tt> function returns zero if the argument is not in the range otherwise, the corresponding shift-JIS
 code is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbctombb">_mbctombb</a>,
 <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>, <a href="#_ismbbkalnum">_ismbbkalnum</a>,
 <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>, <a href="#_ismbbkprint">_ismbbkprint</a>,
 <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>, <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>,
 <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbctombb">_mbctombb</a>,
 <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; c = _mbcjistojms( 0x2152 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, c );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x8171</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="_mbcjmstojis"> _mbcjmstojis </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned int _mbcjmstojis( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbcjmstojis</tt> converts a shift-JIS character set code to a JIS character set code.&nbsp; If the argument is out
 of range,<tt> _mbcjmstojis</tt> returns 0.&nbsp; Valid shift-JIS double-byte characters are those in which the first byte
 falls in the range 0x81 through 0x9F or 0xE0 through 0xFC and whose second byte falls in the range 0x40 through 0x7E or 0x80
 through 0xFC.&nbsp; This is summarized in the following diagram.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#91; 1st byte &#93;&nbsp;&nbsp;&nbsp; &#91; 2nd byte &#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x81-0x9F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x40-0xFC</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; except 0x7F</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xE0-0xFC</tt>
<br><br><b>Note:</b>&nbsp; The JIS character set code is a double-byte character set defined by JIS, the Japan Industrial
 Standard Institutes.&nbsp; Shift-JIS is another double-byte character set.&nbsp; It is defined by Microsoft for personal
 computers and is based on the JIS code.&nbsp; The first byte and the second byte of JIS codes can have values less than 0x80.
&nbsp; Microsoft has designed shift-JIS code so that it can be mixed in strings with single-byte alphanumeric codes.&nbsp;
 Thus the double-byte shift-JIS codes are greater than or equal to 0x8140.
<br><br><b>Note:</b>&nbsp; This function was called <tt> jmstojis</tt> in earlier versions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbcjmstojis</tt> function returns zero if the argument is not in the range otherwise, the corresponding shift-JIS
 code is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbctombb">_mbctombb</a>,
 <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>, <a href="#_ismbbkalnum">_ismbbkalnum</a>,
 <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>, <a href="#_ismbbkprint">_ismbbkprint</a>,
 <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>, <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>,
 <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbctombb">_mbctombb</a>,
 <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; c = _mbcjmstojis( 0x8171 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, c );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x2152</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="_mbclen"> _mbclen, _fmbclen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>size_t _mbclen( const unsigned char *ch );</tt>
<br><tt>size_t far _fmbclen( const unsigned char __far *ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbclen</tt> function determines the number of bytes comprising the multibyte character pointed to by<b> ch</b>.
<br>The<tt> _fmbclen</tt> function is a data model independent form of the<tt> _mbclen</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>If<b> ch</b> is a NULL pointer, the<tt> _mbclen</tt> function returns zero if multibyte character encodings do not have state-dependent
 encoding, and non-zero otherwise.&nbsp; If<b> ch</b> is not a NULL pointer, the<tt> _mbclen</tt> function returns:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>0
<dd>if<b> ch</b> points to the null character
<dt><br>1
<dd>if<b> ch</b> points to a single-byte character
<dt><br>2
<dd>if<b> ch</b> points to a double-byte character
<dt><br>-1
<dd>if<b> ch</b> does not point to a valid multibyte character
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>, <a href="#_mbctolower">_mbctolower</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>, <a href="#mbrlen">mbrlen</a>,
 <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* null character */</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i, j;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; sizeof(chars); i += j ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = _mbclen( &amp;chars&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character\n&quot;, j );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>1 bytes in character</tt>
<br><tt>1 bytes in character</tt>
<br><tt>1 bytes in character</tt>
<br><tt>1 bytes in character</tt>
<br><tt>2 bytes in character</tt>
<br><tt>2 bytes in character</tt>
<br><tt>2 bytes in character</tt>
<br><tt>2 bytes in character</tt>
<br><tt>1 bytes in character</tt>
<br><tt>1 bytes in character</tt>
<br><tt>1 bytes in character</tt>
<br><tt>2 bytes in character</tt>
<br><tt>1 bytes in character</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbclen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbclen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbctolower"> _mbctolower </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned int _mbctolower( unsigned int c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbctolower</tt> function converts an uppercase multibyte character to an equivalent lowercase multibyte character.
<br>For example, in code page 932, this includes the single-byte uppercase letters A-Z and the double-byte uppercase characters
 such that:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x8260 &lt;= c &lt;= 0x8279</tt>
<br><br><b>Note:</b>&nbsp; This function was called <tt> jtolower</tt> in earlier versions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbctolower</tt> function returns the argument value if the argument is not a double-byte uppercase character; otherwise,
 the equivalent lowercase character is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>, <a href="#mbrlen">mbrlen</a>,
 <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'B',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte B */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'C',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte C */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'D',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte D */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'E',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte E */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8260,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8261,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte B */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8262,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte C */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8263,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte D */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8264&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte E */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = _mbctolower( chars&#91; i &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( c &gt; 0xff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c%c&quot;, c&gt;&gt;8, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c&quot;, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>abcde a b c d e</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_mbctoupper"> _mbctoupper </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned int _mbctoupper( unsigned int c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbctoupper</tt> function converts a lowercase multibyte character to an equivalent uppercase multibyte character.
<br>For example, in code page 932, this includes the single-byte lowercase letters a-z and the double-byte lowercase characters
 such that:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x8281 &lt;= c &lt;= 0x829A</tt>
<br><br><b>Note:</b>&nbsp; This function was called <tt> jtoupper</tt> in earlier versions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbctoupper</tt> function returns the argument value if the argument is not a double-byte lowercase character; otherwise,
 the equivalent uppercase character is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#mblen">mblen</a>, <a href="#mbrlen">mbrlen</a>,
 <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'a',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte a */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'b',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte b */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'c',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte c */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'd',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte d */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'e',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte e */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8281,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte a */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8282,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte b */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8283,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte c */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8284,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte d */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8285&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte e */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = _mbctoupper( chars&#91; i &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( c &gt; 0xff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c%c&quot;, c&gt;&gt;8, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c&quot;, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>ABCDE A B C D E</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_mbctohira"> _mbctohira </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned int _mbctohira( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbctohira</tt> converts a double-byte Katakana character to a Hiragana character.&nbsp; A double-byte Katakana character
 is any character for which the following expression is true:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x8340 &lt;= ch &lt;= 0x8396&nbsp; &amp;&amp;&nbsp; ch != 0x837F</tt>
<br><br>Any Katakana character whose value is less than 0x8393 is converted to Hiragana (there are 3 extra Katakana characters
 that have no equivalent).
<br><br><b>Note:</b>&nbsp; The Japanese double-byte character set includes Kanji, Hiragana, and Katakana characters - both
 alphabetic and numeric.&nbsp; Kanji is the ideogram character set of the Japanese character set.&nbsp; Hiragana and Katakana
 are two types of phonetic character sets of the Japanese character set.&nbsp; The Hiragana code set includes 83 characters
 and the Katakana code set includes 86 characters.
<br><br><b>Note:</b>&nbsp; This function was called <tt> jtohira</tt> in earlier versions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbctohira</tt> function returns the argument value if the argument is not a double-byte Katakana character; otherwise,
 the equivalent Hiragana character is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctokata">_mbctokata</a>, <a href="#_mbctolower">_mbctolower</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>, <a href="#mbrlen">mbrlen</a>,
 <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8340,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8364,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x8396</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x - %#6.4x\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91; i &#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _mbctohira( chars&#91; i &#93; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x8340 - 0x829f</tt>
<br><tt>0x8364 - 0x82c3</tt>
<br><tt>0x8396 - 0x8396</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="_mbctokata"> _mbctokata </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned int _mbctokata( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbctokata</tt> converts a double-byte Hiragana character to a Katakana character.&nbsp; A double-byte Hiragana character
 is any character for which the following expression is true:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x829F &lt;= c &lt;= 0x82F1</tt>
<br><br><b>Note:</b>&nbsp; The Japanese double-byte character set includes Kanji, Hiragana, and Katakana characters - both
 alphabetic and numeric.&nbsp; Kanji is the ideogram character set of the Japanese character set.&nbsp; Hiragana and Katakana
 are two types of phonetic character sets of the Japanese character set.&nbsp; The Hiragana code set includes 83 characters
 and the Katakana code set includes 86 characters.
<br><br><b>Note:</b>&nbsp; This function was called <tt> jtokata</tt> in earlier versions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbctokata</tt> function returns the argument value if the argument is not a double-byte Hiragana character; otherwise,
 the equivalent Katakana character is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctolower">_mbctolower</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>, <a href="#mbrlen">mbrlen</a>,
 <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned int chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x829F,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82B0,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82F1</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x - %#6.4x\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chars&#91; i &#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _mbctokata( chars&#91; i &#93; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x829f - 0x8340</tt>
<br><tt>0x82b0 - 0x8351</tt>
<br><tt>0x82f1 - 0x8393</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="_mbctombb"> _mbctombb </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned int _mbctombb( unsigned int ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbctombb</tt> function returns the single-byte character equivalent to the double-byte character<b> ch</b>.&nbsp;
 The single-byte character will be in the range 0x20 through 0x7E or 0xA1 through 0xDF.
<br><b>Note:</b>&nbsp; This function was called <tt> zentohan</tt> in earlier versions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbctombb</tt> function returns<b> ch</b> if there is no equivalent single-byte character; otherwise<tt> _mbctombb</tt>
 returns a single-byte character.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>, <a href="#_ismbbkalnum">_ismbbkalnum</a>,
 <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>, <a href="#_ismbbkprint">_ismbbkprint</a>,
 <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>, <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>,
 <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>#define ZEN(x) 130*256+(x-1+32)</tt>
<br><br><tt>unsigned int alphabet&#91;26&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ZEN('A'),ZEN('B'),ZEN('C'),ZEN('D'),ZEN('E'),</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ZEN('F'),ZEN('G'),ZEN('H'),ZEN('I'),ZEN('J'),</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ZEN('K'),ZEN('L'),ZEN('M'),ZEN('N'),ZEN('O'),</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ZEN('P'),ZEN('Q'),ZEN('R'),ZEN('S'),ZEN('T'),</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ZEN('U'),ZEN('V'),ZEN('W'),ZEN('X'),ZEN('Y'),</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ZEN('Z')</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( alphabet ) / sizeof( unsigned int )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int&nbsp;&nbsp;&nbsp; c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = _mbctombb( alphabet&#91; i &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c&quot;, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>ABCDEFGHIJKLMNOPQRSTUVWXYZ</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_mbgetcode"> _mbgetcode, _fmbgetcode </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbgetcode( unsigned char *mbstr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int *dbchp );</tt>
<br><tt>unsigned char far *_fmbgetcode( unsigned char far *mbstr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int *dbchp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbgetcode</tt> function places the next single- or double-byte character from the start of the Kanji string specified
 by<b> mbstr</b> in the wide character pointed to by<b> dbchp</b>.&nbsp; If the second-half of a double-byte character is
 NULL, then the returned wide character is NULL.
<br>The<tt> _fmbgetcode</tt> function is a code and data model independent form of the<tt> _mbgetcode</tt> function.&nbsp;
 It accepts far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbgetcode</tt> function returns a pointer to the next character to be obtained from the string.&nbsp; If<b> mbstr</b>
 points at a null character then<b> mbstr</b> is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbsnccnt">_mbsnccnt</a>, <a href="#_mbputchar">_mbputchar</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>unsigned char set&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;ab\x81\x41\x81\x42\cd\x81&quot;</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int c;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned char *str;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; str = set;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( ; *str != '\0'; ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str = _mbgetcode( str, &amp;c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Character code 0x%2.2x\n&quot;, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Character code 0x61</tt>
<br><tt>Character code 0x62</tt>
<br><tt>Character code 0x8141</tt>
<br><tt>Character code 0x8142</tt>
<br><tt>Character code 0x63</tt>
<br><tt>Character code 0x64</tt>
<br><tt>Character code 0x00</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbgetcode - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbgetcode - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="mblen"> mblen, _fmblen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; or</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int mblen( const char *s, size_t n );</tt>
<br><tt>int _fmblen( const char __far *s, size_t n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> mblen</tt> function determines the number of bytes comprising the multibyte character pointed to by<b> s</b>.&nbsp;
 At most<b> n</b> bytes of the array pointed to by<b> s</b> will be examined.
<br>The<tt> _fmblen</tt> function is a data model independent form of the<tt> mblen</tt> function.&nbsp; It accepts far pointer
 arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>If<b> s</b> is a NULL pointer, the<tt> mblen</tt> function returns zero if multibyte character encodings are not state dependent,
 and non-zero otherwise.&nbsp; If<b> s</b> is not a NULL pointer, the<tt> mblen</tt> function returns:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>0
<dd>if<b> s</b> points to the null character
<dt><br>len
<dd>the number of bytes that comprise the multibyte character (if the next<b> n</b> or fewer bytes form a valid multibyte character)
<dt><br>-1
<dd>if the next<b> n</b> bytes do not form a valid multibyte character
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mbrlen">mbrlen</a>,
 <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>const char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Character encodings are %sstate dependent\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( mblen( NULL, MB_CUR_MAX ) ) ? &quot;&quot; :
 &quot;not &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; j = 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; j &gt; 0; i += j ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mblen( &amp;chars&#91;i&#93;, MB_CUR_MAX );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character &quot;, j );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars&#91;i&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars&#91;i&#93;&lt;&lt;8 | chars&#91;i+1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;(%#6.4x)\n&quot;, k );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Character encodings are not state dependent</tt>
<br><tt>1 bytes in character (0x0020)</tt>
<br><tt>1 bytes in character (0x002e)</tt>
<br><tt>1 bytes in character (0x0031)</tt>
<br><tt>1 bytes in character (0x0041)</tt>
<br><tt>2 bytes in character (0x8140)</tt>
<br><tt>2 bytes in character (0x8260)</tt>
<br><tt>2 bytes in character (0x82a6)</tt>
<br><tt>2 bytes in character (0x8342)</tt>
<br><tt>1 bytes in character (0x00a1)</tt>
<br><tt>1 bytes in character (0x00a6)</tt>
<br><tt>1 bytes in character (0x00df)</tt>
<br><tt>2 bytes in character (0xe0a1)</tt>
<br><tt>0 bytes in character (&nbsp; 0000)</tt>
</dl>
<dl>
<dt>Classification:
<dd>mblen is ANSI
<br>_fmblen is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> mblen - All, Netware</tt>
<br><tt>_fmblen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbputchar"> _mbputchar, _fmbputchar </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbputchar( unsigned char *mbstr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int dbch );</tt>
<br><tt>unsigned char far *_fmbputchar( unsigned char far *mbstr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int dbch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbputchar</tt> function places the next single- or double-byte character specified by<b> dbch</b> at the start of
 the buffer specified by<b> mbstr</b>.
<br>The<tt> _fmbputchar</tt> function is a code and data model independent form of the<tt> _mbputchar</tt> function.&nbsp;
 It accepts far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbputchar</tt> function returns a pointer to the next location in which to store a character.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbsnccnt">_mbsnccnt</a>, <a href="#_mbgetcode">_mbgetcode</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int c;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned char *str1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned char *str2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned char buf&#91;30&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; str1 = &quot;ab\x82\x62\x82\x63\ef\x81\x66&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; str2 = buf;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( ; *str1 != '\0'; ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str1 = _mbgetcode( str1, &amp;c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str2 = _mbputchar( str2, '&lt;' );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str2 = _mbputchar( str2, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; str2 = _mbputchar( str2, '&gt;' );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; *str2 = '\0';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buf );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>&lt;a&gt;&lt;b&gt;&lt; C&gt;&lt; D&gt;&lt;e&gt;&lt;f&gt;&lt; G&gt;</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbputchar - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbputchar - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="mbrlen"> mbrlen, _fmbrlen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int mbrlen( const char *s, size_t n, mbstate_t *ps );</tt>
<br><tt>int _fmbrlen( const char far *s, size_t n, mbstate_t far *ps );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> mbrlen</tt> function determines the number of bytes comprising the multibyte character pointed to by<b> s</b>.&nbsp;
 The<tt> mbrlen</tt> function is equivalent to the following call:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; mbrtowc((wchar_t *)0, s, n, ps != 0 ? ps : &amp;internal)</tt>
<br><br>where<tt> &amp;internal</tt> is the address of the internal <tt> mbstate_t</tt> object for the<tt> mbrlen</tt> function.
<br><br>The<tt> _fmbrlen</tt> function is a data model independent form of the<tt> mbrlen</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The restartable multibyte/wide character conversion functions differ from the corresponding internal-state multibyte
 character functions ( <tt> mblen</tt>, <tt> mbtowc</tt>, and <tt> wctomb</tt>) in that they have an extra argument,<b> ps</b>,
 of type pointer to <tt> mbstate_t</tt> that points to an object that can completely describe the current conversion state
 of the associated multibyte character sequence.&nbsp; If<b> ps</b> is a null pointer, each function uses its own internal
 <tt> mbstate_t</tt> object instead.&nbsp; You are guaranteed that no other function in the library calls these functions
 with a null pointer for<b> ps</b>, thereby ensuring the stability of the state.
<br><br>Also unlike their corresponding functions, the return value does not represent whether the encoding is state-dependent.
<br><br>If the encoding is state-dependent, on entry each function takes the described conversion state (either internal or
 pointed to by<b> ps</b>) as current.&nbsp; The conversion state described by the pointed-to object is altered as needed to
 track the shift state of the associated multibyte character sequence.&nbsp; For encodings without state dependency, the pointer
 to the <tt> mbstate_t</tt> argument is ignored.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> mbrlen</tt> function returns a value between -2 and<b> n</b>, inclusive.&nbsp; The<tt> mbrlen</tt> function returns
 the first of the following that applies:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>0
<dd>if the next<b> n</b> or fewer bytes form the multibyte character that corresponds to the null wide character.
<dt><br>&gt;0
<dd>if the next<b> n</b> or fewer bytes form a valid multibyte character; the value returned is the number of bytes that constitute
 that multibyte character.
<dt><br>-2
<dd>if the next<b> n</b> bytes form an incomplete (but potentially valid) multibyte character, and all<b> n</b> bytes have been
 processed; it is unspecified whether this can occur when the value of<b> n</b> is less than that of the <tt> MB_CUR_MAX</tt>
 macro.
<dt><br>-1
<dd>if an encoding error occurs (when the next<b> n</b> or fewer bytes do not form a complete and valid multibyte character);
 the value of the macro <tt> EILSEQ</tt> will be stored in <tt> errno</tt>, but the conversion state will be unchanged.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>,
 <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;errno.h&gt;</tt>
<br><br><tt>const char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; j = 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; j &gt; 0; i += j ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mbrlen( &amp;chars&#91;i&#93;, MB_CUR_MAX, NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character &quot;, j );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( errno == EILSEQ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; - illegal multibyte character\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars&#91;i&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars&#91;i&#93;&lt;&lt;8 | chars&#91;i+1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;(%#6.4x)\n&quot;, k );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>1 bytes in character (0x0020)</tt>
<br><tt>1 bytes in character (0x002e)</tt>
<br><tt>1 bytes in character (0x0031)</tt>
<br><tt>1 bytes in character (0x0041)</tt>
<br><tt>2 bytes in character (0x8140)</tt>
<br><tt>2 bytes in character (0x8260)</tt>
<br><tt>2 bytes in character (0x82a6)</tt>
<br><tt>2 bytes in character (0x8342)</tt>
<br><tt>1 bytes in character (0x00a1)</tt>
<br><tt>1 bytes in character (0x00a6)</tt>
<br><tt>1 bytes in character (0x00df)</tt>
<br><tt>2 bytes in character (0xe0a1)</tt>
<br><tt>0 bytes in character (&nbsp; 0000)</tt>
</dl>
<dl>
<dt>Classification:
<dd>mbrlen is ANSI
<br>_fmbrlen is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> mbrlen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbrlen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="mbrtowc"> mbrtowc, _fmbrtowc </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int mbrtowc( wchar_t *pwc, const char *s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n, mbstate_t *ps );</tt>
<br><tt>int _fmbrtowc( wchar_t __far *pwc, const char __far *s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n, mbstate_t __far *ps
 );</tt>
</dl>
<dl>
<dt>Description:
<dd>If<b> s</b> is a null pointer, the<tt> mbrtowc</tt> function determines the number of bytes necessary to enter the initial
 shift state (zero if encodings are not state-dependent or if the initial conversion state is described).&nbsp; In this case,
 the value of the<b> pwc</b> argument will be ignored, and the resulting state described will be the initial conversion state.
<br>If<b> s</b> is not a null pointer, the<tt> mbrtowc</tt> function determines the number of bytes that are contained in
 the multibyte character (plus any leading shift sequences) pointed to by<b> s</b>, produces the value of the corresponding
 wide character and then, if<b> pwc</b> is not a null pointer, stores that value in the object pointed to by<b> pwc</b>.&nbsp;
 If the corresponding wide character is the null wide character, the resulting state described will be the initial conversion
 state.
<br><br>The<tt> _fmbrtowc</tt> function is a data model independent form of the<tt> mbrtowc</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The restartable multibyte/wide character conversion functions differ from the corresponding internal-state multibyte
 character functions ( <tt> mblen</tt>, <tt> mbtowc</tt>, and <tt> wctomb</tt>) in that they have an extra argument,<b> ps</b>,
 of type pointer to <tt> mbstate_t</tt> that points to an object that can completely describe the current conversion state
 of the associated multibyte character sequence.&nbsp; If<b> ps</b> is a null pointer, each function uses its own internal
 <tt> mbstate_t</tt> object instead.&nbsp; You are guaranteed that no other function in the library calls these functions
 with a null pointer for<b> ps</b>, thereby ensuring the stability of the state.
<br><br>Also unlike their corresponding functions, the return value does not represent whether the encoding is state-dependent.
<br><br>If the encoding is state-dependent, on entry each function takes the described conversion state (either internal or
 pointed to by<b> ps</b>) as current.&nbsp; The conversion state described by the pointed-to object is altered as needed to
 track the shift state of the associated multibyte character sequence.&nbsp; For encodings without state dependency, the pointer
 to the <tt> mbstate_t</tt> argument is ignored.
</dl>
<dl>
<dt>Returns:
<dd>If<b> s</b> is a null pointer, the<tt> mbrtowc</tt> function returns the number of bytes necessary to enter the initial shift
 state.&nbsp; The value returned will not be greater than that of the <tt> MB_CUR_MAX</tt> macro.
<br>If<b> s</b> is not a null pointer, the<tt> mbrtowc</tt> function returns the first of the following that applies:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>0
<dd>if the next<b> n</b> or fewer bytes form the multibyte character that corresponds to the null wide character.
<dt><br>&gt;0
<dd>if the next<b> n</b> or fewer bytes form a valid multibyte character; the value returned is the number of bytes that constitute
 that multibyte character.
<dt><br>-2
<dd>if the next<b> n</b> bytes form an incomplete (but potentially valid) multibyte character, and all<b> n</b> bytes have been
 processed; it is unspecified whether this can occur when the value of<b> n</b> is less than that of the <tt> MB_CUR_MAX</tt>
 macro.
<dt><br>-1
<dd>if an encoding error occurs (when the next<b> n</b> or fewer bytes do not form a complete and valid multibyte character);
 the value of the macro <tt> EILSEQ</tt> will be stored in <tt> errno</tt>, but the conversion state will be unchanged.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>,
 <a href="#mbrlen">mbrlen</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;errno.h&gt;</tt>
<br><br><tt>const char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp;&nbsp;&nbsp; pwc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; i = mbrtowc( NULL, NULL, MB_CUR_MAX, NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Number of bytes to enter &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;initial shift state = %d\n&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; j = 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; j &gt; 0; i += j ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mbrtowc( &amp;pwc, &amp;chars&#91;i&#93;, MB_CUR_MAX, NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character &quot;, j );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( errno == EILSEQ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; - illegal multibyte character\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars&#91;i&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars&#91;i&#93;&lt;&lt;8 | chars&#91;i+1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;(%#6.4x-&gt;%#6.4x)\n&quot;, k, pwc );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Number of bytes to enter initial shift state = 0</tt>
<br><tt>1 bytes in character (0x0020-&gt;0x0020)</tt>
<br><tt>1 bytes in character (0x002e-&gt;0x002e)</tt>
<br><tt>1 bytes in character (0x0031-&gt;0x0031)</tt>
<br><tt>1 bytes in character (0x0041-&gt;0x0041)</tt>
<br><tt>2 bytes in character (0x8140-&gt;0x3000)</tt>
<br><tt>2 bytes in character (0x8260-&gt;0xff21)</tt>
<br><tt>2 bytes in character (0x82a6-&gt;0x3048)</tt>
<br><tt>2 bytes in character (0x8342-&gt;0x30a3)</tt>
<br><tt>1 bytes in character (0x00a1-&gt;0xff61)</tt>
<br><tt>1 bytes in character (0x00a6-&gt;0xff66)</tt>
<br><tt>1 bytes in character (0x00df-&gt;0xff9f)</tt>
<br><tt>2 bytes in character (0xe0a1-&gt;0x720d)</tt>
<br><tt>0 bytes in character (&nbsp; 0000-&gt;&nbsp; 0000)</tt>
</dl>
<dl>
<dt>Classification:
<dd>mbrtowc is ANSI
<br>_fmbrtowc is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> mbrtowc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbrtowc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbsbtype"> _mbsbtype, _fmbsbtype </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt; (for manifest constants)</tt>
<br><tt>int _mbsbtype( const unsigned char *mbstr, int count );</tt>
<br><tt>int _fmbsbtype( const unsigned char __far *mbstr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int count );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbsbtype</tt> function determines the type of a byte in a multibyte character string.&nbsp; The function examines
 only the byte at offset<b> count</b> in<b> mbstr</b>, ignoring invalid characters before the specified byte
<br><b>Note:</b>&nbsp; A similar function was called <tt> nthctype</tt> in earlier versions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbsbtype</tt> function returns one of the following values:
<dl>
<dt>_MBC_SINGLE
<dd>the character is a valid single-byte character (e.g., 0x20 - 0x7E, 0xA1 - 0xDF in code page 932)
<dt><br>_MBC_LEAD
<dd>the character is a valid lead byte character (e.g., 0x81 - 0x9F, 0xE0 - 0xFC in code page 932)
<dt><br>_MBC_TRAIL
<dd>the character is a valid trailing byte character (e.g., 0x40 - 0x7E, 0x80 - 0xFC in code page 932)
<dt><br>_MBC_ILLEGAL
<dd>the character is an illegal character (e.g., any value except 0x20 - 0x7E, 0xA1 - 0xDF, 0x81 - 0x9F, 0xE0 - 0xFC in code page
 932)
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_ismbcalnum">_ismbcalnum</a>, <a href="#_ismbcalpha">_ismbcalpha</a>, <a href="#_ismbccntrl">_ismbccntrl</a>,
 <a href="#_ismbcdigit">_ismbcdigit</a>, <a href="#_ismbcgraph">_ismbcgraph</a>, <a href="#_ismbchira">_ismbchira</a>, <a href="#_ismbckata">_ismbckata</a>,
 <a href="#_ismbcl0">_ismbcl0</a>, <a href="#_ismbcl1">_ismbcl1</a>, <a href="#_ismbcl2">_ismbcl2</a>, <a href="#_ismbclegal">_ismbclegal</a>,
 <a href="#_ismbclower">_ismbclower</a>, <a href="#_ismbcprint">_ismbcprint</a>, <a href="#_ismbcpunct">_ismbcpunct</a>, <a href="#_ismbcspace">_ismbcspace</a>,
 <a href="#_ismbcsymbol">_ismbcsymbol</a>, <a href="#_ismbcupper">_ismbcupper</a>, <a href="#_ismbcxdigit">_ismbcxdigit</a>,
 <a href="#_mbbtype">_mbbtype</a>, <a href="#_setmbcp">_setmbcp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>const char *types&#91;4&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;ILLEGAL&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;SINGLE&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;LEAD&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;TRAIL&quot;</tt>
<br><tt>};</tt>
<br><br><tt>const unsigned char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned char )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, types&#91; 1+_mbsbtype( chars, i ) &#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>SINGLE</tt>
<br><tt>SINGLE</tt>
<br><tt>SINGLE</tt>
<br><tt>SINGLE</tt>
<br><tt>LEAD</tt>
<br><tt>TRAIL</tt>
<br><tt>LEAD</tt>
<br><tt>TRAIL</tt>
<br><tt>LEAD</tt>
<br><tt>TRAIL</tt>
<br><tt>LEAD</tt>
<br><tt>TRAIL</tt>
<br><tt>SINGLE</tt>
<br><tt>SINGLE</tt>
<br><tt>SINGLE</tt>
<br><tt>LEAD</tt>
<br><tt>TRAIL</tt>
<br><tt>ILLEGAL</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbsbtype - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsbtype - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbsnbcat"> _mbsnbcat, _fmbsnbcat </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsnbcat( unsigned char *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const unsigned char *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>unsigned char __far *_fmbsnbcat( unsigned char __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbsnbcat</tt> function appends not more than<b> n</b> bytes of the string pointed to by<b> src</b> to the end of
 the string pointed to by<b> dst</b>.&nbsp; If the byte immediately preceding the null character in<b> dst</b> is a lead byte,
 the initial byte of<b> src</b> overwrites this lead byte.&nbsp; Otherwise, the initial byte of<b> src</b> overwrites the
 terminating null character at the end of<b> dst</b>.&nbsp; If the last byte to be copied from<b> src</b> is a lead byte,
 the lead byte is not copied and a null character replaces it in<b> dst</b>.&nbsp; In any case, a terminating null character
 is always appended to the result.
<br>The<tt> _fmbsnbcat</tt> function is a data model independent form of the<tt> _mbsnbcat</tt> function.&nbsp; It accepts
 far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbsnbcat</tt> function returns the value of<b> dst</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbsnbcmp">_mbsnbcmp</a>, <a href="#_mbsnbcpy">_mbsnbcpy</a>, <a href="#_mbsnbset">_mbsnbset</a>, <a href="#_mbsnccnt">_mbsnccnt</a>,
 <a href="#strncat">strncat</a>, <a href="#strcat">strcat</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>const unsigned char str1&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>const unsigned char str2&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; big_string&#91;10&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; memset( (char *) big_string, 0xee, 10 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; big_string&#91;9&#93; = 0x00;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Length of string = %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strlen( (char *) big_string ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _mbsnset( big_string, 0x8145, 5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; big_string&#91;0&#93; = 0x00;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _mbsnbcat( big_string, str1, 3 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; big_string&#91;2&#93; = 0x84;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; big_string&#91;3&#93; = 0x00;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _mbsnbcat( big_string, str2, 5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Length of string = 9</tt>
<br><tt>ee ee ee ee ee ee ee ee ee 00</tt>
<br><tt>81 45 81 45 81 45 81 45 20 00</tt>
<br><tt>81 40 00 00 81 45 81 45 20 00</tt>
<br><tt>81 40 84 00 81 45 81 45 20 00</tt>
<br><tt>81 40 81 40 82 a6 00 00 20 00</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbsnbcat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsnbcat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbsnbcmp"> _mbsnbcmp, _fmbsnbcmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbsnbcmp( const unsigned char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>int _fmbsnbcmp( const unsigned char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far
 *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbsnbcmp</tt> lexicographically compares not more than<b> n</b> bytes from the string pointed to by<b> s1</b> to
 the string pointed to by<b> s2</b>.
<br>The<tt> _fmbsnbcmp</tt> function is a data model independent form of the<tt> _mbsnbcmp</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbsnbcmp</tt> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
 to by<b> s1</b> is less than, equal to, or greater than the string pointed to by<b> s2</b>.<tt>&nbsp; _mbsnbcmp</tt> is similar
 to <tt> _mbsncmp</tt>, except that<tt> _mbsnbcmp</tt> compares strings by bytes rather than by characters.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbsnbcat">_mbsnbcat</a>, <a href="#_mbsnbicmp">_mbsnbicmp</a>, <a href="#strncmp">strncmp</a>, <a href="#strnicmp">strnicmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>const unsigned char str1&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>const unsigned char str2&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, _mbsnbcmp( str1, str2, 3 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbsnbcmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsnbcmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbsnbcnt"> _mbsnbcnt, _fmbsnbcnt, _strncnt, _wcsncnt </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>size_t _mbsnbcnt( const unsigned char *string, size_t n );</tt>
<br><tt>size_t _fmbsnbcnt( const unsigned char __far *string,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t
 n );</tt>
<br><tt>#include &lt;tchar.h&gt;</tt>
<br><tt>size_t _strncnt( const char *string, size_t n );</tt>
<br><tt>size_t _wcsncnt( const wchar_t *string, size_t n ) {</tt>
</dl>
<dl>
<dt>Description:
<dd>The function counts the number of bytes in the first<b> n</b> multibyte characters of the string<b> string</b>.
<br><b>Note:</b>&nbsp; This function was called <tt> mtob</tt> in earlier versions.
<br><br>The function is a data model independent form of the<tt> _strncnt</tt> function that accepts far pointer arguments.
&nbsp; It is most useful in mixed memory model applications.
<br><br>The header file<tt> &lt;tchar.h&gt;</tt> defines the generic-text routine <tt> _tcsnbcnt</tt>.&nbsp; This macro maps
 to if <tt> _MBCS</tt> has been defined, or to the<tt> _wcsncnt</tt> macro if <tt> _UNICODE</tt> has been defined.&nbsp; Otherwise
 <tt> _tcsnbcnt</tt> maps to<tt> _strncnt</tt>.<tt>&nbsp; _strncnt</tt> and<tt> _wcsncnt</tt> are single-byte character string
 and wide-character string versions of .&nbsp; The<tt> _strncnt</tt> and<tt> _wcsncnt</tt> macros are provided only for this
 mapping and should not be used otherwise.
<br><br>The<tt> _strncnt</tt> function returns the number of characters (i.e.,<b> n</b>) in the first<b> n</b> bytes of the
 single-byte string<b> string</b>.&nbsp; The<tt> _wcsncnt</tt> function returns the number of bytes (i.e., 2 *<b> n</b>) in
 the first<b> n</b> wide characters of the wide-character string<b> string</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _strncnt</tt> functions return the number of bytes in the string up to the specified number of characters or until
 a null character is encountered.&nbsp; The null character is not included in the count.&nbsp; If the character preceding
 the null character was a lead byte, the lead byte is not included in the count.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbsnbcat">_mbsnbcat</a>, <a href="#_mbsnbcnt">_mbsnbcnt</a>, <a href="#_mbsnccnt">_mbsnccnt</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>const unsigned char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes found\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _mbsnbcnt( chars, 10 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>14 bytes found</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbsnbcnt - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsnbcnt - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_strncnt - MACRO</tt>
<br><tt>_wcsncnt - MACRO</tt>
</dl>
<h2 id="_mbsnbcpy"> _mbsnbcpy, _fmbsnbcpy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsnbcpy( unsigned char *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const unsigned char *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 size_t n );</tt>
<br><tt>unsigned char __far *_fmbsnbcpy( unsigned char __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbsnbcpy</tt> function copies no more than<b> n</b> bytes from the string pointed to by<b> src</b> into the array
 pointed to by<b> dst</b>.&nbsp; Copying of overlapping objects is not guaranteed to work properly.
<br>If the string pointed to by<b> src</b> is shorter than<b> n</b> bytes, null characters are appended to the copy in the
 array pointed to by<b> dst</b>, until<b> n</b> bytes in all have been written.&nbsp; If the string pointed to by<b> src</b>
 is longer than<b> n</b> characters, then the result will not be terminated by a null character.
<br><br>The<tt> _fmbsnbcpy</tt> function is a data model independent form of the<tt> _mbsnbcpy</tt> function.&nbsp; It accepts
 far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbsnbcpy</tt> function returns the value of<b> dst</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcpy">strcpy</a>, <a href="#strdup">strdup</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>const unsigned char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; chars2&#91;20&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _mbsnset( chars2, 0xFF, 20 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _mbsnbcpy( chars2, chars, 11 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 20; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, chars2&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _mbsnbcpy( chars2, chars, 20 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 20; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, chars2&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>20 2e 31 41 81 40 82 60 82 a6 83 ff ff ff ff ff ff ff ff ff</tt>
<br><tt>20 2e 31 41 81 40 82 60 82 a6 83 42 a1 a6 df e0 a1 00 00 00</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbsnbcpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsnbcpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbsnbicmp"> _mbsnbicmp, _fmbsnbicmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbsnbicmp( const unsigned char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>int _fmbsnbicmp( const unsigned char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far
 *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbsnbicmp</tt> lexicographically compares not more than<b> n</b> bytes from the string pointed to by<b> s1</b> to
 the string pointed to by<b> s2</b>.&nbsp; The comparison is insensitive to case.
<br>The<tt> _fmbsnbicmp</tt> function is a data model independent form of the<tt> _mbsnbicmp</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbsnbicmp</tt> function returns an integer less than, equal to, or greater than zero, indicating that the string
 pointed to by<b> s1</b> is less than, equal to, or greater than the string pointed to by<b> s2</b>.<tt>&nbsp; _mbsnbicmp</tt>
 is similar to <tt> _mbsncmp</tt>, except that<tt> _mbsnbicmp</tt> compares strings by bytes rather than by characters.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbsnbcat">_mbsnbcat</a>, <a href="#_mbsnbcmp">_mbsnbcmp</a>, <a href="#strncmp">strncmp</a>, <a href="#strnicmp">strnicmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>const unsigned char str1&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x79, /* double-byte Z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>const unsigned char str2&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x81, /* double-byte a */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x9a, /* double-byte z */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, _mbsnbicmp( str1, str2, 5 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbsnbicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsnbicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbsnbset"> _mbsnbset, _fmbsnbset </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsnbset( unsigned char *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int fill,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</tt>
<br><tt>unsigned char __far *_fmbsnbset( unsigned char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int fill,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbsnbset</tt> function fills the string<b> str</b> with the value of the argument<b> fill</b>.&nbsp; When the value
 of<b> len</b> is greater than the length of the string, the entire string is filled.&nbsp; Otherwise, that number of characters
 at the start of the string are set to the fill character.
<br><tt>_mbsnbset</tt> is similar to <tt> _mbsnset</tt>, except that it fills in<b> count</b> bytes rather than<b> count</b>
 characters.&nbsp; If the number of bytes to be filled is odd and<b> fill</b> is a double-byte character, the partial byte
 at the end is filled with an ASCII space character.
<br><br>The<tt> _fmbsnbset</tt> function is a data model independent form of the<tt> _mbsnbset</tt> function.&nbsp; It accepts
 far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The address of the original string<b> str</b> is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strnset">strnset</a>, <a href="#strset">strset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned char&nbsp;&nbsp; big_string&#91;10&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; memset( (char *) big_string, 0xee, 10 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; big_string&#91;9&#93; = 0x00;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _mbsnbset( big_string, 0x8145, 5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, big_string&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>ee ee ee ee ee ee ee ee ee 00</tt>
<br><tt>81 45 81 45 20 ee ee ee ee 00</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbsnbset - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsnbset - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbsnccnt"> _mbsnccnt, _fmbsnccnt, _strncnt, _wcsncnt </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>size_t _mbsnccnt( const unsigned char *string, size_t n );</tt>
<br><tt>size_t _fmbsnccnt( const unsigned char __far *string,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t
 n );</tt>
<br><tt>#include &lt;tchar.h&gt;</tt>
<br><tt>size_t _strncnt( const char *string, size_t n );</tt>
<br><tt>size_t _wcsncnt( const wchar_t *string, size_t n ) {</tt>
</dl>
<dl>
<dt>Description:
<dd>The function counts the number of multibyte characters in the first<b> n</b> bytes of the string<b> string</b>.&nbsp; If finds
 a null byte as the second byte of a double-byte character, the first (lead) byte is not included in the count.
<br><b>Note:</b>&nbsp; This function was called <tt> btom</tt> in earlier versions.
<br><br>The function is a data model independent form of the<tt> _strncnt</tt> function that accepts far pointer arguments.
&nbsp; It is most useful in mixed memory model applications.
<br><br>The header file<tt> &lt;tchar.h&gt;</tt> defines the generic-text routine <tt> _tcsnccnt</tt>.&nbsp; This macro maps
 to if <tt> _MBCS</tt> has been defined, or to the<tt> _wcsncnt</tt> macro if <tt> _UNICODE</tt> has been defined.&nbsp; Otherwise
 <tt> _tcsnccnt</tt> maps to<tt> _strncnt</tt>.<tt>&nbsp; _strncnt</tt> and<tt> _wcsncnt</tt> are single-byte character string
 and wide-character string versions of .&nbsp; The<tt> _strncnt</tt> and<tt> _wcsncnt</tt> macros are provided only for this
 mapping and should not be used otherwise.
<br><br>The<tt> _strncnt</tt> function returns the number of characters (i.e.,<b> n</b>) in the first<b> n</b> bytes of the
 single-byte string<b> string</b>.&nbsp; The<tt> _wcsncnt</tt> function returns the number of bytes (i.e., 2 *<b> n</b>) in
 the first<b> n</b> wide characters of the wide-character string<b> string</b>.
</dl>
<dl>
<dt>Returns:
<dd><tt> _strncnt</tt> returns the number of characters from the beginning of the string to byte<b> n</b>.<tt>&nbsp; _wcsncnt</tt>
 returns the number of wide characters from the beginning of the string to byte<b> n</b>.&nbsp; returns the number of multibyte
 characters from the beginning of the string to byte<b> n</b>.&nbsp; If these functions find a null character before byte<b>
 n</b>, they return the number of characters before the null character.&nbsp; If the string consists of fewer than<b> n</b>
 characters, these functions return the number of characters in the string.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbsnbcat">_mbsnbcat</a>, <a href="#_mbsnbcnt">_mbsnbcnt</a>, <a href="#_mbsnccnt">_mbsnccnt</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>const unsigned char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d characters found\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _mbsnccnt( chars, 10 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>7 characters found</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbsnccnt - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsnccnt - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_strncnt - MACRO</tt>
<br><tt>_wcsncnt - MACRO</tt>
</dl>
<h2 id="_mbsnextc"> _mbsnextc, _fmbsnextc, _strnextc, _wcsnextc </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned int _mbsnextc( const unsigned char *string );</tt>
<br><tt>unsigned int _fmbsnextc(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const unsigned char __far *string );</tt>
<br><tt>#include &lt;tchar.h&gt;</tt>
<br><tt>unsigned int _strnextc( const char *string );</tt>
<br><tt>unsigned int _wcsnextc( const wchar_t *string ) {</tt>
</dl>
<dl>
<dt>Description:
<dd>The function returns the integer value of the next multibyte-character in<b> string</b>, without advancing the string pointer.
&nbsp; recognizes multibyte character sequences according to the multibyte code page currently in use.
<br>The header file<tt> &lt;tchar.h&gt;</tt> defines the generic-text routine <tt> _tcsnextc</tt>.&nbsp; This macro maps to
 if <tt> _MBCS</tt> has been defined, or to<tt> _wcsnextc</tt> if <tt> _UNICODE</tt> has been defined.&nbsp; Otherwise <tt>
 _tcsnextc</tt> maps to<tt> _strnextc</tt>.<tt>&nbsp; _strnextc</tt> and<tt> _wcsnextc</tt> are single-byte character string
 and wide-character string versions of .<tt>&nbsp; _strnextc</tt> and<tt> _wcsnextc</tt> are provided only for this mapping
 and should not be used otherwise.<tt>&nbsp; _strnextc</tt> returns the integer value of the next single-byte character in
 the string.<tt>&nbsp; _wcsnextc</tt> returns the integer value of the next wide character in the string.
</dl>
<dl>
<dt>Returns:
<dd>These functions return the integer value of the next character (single-byte, wide, or multibyte) pointed to by<b> string</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbsnextc">_mbsnextc</a>, <a href="#_strdec">_strdec</a>, <a href="#_strinc">_strinc</a>, <a href="#_strninc">_strninc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>const unsigned char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, _mbsnextc( &amp;chars&#91;2&#93; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, _mbsnextc( &amp;chars&#91;4&#93; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, _mbsnextc( &amp;chars&#91;12&#93; ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0x0031</tt>
<br><tt>0x8140</tt>
<br><tt>0x00a1</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbsnextc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsnextc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_strnextc - MACRO</tt>
<br><tt>_wcsnextc - MACRO</tt>
</dl>
<h2 id="mbsrtowcs"> mbsrtowcs, _fmbsrtowcs </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>size_t mbsrtowcs( wchar_t *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char **src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len, mbstate_t *ps );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>size_t _fmbsrtowcs( wchar_t __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far * __far *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len, mbstate_t __far *ps );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#mbsrtowcs_s">mbsrtowcs_s</a> function which is a safer alternative to<tt>
 mbsrtowcs</tt>.&nbsp; This newer<tt> mbsrtowcs_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 mbsrtowcs</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> mbsrtowcs</tt> function converts a sequence of multibyte characters that begins in the shift state described by<b>
 ps</b> from the array indirectly pointed to by<b> src</b> into a sequence of corresponding wide characters, which, if<b>
 dst</b> is not a null pointer, are then stored into the array pointed to by<b> dst</b>.&nbsp; Conversion continues up to
 and including a terminating null character, but the terminating null wide character will not be stored.&nbsp; Conversion
 will stop earlier in two cases:&nbsp; when a sequence of bytes is reached that does not form a valid multibyte character,
 or (if<b> dst</b> is not a null pointer) when<b> len</b> codes have been stored into the array pointed to by<b> dst</b>.
&nbsp; Each conversion takes place as if by a call to the <tt> mbrtowc</tt> function.
<br>If<b> dst</b> is not a null pointer, the pointer object pointed to by<b> src</b> will be assigned either a null pointer
 (if conversion stopped due to reaching a terminating null character) or the address just past the last multibyte character
 converted.&nbsp; If conversion stopped due to reaching a terminating null character and if<b> dst</b> is not a null pointer,
 the resulting state described will be the initial conversion state.
<br><br>The<tt> _fmbsrtowcs</tt> function is a data model independent form of the<tt> mbsrtowcs</tt> function that accepts
 far pointer arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The restartable multibyte/wide string conversion functions differ from the corresponding internal-state multibyte
 string functions ( <tt> mbstowcs</tt> and <tt> wcstombs</tt>) in that they have an extra argument,<b> ps</b>, of type pointer
 to <tt> mbstate_t</tt> that points to an object that can completely describe the current conversion state of the associated
 multibyte character sequence.&nbsp; If<b> ps</b> is a null pointer, each function uses its own internal <tt> mbstate_t</tt>
 object instead.&nbsp; You are guaranteed that no other function in the library calls these functions with a null pointer
 for<b> ps</b>, thereby ensuring the stability of the state.
<br><br>Also unlike their corresponding functions, the conversion source argument,<b> src</b>, has a pointer-to-pointer type.
&nbsp; When the function is storing conversion results (that is, when<b> dst</b> is not a null pointer), the pointer object
 pointed to by this argument will be updated to reflect the amount of the source processed by that invocation.
<br><br>If the encoding is state-dependent, on entry each function takes the described conversion state (either internal or
 pointed to by<b> ps</b>) as current and then, if the destination pointer,<b> dst</b>, is not a null pointer, the conversion
 state described by the pointed-to object is altered as needed to track the shift state of the associated multibyte character
 sequence.&nbsp; For encodings without state dependency, the pointer to the <tt> mbstate_t</tt> argument is ignored.
</dl>
<dl>
<dt>Returns:
<dd>If the input string does not begin with a valid multibyte character, an encoding error occurs:&nbsp; The<tt> mbsrtowcs</tt>
 function stores the value of the macro <tt> EILSEQ</tt> in <tt> errno</tt> and returns<tt> (size_t)-1,</tt> but the conversion
 state will be unchanged.&nbsp; Otherwise, it returns the number of multibyte characters successfully converted, which is
 the same as the number of array elements modified when<b> dst</b> is not a null pointer.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>,
 <a href="#mbrlen">mbrlen</a>, <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;errno.h&gt;</tt>
<br><br><tt>const char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elements;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char&nbsp; *src;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp;&nbsp;&nbsp; wc&#91;50&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mbstate_t&nbsp;&nbsp; pstate;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; src = chars;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; elements = mbsrtowcs( wc, &amp;src, 50, &amp;pstate );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( errno == EILSEQ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error in multibyte character string\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; elements; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, wc&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>0x0020</tt>
<br><tt>0x002e</tt>
<br><tt>0x0031</tt>
<br><tt>0x0041</tt>
<br><tt>0x3000</tt>
<br><tt>0xff21</tt>
<br><tt>0x3048</tt>
<br><tt>0x30a3</tt>
<br><tt>0xff61</tt>
<br><tt>0xff66</tt>
<br><tt>0xff9f</tt>
<br><tt>0x720d</tt>
</dl>
<dl>
<dt>Classification:
<dd>mbsrtowcs is ANSI
<br>_fmbsrtowcs is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> mbsrtowcs - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsrtowcs - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="mbsrtowcs_s"> mbsrtowcs_s, _fmbsrtowcs_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>errno_t mbsrtowcs_s( size_t * restrict retval,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; wchar_t * restrict dst, rsize_t dstmax,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const char ** restrict src, rsize_t len,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; mbstate_t * restrict ps);</tt>
<br><tt>errno_t _fmbsrtowcs_s( size_t __far * restrict retval,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; wchar_t __far * restrict dst, rsize_t dstmax,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const char __far * __far * restrict src, rsize_t len,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; mbstate_t __far * restrict ps);</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 mbsrtowcs_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>None of<b> retval</b> ,<b> src</b> ,<b> *src</b> , or<b> ps</b> shall be null pointers.&nbsp; If<b> dst</b> is not a null
 pointer, then neither<b> len</b> nor<b> dstmax</b> shall be greater than <tt> RSIZE_MAX</tt>.&nbsp; If<b> dst</b> is a null
 pointer, then<b> dstmax</b> shall equal zero.&nbsp; If<b> dst</b> is not a null pointer, then<b> dstmax</b> shall not equal
 zero.&nbsp; If<b> dst</b> is not a null pointer and<b> len</b> is not less than<b> dstmax</b> ,then a null character shall
 occur within the first<b> dstmax</b> multibyte characters of the array pointed to by<b> *src</b>.
<br><br>If there is a runtime-constraint violation, then<tt> mbsrtowcs_s</tt> does the following.&nbsp; If<b> retval</b> is
 not a null pointer, then<tt> mbsrtowcs_s</tt> sets<b> *retval</b> to (size_t)(-1).&nbsp; If<b> dst</b> is not a null pointer
 and<b> dstmax</b> is greater than zero and less than <tt> RSIZE_MAX</tt> , then<tt> mbsrtowcs_s</tt> sets<b> dst&#91;0&#93;</b>
 to the null wide character.
</dl>
<dl>
<dt>Description:
<dd>The<tt> mbsrtowcs_s</tt> function converts a sequence of multibyte characters that begins in the conversion state described
 by the object pointed to by<b> ps</b>, from the array indirectly pointed to by<b> src</b> into a sequence of corresponding
 wide characters.&nbsp; If<b> dst</b> is not a null pointer, the converted characters are stored into the array pointed to
 by<b> dst</b>.&nbsp; Conversion continues up to and including a terminating null character, which is also stored.
<br>Conversion stops earlier in two cases:&nbsp; when a sequence of bytes is encountered that does not form a valid multibyte
 character, or (if<b> dst</b> is not a null pointer) when<b> len</b> wide characters have been stored into the array pointed
 to by<b> dst</b>.&nbsp; If<b> dst</b> is not a null pointer and no null wide character was stored into the array pointed
 to by<b> dst</b>, then<b> dst&#91;len&#93;</b> is set to the null wide character.&nbsp; Each conversion takes place as if
 by a call to the <tt> mbrtowc</tt> function.
<br><br>If<b> dst</b> is not a null pointer, the pointer object pointed to by<b> src</b> is assigned either a null pointer
 (if conversion stopped due to reaching a terminating null character) or the address just past the last multibyte character
 converted (if any).&nbsp; If conversion stopped due to reaching a terminating null character and if<b> dst</b> is not a null
 pointer, the resulting state described is the initial conversion state.
<br><br>Regardless of whether<b> dst</b> is or is not a null pointer, if the input conversion encounters a sequence of bytes
 that do not form a valid multibyte character, an encoding error occurs:&nbsp; the<tt> mbsrtowcs_s</tt> function stores the
 value (size_t)(-1) into<b> *retval</b> and the conversion state is unspecified.&nbsp; Otherwise, the<tt> mbsrtowcs_s</tt>
 function stores into<b> *retval</b> the number of multibyte characters successfully converted, not including the terminating
 null character (if any).
<br><br>All elements following the terminating null wide character (if any) written by<tt> mbsrtowcs_s</tt> in the array of<b>
 dstmax</b> wide characters pointed to by<b> dst</b> take unspecified values when<tt> mbsrtowcs_s</tt> returns.
<br><br>If copying takes place between objects that overlap, the objects take on unspecified values.
<br><br>The<tt> _fmbsrtowcs_s</tt> function is a data model independent form of the mbsrtowcs_s function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> mbsrtowcs_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>,
 <a href="#mbrlen">mbrlen</a>, <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>, <a href="#wcrtomb">wcrtomb</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;errno.h&gt;</tt>
<br><br><tt>const char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>int main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char&nbsp; *src;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp;&nbsp;&nbsp; wc&#91;50&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mbstate_t&nbsp;&nbsp; pstate;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errno_t&nbsp;&nbsp;&nbsp;&nbsp; rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; src = chars;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = mbsrtowcs( &amp;retval, wc, 50, &amp;src, sizeof(chars), &amp;pstate );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( rc != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error in multibyte character string\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; retval; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x\n&quot;, wc&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>mbsrtowcs_s is TR 24731
<br>_fmbsrtowcs_s is WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> mbsrtowcs_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsrtowcs_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="mbstowcs"> mbstowcs, _fmbstowcs </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>size_t mbstowcs( wchar_t *pwcs, const char *s, size_t n );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>size_t _fmbstowcs( const wchar_t __far *pwcs,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char
 __far *s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t
 n );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#mbstowcs_s">mbstowcs_s</a> function which is a safer alternative to<tt>
 mbstowcs</tt>.&nbsp; This newer<tt> mbstowcs_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 mbstowcs</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> mbstowcs</tt> function converts a sequence of multibyte characters pointed to by<b> s</b> into their corresponding
 wide character codes and stores not more than<b> n</b> codes into the array pointed to by<b> pwcs</b>.&nbsp; The<tt> mbstowcs</tt>
 function does not convert any multibyte characters beyond the null character.&nbsp; At most<b> n</b> elements of the array
 pointed to by<b> pwcs</b> will be modified.
<br>The<tt> _fmbstowcs</tt> function is a data model independent form of the<tt> mbstowcs</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>If an invalid multibyte character is encountered, the<tt> mbstowcs</tt> function returns<tt> (size_t)-1.</tt>&nbsp; Otherwise,
 the<tt> mbstowcs</tt> function returns the number of array elements modified, not including the terminating zero code if
 present.
</dl>
<dl>
<dt>See Also:
<dd><a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mblen">mblen</a>, <a href="#mbtowc">mbtowc</a>, <a href="#wctomb">wctomb</a>,
 <a href="#wctomb_s">wctomb_s</a>, <a href="#wcstombs">wcstombs</a>, <a href="#wcstombs_s">wcstombs_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *wc = &quot;string&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wchar_t wbuffer&#91;50&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i, len;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; len = mbstowcs( wbuffer, wc, 50 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( len != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wbuffer&#91;len&#93; = '\0';</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, wc, len );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; len; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;/%4.4x&quot;, wbuffer&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>string(6)</tt>
<br><tt>/0073/0074/0072/0069/006e/0067</tt>
</dl>
<dl>
<dt>Classification:
<dd>mbstowcs is ANSI
<br>_fmbstowcs is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> mbstowcs - All, Netware</tt>
<br><tt>_fmbstowcs - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="mbstowcs_s"> mbstowcs_s, _fmbstowcs_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>errno_t mbstowcs_s( size_t * restrict retval,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 wchar_t * restrict dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 rsize_t dstmax,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const char * restrict src, rsize_t len);</tt>
<br><tt>errno_t _fmbstowcs_s( size_t __far * restrict retval,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 wchar_t __far * restrict dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 rsize_t dstmax,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const char __far * restrict src, rsize_t len);</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 mbstowcs_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> retval</b> nor<b> src</b> shall be a null pointer.&nbsp; If<b> dst</b> is not a null pointer, then neither<b>
 len</b> nor<b> dstmax</b> shall be greater than <tt> RSIZE_MAX</tt>.&nbsp; If<b> dst</b> is a null pointer, then<b> dstmax</b>
 shall equal zero.&nbsp; If<b> dst</b> is not a null pointer, then<b> dstmax</b> shall not equal zero.&nbsp; If<b> dst</b>
 is not a null pointer and<b> len</b> is not less than<b> dstmax</b>, then a null character shall occur within the first<b>
 dstmax</b> multibyte characters of the array pointed to by<b> src</b>.
<br><br>If there is a runtime-constraint violation, then<tt> mbstowcs_s</tt> does the following.&nbsp; If<b> retval</b> is
 not a null pointer, then<tt> mbstowcs_s</tt> sets<b> *retval</b> to (size_t)(-1).&nbsp; If<b> dst</b> is not a null pointer
 and<b> dstmax</b> is greater than zero and less than <tt> RSIZE_MAX</tt>, then<tt> mbstowcs_s</tt> sets<b> dst&#91;0&#93;</b>
 to the null wide character.
</dl>
<dl>
<dt>Description:
<dd>The<tt> mbstowcs_s</tt> function converts a sequence of multibyte characters that begins in the initial shift state from the
 array pointed to by<b> src</b> into a sequence of corresponding wide characters.&nbsp; If<b> dst</b> is not a null pointer,
 the converted characters are stored into the array pointed to by<b> dst</b>.
<br>Conversion continues up to and including a terminating null character, which is also stored.&nbsp; Conversion stops earlier
 in two cases:&nbsp; when a sequence of bytes is encountered that does not form a valid multibyte character, or (if<b> dst</b>
 is not a null pointer) when<b> len</b> wide characters have been stored into the array pointed to by<b> dst</b>.&nbsp; If<b>
 dst</b> is not a null pointer and no null wide character was stored into the array pointed to by<b> dst</b>, then<b> dst&#91;len&#93;</b>
 is set to the null wide character.&nbsp; Each conversion takes place as if by a call to the <tt> mbrtowc</tt> function.
<br><br>Regardless of whether<b> dst</b> is or is not a null pointer, if the input conversion encounters a sequence of bytes
 that do not form a valid multibyte character, an encoding error occurs:&nbsp; the<tt> mbstowcs_s</tt> function stores the
 value (size_t)(-1) into<b> *retval</b>.&nbsp; Otherwise, the<tt> mbstowcs_s</tt> function stores into<b> *retval</b> the
 number of multibyte characters successfully converted, not including the terminating null character (if any).
<br><br>All elements following the terminating null wide character (if any) written by<tt> mbstowcs_s</tt> in the array of<b>
 dstmax</b> wide characters pointed to by<b> dst</b> take unspecified values when<tt> mbstowcs_s</tt> returns.
<br><br>If copying takes place between objects that overlap, the objects take on unspecified values.
<br><br>The<tt> _fmbstowcs_s</tt> function is a data model independent form of the mbstowcs_s function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> mbstowcs_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#mbstowcs">mbstowcs</a>, <a href="#mblen">mblen</a>, <a href="#mbtowc">mbtowc</a>, <a href="#wctomb">wctomb</a>,
 <a href="#wctomb_s">wctomb_s</a>, <a href="#wcstombs">wcstombs</a>, <a href="#wcstombs_s">wcstombs_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>int&nbsp; main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *wc = &quot;string&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wchar_t wbuffer&#91;50&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errno_t rc;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t&nbsp; retval;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = mbstowcs_s( &amp;retval, wbuffer, 50, wc, 10);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( rc == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wbuffer&#91;retval&#93; = L'\0';</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, wc, retval );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; retval; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;/%4.4x&quot;, wbuffer&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>string(6)</tt>
<br><tt>/0073/0074/0072/0069/006e/0067</tt>
</dl>
<dl>
<dt>Classification:
<dd>mbstowcs_s is TR 24731
<br>_fmbstowcs_s is WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> mbstowcs_s - All, Netware</tt>
<br><tt>_fmbstowcs_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbterm"> _mbterm, _fmbterm </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbterm( const unsigned char *ch );</tt>
<br><tt>int _fmbterm( const unsigned char __far *ch );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbterm</tt> function determines if the next multibyte character in the string pointed to by<b> ch</b> is a null character
 or a valid lead byte followed by a null character.
<br>The<tt> _fmbterm</tt> function is a data model independent form of the<tt> _mbterm</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbterm</tt> function returns 1 if the multibyte character pointed to by<b> ch</b> is a null character.&nbsp; The<tt>
 _mbterm</tt> function returns 2 if the multibyte character pointed to by<b> ch</b> is a valid lead byte character followed
 by a null character.&nbsp; Otherwise, the<tt> _mbterm</tt> function returns 0.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>,
 <a href="#mbrlen">mbrlen</a>, <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>,
 <a href="#mbstowcs">mbstowcs</a>, <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>,
 <a href="#wcrtomb">wcrtomb</a>, <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>,
 <a href="#wcstombs">wcstombs</a>, <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>,
 <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>const unsigned char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x00&nbsp; /* invalid double-byte */</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;0x%2.2x %d\n&quot;, chars&#91;i&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _mbterm( &amp;chars&#91;i&#93;
 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>0x20 0</tt>
<br><tt>0x2e 0</tt>
<br><tt>0x31 0</tt>
<br><tt>0x41 0</tt>
<br><tt>0x81 0</tt>
<br><tt>0x40 0</tt>
<br><tt>0x82 2</tt>
<br><tt>0x00 1</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbterm - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbterm - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="mbtowc"> mbtowc, _fmbtowc </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>int mbtowc( wchar_t *pwc, const char *s, size_t n );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _fmbtowc( wchar_t __far *pwc,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far *s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> mbtowc</tt> function converts a single multibyte character pointed to by<b> s</b> into the wide character code that
 corresponds to that multibyte character.&nbsp; The code for the null character is zero.&nbsp; If the multibyte character
 is valid and<b> pwc</b> is not a NULL pointer, the code is stored in the object pointed to by<b> pwc</b>.&nbsp; At most<b>
 n</b> bytes of the array pointed to by<b> s</b> will be examined.
<br>The<tt> mbtowc</tt> function does not examine more than <tt> MB_CUR_MAX</tt> bytes.
<br><br>The<tt> _fmbtowc</tt> function is a data model independent form of the<tt> mbtowc</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>If<b> s</b> is a NULL pointer, the<tt> mbtowc</tt> function returns zero if multibyte character encodings are not state dependent,
 and non-zero otherwise.&nbsp; If<b> s</b> is not a NULL pointer, the<tt> mbtowc</tt> function returns:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>0
<dd>if<b> s</b> points to the null character
<dt><br>len
<dd>the number of bytes that comprise the multibyte character (if the next<b> n</b> or fewer bytes form a valid multibyte character)
<dt><br>-1
<dd>if the next<b> n</b> bytes do not form a valid multibyte character
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#mblen">mblen</a>, <a href="#wctomb">wctomb</a>, <a href="#mbstowcs">mbstowcs</a>, <a href="#wcstombs">wcstombs</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *wc = &quot;string&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wchar_t wbuffer&#91;10&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i, len;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Character encodings are %sstate dependent\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( mbtowc( wbuffer, NULL, 0 ) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? &quot;&quot; : &quot;not &quot; );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; len = mbtowc( wbuffer, wc, MB_CUR_MAX );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wbuffer&#91;len&#93; = '\0';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, wc, len );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; len; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;/%4.4x&quot;, wbuffer&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Character encodings are not state dependent</tt>
<br><tt>string(1)</tt>
<br><tt>/0073</tt>
</dl>
<dl>
<dt>Classification:
<dd>mbtowc is ANSI
<br>_fmbtowc is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> mbtowc - All, Netware</tt>
<br><tt>_fmbtowc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_mbvtop"> _mbvtop, _fmbvtop </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbvtop( unsigned int ch,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned char *addr );</tt>
<br><tt>unsigned char __far *_fmbvtop( unsigned int ch,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned char __far *addr );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbvtop</tt> function stores the multibyte character<b> ch</b> into the string pointed to by<b> addr</b>.
<br>The<tt> _fmbvtop</tt> function is a data model independent form of the<tt> _mbvtop</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mbvtop</tt> function returns the value of the argument<b> addr</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>,
 <a href="#mbrlen">mbrlen</a>, <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>,
 <a href="#mbstowcs">mbstowcs</a>, <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>,
 <a href="#wcrtomb">wcrtomb</a>, <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>,
 <a href="#wcstombs">wcstombs</a>, <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>,
 <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned char string&#91;10&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned char *p;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p = string;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _mbvtop( '.', p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p++;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _mbvtop( '1', p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p++;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _mbvtop( 'A', p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p++;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _mbvtop( 0x8140, p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p += 2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _mbvtop( 0x8260, p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p += 2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _mbvtop( 0x82A6, p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p += 2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _mbvtop( '\0', p );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 10; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2.2x &quot;, string&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>2e 31 41 81 40 82 60 82 a6 00</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mbvtop - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbvtop - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_memavl"> _memavl </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>size_t _memavl( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _memavl</tt> function returns the number of bytes of memory available for dynamic memory allocation in the near heap
 (the default data segment).&nbsp; In the tiny, small and medium memory models, the default data segment is only extended
 as needed to satisfy requests for memory allocation.&nbsp; Therefore, you will need to call <tt> _nheapgrow</tt> in these
 memory models before calling<tt> _memavl</tt> in order to get a meaningful result.
<br>The number returned by<tt> _memavl</tt> may not represent a single contiguous block of memory.&nbsp; Use the <tt> _memmax</tt>
 function to find the largest contiguous block of memory that can be allocated.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _memavl</tt> function returns the number of bytes of memory available for dynamic memory allocation in the near heap
 (the default data segment).
</dl>
<dl>
<dt>See Also:
<dd><a href="#calloc">calloc</a> Functions, <a href="#_freect">_freect</a>, <a href="#_memmax">_memmax</a>, <a href="#_heapgrow">_heapgrow</a>
 Functions, <a href="#malloc">malloc</a> Functions, <a href="#realloc">realloc</a> Functions
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *p;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *fmt = &quot;Memory available = %u\n&quot;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( fmt, _memavl() );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _nheapgrow();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( fmt, _memavl() );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p = (char *) malloc( 2000 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( fmt, _memavl() );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Memory available = 0</tt>
<br><tt>Memory available = 62732</tt>
<br><tt>Memory available = 60730</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="memccpy"> memccpy, _fmemccpy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>void *memccpy( void *dest, const void *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int c, size_t cnt );</tt>
<br><tt>void __far *_fmemccpy( void __far *dest,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const void __far *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; int c, size_t cnt );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> memccpy</tt> function copies bytes from<b> src</b> to<b> dest</b> up to and including the first occurrence of the
 character<b> c</b> or until<b> cnt</b> bytes have been copied, whichever comes first.
<br>The<tt> _fmemccpy</tt> function is a data model independent form of the<tt> memccpy</tt> function.&nbsp; It accepts far
 pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> memccpy</tt> function returns a pointer to the byte in<b> dest</b> following the character<b> c</b> if one is found
 and copied, otherwise it returns NULL.
</dl>
<dl>
<dt>See Also:
<dd><a href="#memcpy">memcpy</a>, <a href="#memmove">memmove</a>, <a href="#memset">memset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char *msg = &quot;This is the string: not copied&quot;;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; memset( buffer, '\0', 80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; memccpy( buffer, msg, ':', 80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>This is the string:</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> memccpy - All, Netware</tt>
<br><tt>_fmemccpy - All</tt>
</dl>
<h2 id="memchr"> memchr, _fmemchr, wmemchr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>void *memchr( const void *buf, int ch, size_t length );</tt>
<br><tt>void __far *_fmemchr( const void __far *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; int ch,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; size_t length );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *wmemchr( const wchar_t *buf, wchar_t ch, size_t length );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> memchr</tt> function locates the first occurrence of<b> ch</b> (converted to an unsigned char) in the first<b> length</b>
 characters of the object pointed to by<b> buf</b>.
<br>The<tt> _fmemchr</tt> function is a data model independent form of the<tt> memchr</tt> function.&nbsp; It accepts far
 pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wmemchr</tt> wide-character function is identical to<tt> memchr</tt> except that it operates on characters
 of <tt> wchar_t</tt> type.&nbsp; The argument<b> length</b> is interpreted to mean the number of wide characters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> memchr</tt> function returns a pointer to the located character, or<tt> NULL</tt> if the character does not occur
 in the object.
</dl>
<dl>
<dt>See Also:
<dd><a href="#memcmp">memcmp</a>, <a href="#memcpy">memcpy</a>, <a href="#memicmp">memicmp</a>, <a href="#memset">memset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *where;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;video x-rays&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; where = (char *)memchr( buffer, 'x', 6 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( where == NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;'x' not found\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, where );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; where = (char *)memchr( buffer, 'r', 9 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( where == NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;'r' not found\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, where );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>memchr is ANSI
<br>_fmemchr is not ANSI
<br>wmemchr is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> memchr - All, Netware</tt>
<br><tt>_fmemchr - All</tt>
<br><tt>wmemchr - All</tt>
</dl>
<h2 id="memcmp"> memcmp, _fmemcmp, wmemcmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>int memcmp( const void *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</tt>
<br><tt>int _fmemcmp( const void __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void __far *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int wmemcmp( const wchar_t *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> memcmp</tt> function compares the first<b> length</b> characters of the object pointed to by<b> s1</b> to the object
 pointed to by<b> s2</b>.
<br>The<tt> _fmemcmp</tt> function is a data model independent form of the<tt> memcmp</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wmemcmp</tt> wide-character function is identical to<tt> memcmp</tt> except that it operates on characters
 of <tt> wchar_t</tt> type.&nbsp; The argument<b> length</b> is interpreted to mean the number of wide characters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> memcmp</tt> function returns an integer less than, equal to, or greater than zero, indicating that the object pointed
 to by<b> s1</b> is less than, equal to, or greater than the object pointed to by<b> s2</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#memchr">memchr</a>, <a href="#memcpy">memcpy</a>, <a href="#memicmp">memicmp</a>, <a href="#memset">memset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;world&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( memcmp( buffer, &quot;Hello &quot;, 6 ) &lt; 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>memcmp is ANSI
<br>_fmemcmp is not ANSI
<br>wmemcmp is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> memcmp - All, Netware</tt>
<br><tt>_fmemcmp - All</tt>
<br><tt>wmemcmp - All</tt>
</dl>
<h2 id="memcpy"> memcpy, _fmemcpy, wmemcpy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>void *memcpy( void *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</tt>
<br><tt>void __far *_fmemcpy( void __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const void __far *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; size_t length );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *wmemcpy( wchar_t *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
 *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length
 );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#memcpy_s">memcpy_s</a> function which is a safer alternative to<tt> memcpy</tt>.
&nbsp; This newer<tt> memcpy_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> memcpy</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> memcpy</tt> function copies<b> length</b> characters from the buffer pointed to by<b> src</b> into the buffer pointed
 to by<b> dst</b>.&nbsp; Copying of overlapping objects is not guaranteed to work properly.&nbsp; See the <tt> memmove</tt>
 function if you wish to copy objects that overlap.
<br>The<tt> _fmemcpy</tt> function is a data model independent form of the<tt> memcpy</tt> function.&nbsp; It accepts far
 pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wmemcpy</tt> wide-character function is identical to<tt> memcpy</tt> except that it operates on characters
 of <tt> wchar_t</tt> type.&nbsp; The argument<b> length</b> is interpreted to mean the number of wide characters.
</dl>
<dl>
<dt>Returns:
<dd>The original value of<b> dst</b> is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#memchr">memchr</a>, <a href="#memcmp">memcmp</a>, <a href="#memicmp">memicmp</a>, <a href="#memmove">memmove</a>,
 <a href="#memset">memset</a>, <a href="#memcpy_s">memcpy_s</a>, <a href="#memmove_s">memmove_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; memcpy( buffer, &quot;Hello&quot;, 5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; buffer&#91;5&#93; = '\0';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>memcpy is ANSI
<br>_fmemcpy is not ANSI
<br>wmemcpy is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> memcpy - All, Netware</tt>
<br><tt>_fmemcpy - All</tt>
<br><tt>wmemcpy - All</tt>
</dl>
<h2 id="memcpy_s"> memcpy_s, wmemcpy_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>errno_t memcpy_s( void * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void
 * restrict s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t n );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>errno_t wmemcpy_s( wchar_t * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 wchar_t * restrict s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t
 n );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 memcpy_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> s1</b> nor<b> s2</b> shall be a null pointer.&nbsp; Neither<b> s1max</b> nor<b> n</b> shall be greater than
 <tt> RSIZE_MAX</tt>.<b>&nbsp; n</b> shall not be greater than<b> s1max</b>.&nbsp; Copying shall not take place between objects
 that overlap.
<br><br>If there is a runtime-constraint violation, the<tt> memcpy_s</tt> function stores zeros in the first<b> s1max</b>
 characters of the object pointed to by<b> s1</b> if<b> s1</b> is not a null pointer and<b> s1max</b> is not greater than
 <tt> RSIZE_MAX</tt>.
</dl>
<dl>
<dt>Description:
<dd>The<tt> memcpy_s</tt> function copies<b> n</b> characters from the buffer pointed to by<b> s2</b> into the buffer pointed
 to by<b> s1</b>.&nbsp; Copying between overlapping objects is not allowed.&nbsp; See the <tt> memmove_s</tt> function if
 you wish to copy objects that overlap.
<br>The<tt> wmemcpy_s</tt> wide-character function is identical to<tt> memcpy_s</tt> except that it operates on characters
 of <tt> wchar_t</tt> type.&nbsp; The arguments<b> s1max</b> and<b> n</b> are interpreted to mean the number of wide characters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> memcpy_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#memcpy">memcpy</a>, <a href="#memchr">memchr</a>, <a href="#memcmp">memcmp</a>, <a href="#memcpy">memcpy</a>, <a href="#memicmp">memicmp</a>,
 <a href="#memmove">memmove</a>, <a href="#memset">memset</a>, <a href="#memmove_s">memmove_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; memcpy_s( buffer, sizeof( buffer ), &quot;Hello&quot;, 5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; buffer&#91;5&#93; = '\0';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>memcpy_s is TR 24731
<br>wmemcpy_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> memcpy_s - All, Netware</tt>
<br><tt>wmemcpy_s - All</tt>
</dl>
<h2 id="memicmp"> memicmp, _memicmp, _fmemicmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>int memicmp( const void *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</tt>
<br><tt>int _memicmp( const void *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</tt>
<br><tt>int _fmemicmp( const void __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void __far *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> memicmp</tt> function compares, with case insensitivity (upper- and lowercase characters are equivalent), the first<b>
 length</b> characters of the object pointed to by<b> s1</b> to the object pointed to by<b> s2</b>.
<br>The<tt> _fmemicmp</tt> function is a data model independent form of the<tt> memicmp</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> _memicmp</tt> function is identical to<tt> memicmp</tt>.&nbsp; Use<tt> _memicmp</tt> for ANSI/ISO naming conventions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> memicmp</tt> function returns an integer less than, equal to, or greater than zero, indicating that the object pointed
 to by<b> s1</b> is less than, equal to, or greater than the object pointed to by<b> s2</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#memchr">memchr</a>, <a href="#memcmp">memcmp</a>, <a href="#memcpy">memcpy</a>, <a href="#memset">memset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( memicmp( buffer, &quot;Hello&quot;, 5 ) &lt; 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_memicmp conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> memicmp - All, Netware</tt>
<br><tt>_memicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmemicmp - All</tt>
</dl>
<h2 id="_memmax"> _memmax </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>size_t _memmax( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _memmax</tt> function returns the size of the largest contiguous block of memory available for dynamic memory allocation
 in the near heap (the default data segment).&nbsp; In the tiny, small and medium memory models, the default data segment
 is only extended as needed to satisfy requests for memory allocation.&nbsp; Therefore, you will need to call <tt> _nheapgrow</tt>
 in these memory models before calling<tt> _memmax</tt> in order to get a meaningful result.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _memmax</tt> function returns the size of the largest contiguous block of memory available for dynamic memory allocation
 in the near heap.&nbsp; If 0 is returned, then there is no more memory available in the near heap.
</dl>
<dl>
<dt>See Also:
<dd><a href="#calloc">calloc</a>, <a href="#_freect">_freect</a>, <a href="#_memavl">_memavl</a>, <a href="#_heapgrow">_heapgrow</a>,
 <a href="#malloc">malloc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *p;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t size;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; size = _memmax();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Maximum memory available is %u\n&quot;, size );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _nheapgrow();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size = _memmax();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Maximum memory available is %u\n&quot;, size );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p = (char *) _nmalloc( size );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size = _memmax();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Maximum memory available is %u\n&quot;, size );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Maximum memory available is 0</tt>
<br><tt>Maximum memory available is 62700</tt>
<br><tt>Maximum memory available is 0</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="memmove"> memmove, _fmemmove, wmemmove </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>void *memmove( void *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</tt>
<br><tt>void __far *_fmemmove( void __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const void __far *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; size_t length );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *wmemmove( wchar_t *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 wchar_t *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t
 length );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#memmove_s">memmove_s</a> function which is a safer alternative to<tt>
 memmove</tt>.&nbsp; This newer<tt> memmove_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 memmove</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> memmove</tt> function copies<b> length</b> characters from the buffer pointed to by<b> src</b> to the buffer pointed
 to by<b> dst</b>.&nbsp; Copying of overlapping objects will take place properly.&nbsp; See the <tt> memcpy</tt> function
 to copy objects that do not overlap.
<br>The<tt> _fmemmove</tt> function is a data model independent form of the<tt> memmove</tt> function.&nbsp; It accepts far
 pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wmemmove</tt> wide-character function is identical to<tt> memmove</tt> except that it operates on characters
 of <tt> wchar_t</tt> type.&nbsp; The argument<b> length</b> is interpreted to mean the number of wide characters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> memmove</tt> function returns<b> dst</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#memchr">memchr</a>, <a href="#memcmp">memcmp</a>, <a href="#memcpy">memcpy</a>, <a href="#memicmp">memicmp</a>,
 <a href="#memset">memset</a>, <a href="#memmove_s">memmove_s</a>, <a href="#memcpy_s">memcpy_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; memmove( buffer + 1, buffer, 79 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; buffer&#91;0&#93; = '*';</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>memmove is ANSI
<br>_fmemmove is not ANSI
<br>wmemmove is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> memmove - All, Netware</tt>
<br><tt>_fmemmove - All</tt>
<br><tt>wmemmove - All</tt>
</dl>
<h2 id="memmove_s"> memmove_s, wmemmove_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>errno_t memmove_s( void * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 void * restrict s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 n );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>errno_t wmemmove_s( wchar_t * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 rsize_t s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const wchar_t * restrict s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 size_t n );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 memmove_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> s1</b> nor<b> s2</b> shall be a null pointer.&nbsp; Neither<b> s1max</b> nor<b> n</b> shall be greater than<b>
 RSIZE_MAX</b>.<b>&nbsp; n</b> shall not be greater than<b> s1max</b>.
<br><br>If there is a runtime-constraint violation, the<tt> memmove_s</tt> function stores zeros in the first<b> s1max</b>
 characters of the object pointed to by<b> s1</b> if<b> s1</b> is not a null pointer and<b> s1max</b> is not greater than<b>
 RSIZE_MAX</b>.
</dl>
<dl>
<dt>Description:
<dd>The<tt> memmove_s</tt> function copies<b> n</b> characters from the buffer pointed to by<b> s2</b> into the buffer pointed
 to by<b> s1</b>.&nbsp; This copying takes place as if the<b> n</b> characters from the buffer pointed to by<b> s2</b> are
 first copied into a temporary array of<b> n</b> characters that does not overlap the objects pointed to by<b> s1</b> or<b>
 s2</b> ,and then the<b> n</b> characters from the temporary array are copied into the object pointed to by<b> s1</b>.
<br>See the<b> memcpy_s</b> function if you wish to copy objects that do not overlap.
<br><br>The<tt> wmemmove_s</tt> wide-character function is identical to<tt> memmove_s</tt> except that it operates on characters
 of<b> wchar_t</b> type.&nbsp; The arguments<b> s1max</b> and<b> n</b> are interpreted to mean the number of wide characters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> memmove_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#memchr">memchr</a>, <a href="#memcmp">memcmp</a>, <a href="#memcpy">memcpy</a>, <a href="#memicmp">memicmp</a>,
 <a href="#memmove">memmove</a>, <a href="#memset">memset</a>, <a href="#memcpy_s">memcpy_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93; = &quot;0123456789&quot;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; memmove_s( buffer + 1, sizeof( buffer ), buffer, 79 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; buffer&#91;0&#93; = '*';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( buffer );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>*0123456789</tt>
</dl>
<dl>
<dt>Classification:
<dd>memmove_s is TR 24731
<br>wmemmove_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> memmove_s - All, Netware</tt>
<br><tt>wmemmove_s - All</tt>
</dl>
<h2 id="_m_empty"> _m_empty </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>void&nbsp; _m_empty(void);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _m_empty</tt> function empties the multimedia state.&nbsp; The values in the Multimedia Tag Word (TW) are set to empty
 (i.e., all ones).&nbsp; This will indicate that no Multimedia registers are in use.
<br>This function is useful for applications that mix floating-point (FP) instructions with multimedia instructions.&nbsp;
 Intel maps the multimedia registers onto the floating-point registers.&nbsp; For this reason, you are discouraged from intermixing
 MM code and FP code.&nbsp; The recommended way to write an application with FP instructions and MM instructions is:
<ul>
<li>Split the FP code and MM code into two separate instruction streams such that each stream contains only instructions of
 one type.
<li>Do not rely on the contents of FP/MM registers across transitions from one stream to the other.
<li>Leave the MM state empty at the end of an MM stream using the<tt> _m_empty</tt> function.
<li>Similarly, leave the FP stack empty at the end of an FP stream.
</ul>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _m_empty</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_from_int">_m_from_int</a>, <a href="#_m_to_int">_m_to_int</a>, <a href="#_m_packsswb">_m_packsswb</a>, <a href="#_m_paddb">_m_paddb</a>,
 <a href="#_m_pand">_m_pand</a>, <a href="#_m_pcmpeqb">_m_pcmpeqb</a>, <a href="#_m_pmaddwd">_m_pmaddwd</a>, <a href="#_m_psllw">_m_psllw</a>,
 <a href="#_m_psraw">_m_psraw</a>, <a href="#_m_psrlw">_m_psrlw</a>, <a href="#_m_psubb">_m_psubb</a>, <a href="#_m_punpckhbw">_m_punpckhbw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>long featureflags( void );</tt>
<br><br><tt>#pragma aux featureflags = \</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;.586&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;mov eax,1&quot;&nbsp;&nbsp;&nbsp;&nbsp; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;cpuid&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;mov eax,edx&quot;&nbsp;&nbsp; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp; modify &#91;eax ebx ecx edx&#93;</tt>
<br><br><tt>#define MM_EXTENSION 0x00800000</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( featureflags() &amp; MM_EXTENSION ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /*</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sequence of code that uses Multimedia functions</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</tt>
<br><tt>&nbsp;&nbsp;&nbsp; */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _m_empty();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /*</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sequence of code that uses floating-point</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</tt>
<br><tt>&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="memset"> memset, _fmemset, wmemset </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>void *memset( void *dst, int c, size_t length );</tt>
<br><tt>void __far *_fmemset( void __far *dst, int c,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; size_t length );</tt>
<br><tt>wchar_t *wmemset( wchar_t *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t c,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length
 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> memset</tt> function fills the first<b> length</b> characters of the object pointed to by<b> dst</b> with the value<b>
 c</b>.
<br>The<tt> _fmemset</tt> function is a data model independent form of the<tt> memset</tt> function.&nbsp; It accepts far
 pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wmemset</tt> wide-character function is identical to<tt> memset</tt> except that it operates on characters
 of <tt> wchar_t</tt> type.&nbsp; The argument<b> length</b> is interpreted to mean the number of wide characters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> memset</tt> function returns the pointer<b> dst</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#memchr">memchr</a>, <a href="#memcmp">memcmp</a>, <a href="#memcpy">memcpy</a>, <a href="#memicmp">memicmp</a>,
 <a href="#memmove">memmove</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; memset( buffer, '=', 80 );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>memset is ANSI
<br>_fmemset is not ANSI
<br>wmemset is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> memset - All, Netware</tt>
<br><tt>_fmemset - All</tt>
<br><tt>wmemset - All</tt>
</dl>
<h2 id="_m_from_int"> _m_from_int </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_from_int(int i);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _m_from_int</tt> function forms a 64-bit MM value from an unsigned 32-bit integer value.
</dl>
<dl>
<dt>Returns:
<dd>The 64-bit result of loading MM0 with an unsigned 32-bit integer value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_to_int">_m_to_int</a>, <a href="#_m_packsswb">_m_packsswb</a>, <a href="#_m_paddb">_m_paddb</a>,
 <a href="#_m_pand">_m_pand</a>, <a href="#_m_empty">_m_empty</a>, <a href="#_m_pcmpeqb">_m_pcmpeqb</a>, <a href="#_m_pmaddwd">_m_pmaddwd</a>,
 <a href="#_m_psllw">_m_psllw</a>, <a href="#_m_psraw">_m_psraw</a>, <a href="#_m_psrlw">_m_psrlw</a>, <a href="#_m_empty">_m_empty</a>,
 <a href="#_m_psubb">_m_psubb</a>, <a href="#_m_punpckhbw">_m_punpckhbw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><br><tt>int&nbsp;&nbsp;&nbsp;&nbsp; k = 0xF1F2F3F4;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_from_int( k );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;int=%8.8lx m=%8.8lx%8.8lx\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k, a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>int=f1f2f3f4 m=00000000f1f2f3f4</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="min"> min </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#define min(a,b)&nbsp; (((a) &lt; (b)) ? (a) : (b))</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> min</tt> macro will evaluate to be the lesser of two values.&nbsp; It is implemented as follows.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; #define min(a,b)&nbsp; (((a) &lt; (b)) ? (a) : (b))</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> min</tt> macro will evaluate to the smaller of the two values passed.
</dl>
<dl>
<dt>See Also:
<dd><a href="#max">max</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int a;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /*</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; * The following line will set the variable &quot;a&quot; to 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; * since 10 is greater than 1.</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = min( 1, 10 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The value is: %d\n&quot;, a );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="mkdir"> mkdir, _mkdir, _wmkdir </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><tt>int mkdir( const char *path );</tt>
<br><tt>int _mkdir( const char *path );</tt>
<br><tt>int _wmkdir( const wchar_t *path );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> mkdir</tt> function creates a new subdirectory with name<b> path</b>.&nbsp; The<b> path</b> can be either relative
 to the current working directory or it can be an absolute path name.
<br>The<tt> _mkdir</tt> function is identical to<tt> mkdir</tt>.&nbsp; Use<tt> _mkdir</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _wmkdir</tt> function is identical to<tt> mkdir</tt> except that it accepts a wide-character string argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> mkdir</tt> function returns zero if successful, and a non-zero value otherwise.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EACCES
<dd>Search permission is denied for a component of<b> path</b> or write permission is denied on the parent directory of the directory
 to be created.
<dt><br>EEXIST
<dd>The named file exists.
<dt><br>ENOENT
<dd>The specified<b> path</b> does not exist or<b> path</b> is an empty string.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#chdir">chdir</a>, <a href="#chmod">chmod</a>, <a href="#getcwd">getcwd</a>, <a href="#rmdir">rmdir</a>, <a href="#stat">stat</a>,
 <a href="#umask">umask</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>To make a new directory called<tt> \watcom</tt> on drive<tt> C:</tt>
<br><br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mkdir( &quot;c:\\watcom&quot; );</tt>
<br><tt>}</tt>
<br><br>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</dl>
<dl>
<dt>Classification:
<dd>mkdir is POSIX 1003.1
<br>_mkdir is not POSIX
<br>_wmkdir is not POSIX
<br>_mkdir conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> mkdir - All, Netware</tt>
<br><tt>_mkdir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wmkdir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="MK_FP"> MK_FP </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>void __far *MK_FP( unsigned int segment,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned
 int offset );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> MK_FP</tt> macro can be used to obtain the far pointer value given by the<b> segment</b> segment value and the<b>
 offset</b> offset value.&nbsp; These values may be obtained by using the <tt> FP_SEG</tt> and <tt> FP_OFF</tt> macros.
</dl>
<dl>
<dt>Returns:
<dd>The macro returns a far pointer.
</dl>
<dl>
<dt>See Also:
<dd><a href="#FP_OFF">FP_OFF</a>, <a href="#FP_SEG">FP_SEG</a>, <a href="#segread">segread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short __far *bios_prtr_port_1;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; bios_prtr_port_1 =</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned short __far *) MK_FP( 0x40, 0x8 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Port address is %x\n&quot;, *bios_prtr_port_1 );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="mkstemp"> mkstemp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>int mkstemp( char *template );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> mkstemp</tt> function creates a file with unique name by modifying the<b> template</b> argument, and returns its file
 handle open for reading and writing in binary mode.&nbsp; The use of<tt> mkstemp</tt> prevents any possible race condition
 between testing whether the file exists and opening it for use.
<br>The string<b> template</b> has the form<tt> baseXXXXXX</tt> where<tt> base</tt> is the fixed part of the generated filename
 and<tt> XXXXXX</tt> is the variable part of the generated filename.&nbsp; Each of the 6 X's is a placeholder for a character
 supplied by<tt> mkstemp</tt>.&nbsp; Each placeholder character in<b> template</b> must be an uppercase &quot;X&quot;.<tt>
&nbsp; mkstemp</tt> preserves<tt> base</tt> and replaces the first of the 6 trailing X's with a unique sequence of alphanumeric
 characters.&nbsp; The string<b> template</b> therefore must be writable.
<br><br><tt>mkstemp</tt> checks to see if a file with the generated name already exists and if so selects another name, until
 it finds a file that doesn't exist.&nbsp; If it is unsuccessful at finding a name for a file that does not already exist
 or is unable to create a file,<tt> mkstemp</tt> returns -1.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> mkstemp</tt> function returns a file handle.&nbsp; When an error occurs while creating the file, -1 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#freopen">freopen</a>, <a href="#_mktemp">_mktemp</a>, <a href="#_tempnam">_tempnam</a>,
 <a href="#tmpfile">tmpfile</a>, <a href="#tmpnam">tmpnam</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;unistd.h&gt;</tt>
<br><br><tt>#define TEMPLATE&nbsp;&nbsp;&nbsp; &quot;_tXXXXXX&quot;</tt>
<br><tt>#define MAX_TEMPS&nbsp;&nbsp; 5</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; name&#91;sizeof( TEMPLATE )&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; handles&#91;MAX_TEMPS&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; MAX_TEMPS; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( name, TEMPLATE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handles&#91;i&#93; = mkstemp( name );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( handles&#91;i&#93; == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Failed to create temporary file\n&quot;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Created temporary file '%s'\n&quot;,
 name );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; MAX_TEMPS; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( handles&#91;i&#93; != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handles&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>POSIX
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_mktemp"> _mktemp, _wmktemp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>char *_mktemp( char *template );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *_wmktemp( wchar_t *template );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mktemp</tt> function creates a unique filename by modifying the<b> template</b> argument.<tt>&nbsp; _mktemp</tt>
 automatically handles multibyte-character string arguments as appropriate, recognizing multibyte-character sequences according
 to the multibyte code page currently in use by the run-time system.
<br>The<tt> _wmktemp</tt> function is a wide-character version of<tt> _mktemp</tt> that operates with wide-character strings.
<br><br>The string<b> template</b> has the form<tt> baseXXXXXX</tt> where<tt> base</tt> is the fixed part of the generated
 filename and<tt> XXXXXX</tt> is the variable part of the generated filename.&nbsp; Each of the 6 X's is a placeholder for
 a character supplied by<tt> _mktemp</tt>.&nbsp; Each placeholder character in<b> template</b> must be an uppercase &quot;X&quot;.<tt>
&nbsp; _mktemp</tt> preserves<tt> base</tt> and replaces the first of the 6 trailing X's with a lowercase alphabetic character
 (a-z).<tt>&nbsp; _mktemp</tt> replaces the following 5 trailing X's with a five-digit value this value is a unique number
 identifying the calling process or thread.
<br><br><tt>_mktemp</tt> checks to see if a file with the generated name already exists and if so selects another letter,
 in succession, from &quot;a&quot; to &quot;z&quot; until it finds a file that doesn't exist.&nbsp; If it is unsuccessful
 at finding a name for a file that does not already exist,<tt> _mktemp</tt> returns NULL.&nbsp; At most, 26 unique file names
 can be returned to the calling process or thread.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _mktemp</tt> function returns a pointer to the modified<b> template</b>.&nbsp; The<tt> _mktemp</tt> function returns
 NULL if<b> template</b> is badly formed or no more unique names can be created from the given template.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#freopen">freopen</a>, <a href="#mkstemp">mkstemp</a>, <a href="#_tempnam">_tempnam</a>,
 <a href="#tmpfile">tmpfile</a>, <a href="#tmpnam">tmpnam</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>#define TMPLTE &quot;_tXXXXXX&quot;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char name&#91;sizeof(TMPLTE)&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *mknm;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 30; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy( name, TMPLTE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mknm = _mktemp( name );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( mknm == NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Name is badly formed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Name is %s\n&quot;, mknm );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp = fopen( mknm, &quot;w&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( fp, &quot;Name is %s\n&quot;, mknm );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _mktemp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wmktemp - Win32</tt>
</dl>
<h2 id="mktime"> mktime </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>time_t mktime( struct tm *timeptr );</tt>
<br><br><tt>struct&nbsp; tm {</tt>
<br><tt>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- &#91;0,61&#93; */</tt>
<br><tt>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- &#91;0,59&#93; */</tt>
<br><tt>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,23&#93; */</tt>
<br><tt>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;1,31&#93; */</tt>
<br><tt>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,11&#93; */</tt>
<br><tt>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,6&#93;&nbsp; */</tt>
<br><tt>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,365&#93;*/</tt>
<br><tt>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> mktime</tt> function converts the local time information in the structure pointed to by<b> timeptr</b> into a calendar
 time (Coordinated Universal Time) with the same encoding used by the <tt> time</tt> function.&nbsp; The original values of
 the fields <tt> tm_sec</tt>, <tt> tm_min</tt>, <tt> tm_hour</tt>, <tt> tm_mday</tt>, and <tt> tm_mon</tt> are not restricted
 to ranges described for <tt> struct tm</tt>.&nbsp; If these fields are not in their proper ranges, they are adjusted so that
 they are in the proper ranges.&nbsp; Values for the fields <tt> tm_wday</tt> and <tt> tm_yday</tt> are computed after all
 the other fields have been adjusted.
<br>If the original value of <tt> tm_isdst</tt> is negative, this field is computed also.&nbsp; Otherwise, a value of 0 is
 treated as &quot;daylight savings time is not in effect&quot; and a positive value is treated as &quot;daylight savings time
 is in effect&quot;.
<br><br>Whenever<tt> mktime</tt> is called, the <tt> tzset</tt> function is also called.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> mktime</tt> function returns the converted calendar time.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#asctime_s">asctime_s</a>, <a href="#clock">clock</a>, <a href="#ctime">ctime</a>
 Functions, <a href="#ctime_s">ctime_s</a>, <a href="#difftime">difftime</a>, <a href="#gmtime">gmtime</a>, <a href="#gmtime_s">gmtime_s</a>,
 <a href="#localtime">localtime</a>, <a href="#localtime_s">localtime_s</a>, <a href="#strftime">strftime</a>, <a href="#time">time</a>,
 <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>static const char *week_day&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct tm new_year;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; new_year.tm_year&nbsp; = 2001 - 1900;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; new_year.tm_mon&nbsp;&nbsp; = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; new_year.tm_mday&nbsp; = 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; new_year.tm_hour&nbsp; = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; new_year.tm_min&nbsp;&nbsp; = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; new_year.tm_sec&nbsp;&nbsp; = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; new_year.tm_isdst = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mktime( &amp;new_year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;The 21st century began on a %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; week_day&#91; new_year.tm_wday &#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>The 21st century began on a Monday</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="modf"> modf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double modf( double value, double *iptr );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> modf</tt> function breaks the argument<b> value</b> into integral and fractional parts, each of which has the same
 sign as the argument.&nbsp; It stores the integral part as a<tt> double</tt> in the object pointed to by<b> iptr</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> modf</tt> function returns the signed fractional part of<b> value</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#frexp">frexp</a>, <a href="#ldexp">ldexp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; double integral_value, fractional_part;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fractional_part = modf( 4.5, &amp;integral_value );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f %f\n&quot;, fractional_part, integral_value );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fractional_part = modf( -4.5, &amp;integral_value );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f %f\n&quot;, fractional_part, integral_value );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.500000 4.000000</tt>
<br><tt>-0.500000 -4.000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="movedata"> movedata </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>void movedata( unsigned int src_segment,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int src_offset,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int tgt_segment,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int tgt_offset,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t length );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> movedata</tt> function copies<b> length</b> bytes from the far pointer calculated as<tt> (src_segment:src_offset)</tt>
 to a target location determined as a far pointer<tt> (tgt_segment:tgt_offset).</tt>
<br>Overlapping data may not be correctly copied.&nbsp; When the source and target areas may overlap, copy the areas one character
 at a time.
<br><br>The function is useful to move data when the near address(es) of the source and/or target areas are not known.
</dl>
<dl>
<dt>Returns:
<dd>No value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#FP_SEG">FP_SEG</a>, <a href="#FP_OFF">FP_OFF</a>, <a href="#memcpy">memcpy</a>, <a href="#segread">segread</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;14&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '*', 0x17, 'H', 0x17, 'e', 0x17, 'l', 0x17,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'l', 0x17, 'o', 0x17, '*', 0x17 };</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; movedata( FP_SEG( buffer ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FP_OFF( buffer ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xB800,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0720,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14 );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_moveto"> _moveto, _moveto_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>struct xycoord _FAR _moveto( short x, short y );</tt>
<br><br><tt>struct _wxycoord _FAR _moveto_w( double x, double y );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _moveto</tt> functions set the current output position for graphics.&nbsp; The<tt> _moveto</tt> function uses the
 view coordinate system.&nbsp; The<tt> _moveto_w</tt> function uses the window coordinate system.
<br>The current output position is set to be the point at the coordinates<tt> (x,y).</tt>&nbsp; Nothing is drawn by the function.
&nbsp; The <tt> _lineto</tt> function uses the current output position as the starting point when a line is drawn.
<br><br>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
 text output can be set by use of the <tt> _settextposition</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _moveto</tt> functions return the previous value of the output position for graphics.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getcurrentposition">_getcurrentposition</a>, <a href="#_lineto">_lineto</a>, <a href="#_settextposition">_settextposition</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _lineto( 540, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _lineto( 320, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _lineto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _moveto - DOS, QNX</tt>
<br><tt>_moveto_w - DOS, QNX</tt>
</dl>
<h2 id="_m_packssdw"> _m_packssdw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_packssdw(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>Convert signed packed double-words into signed packed words by packing (with signed saturation) the low-order words of the
 signed double-word elements from<b> m1</b> and<b> m2</b> into the respective signed words of the result.&nbsp; If the signed
 values in the word elements of<b> m1</b> and<b> m2</b> are smaller than 0x8000, the result elements are clamped to 0x8000.
&nbsp; If the signed values in the word elements of<b> m1</b> and<b> m2</b> are larger than 0x7fff, the result elements are
 clamped to 0x7fff.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------&nbsp;&nbsp; ---------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; | w3 : w2 | w1 : w0 |&nbsp;&nbsp; | w3 : w2 | w1 : w0 |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; ---------------------&nbsp;&nbsp; ---------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `--------.`---.&nbsp;&nbsp;&nbsp;&nbsp; .---'.--------'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;
&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp; V</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | w3 | w2 | w1 |
 w0 |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ---------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result</tt>
</dl>
<dl>
<dt>Returns:
<dd>The result of packing, with signed saturation, 32-bit signed double-words into 16-bit signed words is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_packsswb">_m_packsswb</a>, <a href="#_m_packuswb">_m_packuswb</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
 %2.2x %2.2x&quot;</tt>
<br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0000567800001234 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xfffffffe00010101 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_packssdw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_DWORDS&quot; &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32&#91;1&#93;, c._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32&#91;1&#93;, b._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m2=fffffffe 00010101 m1=00005678 00001234</tt>
<br><tt>mm=fffe 7fff 5678 1234</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_packsswb"> _m_packsswb </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_packsswb(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>Convert signed packed words into signed packed bytes by packing (with signed saturation) the low-order bytes of the signed
 word elements from<b> m1</b> and<b> m2</b> into the respective signed bytes of the result.&nbsp; If the signed values in
 the word elements of<b> m1</b> and<b> m2</b> are smaller than 0x80, the result elements are clamped to 0x80.&nbsp; If the
 signed values in the word elements of<b> m1</b> and<b> m2</b> are larger than 0x7f, the result elements are clamped to 0x7f.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 m1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |b7 b6|b5 b4|b3 b2|b1 b0|&nbsp; |b7 b6|b5 b4|b3 b2|b1 b0|</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; `--.&nbsp; .--'&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; `-----.&nbsp; |&nbsp;
 |&nbsp; .-----'&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; `--------.&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp;
 .--------'&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `-----------.&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; .-----------'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 V&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp; V</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result</tt>
</dl>
<dl>
<dt>Returns:
<dd>The result of packing, with signed saturation, 16-bit signed words into 8-bit signed bytes is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_packssdw">_m_packssdw</a>, <a href="#_m_packuswb">_m_packuswb</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
 %2.2x %2.2x&quot;</tt>
<br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_packsswb( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_WORDS&quot; &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;7&#93;, a._8&#91;6&#93;, a._8&#91;5&#93;, a._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;3&#93;, a._8&#91;2&#93;, a._8&#91;1&#93;, a._8&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m2=ff7f ff80 0080 007f m1=0004 0003 0002 0001</tt>
<br><tt>mm=80 80 7f 7f 04 03 02 01</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_packuswb"> _m_packuswb </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_packuswb(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>Convert signed packed words into unsigned packed bytes by packing (with unsigned saturation) the low-order bytes of the signed
 word elements from<b> m1</b> and<b> m2</b> into the respective unsigned bytes of the result.&nbsp; If the signed values in
 the word elements of<b> m1</b> and<b> m2</b> are too large to be represented in an unsigned byte, the result elements are
 clamped to 0xff.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 m1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |b7 b6|b5 b4|b3 b2|b1 b0|&nbsp; |b7 b6|b5 b4|b3 b2|b1 b0|</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;
&nbsp; `--.&nbsp; .--'&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; `-----.&nbsp; |&nbsp;
 |&nbsp; .-----'&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; `--------.&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp;
 .--------'&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `-----------.&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; .-----------'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 V&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp; V</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result</tt>
</dl>
<dl>
<dt>Returns:
<dd>The result of packing, with unsigned saturation, 16-bit signed words into 8-bit unsigned bytes is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_packssdw">_m_packssdw</a>, <a href="#_m_packsswb">_m_packsswb</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
 %2.2x %2.2x&quot;</tt>
<br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_packuswb( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_WORDS&quot; &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;7&#93;, a._8&#91;6&#93;, a._8&#91;5&#93;, a._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;3&#93;, a._8&#91;2&#93;, a._8&#91;1&#93;, a._8&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m2=ff7f ff80 0080 007f m1=0004 0003 0002 0001</tt>
<br><tt>mm=00 00 80 7f 04 03 02 01</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_paddb"> _m_paddb </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_paddb(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The signed or unsigned 8-bit bytes of<b> m2</b> are added to the respective signed or unsigned 8-bit bytes of<b> m1</b> and
 the result is stored in memory.&nbsp; If any result element does not fit into 8 bits (overflow), the lower 8 bits of the
 result elements are stored (i.e., truncation takes place).
</dl>
<dl>
<dt>Returns:
<dd>The result of adding the packed bytes of two 64-bit multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_paddd">_m_paddd</a>, <a href="#_m_paddsb">_m_paddsb</a>, <a href="#_m_paddsw">_m_paddsw</a>,
 <a href="#_m_paddusb">_m_paddusb</a>, <a href="#_m_paddusw">_m_paddusw</a>, <a href="#_m_paddw">_m_paddw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
 %2.2x %2.2x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_paddb( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;7&#93;, b._8&#91;6&#93;, b._8&#91;5&#93;, b._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;3&#93;, b._8&#91;2&#93;, b._8&#91;1&#93;, b._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;7&#93;, c._8&#91;6&#93;, c._8&#91;5&#93;, c._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;3&#93;, c._8&#91;2&#93;, c._8&#91;1&#93;, c._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;7&#93;, a._8&#91;6&#93;, a._8&#91;5&#93;, a._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;3&#93;, a._8&#91;2&#93;, a._8&#91;1&#93;, a._8&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=01 23 45 67 89 ab cd ef</tt>
<br><tt>m2=fe dc ba 98 76 54 32 10</tt>
<br><tt>mm=ff ff ff ff ff ff ff ff</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_paddd"> _m_paddd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_paddd(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The signed or unsigned 32-bit double-words of<b> m2</b> are added to the respective signed or unsigned 32-bit double-words
 of<b> m1</b> and the result is stored in memory.&nbsp; If any result element does not fit into 32 bits (overflow), the lower
 32-bits of the result elements are stored (i.e., truncation takes place).
</dl>
<dl>
<dt>Returns:
<dd>The result of adding the packed double-words of two 64-bit multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_paddb">_m_paddb</a>, <a href="#_m_paddsb">_m_paddsb</a>, <a href="#_m_paddsw">_m_paddsw</a>,
 <a href="#_m_paddusb">_m_paddusb</a>, <a href="#_m_paddusw">_m_paddusw</a>, <a href="#_m_paddw">_m_paddw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_paddd( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32&#91;1&#93;, b._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32&#91;1&#93;, c._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=01234567 89abcdef</tt>
<br><tt>m2=fedcba98 76543210</tt>
<br><tt>mm=ffffffff ffffffff</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_paddsb"> _m_paddsb </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_paddsb(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The signed 8-bit bytes of<b> m2</b> are added to the respective signed 8-bit bytes of<b> m1</b> and the result is stored in
 memory.&nbsp; Saturation occurs when a result exceeds the range of a signed byte.&nbsp; In the case where a result is a byte
 larger than 0x7f (overflow), it is clamped to 0x7f.&nbsp; In the case where a result is a byte smaller than 0x80 (underflow),
 it is clamped to 0x80.
</dl>
<dl>
<dt>Returns:
<dd>The result of adding the packed signed bytes, with saturation, of two 64-bit multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_paddb">_m_paddb</a>, <a href="#_m_paddd">_m_paddd</a>, <a href="#_m_paddsw">_m_paddsw</a>,
 <a href="#_m_paddusb">_m_paddusb</a>, <a href="#_m_paddusw">_m_paddusw</a>, <a href="#_m_paddw">_m_paddw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
 %2.2x %2.2x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_paddsb( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;7&#93;, b._8&#91;6&#93;, b._8&#91;5&#93;, b._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;3&#93;, b._8&#91;2&#93;, b._8&#91;1&#93;, b._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;7&#93;, c._8&#91;6&#93;, c._8&#91;5&#93;, c._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;3&#93;, c._8&#91;2&#93;, c._8&#91;1&#93;, c._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;7&#93;, a._8&#91;6&#93;, a._8&#91;5&#93;, a._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;3&#93;, a._8&#91;2&#93;, a._8&#91;1&#93;, a._8&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=8a ac ce ef 02 24 46 68</tt>
<br><tt>m2=76 54 32 11 fe dc ba 98</tt>
<br><tt>mm=00 00 00 00 00 00 00 00</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_paddsw"> _m_paddsw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_paddsw(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The signed 16-bit words of<b> m2</b> are added to the respective signed 16-bit words of<b> m1</b> and the result is stored
 in memory.&nbsp; Saturation occurs when a result exceeds the range of a signed word.&nbsp; In the case where a result is
 a word larger than 0x7fff (overflow), it is clamped to 0x7fff.&nbsp; In the case where a result is a word smaller than 0x8000
 (underflow), it is clamped to 0x8000.
</dl>
<dl>
<dt>Returns:
<dd>The result of adding the packed signed words, with saturation, of two 64-bit multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_paddb">_m_paddb</a>, <a href="#_m_paddd">_m_paddd</a>, <a href="#_m_paddsb">_m_paddsb</a>,
 <a href="#_m_paddusb">_m_paddusb</a>, <a href="#_m_paddusw">_m_paddusw</a>, <a href="#_m_paddw">_m_paddw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_paddsw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=8aac ceef 0224 4668</tt>
<br><tt>m2=7654 3211 fedc ba98</tt>
<br><tt>mm=0100 0100 0100 0100</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_paddusb"> _m_paddusb </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_paddusb(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The unsigned 8-bit bytes of<b> m2</b> are added to the respective unsigned 8-bit bytes of<b> m1</b> and the result is stored
 in memory.&nbsp; Saturation occurs when a result exceeds the range of an unsigned byte.&nbsp; In the case where a result
 is a byte larger than 0xff (overflow), it is clamped to 0xff.
</dl>
<dl>
<dt>Returns:
<dd>The result of adding the packed unsigned bytes, with saturation, of two 64-bit multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_paddb">_m_paddb</a>, <a href="#_m_paddd">_m_paddd</a>, <a href="#_m_paddsb">_m_paddsb</a>,
 <a href="#_m_paddsw">_m_paddsw</a>, <a href="#_m_paddusw">_m_paddusw</a>, <a href="#_m_paddw">_m_paddw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
 %2.2x %2.2x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_paddusb( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;7&#93;, b._8&#91;6&#93;, b._8&#91;5&#93;, b._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;3&#93;, b._8&#91;2&#93;, b._8&#91;1&#93;, b._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;7&#93;, c._8&#91;6&#93;, c._8&#91;5&#93;, c._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;3&#93;, c._8&#91;2&#93;, c._8&#91;1&#93;, c._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;7&#93;, a._8&#91;6&#93;, a._8&#91;5&#93;, a._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;3&#93;, a._8&#91;2&#93;, a._8&#91;1&#93;, a._8&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=8a ac ce ef 02 24 46 68</tt>
<br><tt>m2=76 54 32 11 fe dc ba 98</tt>
<br><tt>mm=ff ff ff ff ff ff ff ff</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_paddusw"> _m_paddusw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_paddusw(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The unsigned 16-bit words of<b> m2</b> are added to the respective unsigned 16-bit words of<b> m1</b> and the result is stored
 in memory.&nbsp; Saturation occurs when a result exceeds the range of an unsigned word.&nbsp; In the case where a result
 is a word larger than 0xffff (overflow), it is clamped to 0xffff.
</dl>
<dl>
<dt>Returns:
<dd>The result of adding the packed unsigned words, with saturation, of two 64-bit multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_paddb">_m_paddb</a>, <a href="#_m_paddd">_m_paddd</a>, <a href="#_m_paddsb">_m_paddsb</a>,
 <a href="#_m_paddsw">_m_paddsw</a>, <a href="#_m_paddusb">_m_paddusb</a>, <a href="#_m_paddw">_m_paddw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_paddusw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=8aac ceef 0224 4668</tt>
<br><tt>m2=7654 3211 fedc ba98</tt>
<br><tt>mm=ffff ffff ffff ffff</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_paddw"> _m_paddw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_paddw(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The signed or unsigned 16-bit words of<b> m2</b> are added to the respective signed or unsigned 16-bit words of<b> m1</b>
 and the result is stored in memory.&nbsp; If any result element does not fit into 16 bits (overflow), the lower 16 bits of
 the result elements are stored (i.e., truncation takes place).
</dl>
<dl>
<dt>Returns:
<dd>The result of adding the packed words of two 64-bit multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_paddb">_m_paddb</a>, <a href="#_m_paddd">_m_paddd</a>, <a href="#_m_paddsb">_m_paddsb</a>,
 <a href="#_m_paddsw">_m_paddsw</a>, <a href="#_m_paddusb">_m_paddusb</a>, <a href="#_m_paddusw">_m_paddusw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_paddw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=0123 4567 89ab cdef</tt>
<br><tt>m2=fedc ba98 7654 3210</tt>
<br><tt>mm=ffff ffff ffff ffff</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pand"> _m_pand </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pand(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>A bit-wise logical AND is performed between 64-bit multimedia operands<b> m1</b> and<b> m2</b> and the result is stored in
 memory.
</dl>
<dl>
<dt>Returns:
<dd>The bit-wise logical AND of two 64-bit values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pandn">_m_pandn</a>, <a href="#_m_por">_m_por</a>, <a href="#_m_pxor">_m_pxor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pand( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, c, a );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=0123456789abcdef</tt>
<br><tt>m2=fedcba9876543210</tt>
<br><tt>mm=0000000000000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pandn"> _m_pandn </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pandn(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>A bit-wise logical AND is performed on the logical inversion of 64-bit multimedia operand<b> m1</b> and 64-bit multimedia
 operand<b> m2</b> and the result is stored in memory.
</dl>
<dl>
<dt>Returns:
<dd>The bit-wise logical AND of an inverted 64-bit value and a non-inverted value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pand">_m_pand</a>, <a href="#_m_por">_m_por</a>, <a href="#_m_pxor">_m_pxor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pandn( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, c, a );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=0123456789abcdef</tt>
<br><tt>m2=fedcba9876543210</tt>
<br><tt>mm=fedcba9876543210</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pcmpeqb"> _m_pcmpeqb </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pcmpeqb(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>If the respective bytes of<b> m1</b> are equal to the respective bytes of<b> m2</b>, the respective bytes of the result are
 set to all ones, otherwise they are set to all zeros.
</dl>
<dl>
<dt>Returns:
<dd>The result of comparing the packed bytes of two 64-bit multimedia values is returned as a sequence of bytes (0xff for equal,
 0x00 for not equal).
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pcmpeqd">_m_pcmpeqd</a>, <a href="#_m_pcmpeqw">_m_pcmpeqw</a>, <a href="#_m_pcmpgtb">_m_pcmpgtb</a>,
 <a href="#_m_pcmpgtd">_m_pcmpgtd</a>, <a href="#_m_pcmpgtw">_m_pcmpgtw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
 %2.2x %2.2x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pcmpeqb( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;7&#93;, b._8&#91;6&#93;, b._8&#91;5&#93;, b._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;3&#93;, b._8&#91;2&#93;, b._8&#91;1&#93;, b._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;7&#93;, c._8&#91;6&#93;, c._8&#91;5&#93;, c._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;3&#93;, c._8&#91;2&#93;, c._8&#91;1&#93;, c._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;7&#93;, a._8&#91;6&#93;, a._8&#91;5&#93;, a._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;3&#93;, a._8&#91;2&#93;, a._8&#91;1&#93;, a._8&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=00 04 00 03 00 02 00 01</tt>
<br><tt>m2=ff 7f ff 80 00 80 00 7f</tt>
<br><tt>mm=00 00 00 00 ff 00 ff 00</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pcmpeqd"> _m_pcmpeqd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pcmpeqd(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>If the respective double-words of<b> m1</b> are equal to the respective double-words of<b> m2</b>, the respective double-words
 of the result are set to all ones, otherwise they are set to all zeros.
</dl>
<dl>
<dt>Returns:
<dd>The result of comparing the 32-bit packed double-words of two 64-bit multimedia values is returned as a sequence of double-words
 (0xffffffff for equal, 0x00000000 for not equal).
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pcmpeqb">_m_pcmpeqb</a>, <a href="#_m_pcmpeqw">_m_pcmpeqw</a>, <a href="#_m_pcmpgtb">_m_pcmpgtb</a>,
 <a href="#_m_pcmpgtd">_m_pcmpgtd</a>, <a href="#_m_pcmpgtw">_m_pcmpgtw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x000400030002007f };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pcmpeqd( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32&#91;1&#93;, b._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32&#91;1&#93;, c._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=00040003 00020001</tt>
<br><tt>m2=00040003 0002007f</tt>
<br><tt>mm=ffffffff 00000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pcmpeqw"> _m_pcmpeqw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pcmpeqw(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>If the respective words of<b> m1</b> are equal to the respective words of<b> m2</b>, the respective words of the result are
 set to all ones, otherwise they are set to all zeros.
</dl>
<dl>
<dt>Returns:
<dd>The result of comparing the packed words of two 64-bit multimedia values is returned as a sequence of words (0xffff for equal,
 0x0000 for not equal).
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pcmpeqb">_m_pcmpeqb</a>, <a href="#_m_pcmpeqd">_m_pcmpeqd</a>, <a href="#_m_pcmpgtb">_m_pcmpgtb</a>,
 <a href="#_m_pcmpgtd">_m_pcmpgtd</a>, <a href="#_m_pcmpgtw">_m_pcmpgtw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0004ff8000800001 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pcmpeqw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=0004 0003 0002 0001</tt>
<br><tt>m2=0004 ff80 0080 0001</tt>
<br><tt>mm=ffff 0000 0000 ffff</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pcmpgtb"> _m_pcmpgtb </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pcmpgtb(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>If the respective signed bytes of<b> m1</b> are greater than the respective signed bytes of<b> m2</b>, the respective bytes
 of the result are set to all ones, otherwise they are set to all zeros.
</dl>
<dl>
<dt>Returns:
<dd>The result of comparing the packed signed bytes of two 64-bit multimedia values is returned as a sequence of bytes (0xff for
 greater than, 0x00 for not greater than).
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pcmpeqb">_m_pcmpeqb</a>, <a href="#_m_pcmpeqd">_m_pcmpeqd</a>, <a href="#_m_pcmpeqw">_m_pcmpeqw</a>,
 <a href="#_m_pcmpgtd">_m_pcmpgtd</a>, <a href="#_m_pcmpgtw">_m_pcmpgtw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
 %2.2x %2.2x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pcmpgtb( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;7&#93;, b._8&#91;6&#93;, b._8&#91;5&#93;, b._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;3&#93;, b._8&#91;2&#93;, b._8&#91;1&#93;, b._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;7&#93;, c._8&#91;6&#93;, c._8&#91;5&#93;, c._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;3&#93;, c._8&#91;2&#93;, c._8&#91;1&#93;, c._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;7&#93;, a._8&#91;6&#93;, a._8&#91;5&#93;, a._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;3&#93;, a._8&#91;2&#93;, a._8&#91;1&#93;, a._8&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=00 04 00 03 00 02 00 01</tt>
<br><tt>m2=ff 7f ff 80 00 80 00 7f</tt>
<br><tt>mm=ff 00 ff ff 00 ff 00 00</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pcmpgtd"> _m_pcmpgtd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pcmpgtd(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>If the respective signed double-words of<b> m1</b> are greater than the respective signed double-words of<b> m2</b>, the respective
 double-words of the result are set to all ones, otherwise they are set to all zeros.
</dl>
<dl>
<dt>Returns:
<dd>The result of comparing the 32-bit packed signed double-words of two 64-bit multimedia values is returned as a sequence of
 double-words (0xffffffff for greater than, 0x00000000 for not greater than).
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pcmpeqb">_m_pcmpeqb</a>, <a href="#_m_pcmpeqd">_m_pcmpeqd</a>, <a href="#_m_pcmpeqw">_m_pcmpeqw</a>,
 <a href="#_m_pcmpgtb">_m_pcmpgtb</a>, <a href="#_m_pcmpgtw">_m_pcmpgtw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0004000400020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x000400030080007f };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pcmpgtd( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32&#91;1&#93;, b._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32&#91;1&#93;, c._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=00040004 00020001</tt>
<br><tt>m2=00040003 0080007f</tt>
<br><tt>mm=ffffffff 00000000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pcmpgtw"> _m_pcmpgtw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pcmpgtw(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>If the respective signed words of<b> m1</b> are greater than the respective signed words of<b> m2</b>, the respective words
 of the result are set to all ones, otherwise they are set to all zeros.
</dl>
<dl>
<dt>Returns:
<dd>The result of comparing the 16-bit packed signed words of two 64-bit multimedia values is returned as a sequence of words
 (0xffff for greater than, 0x0000 for not greater than).
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pcmpeqb">_m_pcmpeqb</a>, <a href="#_m_pcmpeqd">_m_pcmpeqd</a>, <a href="#_m_pcmpeqw">_m_pcmpeqw</a>,
 <a href="#_m_pcmpgtb">_m_pcmpgtb</a>, <a href="#_m_pcmpgtd">_m_pcmpgtd</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0005000300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0004ff8000800001 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pcmpgtw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=0005 0003 0002 0001</tt>
<br><tt>m2=0004 ff80 0080 0001</tt>
<br><tt>mm=ffff ffff 0000 0000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pmaddwd"> _m_pmaddwd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pmaddwd(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The signed 16-bit words of<b> m1</b> are multiplied with the respective signed 16-bit words of<b> m2</b>.&nbsp; The 32-bit
 intermediate results are summed by pairs producing two 32-bit integers.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MM&#91;63-32&#93; = M1&#91;63-48&#93; x M2&#91;63-48&#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + M1&#91;47-32&#93; x M2&#91;47-32&#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; MM&#91;31-0&#93;&nbsp; = M1&#91;31-16&#93; x M2&#91;31-16&#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + M1&#91;15-0&#93;&nbsp; x M2&#91;15-0&#93;</tt>
<br><br>In cases which overflow, the results are truncated.&nbsp; These two integers are packed into their respective elements
 of the result.
</dl>
<dl>
<dt>Returns:
<dd>The result of multiplying the packed signed 16-bit words of two 64-bit multimedia values and adding the 32-bit results pairwise
 is returned as packed double-words.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pmulhw">_m_pmulhw</a>, <a href="#_m_pmullw">_m_pmullw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0000006000123456 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0000000200010020 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pmaddwd( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=0000 0060 0012 3456</tt>
<br><tt>m2=0000 0002 0001 0020</tt>
<br><tt>mm=000000c0 00068ad2</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pmulhw"> _m_pmulhw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pmulhw(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The signed 16-bit words of<b> m1</b> are multiplied with the respective signed 16-bit words of<b> m2</b>.&nbsp; The high-order
 16-bits of each result are placed in the respective elements of the result.
</dl>
<dl>
<dt>Returns:
<dd>The packed 16-bit words in<b> m1</b> are multiplied with the packed 16-bit words in<b> m2</b> and the high-order 16-bits of
 the results are returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pmaddwd">_m_pmaddwd</a>, <a href="#_m_pmullw">_m_pmullw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x4000006000123456 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0008000210000020 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pmulhw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=4000 0060 0012 3456</tt>
<br><tt>m2=0008 0002 1000 0020</tt>
<br><tt>mm=0002 0000 0001 0006</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pmullw"> _m_pmullw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pmullw(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The signed or unsigned 16-bit words of<b> m1</b> are multiplied with the respective signed or unsigned 16-bit words of<b>
 m2</b>.&nbsp; The low-order 16-bits of each result are placed in the respective elements of the result.
</dl>
<dl>
<dt>Returns:
<dd>The packed 16-bit words in<b> m1</b> are multiplied with the packed 16-bit words in<b> m2</b> and the low-order 16-bits of
 the results are returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pmaddwd">_m_pmaddwd</a>, <a href="#_m_pmulhw">_m_pmulhw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x4000006000123456 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0008000210000020 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pmullw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=4000 0060 0012 3456</tt>
<br><tt>m2=0008 0002 1000 0020</tt>
<br><tt>mm=0000 00c0 2000 8ac0</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_por"> _m_por </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_por(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>A bit-wise logical OR is performed between 64-bit multimedia operands<b> m1</b> and<b> m2</b> and the result is stored in
 memory.
</dl>
<dl>
<dt>Returns:
<dd>The bit-wise logical OR of two 64-bit values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pand">_m_pand</a>, <a href="#_m_pandn">_m_pandn</a>, <a href="#_m_pxor">_m_pxor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_por( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, c, a );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=0123456789abcdef</tt>
<br><tt>m2=fedcba9876543210</tt>
<br><tt>mm=ffffffffffffffff</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pslld"> _m_pslld </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pslld(__m64 *m, __m64 *count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 32-bit double-words in<b> m</b> are each independently shifted to the left by the scalar shift count in<b> count</b>.
&nbsp; The low-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift
 counts greater than 31 yield all zeros.
</dl>
<dl>
<dt>Returns:
<dd>Shift left each 32-bit double-word in<b> m</b> by an amount specified in<b> count</b> while shifting in zeros.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pslldi">_m_pslldi</a>, <a href="#_m_psllq">_m_psllq</a>, <a href="#_m_psllqi">_m_psllqi</a>,
 <a href="#_m_psllw">_m_psllw</a>, <a href="#_m_psllwi">_m_psllwi</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pslld( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32&#91;1&#93;, b._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=3f048003 00020001</tt>
<br><tt>m2=0000000000000002</tt>
<br><tt>mm=fc12000c 00080004</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pslldi"> _m_pslldi </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pslldi(__m64 *m, int count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 32-bit double-words in<b> m</b> are each independently shifted to the left by the scalar shift count in<b> count</b>.
&nbsp; The low-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift
 counts greater than 31 yield all zeros.
</dl>
<dl>
<dt>Returns:
<dd>Shift left each 32-bit double-word in<b> m</b> by an amount specified in<b> count</b> while shifting in zeros.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pslld">_m_pslld</a>, <a href="#_m_psllq">_m_psllq</a>, <a href="#_m_psllqi">_m_psllqi</a>,
 <a href="#_m_psllw">_m_psllw</a>, <a href="#_m_psllwi">_m_psllwi</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pslldi( b, 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32&#91;1&#93;, b._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m =3f048003 00020001</tt>
<br><tt>mm=fc12000c 00080004</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psllq"> _m_psllq </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psllq(__m64 *m, __m64 *count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 64-bit quad-word in<b> m</b> is shifted to the left by the scalar shift count in<b> count</b>.&nbsp; The low-order bits
 are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts greater than 63 yield all zeros.
</dl>
<dl>
<dt>Returns:
<dd>Shift left the 64-bit quad-word in<b> m</b> by an amount specified in<b> count</b> while shifting in zeros.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pslld">_m_pslld</a>, <a href="#_m_pslldi">_m_pslldi</a>, <a href="#_m_psllqi">_m_psllqi</a>,
 <a href="#_m_psllw">_m_psllw</a>, <a href="#_m_psllwi">_m_psllwi</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psllq( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, c, a );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=3f04800300020001</tt>
<br><tt>m2=0000000000000002</tt>
<br><tt>mm=fc12000c00080004</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psllqi"> _m_psllqi </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psllqi(__m64 *m, int count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 64-bit quad-word in<b> m</b> is shifted to the left by the scalar shift count in<b> count</b>.&nbsp; The low-order bits
 are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts greater than 63 yield all zeros.
</dl>
<dl>
<dt>Returns:
<dd>Shift left the 64-bit quad-word in<b> m</b> by an amount specified in<b> count</b> while shifting in zeros.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pslld">_m_pslld</a>, <a href="#_m_pslldi">_m_pslldi</a>, <a href="#_m_psllq">_m_psllq</a>,
 <a href="#_m_psllw">_m_psllw</a>, <a href="#_m_psllwi">_m_psllwi</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psllqi( b, 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, a );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m =3f04800300020001</tt>
<br><tt>mm=fc12000c00080004</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psllw"> _m_psllw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psllw(__m64 *m, __m64 *count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 16-bit words in<b> m</b> are each independently shifted to the left by the scalar shift count in<b> count</b>.&nbsp; The
 low-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts
 greater than 15 yield all zeros.
</dl>
<dl>
<dt>Returns:
<dd>Shift left each 16-bit word in<b> m</b> by an amount specified in<b> count</b> while shifting in zeros.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pslld">_m_pslld</a>, <a href="#_m_pslldi">_m_pslldi</a>, <a href="#_m_psllq">_m_psllq</a>,
 <a href="#_m_psllqi">_m_psllqi</a>, <a href="#_m_psllwi">_m_psllwi</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psllw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=3f04 8003 0002 0001</tt>
<br><tt>m2=0000000000000002</tt>
<br><tt>mm=fc10 000c 0008 0004</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psllwi"> _m_psllwi </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psllwi(__m64 *m, int count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 16-bit words in<b> m</b> are each independently shifted to the left by the scalar shift count in<b> count</b>.&nbsp; The
 low-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts
 greater than 15 yield all zeros.
</dl>
<dl>
<dt>Returns:
<dd>Shift left each 16-bit word in<b> m</b> by an amount specified in<b> count</b> while shifting in zeros.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pslld">_m_pslld</a>, <a href="#_m_pslldi">_m_pslldi</a>, <a href="#_m_psllq">_m_psllq</a>,
 <a href="#_m_psllqi">_m_psllqi</a>, <a href="#_m_psllw">_m_psllw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psllwi( b, 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m =3f04 8003 0002 0001</tt>
<br><tt>mm=fc10 000c 0008 0004</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psrad"> _m_psrad </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psrad(__m64 *m, __m64 *count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 32-bit signed double-words in<b> m</b> are each independently shifted to the right by the scalar shift count in<b> count</b>.
&nbsp; The high-order bits of each element are filled with the initial value of the sign bit of each element.&nbsp; The shift
 count is interpreted as unsigned.&nbsp; Shift counts greater than 31 yield all ones or zeros depending on the initial value
 of the sign bit.
</dl>
<dl>
<dt>Returns:
<dd>Shift right each 32-bit double-word in<b> m</b> by an amount specified in<b> count</b> while shifting in sign bits.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psradi">_m_psradi</a>, <a href="#_m_psraw">_m_psraw</a>, <a href="#_m_psrawi">_m_psrawi</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psrad( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32&#91;1&#93;, b._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=3f048003 00020001</tt>
<br><tt>m2=0000000000000002</tt>
<br><tt>mm=0fc12000 00008000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psradi"> _m_psradi </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psradi(__m64 *m, int count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 32-bit signed double-words in<b> m</b> are each independently shifted to the right by the scalar shift count in<b> count</b>.
&nbsp; The high-order bits of each element are filled with the initial value of the sign bit of each element.&nbsp; The shift
 count is interpreted as unsigned.&nbsp; Shift counts greater than 31 yield all ones or zeros depending on the initial value
 of the sign bit.
</dl>
<dl>
<dt>Returns:
<dd>Shift right each 32-bit double-word in<b> m</b> by an amount specified in<b> count</b> while shifting in sign bits.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psrad">_m_psrad</a>, <a href="#_m_psraw">_m_psraw</a>, <a href="#_m_psrawi">_m_psrawi</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psradi( b, 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32&#91;1&#93;, b._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m =3f048003 00020001</tt>
<br><tt>mm=0fc12000 00008000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psraw"> _m_psraw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psraw(__m64 *m, __m64 *count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 16-bit signed words in<b> m</b> are each independently shifted to the right by the scalar shift count in<b> count</b>.
&nbsp; The high-order bits of each element are filled with the initial value of the sign bit of each element.&nbsp; The shift
 count is interpreted as unsigned.&nbsp; Shift counts greater than 15 yield all ones or zeros depending on the initial value
 of the sign bit.
</dl>
<dl>
<dt>Returns:
<dd>Shift right each 16-bit word in<b> m</b> by an amount specified in<b> count</b> while shifting in sign bits.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psrad">_m_psrad</a>, <a href="#_m_psradi">_m_psradi</a>, <a href="#_m_psrawi">_m_psrawi</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300040001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psraw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=3f04 8003 0004 0001</tt>
<br><tt>m2=0000000000000002</tt>
<br><tt>mm=0fc1 e000 0001 0000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psrawi"> _m_psrawi </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psrawi(__m64 *m, int count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 16-bit signed words in<b> m</b> are each independently shifted to the right by the scalar shift count in<b> count</b>.
&nbsp; The high-order bits of each element are filled with the initial value of the sign bit of each element.&nbsp; The shift
 count is interpreted as unsigned.&nbsp; Shift counts greater than 15 yield all ones or zeros depending on the initial value
 of the sign bit.
</dl>
<dl>
<dt>Returns:
<dd>Shift right each 16-bit word in<b> m</b> by an amount specified in<b> count</b> while shifting in sign bits.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psrad">_m_psrad</a>, <a href="#_m_psradi">_m_psradi</a>, <a href="#_m_psraw">_m_psraw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300040001 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psrawi( b, 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m =3f04 8003 0004 0001</tt>
<br><tt>mm=0fc1 e000 0001 0000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psrld"> _m_psrld </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psrld(__m64 *m, __m64 *count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 32-bit double-words in<b> m</b> are each independently shifted to the right by the scalar shift count in<b> count</b>.
&nbsp; The high-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp;
 Shift counts greater than 31 yield all zeros.
</dl>
<dl>
<dt>Returns:
<dd>Shift right each 32-bit double-word in<b> m</b> by an amount specified in<b> count</b> while shifting in zeros.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psrldi">_m_psrldi</a>, <a href="#_m_psrlq">_m_psrlq</a>, <a href="#_m_psrlqi">_m_psrlqi</a>,
 <a href="#_m_psrlw">_m_psrlw</a>, <a href="#_m_psrlwi">_m_psrlwi</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psrld( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32&#91;1&#93;, b._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=3f048003 00020001</tt>
<br><tt>m2=0000000000000002</tt>
<br><tt>mm=0fc12000 00008000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psrldi"> _m_psrldi </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psrldi(__m64 *m, int count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 32-bit double-words in<b> m</b> are each independently shifted to the right by the scalar shift count in<b> count</b>.
&nbsp; The high-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp;
 Shift counts greater than 31 yield all zeros.
</dl>
<dl>
<dt>Returns:
<dd>Shift right each 32-bit double-word in<b> m</b> by an amount specified in<b> count</b> while shifting in zeros.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psrld">_m_psrld</a>, <a href="#_m_psrlq">_m_psrlq</a>, <a href="#_m_psrlqi">_m_psrlqi</a>,
 <a href="#_m_psrlw">_m_psrlw</a>, <a href="#_m_psrlwi">_m_psrlwi</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psrldi( b, 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32&#91;1&#93;, b._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m =3f048003 00020001</tt>
<br><tt>mm=0fc12000 00008000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psrlq"> _m_psrlq </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psrlq(__m64 *m, __m64 *count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 64-bit quad-word in<b> m</b> is shifted to the right by the scalar shift count in<b> count</b>.&nbsp; The high-order bits
 are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts greater than 63 yield all zeros.
</dl>
<dl>
<dt>Returns:
<dd>Shift right the 64-bit quad-word in<b> m</b> by an amount specified in<b> count</b> while shifting in zeros.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psrld">_m_psrld</a>, <a href="#_m_psrldi">_m_psrldi</a>, <a href="#_m_psrlqi">_m_psrlqi</a>,
 <a href="#_m_psrlw">_m_psrlw</a>, <a href="#_m_psrlwi">_m_psrlwi</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psrlq( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, c, a );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=3f04800300020001</tt>
<br><tt>m2=0000000000000002</tt>
<br><tt>mm=0fc12000c0008000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psrlqi"> _m_psrlqi </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psrlqi(__m64 *m, int count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 64-bit quad-word in<b> m</b> is shifted to the right by the scalar shift count in<b> count</b>.&nbsp; The high-order bits
 are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift counts greater than 63 yield all zeros.
</dl>
<dl>
<dt>Returns:
<dd>Shift right the 64-bit quad-word in<b> m</b> by an amount specified in<b> count</b> while shifting in zeros.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psrld">_m_psrld</a>, <a href="#_m_psrldi">_m_psrldi</a>, <a href="#_m_psrlq">_m_psrlq</a>,
 <a href="#_m_psrlw">_m_psrlw</a>, <a href="#_m_psrlwi">_m_psrlwi</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300020001 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psrlqi( b, 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, a );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m =3f04800300020001</tt>
<br><tt>mm=0fc12000c0008000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psrlw"> _m_psrlw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psrlw(__m64 *m, __m64 *count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 16-bit words in<b> m</b> are each independently shifted to the right by the scalar shift count in<b> count</b>.&nbsp;
 The high-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift
 counts greater than 15 yield all zeros.
</dl>
<dl>
<dt>Returns:
<dd>Shift right each 16-bit word in<b> m</b> by an amount specified in<b> count</b> while shifting in zeros.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psrld">_m_psrld</a>, <a href="#_m_psrldi">_m_psrldi</a>, <a href="#_m_psrlq">_m_psrlq</a>,
 <a href="#_m_psrlqi">_m_psrlqi</a>, <a href="#_m_psrlwi">_m_psrlwi</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300040001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0000000000000002 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psrlw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=3f04 8003 0004 0001</tt>
<br><tt>m2=0000000000000002</tt>
<br><tt>mm=0fc1 2000 0001 0000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psrlwi"> _m_psrlwi </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psrlwi(__m64 *m, int count);</tt>
</dl>
<dl>
<dt>Description:
<dd>The 16-bit words in<b> m</b> are each independently shifted to the right by the scalar shift count in<b> count</b>.&nbsp;
 The high-order bits of each element are filled with zeros.&nbsp; The shift count is interpreted as unsigned.&nbsp; Shift
 counts greater than 15 yield all zeros.
</dl>
<dl>
<dt>Returns:
<dd>Shift right each 16-bit word in<b> m</b> by an amount specified in<b> count</b> while shifting in zeros.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psrld">_m_psrld</a>, <a href="#_m_psrldi">_m_psrldi</a>, <a href="#_m_psrlq">_m_psrlq</a>,
 <a href="#_m_psrlqi">_m_psrlqi</a>, <a href="#_m_psrlw">_m_psrlw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x3f04800300040001 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psrlwi( b, 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m =&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m =3f04 8003 0004 0001</tt>
<br><tt>mm=0fc1 2000 0001 0000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psubb"> _m_psubb </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psubb(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The signed or unsigned 8-bit bytes of<b> m2</b> are subtracted from the respective signed or unsigned 8-bit bytes of<b> m1</b>
 and the result is stored in memory.&nbsp; If any result element does not fit into 8 bits (underflow or overflow), the lower
 8 bits of the result elements are stored (i.e., truncation takes place).
</dl>
<dl>
<dt>Returns:
<dd>The result of subtracting the packed bytes of one 64-bit multimedia value from another is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psubd">_m_psubd</a>, <a href="#_m_psubsb">_m_psubsb</a>, <a href="#_m_psubsw">_m_psubsw</a>,
 <a href="#_m_psubusb">_m_psubusb</a>, <a href="#_m_psubusw">_m_psubusw</a>, <a href="#_m_psubw">_m_psubw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
 %2.2x %2.2x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psubb( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;7&#93;, b._8&#91;6&#93;, b._8&#91;5&#93;, b._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;3&#93;, b._8&#91;2&#93;, b._8&#91;1&#93;, b._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;7&#93;, c._8&#91;6&#93;, c._8&#91;5&#93;, c._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;3&#93;, c._8&#91;2&#93;, c._8&#91;1&#93;, c._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;7&#93;, a._8&#91;6&#93;, a._8&#91;5&#93;, a._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;3&#93;, a._8&#91;2&#93;, a._8&#91;1&#93;, a._8&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=01 23 45 67 89 ab cd ef</tt>
<br><tt>m2=fe dc ba 98 76 54 32 10</tt>
<br><tt>mm=03 47 8b cf 13 57 9b df</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psubd"> _m_psubd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psubd(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The signed or unsigned 32-bit double-words of<b> m2</b> are subtracted from the respective signed or unsigned 32-bit double-words
 of<b> m1</b> and the result is stored in memory.&nbsp; If any result element does not fit into 32 bits (underflow or overflow),
 the lower 32-bits of the result elements are stored (i.e., truncation takes place).
</dl>
<dl>
<dt>Returns:
<dd>The result of subtracting one set of packed double-words from a second set of packed double-words is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psubb">_m_psubb</a>, <a href="#_m_psubsb">_m_psubsb</a>, <a href="#_m_psubsw">_m_psubsw</a>,
 <a href="#_m_psubusb">_m_psubusb</a>, <a href="#_m_psubusw">_m_psubusw</a>, <a href="#_m_psubw">_m_psubw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psubd( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32&#91;1&#93;, b._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32&#91;1&#93;, c._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=01234567 89abcdef</tt>
<br><tt>m2=fedcba98 76543210</tt>
<br><tt>mm=02468acf 13579bdf</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psubsb"> _m_psubsb </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psubsb(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The signed 8-bit bytes of<b> m2</b> are subtracted from the respective signed 8-bit bytes of<b> m1</b> and the result is stored
 in memory.&nbsp; Saturation occurs when a result exceeds the range of a signed byte.&nbsp; In the case where a result is
 a byte larger than 0x7f (overflow), it is clamped to 0x7f.&nbsp; In the case where a result is a byte smaller than 0x80 (underflow),
 it is clamped to 0x80.
</dl>
<dl>
<dt>Returns:
<dd>The result of subtracting the packed signed bytes, with saturation, of one 64-bit multimedia value from a second multimedia
 value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psubb">_m_psubb</a>, <a href="#_m_psubd">_m_psubd</a>, <a href="#_m_psubsw">_m_psubsw</a>,
 <a href="#_m_psubusb">_m_psubusb</a>, <a href="#_m_psubusw">_m_psubusw</a>, <a href="#_m_psubw">_m_psubw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
 %2.2x %2.2x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psubsb( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;7&#93;, b._8&#91;6&#93;, b._8&#91;5&#93;, b._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;3&#93;, b._8&#91;2&#93;, b._8&#91;1&#93;, b._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;7&#93;, c._8&#91;6&#93;, c._8&#91;5&#93;, c._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;3&#93;, c._8&#91;2&#93;, c._8&#91;1&#93;, c._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;7&#93;, a._8&#91;6&#93;, a._8&#91;5&#93;, a._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;3&#93;, a._8&#91;2&#93;, a._8&#91;1&#93;, a._8&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=8a ac ce ef 02 24 46 68</tt>
<br><tt>m2=76 54 32 11 fe dc ba 98</tt>
<br><tt>mm=80 80 9c de 04 48 7f 7f</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psubsw"> _m_psubsw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psubsw(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The signed 16-bit words of<b> m2</b> are subtracted from the respective signed 16-bit words of<b> m1</b> and the result is
 stored in memory.&nbsp; Saturation occurs when a result exceeds the range of a signed word.&nbsp; In the case where a result
 is a word larger than 0x7fff (overflow), it is clamped to 0x7fff.&nbsp; In the case where a result is a word smaller than
 0x8000 (underflow), it is clamped to 0x8000.
</dl>
<dl>
<dt>Returns:
<dd>The result of subtracting the packed signed words, with saturation, of one 64-bit multimedia value from a second multimedia
 value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psubb">_m_psubb</a>, <a href="#_m_psubd">_m_psubd</a>, <a href="#_m_psubsb">_m_psubsb</a>,
 <a href="#_m_psubusb">_m_psubusb</a>, <a href="#_m_psubusw">_m_psubusw</a>, <a href="#_m_psubw">_m_psubw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psubsw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=8aac ceef 0224 4668</tt>
<br><tt>m2=7654 3211 fedc ba98</tt>
<br><tt>mm=8000 9cde 0348 7fff</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psubusb"> _m_psubusb </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psubusb(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The unsigned 8-bit bytes of<b> m2</b> are subtracted from the respective unsigned 8-bit bytes of<b> m1</b> and the result
 is stored in memory.&nbsp; Saturation occurs when a result is less than zero.&nbsp; If a result is less than zero, it is
 clamped to 0xff.
</dl>
<dl>
<dt>Returns:
<dd>The result of subtracting the packed unsigned bytes, with saturation, of one 64-bit multimedia value from a second multimedia
 value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psubb">_m_psubb</a>, <a href="#_m_psubd">_m_psubd</a>, <a href="#_m_psubsb">_m_psubsb</a>,
 <a href="#_m_psubsw">_m_psubsw</a>, <a href="#_m_psubusw">_m_psubusw</a>, <a href="#_m_psubw">_m_psubw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
 %2.2x %2.2x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psubusb( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;7&#93;, b._8&#91;6&#93;, b._8&#91;5&#93;, b._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;3&#93;, b._8&#91;2&#93;, b._8&#91;1&#93;, b._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;7&#93;, c._8&#91;6&#93;, c._8&#91;5&#93;, c._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;3&#93;, c._8&#91;2&#93;, c._8&#91;1&#93;, c._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;7&#93;, a._8&#91;6&#93;, a._8&#91;5&#93;, a._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;3&#93;, a._8&#91;2&#93;, a._8&#91;1&#93;, a._8&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=8a ac ce ef 02 24 46 68</tt>
<br><tt>m2=76 54 32 11 fe dc ba 98</tt>
<br><tt>mm=14 58 9c de 00 00 00 00</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psubusw"> _m_psubusw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psubusw(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The unsigned 16-bit words of<b> m2</b> are subtracted from the respective unsigned 16-bit words of<b> m1</b> and the result
 is stored in memory.&nbsp; Saturation occurs when a result is less than zero.&nbsp; If a result is less than zero, it is
 clamped to 0xffff.
</dl>
<dl>
<dt>Returns:
<dd>The result of subtracting the packed unsigned words, with saturation, of one 64-bit multimedia value from a second multimedia
 value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psubb">_m_psubb</a>, <a href="#_m_psubd">_m_psubd</a>, <a href="#_m_psubsb">_m_psubsb</a>,
 <a href="#_m_psubsw">_m_psubsw</a>, <a href="#_m_psubusb">_m_psubusb</a>, <a href="#_m_psubw">_m_psubw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x8aacceef02244668 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x76543211fedcba98 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psubusw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=8aac ceef 0224 4668</tt>
<br><tt>m2=7654 3211 fedc ba98</tt>
<br><tt>mm=1458 9cde 0000 0000</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_psubw"> _m_psubw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_psubw(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The signed or unsigned 16-bit words of<b> m2</b> are subtracted from the respective signed or unsigned 16-bit words of<b>
 m1</b> and the result is stored in memory.&nbsp; If any result element does not fit into 16 bits (underflow or overflow),
 the lower 16 bits of the result elements are stored (i.e., truncation takes place).
</dl>
<dl>
<dt>Returns:
<dd>The result of subtracting the packed words of two 64-bit multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_psubb">_m_psubb</a>, <a href="#_m_psubd">_m_psubd</a>, <a href="#_m_psubsb">_m_psubsb</a>,
 <a href="#_m_psubsw">_m_psubsw</a>, <a href="#_m_psubusb">_m_psubusb</a>, <a href="#_m_psubusw">_m_psubusw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_psubw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=0123 4567 89ab cdef</tt>
<br><tt>m2=fedc ba98 7654 3210</tt>
<br><tt>mm=0247 8acf 1357 9bdf</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_punpckhbw"> _m_punpckhbw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_punpckhbw(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _m_punpckhbw</tt> function performs an interleaved unpack of the high-order data elements of<b> m1</b> and<b> m2</b>.
&nbsp; It ignores the low-order bytes.&nbsp; When unpacking from a memory operand, the full 64-bit operand is accessed from
 memory but only the high-order 32 bits are utilized.&nbsp; By choosing<b> m1</b> or<b> m2</b> to be zero, an unpacking of
 byte elements into word elements is performed.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 m1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp; |&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp; V&nbsp; V&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp; V&nbsp; V&nbsp; V</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b7 b5 b3 b1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; b6 b4 b2 b0</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result</tt>
</dl>
<dl>
<dt>Returns:
<dd>The result of the interleaved unpacking of the high-order bytes of two multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_punpckhdq">_m_punpckhdq</a>, <a href="#_m_punpckhwd">_m_punpckhwd</a>, <a href="#_m_punpcklbw">_m_punpcklbw</a>,
 <a href="#_m_punpckldq">_m_punpckldq</a>, <a href="#_m_punpcklwd">_m_punpcklwd</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
 %2.2x %2.2x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_punpckhbw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_BYTES&quot; &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;7&#93;, c._8&#91;6&#93;, c._8&#91;5&#93;, c._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;3&#93;, c._8&#91;2&#93;, c._8&#91;1&#93;, c._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;7&#93;, b._8&#91;6&#93;, b._8&#91;5&#93;, b._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;3&#93;, b._8&#91;2&#93;, b._8&#91;1&#93;, b._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;7&#93;, a._8&#91;6&#93;, a._8&#91;5&#93;, a._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;3&#93;, a._8&#91;2&#93;, a._8&#91;1&#93;, a._8&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m2=ff 7f ff 80 00 80 00 7f m1=00 04 00 03 00 02 00 01</tt>
<br><tt>mm=ff 00 7f 04 ff 00 80 03</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_punpckhdq"> _m_punpckhdq </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_punpckhdq(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _m_punpckhdq</tt> function performs an interleaved unpack of the high-order data elements of<b> m1</b> and<b> m2</b>.
&nbsp; It ignores the low-order double-words.&nbsp; When unpacking from a memory operand, the full 64-bit operand is accessed
 from memory but only the high-order 32 bits are utilized.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 m1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d0&nbsp;&nbsp;&nbsp;
 |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d0&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d0</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d0&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result</tt>
</dl>
<dl>
<dt>Returns:
<dd>The result of the interleaved unpacking of the high-order double-words of two multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_punpckhbw">_m_punpckhbw</a>, <a href="#_m_punpckhwd">_m_punpckhwd</a>, <a href="#_m_punpcklbw">_m_punpcklbw</a>,
 <a href="#_m_punpckldq">_m_punpckldq</a>, <a href="#_m_punpcklwd">_m_punpcklwd</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_punpckhdq( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_DWORDS&quot; &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32&#91;1&#93;, c._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32&#91;1&#93;, b._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m2=ff7fff80 0080007f m1=00040003 00020001</tt>
<br><tt>mm=ff7fff80 00040003</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_punpckhwd"> _m_punpckhwd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_punpckhwd(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _m_punpckhwd</tt> function performs an interleaved unpack of the high-order data elements of<b> m1</b> and<b> m2</b>.
&nbsp; It ignores the low-order words.&nbsp; When unpacking from a memory operand, the full 64-bit operand is accessed from
 memory but only the high-order 32 bits are utilized.&nbsp; By choosing<b> m1</b> or<b> m2</b> to be zero, an unpacking of
 word elements into double-word elements is performed.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 m1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; w3 |&nbsp; w2 |&nbsp; w1 |&nbsp; w0 |&nbsp; |&nbsp; w3 |&nbsp; w2 |&nbsp; w1 |&nbsp;
 w0 |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp; V</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w3&nbsp;&nbsp;&nbsp; w1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; w2&nbsp;&nbsp;&nbsp; w0</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
 w3 |&nbsp; w2 |&nbsp; w1 |&nbsp; w0 |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result</tt>
</dl>
<dl>
<dt>Returns:
<dd>The result of the interleaved unpacking of the high-order words of two multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_punpckhbw">_m_punpckhbw</a>, <a href="#_m_punpckhdq">_m_punpckhdq</a>, <a href="#_m_punpcklbw">_m_punpcklbw</a>,
 <a href="#_m_punpckldq">_m_punpckldq</a>, <a href="#_m_punpcklwd">_m_punpcklwd</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_punpckhwd( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_WORDS&quot; &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m2=ff7f ff80 0080 007f m1=0004 0003 0002 0001</tt>
<br><tt>mm=ff7f 0004 ff80 0003</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_punpcklbw"> _m_punpcklbw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_punpcklbw(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _m_punpcklbw</tt> function performs an interleaved unpack of the low-order data elements of<b> m1</b> and<b> m2</b>.
&nbsp; It ignores the high-order bytes.&nbsp; When unpacking from a memory operand, 32 bits are accessed and all are utilized
 by the instruction.&nbsp; By choosing<b> m1</b> or<b> m2</b> to be zero, an unpacking of byte elements into word elements
 is performed.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 m1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |b3|b2|b1|b0|&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;
 |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;
 |&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp; V&nbsp;
 V&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp; V&nbsp;
 V&nbsp; V</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b7 b5 b3 b1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b6 b4 b2 b0</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |b7|b6|b5|b4|b3|b2|b1|b0|</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result</tt>
</dl>
<dl>
<dt>Returns:
<dd>The result of the interleaved unpacking of the low-order bytes of two multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_punpckhbw">_m_punpckhbw</a>, <a href="#_m_punpckhdq">_m_punpckhdq</a>, <a href="#_m_punpckhwd">_m_punpckhwd</a>,
 <a href="#_m_punpckldq">_m_punpckldq</a>, <a href="#_m_punpcklwd">_m_punpcklwd</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_BYTES &quot;%2.2x %2.2x %2.2x %2.2x &quot; \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2x %2.2x
 %2.2x %2.2x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x000200013478bcf0 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0x0080007f12569ade };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_punpcklbw( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_BYTES&quot; &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_BYTES&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_BYTES&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;7&#93;, c._8&#91;6&#93;, c._8&#91;5&#93;, c._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._8&#91;3&#93;, c._8&#91;2&#93;, c._8&#91;1&#93;, c._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;7&#93;, b._8&#91;6&#93;, b._8&#91;5&#93;, b._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._8&#91;3&#93;, b._8&#91;2&#93;, b._8&#91;1&#93;, b._8&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;7&#93;, a._8&#91;6&#93;, a._8&#91;5&#93;, a._8&#91;4&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._8&#91;3&#93;, a._8&#91;2&#93;, a._8&#91;1&#93;, a._8&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m2=00 80 00 7f 12 56 9a de m1=00 02 00 01 34 78 bc f0</tt>
<br><tt>mm=12 34 56 78 9a bc de f0</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_punpckldq"> _m_punpckldq </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_punpckldq(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _m_punpckldq</tt> function performs an interleaved unpack of the low-order data elements of<b> m1</b> and<b> m2</b>.
&nbsp; It ignores the high-order double-words.&nbsp; When unpacking from a memory operand, 32 bits are accessed and all are
 utilized by the instruction.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 m1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d0&nbsp;&nbsp;&nbsp;
 |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d0&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; V</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d0</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
&nbsp;&nbsp;&nbsp; d1&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; d0&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result</tt>
</dl>
<dl>
<dt>Returns:
<dd>The result of the interleaved unpacking of the low-order double-words of two multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_punpckhbw">_m_punpckhbw</a>, <a href="#_m_punpckhdq">_m_punpckhdq</a>, <a href="#_m_punpckhwd">_m_punpckhwd</a>,
 <a href="#_m_punpcklbw">_m_punpcklbw</a>, <a href="#_m_punpcklwd">_m_punpcklwd</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_DWORDS &quot;%8.8lx %8.8lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_punpckldq( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_DWORDS&quot; &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_DWORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_DWORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._32&#91;1&#93;, c._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._32&#91;1&#93;, b._32&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._32&#91;1&#93;, a._32&#91;0&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m2=ff7fff80 0080007f m1=00040003 00020001</tt>
<br><tt>mm=0080007f 00020001</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_punpcklwd"> _m_punpcklwd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_punpcklwd(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _m_punpcklwd</tt> function performs an interleaved unpack of the low-order data elements of<b> m1</b> and<b> m2</b>.
&nbsp; It ignores the high-order words.&nbsp; When unpacking from a memory operand, 32 bits are accessed and all are utilized
 by the instruction.&nbsp; By choosing<b> m1</b> or<b> m2</b> to be zero, an unpacking of word elements into double-word elements
 is performed.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m2&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 m1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; w3 |&nbsp; w2 |&nbsp; w1 |&nbsp; w0 |&nbsp; |&nbsp; w3 |&nbsp; w2 |&nbsp; w1 |&nbsp;
 w0 |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; -------------------------&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 V&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; V&nbsp;&nbsp;&nbsp; V</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 w3&nbsp;&nbsp;&nbsp; w1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; w2&nbsp;&nbsp;&nbsp; w0</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;
 w3 |&nbsp; w2 |&nbsp; w1 |&nbsp; w0 |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -------------------------</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result</tt>
</dl>
<dl>
<dt>Returns:
<dd>The result of the interleaved unpacking of the low-order words of two multimedia values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_punpckhbw">_m_punpckhbw</a>, <a href="#_m_punpckhdq">_m_punpckhdq</a>, <a href="#_m_punpckhwd">_m_punpckhwd</a>,
 <a href="#_m_punpcklbw">_m_punpcklbw</a>, <a href="#_m_punpckldq">_m_punpckldq</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_WORDS &quot;%4.4x %4.4x %4.4x %4.4x&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0004000300020001 };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xff7fff800080007f };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_punpcklwd( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m2=&quot;AS_WORDS&quot; &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m1=&quot;AS_WORDS&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_WORDS&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c._16&#91;3&#93;, c._16&#91;2&#93;, c._16&#91;1&#93;, c._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b._16&#91;3&#93;, b._16&#91;2&#93;, b._16&#91;1&#93;, b._16&#91;0&#93;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a._16&#91;3&#93;, a._16&#91;2&#93;, a._16&#91;1&#93;, a._16&#91;0&#93;
 );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m2=ff7f ff80 0080 007f m1=0004 0003 0002 0001</tt>
<br><tt>mm=0080 0002 007f 0001</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_m_pxor"> _m_pxor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>__m64 _m_pxor(__m64 *m1, __m64 *m2);</tt>
</dl>
<dl>
<dt>Description:
<dd>A bit-wise logical XOR is performed between 64-bit multimedia operands<b> m1</b> and<b> m2</b> and the result is stored in
 memory.
</dl>
<dl>
<dt>Returns:
<dd>The bit-wise logical exclusive OR of two 64-bit values is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_pand">_m_pand</a>, <a href="#_m_pandn">_m_pandn</a>, <a href="#_m_por">_m_por</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>#define AS_QWORD &quot;%16.16Lx&quot;</tt>
<br><br><tt>__m64&nbsp;&nbsp; a;</tt>
<br><tt>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</tt>
<br><tt>__m64&nbsp;&nbsp; c = { 0xfedcba9876543210 };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; a = _m_pxor( b, c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m1=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;m2=&quot;AS_QWORD&quot;\n&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;mm=&quot;AS_QWORD&quot;\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, c, a );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m1=0123456789abcdef</tt>
<br><tt>m2=fedcba9876543210</tt>
<br><tt>mm=ffffffffffffffff</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_msize"> _msize Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>size_t _msize( void *buffer );</tt>
<br><tt>size_t _bmsize( __segment seg, void __based(void) *buffer );</tt>
<br><tt>size_t _fmsize( void __far *buffer );</tt>
<br><tt>size_t _nmsize( void __near *buffer );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _msize</tt> functions return the size of the memory block pointed to by<b> buffer</b> that was allocated by a call
 to the appropriate version of the <tt> calloc</tt>, <tt> malloc</tt>, or <tt> realloc</tt> functions.
<br>You must use the correct<tt> _msize</tt> function as listed below depending on which heap the memory block belongs to.
<dl>
<dt>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap
<dt>_msize
<dd>Depends on data model of the program
<dt><br>_bmsize
<dd>Based heap specified by<b> seg</b> value
<dt><br>_fmsize
<dd>Far heap (outside the default data segment)
<dt><br>_nmsize
<dd>Near heap (inside the default data segment)
</dl>
<br>In small data models (small and medium memory models),<tt> _msize</tt> maps to <tt> _nmsize</tt>.&nbsp; In large data
 models (compact, large and huge memory models),<tt> _msize</tt> maps to <tt> _fmsize</tt>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _msize</tt> functions return the size of the memory block pointed to by<b> buffer</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#calloc">calloc</a> Functions, <a href="#_expand">_expand</a> Functions, <a href="#free">free</a> Functions, <a href="#halloc">halloc</a>,
 <a href="#hfree">hfree</a>, <a href="#malloc">malloc</a> Functions, <a href="#realloc">realloc</a> Functions, <a href="#sbrk">sbrk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; void *buffer;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; buffer = malloc( 999 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Size of block is %u bytes\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _msize( buffer ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Size of block is 1000 bytes</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _msize - All, Netware</tt>
<br><tt>_bmsize - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_fmsize - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_nmsize - DOS, Windows, Win386, Win32, QNX, OS/2 1.x, OS/2 1.x(MT), OS/2-32</tt>
</dl>
<h2 id="_m_to_int"> _m_to_int </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><tt>int&nbsp;&nbsp; _m_to_int(__m64 *__m);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _m_to_int</tt> function returns the low-order 32 bits of a multimedia value.
</dl>
<dl>
<dt>Returns:
<dd>The low-order 32 bits of a multimedia value are fetched and returned as the result.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_m_empty">_m_empty</a>, <a href="#_m_from_int">_m_from_int</a>, <a href="#_m_packsswb">_m_packsswb</a>, <a href="#_m_paddb">_m_paddb</a>,
 <a href="#_m_pand">_m_pand</a>, <a href="#_m_empty">_m_empty</a>, <a href="#_m_pcmpeqb">_m_pcmpeqb</a>, <a href="#_m_pmaddwd">_m_pmaddwd</a>,
 <a href="#_m_psllw">_m_psllw</a>, <a href="#_m_psraw">_m_psraw</a>, <a href="#_m_psrlw">_m_psrlw</a>, <a href="#_m_empty">_m_empty</a>,
 <a href="#_m_psubb">_m_psubb</a>, <a href="#_m_punpckhbw">_m_punpckhbw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mmintrin.h&gt;</tt>
<br><br><tt>__m64&nbsp;&nbsp; b = { 0x0123456789abcdef };</tt>
<br><br><tt>int&nbsp;&nbsp;&nbsp;&nbsp; j;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; j = _m_to_int( b );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;m=%16.16Lx int=%8.8lx\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b, j );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>m=0123456789abcdef int=89abcdef</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="nosound"> nosound </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>void nosound( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> nosound</tt> function turns off the PC's speaker.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> nosound</tt> function has no return value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#delay">delay</a>, <a href="#sound">sound</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; sound( 200 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; delay( 500 );&nbsp; /* delay for 1/2 second */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; nosound();</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, QNX
</dl>
<h2 id="offsetof"> offsetof </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stddef.h&gt;</tt>
<br><tt>size_t offsetof( composite, name );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> offsetof</tt> macro returns the offset of the element<b> name</b> within the <tt> struct</tt> or <tt> union</tt><b>
 composite</b>.&nbsp; This provides a portable method to determine the offset.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> offsetof</tt> function returns the offset of<b> name</b>.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stddef.h&gt;</tt>
<br><br><tt>struct new_def</tt>
<br><tt>{&nbsp; char *first;</tt>
<br><tt>&nbsp;&nbsp; char second&#91;10&#93;;</tt>
<br><tt>&nbsp;&nbsp; int third;</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;first:%d second:%d third:%d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof( struct new_def, first ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof( struct new_def, second ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof( struct new_def, third ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br>In a small data model, the following would result:
<br><br><tt>first:0 second:2 third:12</tt>
<br><br>In a large data model, the following would result:
<br><br><tt>first:0 second:4 third:14</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="onexit"> onexit </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>onexit_t onexit( onexit_t func );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> onexit</tt> function is passed the address of function<b> func</b> to be called when the program terminates normally.
&nbsp; Successive calls to<tt> onexit</tt> create a list of functions that will be executed on a &quot;last-in, first-out&quot;
 basis.&nbsp; No more than 32 functions can be registered with the<tt> onexit</tt> function.
<br>The functions have no parameters and do not return values.
<br><br>NOTE:&nbsp; The<tt> onexit</tt> function is not an ANSI function.&nbsp; The ANSI standard function <tt> atexit</tt>
 does the same thing that<tt> onexit</tt> does and should be used instead of<tt> onexit</tt> where ANSI portability is concerned.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> onexit</tt> function returns<b> func</b> if the registration succeeds, NULL if it fails.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abort">abort</a>, <a href="#atexit">atexit</a>, <a href="#exit">exit</a>, <a href="#_exit">_exit</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; extern void func1(void), func2(void), func3(void);</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; onexit( func1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; onexit( func2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; onexit( func3 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Do this first.\n&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void func1(void) { printf( &quot;last.\n&quot; ); }</tt>
<br><tt>void func2(void) { printf( &quot;this &quot; ); }</tt>
<br><tt>void func3(void) { printf( &quot;Do &quot; ); }</tt>
<br><br>produces the following:
<br><br><tt>Do this first.</tt>
<br><tt>Do this last.</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="open"> open, _open, _wopen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>int open( const char *path, int access, ... );</tt>
<br><tt>int _open( const char *path, int access, ... );</tt>
<br><tt>int _wopen( const wchar_t *path, int access, ... );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> open</tt> function opens a file at the operating system level.&nbsp; The name of the file to be opened is given by<b>
 path</b>.&nbsp; The file will be accessed according to the access mode specified by<b> access</b>.&nbsp; The optional argument
 is the file permissions to be used when the <tt> O_CREAT</tt> flag is on in the<b> access</b> mode.
<br>The<tt> _open</tt> function is identical to<tt> open</tt>.&nbsp; Use<tt> _open</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _wopen</tt> function is identical to<tt> open</tt> except that it accepts a wide character string argument
 for<b> path</b>.
<br><br>The access mode is established by a combination of the bits defined in the<tt> &lt;fcntl.h&gt;</tt> header file.&nbsp;
 The following bits may be set:
<dl>
<dt>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>O_RDONLY
<dd>permit the file to be only read.
<dt><br>O_WRONLY
<dd>permit the file to be only written.
<dt><br>O_RDWR
<dd>permit the file to be both read and written.
<dt><br>O_APPEND
<dd>causes each record that is written to be written at the end of the file.
<dt><br>O_CREAT
<dd>has no effect when the file indicated by<b> filename</b> already exists; otherwise, the file is created;
<dt><br>O_TRUNC
<dd>causes the file to be truncated to contain no data when the file exists; has no effect when the file does not exist.
<dt><br>O_BINARY
<dd>causes the file to be opened in binary mode which means that data will be transmitted to and from the file unchanged.
<dt><br>O_TEXT
<dd>causes the file to be opened in text mode which means that carriage-return characters are written before any linefeed character
 that is written and causes carriage-return characters to be removed when encountered during reads.
<dt><br>O_NOINHERIT
<dd>indicates that this file is not to be inherited by a child process.
<dt><br>O_EXCL
<dd>indicates that this file is to be opened for exclusive access.&nbsp; If the file exists and <tt> O_CREAT</tt> was also specified
 then the open will fail (i.e., use <tt> O_EXCL</tt> to ensure that the file does not already exist).
</dl>
<br>When neither <tt> O_TEXT</tt> nor <tt> O_BINARY</tt> are specified, the default value in the global variable <tt> _fmode</tt>
 is used to set the file translation mode.&nbsp; When the program begins execution, this variable has a value of <tt> O_TEXT</tt>.
<br><br><tt> O_CREAT</tt> must be specified when the file does not exist and it is to be written.
<br><br>When the file is to be created (<tt> O_CREAT</tt> is specified), an additional argument must be passed which contains
 the file permissions to be used for the new file.&nbsp; The access permissions for the file or directory are specified as
 a combination of bits (defined in the<tt> &lt;sys\stat.h&gt;</tt> header file).
<br><br>The following bits define permissions for the owner.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXU
<dd>Read, write, execute/search
<dt><br>S_IRUSR
<dd>Read permission
<dt><br>S_IWUSR
<dd>Write permission
<dt><br>S_IXUSR
<dd>Execute/search permission
</dl>
<br>The following bits define permissions for the group.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXG
<dd>Read, write, execute/search
<dt><br>S_IRGRP
<dd>Read permission
<dt><br>S_IWGRP
<dd>Write permission
<dt><br>S_IXGRP
<dd>Execute/search permission
</dl>
<br>The following bits define permissions for others.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXO
<dd>Read, write, execute/search
<dt><br>S_IROTH
<dd>Read permission
<dt><br>S_IWOTH
<dd>Write permission
<dt><br>S_IXOTH
<dd>Execute/search permission
</dl>
<br>The following bits define miscellaneous permissions used by other implementations.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IREAD
<dd>is equivalent to S_IRUSR (read permission)
<dt><br>S_IWRITE
<dd>is equivalent to S_IWUSR (write permission)
<dt><br>S_IEXEC
<dd>is equivalent to S_IXUSR (execute/search permission)
</dl>
<br>All files are readable with DOS; however, it is a good idea to set <tt> S_IREAD</tt> when read permission is intended
 for the file.
<br><br>The<tt> open</tt> function applies the current file permission mask to the specified permissions (see <tt> umask</tt>).
</dl>
<dl>
<dt>Returns:
<dd>If successful,<tt> open</tt> returns a handle for the file.&nbsp; When an error occurs while opening the file, -1 is returned.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EACCES
<dd>Access denied because<b> path</b> specifies a directory or a volume ID, or attempting to open a read-only file for writing
<dt><br>EMFILE
<dd>No more handles available (too many open files)
<dt><br>ENOENT
<dd>Path or file not found
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#chsize">chsize</a>, <a href="#close">close</a>, <a href="#creat">creat</a>, <a href="#dup">dup</a>, <a href="#dup2">dup2</a>,
 <a href="#eof">eof</a>, <a href="#exec___">exec...</a>, <a href="#fdopen">fdopen</a>, <a href="#filelength">filelength</a>,
 <a href="#fileno">fileno</a>, <a href="#fstat">fstat</a>, <a href="#_grow_handles">_grow_handles</a>, <a href="#isatty">isatty</a>,
 <a href="#lseek">lseek</a>, <a href="#read">read</a>, <a href="#setmode">setmode</a>, <a href="#sopen">sopen</a>, <a href="#stat">stat</a>,
 <a href="#tell">tell</a>, <a href="#write">write</a>, <a href="#umask">umask</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* open a file for output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* replace existing file if it exists&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
 | S_IWGRP );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* read a file which is assumed to exist&nbsp;&nbsp; */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* append to the end of an existing file&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* write a new file if file does not exist */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_APPEND,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
 | S_IWGRP );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>open is POSIX 1003.1
<br>_open is not POSIX
<br>_wopen is not POSIX
<br>_open conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> open - All, Netware</tt>
<br><tt>_open - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wopen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="opendir"> opendir, _wopendir </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><tt>struct dirent *opendir( const char *dirname );</tt>
<br><tt>struct _wdirent *_wopendir( const wchar_t *dirname );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> opendir</tt> function is used in conjunction with the functions <tt> readdir</tt> and <tt> closedir</tt> to obtain
 the list of file names contained in the directory specified by<b> dirname</b>.&nbsp; The path indicated by<b> dirname</b>
 can be either relative to the current working directory or it can be an absolute path name.&nbsp; As an extension to POSIX,
 the last part of<b> dirname</b> can contain the characters '?' and '*' for matching multiple files within a directory.
<br>The file<tt> &lt;direct.h&gt;</tt> contains definitions for the structure <tt> dirent</tt>.
<br><br><tt>#if defined(__OS2__) || defined(__NT__)</tt>
<br><tt>#define NAME_MAX 255&nbsp;&nbsp;&nbsp; /* maximum for HPFS or NTFS */</tt>
<br><tt>#else</tt>
<br><tt>#define NAME_MAX&nbsp; 12&nbsp;&nbsp;&nbsp; /* 8 chars + '.' +&nbsp; 3 chars */</tt>
<br><tt>#endif</tt>
<br><br><tt>typedef struct dirent {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_dta&#91; 21 &#93;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disk transfer
 area */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_attr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; /* file's attribute */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short int d_time;&nbsp; /* file's time */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short int d_date;&nbsp; /* file's date */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; d_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; /* file's size */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_name&#91; NAME_MAX + 1 &#93;; /* file's name */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short d_ino;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* serial number */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_first;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 /* flag for 1st time */</tt>
<br><tt>} DIR;</tt>
<br>The file attribute field <tt> d_attr</tt> field is a set of bits representing the following attributes.
<br><br><tt>_A_RDONLY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Read-only file */</tt>
<br><tt>_A_HIDDEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Hidden file */</tt>
<br><tt>_A_SYSTEM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* System file */</tt>
<br><tt>_A_VOLID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Volume-ID entry (only MSFT knows) */</tt>
<br><tt>_A_SUBDIR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Subdirectory */</tt>
<br><tt>_A_ARCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Archive file */</tt>
<br>If the<tt> _A_RDONLY</tt> bit is off, then the file is read/write.
<br><br>The format of the <tt> d_time</tt> field is described by the following structure (this structure is not defined in
 any Watcom header file).
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; twosecs : 5;&nbsp;&nbsp;&nbsp; /* seconds / 2 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; minutes : 6;&nbsp;&nbsp;&nbsp; /* minutes (0,59) */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; hours&nbsp;&nbsp; : 5;&nbsp;&nbsp;&nbsp; /* hours (0,23) */</tt>
<br><tt>} ftime_t;</tt>
<br>The format of the <tt> d_date</tt> field is described by the following structure (this structure is not defined in any
 Watcom header file).
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; day&nbsp;&nbsp;&nbsp;&nbsp; : 5;&nbsp;&nbsp;&nbsp; /* day (1,31) */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; month&nbsp;&nbsp; : 4;&nbsp;&nbsp;&nbsp; /* month (1,12) */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; year&nbsp;&nbsp;&nbsp; : 7;&nbsp;&nbsp;&nbsp; /* 0 is 1980 */</tt>
<br><tt>} fdate_t;</tt>
<br>See the sample program below for an example of the use of these structures.
<br><br>More than one directory can be read at the same time using the <tt> opendir</tt>, <tt> readdir</tt>, and <tt> closedir</tt>
 functions.
<br><br>The<tt> _wopendir</tt> function is identical to<tt> opendir</tt> except that it accepts a wide-character string argument
 and returns a pointer to a <tt> _wdirent</tt> structure that can be used with the <tt> _wreaddir</tt> and <tt> _wclosedir</tt>
 functions.
<br><br>The file<tt> &lt;direct.h&gt;</tt> contains definitions for the structure <tt> _wdirent</tt>.
<br><br><tt>struct _wdirent {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_dta&#91;21&#93;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disk transfer area */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_attr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file's attribute
 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short int d_time;/* file's time */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short int d_date;/* file's date */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; d_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file's size */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wchar_t d_name&#91;NAME_MAX+1&#93;;/* file's name */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short d_ino;&nbsp;&nbsp; /* serial number (not used) */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_first;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* flag for 1st time
 */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> opendir</tt> function, if successful, returns a pointer to a structure required for subsequent calls to <tt> readdir</tt>
 to retrieve the file names matching the pattern specified by<b> dirname</b>.&nbsp; The<tt> opendir</tt> function returns<tt>
 NULL</tt> if<b> dirname</b> is not a valid pathname, or if there are no files matching<b> dirname</b>.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EACCES
<dd>Search permission is denied for a component of<b> dirname</b> or read permission is denied for<b> dirname</b>.
<dt><br>ENOENT
<dd>The named directory does not exist.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#closedir">closedir</a>, <a href="#_dos_find___">_dos_find...</a>, <a href="#readdir">readdir</a>, <a href="#rewinddir">rewinddir</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>To get a list of files contained in the directory<tt> \watcom\h</tt> on your default disk:
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; twosecs : 5;&nbsp;&nbsp;&nbsp; /* seconds / 2 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; minutes : 6;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; hours&nbsp;&nbsp; : 5;</tt>
<br><tt>} ftime_t;</tt>
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; day&nbsp;&nbsp;&nbsp;&nbsp; : 5;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; month&nbsp;&nbsp; : 4;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; year&nbsp;&nbsp;&nbsp; : 7;</tt>
<br><tt>} fdate_t;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; DIR *dirp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct dirent *direntp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ftime_t *f_time;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fdate_t *f_date;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; dirp = opendir( &quot;\\watcom\\h&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( dirp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp = readdir( dirp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( direntp == NULL ) break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time = (ftime_t *)&amp;direntp-&gt;d_time;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date = (fdate_t *)&amp;direntp-&gt;d_date;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%-12s %d/%2.2d/%2.2d &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2d:%2.2d:%2.2d
 \n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp-&gt;d_name,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;year + 1980,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;month,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;day,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;hours,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;minutes,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;twosecs * 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; closedir( dirp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</dl>
<dl>
<dt>Classification:
<dd>opendir is POSIX 1003.1
<br>_wopendir is not POSIX
</dl>
<dl>
<dt>Systems:
<dd><tt> opendir - All, Netware</tt>
<br><tt>_wopendir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_open_osfhandle"> _open_osfhandle </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int _open_osfhandle( long osfhandle, int access );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _open_osfhandle</tt> function allocates a POSIX-level file handle and sets it to point to the operating system's internal
 file handle specified by<b> osfhandle</b>.&nbsp; The value returned by <tt> _get_osfhandle</tt> can be used as an argument
 to the<tt> _open_osfhandle</tt> function.
<br>The access mode is established by a combination of the bits defined in the<tt> &lt;fcntl.h&gt;</tt> header file.&nbsp;
 The following bits may be set:
<dl>
<dt>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>O_RDONLY
<dd>permit the file to be only read.
<dt><br>O_WRONLY
<dd>permit the file to be only written.
<dt><br>O_RDWR
<dd>permit the file to be both read and written.
<dt><br>O_APPEND
<dd>causes each record that is written to be written at the end of the file.
<dt><br>O_CREAT
<dd>has no effect when the file indicated by<b> filename</b> already exists; otherwise, the file is created;
<dt><br>O_TRUNC
<dd>causes the file to be truncated to contain no data when the file exists; has no effect when the file does not exist.
<dt><br>O_BINARY
<dd>causes the file to be opened in binary mode which means that data will be transmitted to and from the file unchanged.
<dt><br>O_TEXT
<dd>causes the file to be opened in text mode which means that carriage-return characters are written before any linefeed character
 that is written and causes carriage-return characters to be removed when encountered during reads.
<dt><br>O_NOINHERIT
<dd>indicates that this file is not to be inherited by a child process.
<dt><br>O_EXCL
<dd>indicates that this file is to be opened for exclusive access.&nbsp; If the file exists and <tt> O_CREAT</tt> was also specified
 then the open will fail (i.e., use <tt> O_EXCL</tt> to ensure that the file does not already exist).
</dl>
<br>When neither <tt> O_TEXT</tt> nor <tt> O_BINARY</tt> are specified, the default value in the global variable <tt> _fmode</tt>
 is used to set the file translation mode.&nbsp; When the program begins execution, this variable has a value of <tt> O_TEXT</tt>.
<br><br><tt> O_CREAT</tt> must be specified when the file does not exist and it is to be written.
<br><br>When two or more manifest constants are used to form the<b> flags</b> argument, the constants are combined with the
 bitwise-OR operator (|).
<br><br>The example below demonstrates the use of the <tt> _get_osfhandle</tt> and<tt> _open_osfhandle</tt> functions.&nbsp;
 Note that the example shows how the <tt> dup2</tt> function can be used to obtain almost identical functionality.
<br><br>When the POSIX-level file handles associated with one OS file handle are closed, the first one closes successfully
 but the others return an error (since the first call close the file and released the OS file handle).&nbsp; So it is important
 to call <tt> close</tt> at the right time, i.e., after all I/O operations are completed to the file.
</dl>
<dl>
<dt>Returns:
<dd>If successful,<tt> _open_osfhandle</tt> returns a POSIX-style file handle.&nbsp; Otherwise, it returns -1.
</dl>
<dl>
<dt>See Also:
<dd><a href="#close">close</a>, <a href="#_dos_open">_dos_open</a>, <a href="#dup2">dup2</a>, <a href="#fdopen">fdopen</a>, <a href="#fopen">fopen</a>,
 <a href="#freopen">freopen</a>, <a href="#_fsopen">_fsopen</a>, <a href="#_get_osfhandle">_get_osfhandle</a>, <a href="#_grow_handles">_grow_handles</a>,
 <a href="#_hdopen">_hdopen</a>, <a href="#open">open</a>, <a href="#_os_handle">_os_handle</a>, <a href="#_popen">_popen</a>,
 <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long os_handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int fh1, fh2, rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fh1 = open( &quot;file&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC
 | O_BINARY,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
 | S_IWGRP );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fh1 == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Could not open output file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;First POSIX handle %d\n&quot;, fh1 );</tt>
<br><br><tt>#if defined(USE_DUP2)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fh2 = 6;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( dup2( fh1, fh2 ) == -1 ) fh2 = -1;</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; os_handle = _get_osfhandle( fh1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;OS Handle %ld\n&quot;, os_handle );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fh2 = _open_osfhandle( os_handle, O_WRONLY |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_BINARY );</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fh2 == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Could not open with second handle\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Second POSIX handle %d\n&quot;, fh2 );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = write( fh2, &quot;trash\x0d\x0a&quot;, 7 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Write file using second handle %d\n&quot;, rc );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = close( fh2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Closing second handle %d\n&quot;, rc );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = close( fh1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Closing first handle %d\n&quot;, rc );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_os_handle"> _os_handle </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int _os_handle( int handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _os_handle</tt> function takes a POSIX-style file handle specified by<b> handle</b>.&nbsp; It returns the corresponding
 operating system level handle.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _os_handle</tt> function returns the operating system handle that corresponds to the specified POSIX-style file handle.
</dl>
<dl>
<dt>See Also:
<dd><a href="#close">close</a>, <a href="#fdopen">fdopen</a>, <a href="#_get_osfhandle">_get_osfhandle</a>, <a href="#_hdopen">_hdopen</a>,
 <a href="#open">open</a>, <a href="#_open_osfhandle">_open_osfhandle</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle = _os_handle( fileno( fp ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Netware
</dl>
<h2 id="_outgtext"> _outgtext </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _outgtext( char _FAR *text );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _outgtext</tt> function displays the character string indicated by the argument<b> text</b>.&nbsp; The string must
 be terminated by a null character ('\0').
<br>The string is displayed starting at the current position (see the <tt> _moveto</tt> function) in the current color and
 in the currently selected font (see the <tt> _setfont</tt> function).&nbsp; The current position is updated to follow the
 displayed text.
<br><br>When no font has been previously selected with <tt> _setfont</tt>, a default font will be used.&nbsp; The default
 font is an 8-by-8 bit-mapped font.
<br><br>The graphics library can display text in three different ways.
<ol>
<li>The <tt> _outtext</tt> and <tt> _outmem</tt> functions can be used in any video mode.&nbsp; However, this variety of text
 can be displayed in only one size.
<li>The <tt> _grtext</tt> function displays text as a sequence of line segments, and can be drawn in different sizes, with
 different orientations and alignments.
<li>The <tt> _outgtext</tt> function displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts
 are supported; the size and type of text depends on the fonts that are available.
</ol>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _outgtext</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_setfont">_setfont</a>,
 <a href="#_getfontinfo">_getfontinfo</a>, <a href="#_getgtextextent">_getgtextextent</a>, <a href="#_setgtextvector">_setgtextvector</a>,
 <a href="#_getgtextvector">_getgtextvector</a>, <a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_grtext">_grtext</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i, n;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 10 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; n = _registerfonts( &quot;*.fon&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; n; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;n%d&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setfont( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _clearscreen( _GCLEARSCREEN );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _unregisterfonts();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>_outgtext is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_outmem"> _outmem </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _outmem( char _FAR *text, short length );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _outmem</tt> function displays the character string indicated by the argument<b> text</b>.&nbsp; The argument<b> length</b>
 specifies the number of characters to be displayed.&nbsp; Unlike the <tt> _outtext</tt> function,<tt> _outmem</tt> will display
 the graphical representation of characters such as ASCII 10 and 0, instead of interpreting them as control characters.
<br>The text is displayed using the current text color (see the <tt> _settextcolor</tt> function), starting at the current
 text position (see the <tt> _settextposition</tt> function).&nbsp; The text position is updated to follow the end of the
 displayed text.
<br><br>The graphics library can display text in three different ways.
<ol>
<li>The <tt> _outtext</tt> and <tt> _outmem</tt> functions can be used in any video mode.&nbsp; However, this variety of text
 can be displayed in only one size.
<li>The <tt> _grtext</tt> function displays text as a sequence of line segments, and can be drawn in different sizes, with
 different orientations and alignments.
<li>The <tt> _outgtext</tt> function displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts
 are supported; the size and type of text depends on the fonts that are available.
</ol>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _outmem</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextcolor">_settextcolor</a>, <a href="#_settextposition">_settextposition</a>, <a href="#_settextwindow">_settextwindow</a>,
 <a href="#_grtext">_grtext</a>, <a href="#_outtext">_outtext</a>, <a href="#_outgtext">_outgtext</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 1 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _clearscreen( _GCLEARSCREEN );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt;= 255; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _settextposition( 1 + i % 16,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 + 5 * ( i / 16 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf&#91; 0 &#93; = i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outmem( buf, 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="outp"> outp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>unsigned int outp( int port, int value );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> outp</tt> function writes one byte, determined by<b> value</b>, to the 80x86 hardware port whose number is given by<b>
 port</b>.
<br>A hardware port is used to communicate with a device.&nbsp; One or two bytes can be read and/or written from each port,
 depending upon the hardware.&nbsp; Consult the technical documentation for your computer to determine the port numbers for
 a device and the expected usage of each port for a device.
</dl>
<dl>
<dt>Returns:
<dd>The value transmitted is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#inp">inp</a>, <a href="#inpd">inpd</a>, <a href="#inpw">inpw</a>, <a href="#outpd">outpd</a>, <a href="#outpw">outpw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* turn off speaker */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; outp( 0x61, inp( 0x61 ) &amp; 0xFC );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="outpd"> outpd </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>unsigned long outpd( int port,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 unsigned long value );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> outpd</tt> function writes a double-word (four bytes), determined by<b> value</b>, to the 80x86 hardware port whose
 number is given by<b> port</b>.
<br>A hardware port is used to communicate with a device.&nbsp; One or two bytes can be read and/or written from each port,
 depending upon the hardware.&nbsp; Consult the technical documentation for your computer to determine the port numbers for
 a device and the expected usage of each port for a device.
</dl>
<dl>
<dt>Returns:
<dd>The value transmitted is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#inp">inp</a>, <a href="#inpd">inpd</a>, <a href="#inpw">inpw</a>, <a href="#outp">outp</a>, <a href="#outpw">outpw</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#define DEVICE 34</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; outpd( DEVICE, 0x12345678 );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>DOS/32, Win386, Win32, QNX/32, OS/2-32, Netware
</dl>
<h2 id="outpw"> outpw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>unsigned int outpw( int port,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 unsigned int value );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> outpw</tt> function writes a word (two bytes), determined by<b> value</b>, to the 80x86 hardware port whose number
 is given by<b> port</b>.
<br>A hardware port is used to communicate with a device.&nbsp; One or two bytes can be read and/or written from each port,
 depending upon the hardware.&nbsp; Consult the technical documentation for your computer to determine the port numbers for
 a device and the expected usage of each port for a device.
</dl>
<dl>
<dt>Returns:
<dd>The value transmitted is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#inp">inp</a>, <a href="#inpd">inpd</a>, <a href="#inpw">inpw</a>, <a href="#outp">outp</a>, <a href="#outpd">outpd</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#define DEVICE 34</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; outpw( DEVICE, 0x1234 );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_outtext"> _outtext </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _outtext( char _FAR *text );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _outtext</tt> function displays the character string indicated by the argument<b> text</b>.&nbsp; The string must
 be terminated by a null character ('\0').&nbsp; When a line-feed character ('\n') is encountered in the string, the characters
 following will be displayed on the next row of the screen.
<br>The text is displayed using the current text color (see the <tt> _settextcolor</tt> function), starting at the current
 text position (see the <tt> _settextposition</tt> function).&nbsp; The text position is updated to follow the end of the
 displayed text.
<br><br>The graphics library can display text in three different ways.
<ol>
<li>The <tt> _outtext</tt> and <tt> _outmem</tt> functions can be used in any video mode.&nbsp; However, this variety of text
 can be displayed in only one size.
<li>The <tt> _grtext</tt> function displays text as a sequence of line segments, and can be drawn in different sizes, with
 different orientations and alignments.
<li>The <tt> _outgtext</tt> function displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts
 are supported; the size and type of text depends on the fonts that are available.
</ol>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _outtext</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextcolor">_settextcolor</a>, <a href="#_settextposition">_settextposition</a>, <a href="#_settextwindow">_settextwindow</a>,
 <a href="#_grtext">_grtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_outgtext">_outgtext</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextposition( 10, 30 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( &quot;WATCOM Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pclose"> _pclose </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int _pclose( FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pclose</tt> function closes the pipe associated with<b> fp</b> and waits for the subprocess created by <tt> _popen</tt>
 to terminate.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pclose</tt> function returns the termination status of the command language interpreter.&nbsp; If an error occured,<tt>
 _pclose</tt> returns (-1) with <tt> errno</tt> set appropriately.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt><b><i>Constant</i></b>
<dd><b><i>Meaning</i></b>
<dt><br>EINTR
<dd>The<tt> _pclose</tt> function was interrupted by a signal while waiting for the child process to terminate.
<dt><br>ECHILD
<dd>The<tt> _pclose</tt> function was unable to obtain the termination status of the child process.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#perror">perror</a>, <a href="#_pipe">_pipe</a>, <a href="#_popen">_popen</a>
</dl>
<dl>
<dt>Example:
<dd>See example provided with<tt> _popen.</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="perror"> perror, _wperror </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>void perror( const char *prefix );</tt>
<br><tt>void _wperror( const wchar_t *prefix );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> perror</tt> function prints, on the file designated by <tt> stderr</tt>, the error message corresponding to the error
 number contained in <tt> errno</tt>.&nbsp; The<tt> perror</tt> function writes first the string pointed to by<b> prefix</b>
 to stderr.&nbsp; This is followed by a colon (&quot;:&quot;), a space, the string returned by<tt> strerror(errno)</tt>, and
 a newline character.
<br>The<tt> _wperror</tt> function is identical to<tt> perror</tt> except that it accepts a wide-character string argument
 and produces wide-character output.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> perror</tt> function returns no value.&nbsp; Because<tt> perror</tt> uses the <tt> fprintf</tt> function, <tt> errno</tt>
 can be set when an error is detected during the execution of that function.
</dl>
<dl>
<dt>See Also:
<dd><a href="#clearerr">clearerr</a>, <a href="#feof">feof</a>, <a href="#ferror">ferror</a>, <a href="#strerror">strerror</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;data.fil&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;Unable to open file&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>perror is ANSI
<br>_wperror is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> perror - All, Netware</tt>
<br><tt>_wperror - All</tt>
</dl>
<h2 id="_pg_analyzechart"> _pg_analyzechart, _pg_analyzechartms </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_analyzechart( chartenv _FAR *env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *cat,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *values, short n );</tt>
<br><br><tt>short _FAR _pg_analyzechartms( chartenv _FAR *env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *cat,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *values,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short nseries,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short n, short dim,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *labels );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_analyzechart</tt> functions analyze either a single-series or a multi-series bar, column or line chart.&nbsp;
 These functions calculate default values for chart elements without actually displaying the chart.
<br>The<tt> _pg_analyzechart</tt> function analyzes a single-series bar, column or line chart.&nbsp; The chart environment
 structure<b> env</b> is filled with default values based on the type of chart and the values of the<b> cat</b> and<b> values</b>
 arguments.&nbsp; The arguments are the same as for the <tt> _pg_chart</tt> function.
<br><br>The<tt> _pg_analyzechartms</tt> function analyzes a multi-series bar, column or line chart.&nbsp; The chart environment
 structure<b> env</b> is filled with default values based on the type of chart and the values of the<b> cat</b>,<b> values</b>
 and<b> labels</b> arguments.&nbsp; The arguments are the same as for the <tt> _pg_chartms</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_analyzechart</tt> functions return zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_analyzepie">_pg_analyzepie</a>,
 <a href="#_pg_analyzescatter">_pg_analyzescatter</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_analyzechart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; categories, values, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* use manual scaling */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.yaxis.autoscale = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.yaxis.scalemin = 0.0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.yaxis.scalemax = 100.0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.yaxis.ticinterval = 25.0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>_pg_analyzechart is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _pg_analyzechart - DOS, QNX</tt>
<br><tt>_pg_analyzechartms - DOS, QNX</tt>
</dl>
<h2 id="_pg_analyzepie"> _pg_analyzepie </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_analyzepie( chartenv _FAR *env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *cat,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *values,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short _FAR *explode, short n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_analyzepie</tt> function analyzes a pie chart.&nbsp; This function calculates default values for chart elements
 without actually displaying the chart.
<br>The chart environment structure<b> env</b> is filled with default values based on the values of the<b> cat</b>,<b> values</b>
 and<b> explode</b> arguments.&nbsp; The arguments are the same as for the <tt> _pg_chartpie</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_analyzepie</tt> function returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_analyzechart">_pg_analyzechart</a>,
 <a href="#_pg_analyzescatter">_pg_analyzescatter</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>short explode&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 1, 0, 0, 0</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_PIECHART, _PG_NOPERCENT );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Pie Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.legend.place = _PG_BOTTOM;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_analyzepie( &amp;env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 values, explode, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* make legend window same width as data window */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.legend.autosize = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.legend.legendwindow.x1 = env.datawindow.x1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.legend.legendwindow.x2 = env.datawindow.x2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chartpie( &amp;env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values, explode,
 NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_analyzescatter"> _pg_analyzescatter, _pg_analyzescatterms </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_analyzescatter( chartenv _FAR *env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *x,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *y, short n );</tt>
<br><br><tt>short _FAR _pg_analyzescatterms(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; chartenv _FAR *env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; float _FAR *x, float _FAR *y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; short nseries, short n, short dim,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char _FAR * _FAR *labels );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_analyzescatter</tt> functions analyze either a single-series or a multi-series scatter chart.&nbsp; These functions
 calculate default values for chart elements without actually displaying the chart.
<br>The<tt> _pg_analyzescatter</tt> function analyzes a single-series scatter chart.&nbsp; The chart environment structure<b>
 env</b> is filled with default values based on the values of the<b> x</b> and<b> y</b> arguments.&nbsp; The arguments are
 the same as for the <tt> _pg_chartscatter</tt> function.
<br><br>The<tt> _pg_analyzescatterms</tt> function analyzes a multi-series scatter chart.&nbsp; The chart environment structure<b>
 env</b> is filled with default values based on the values of the<b> x</b>,<b> y</b> and<b> labels</b> arguments.&nbsp; The
 arguments are the same as for the <tt> _pg_chartscatterms</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_analyzescatter</tt> functions return zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_analyzechart">_pg_analyzechart</a>,
 <a href="#_pg_analyzepie">_pg_analyzepie</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><tt>#define NUM_SERIES 2</tt>
<br><br><tt>char _FAR *labels&#91; NUM_SERIES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float x&#91; NUM_SERIES &#93;&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 5, 15, 30, 40, 10, 20, 30, 45</tt>
<br><tt>};</tt>
<br><br><tt>float y&#91; NUM_SERIES &#93;&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 10, 15, 30, 45, 40, 30, 15, 5</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_SCATTERCHART, _PG_POINTANDLINE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Scatter Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_analyzescatterms( &amp;env, x, y, NUM_SERIES,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NUM_VALUES, NUM_VALUES, labels );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* display x-axis labels with 2 decimal places */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.xaxis.autoscale = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.xaxis.ticdecimals = 2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chartscatterms( &amp;env, x, y, NUM_SERIES,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; NUM_VALUES, NUM_VALUES, labels );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _pg_analyzescatter - DOS, QNX</tt>
<br><tt>_pg_analyzescatterms - DOS, QNX</tt>
</dl>
<h2 id="_pg_chart"> _pg_chart, _pg_chartms </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_chart( chartenv _FAR *env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char _FAR * _FAR *cat,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; float _FAR *values, short n );</tt>
<br><br><tt>short _FAR _pg_chartms( chartenv _FAR *env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *cat,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *values, short nseries,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; short n, short dim,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *labels );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_chart</tt> functions display either a single-series or a multi-series bar, column or line chart.&nbsp; The type
 of chart displayed and other chart options are contained in the<b> env</b> argument.&nbsp; The argument<b> cat</b> is an
 array of strings.&nbsp; These strings describe the categories against which the data in the<b> values</b> array is charted.
<br>The<tt> _pg_chart</tt> function displays a bar, column or line chart from the single series of data contained in the<b>
 values</b> array.&nbsp; The argument<b> n</b> specifies the number of values to chart.
<br><br>The<tt> _pg_chartms</tt> function displays a multi-series bar, column or line chart.&nbsp; The argument<b> nseries</b>
 specifies the number of series of data to chart.&nbsp; The argument<b> values</b> is assumed to be a two-dimensional array
 defined as follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; float values&#91; nseries &#93;&#91; dim &#93;;</tt>
<br><br>The number of values used from each series is given by the argument<b> n</b>, where<b> n</b> is less than or equal
 to<b> dim</b>.&nbsp; The argument<b> labels</b> is an array of strings.&nbsp; These strings describe each of the series and
 are used in the chart legend.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_chart</tt> functions return zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chartpie">_pg_chartpie</a>,
 <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_analyzechart">_pg_analyzechart</a>, <a href="#_pg_analyzepie">_pg_analyzepie</a>,
 <a href="#_pg_analyzescatter">_pg_analyzescatter</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_pgc.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _pg_chart - DOS, QNX</tt>
<br><tt>_pg_chartms - DOS, QNX</tt>
</dl>
<h2 id="_pg_chartpie"> _pg_chartpie </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_chartpie( chartenv _FAR *env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *cat,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *values,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short _FAR *explode, short n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_chartpie</tt> function displays a pie chart.&nbsp; The chart is displayed using the options specified in the<b>
 env</b> argument.
<br>The pie chart is created from the data contained in the<b> values</b> array.&nbsp; The argument<b> n</b> specifies the
 number of values to chart.
<br><br>The argument<b> cat</b> is an array of strings.&nbsp; These strings describe each of the pie slices and are used in
 the chart legend.&nbsp; The argument<b> explode</b> is an array of values corresponding to each of the pie slices.&nbsp;
 For each non-zero element in the array, the corresponding pie slice is drawn &quot;exploded&quot;, or slightly offset from
 the rest of the pie.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_chartpie</tt> function returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_analyzechart">_pg_analyzechart</a>, <a href="#_pg_analyzepie">_pg_analyzepie</a>,
 <a href="#_pg_analyzescatter">_pg_analyzescatter</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>short explode&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 1, 0, 0, 0</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_PIECHART, _PG_NOPERCENT );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Pie Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chartpie( &amp;env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values, explode,
 NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_pgcp.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_chartscatter"> _pg_chartscatter, _pg_chartscatterms </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_chartscatter( chartenv _FAR *env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *x,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *y, short n );</tt>
<br><br><tt>short _FAR _pg_chartscatterms( chartenv _FAR *env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *x,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; float _FAR *y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short nseries,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short n, short dim,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR * _FAR *labels );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_chartscatter</tt> functions display either a single-series or a multi-series scatter chart.&nbsp; The chart is
 displayed using the options specified in the<b> env</b> argument.
<br>The<tt> _pg_chartscatter</tt> function displays a scatter chart from the single series of data contained in the arrays<b>
 x</b> and<b> y</b>.&nbsp; The argument<b> n</b> specifies the number of values to chart.
<br><br>The<tt> _pg_chartscatterms</tt> function displays a multi-series scatter chart.&nbsp; The argument<b> nseries</b>
 specifies the number of series of data to chart.&nbsp; The arguments<b> x</b> and<b> y</b> are assumed to be two-dimensional
 arrays defined as follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; float x&#91; nseries &#93;&#91; dim &#93;;</tt>
<br><br>The number of values used from each series is given by the argument<b> n</b>, where<b> n</b> is less than or equal
 to<b> dim</b>.&nbsp; The argument<b> labels</b> is an array of strings.&nbsp; These strings describe each of the series and
 are used in the chart legend.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_chartscatter</tt> functions return zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_analyzechart">_pg_analyzechart</a>, <a href="#_pg_analyzepie">_pg_analyzepie</a>,
 <a href="#_pg_analyzescatter">_pg_analyzescatter</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><tt>#define NUM_SERIES 2</tt>
<br><br><tt>char _FAR *labels&#91; NUM_SERIES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float x&#91; NUM_SERIES &#93;&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 5, 15, 30, 40, 10, 20, 30, 45</tt>
<br><tt>};</tt>
<br><br><tt>float y&#91; NUM_SERIES &#93;&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 10, 15, 30, 45, 40, 30, 15, 5</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_SCATTERCHART, _PG_POINTANDLINE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Scatter Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chartscatterms( &amp;env, x, y, NUM_SERIES,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; NUM_VALUES, NUM_VALUES, labels );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_pgcs.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _pg_chartscatter - DOS, QNX</tt>
<br><tt>_pg_chartscatterms - DOS, QNX</tt>
</dl>
<h2 id="_pg_defaultchart"> _pg_defaultchart </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_defaultchart( chartenv _FAR *env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short type, short style );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_defaultchart</tt> function initializes the chart structure<b> env</b> to contain default values before a chart
 is drawn.&nbsp; All values in the chart structure are initialized, including blanking of all titles.&nbsp; The chart type
 in the structure is initialized to the value<b> type</b>, and the chart style is initialized to<b> style</b>.
<br>The argument<b> type</b> can have one of the following values:
<dl>
<dt>_PG_BARCHART
<dd>Bar chart (horizontal bars)
<dt><br>_PG_COLUMNCHART
<dd>Column chart (vertical bars)
<dt><br>_PG_LINECHART
<dd>Line chart
<dt><br>_PG_SCATTERCHART
<dd>Scatter chart
<dt><br>_PG_PIECHART
<dd>Pie chart
</dl>
<br>Each type of chart can be drawn in one of two styles.&nbsp; For each chart type the argument<b> style</b> can have one
 of the following values:&nbsp; uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Style 1&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Style 2</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_PLAINBARS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_STACKEDBARS</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Column&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_PLAINBARS&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_STACKEDBARS</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Line&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTANDLINE&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTONLY</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Scatter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTANDLINE&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTONLY</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Pie&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_PERCENT&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_NOPERCENT</tt>
<br><br>For single-series bar and column charts, the chart style is ignored.&nbsp; The &quot;plain&quot; (clustered) and &quot;stacked&quot;
 styles only apply when there is more than one series of data.&nbsp; The &quot;percent&quot; style for pie charts causes percentages
 to be displayed beside each of the pie slices.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_defaultchart</tt> function returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>, <a href="#_pg_chartpie">_pg_chartpie</a>,
 <a href="#_pg_chartscatter">_pg_chartscatter</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_getchardef"> _pg_getchardef </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_getchardef( short ch,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char _FAR *def );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_getchardef</tt> function retrieves the current bit-map definition for the character<b> ch</b>.&nbsp; The bit-map
 is placed in the array<b> def</b>.&nbsp; The current font must be an 8-by-8 bit-mapped font.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_getchardef</tt> function returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_setchardef">_pg_setchardef</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>float x&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 5, 25, 45, 65</tt>
<br><tt>};</tt>
<br><br><tt>float y&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 5, 45, 25, 65</tt>
<br><tt>};</tt>
<br><br><tt>char diamond&#91; 8 &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x10, 0x28, 0x44, 0x82, 0x44, 0x28, 0x10, 0x00</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char old_def&#91; 8 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_SCATTERCHART, _PG_POINTANDLINE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Scatter Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* change asterisk character to diamond */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_getchardef( '*', old_def );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_setchardef( '*', diamond );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chartscatter( &amp;env, x, y, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_setchardef( '*', old_def );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_getpalette"> _pg_getpalette </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_getpalette( paletteentry _FAR *pal );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_getpalette</tt> function retrieves the internal palette of the presentation graphics system.&nbsp; The palette
 controls the colors, line styles, fill patterns and plot characters used to display each series of data in a chart.
<br>The argument<b> pal</b> is an array of palette structures that will contain the palette.&nbsp; Each element of the palette
 is a structure containing the following fields:
<dl>
<dt>color
<dd>color used to display series
<dt><br>style
<dd>line style used for line and scatter charts
<dt><br>fill
<dd>fill pattern used to fill interior of bar and pie sections
<dt><br>plotchar
<dd>character plotted on line and scatter charts
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_getpalette</tt> function returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_setpalette">_pg_setpalette</a>,
 <a href="#_pg_resetpalette">_pg_resetpalette</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>char bricks&#91; 8 &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff, 0x80, 0x80, 0x80, 0xff, 0x08, 0x08, 0x08</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; palettetype pal;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* get default palette and change 1st entry */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_getpalette( &amp;pal );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pal&#91; 1 &#93;.color = 12;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; memcpy( pal&#91; 1 &#93;.fill, bricks, 8 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* use new palette */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_setpalette( &amp;pal );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* reset palette to default */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_resetpalette();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_getstyleset"> _pg_getstyleset </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>void _FAR _pg_getstyleset( unsigned short _FAR *style );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_getstyleset</tt> function retrieves the internal style-set of the presentation graphics system.&nbsp; The style-set
 is a set of line styles used for drawing window borders and grid-lines.&nbsp; The argument<b> style</b> is an array that
 will contain the style-set.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_getstyleset</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_setstyleset">_pg_setstyleset</a>,
 <a href="#_pg_resetstyleset">_pg_resetstyleset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; styleset style;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* turn on yaxis grid, and use style 2 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.yaxis.grid = 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.yaxis.gridstyle = 2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* get default style-set and change entry 2 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_getstyleset( &amp;style );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; style&#91; 2 &#93; = 0x8888;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* use new style-set */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_setstyleset( &amp;style );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* reset style-set to default */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_resetstyleset();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_hlabelchart"> _pg_hlabelchart </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_hlabelchart( chartenv _FAR *env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x, short y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short color,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR *label );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_hlabelchart</tt> function displays the text string<b> label</b> on the chart described by the<b> env</b> chart
 structure.&nbsp; The string is displayed horizontally starting at the point<tt> (x,y),</tt> relative to the upper left corner
 of the chart.&nbsp; The<b> color</b> specifies the palette color used to display the string.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_hlabelchart</tt> function returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_vlabelchart">_pg_vlabelchart</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_hlabelchart( &amp;env, 64, 32, 1, &quot;Horizontal label&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_vlabelchart( &amp;env, 48, 32, 1, &quot;Vertical label&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_initchart"> _pg_initchart </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_initchart( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_initchart</tt> function initializes the presentation graphics system.&nbsp; This includes initializing the internal
 palette and style-set used when drawing charts.&nbsp; This function must be called before any of the other presentation graphics
 functions.
<br>The initialization of the presentation graphics system requires that a valid graphics mode has been selected.&nbsp; For
 this reason the <tt> _setvideomode</tt> function must be called before<tt> _pg_initchart</tt> is called.&nbsp; If a font
 has been selected (with the <tt> _setfont</tt> function), that font will be used when text is displayed in a chart.&nbsp;
 Font selection should also be done before initializing the presentation graphics system.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_initchart</tt> function returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_chart">_pg_chart</a>, <a href="#_pg_chartpie">_pg_chartpie</a>,
 <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_setvideomode">_setvideomode</a>, <a href="#_setfont">_setfont</a>,
 <a href="#_registerfonts">_registerfonts</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_resetpalette"> _pg_resetpalette </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_resetpalette( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_resetpalette</tt> function resets the internal palette of the presentation graphics system to default values.
&nbsp; The palette controls the colors, line styles, fill patterns and plot characters used to display each series of data
 in a chart.&nbsp; The default palette chosen is dependent on the current video mode.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_resetpalette</tt> function returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_getpalette">_pg_getpalette</a>,
 <a href="#_pg_setpalette">_pg_setpalette</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>char bricks&#91; 8 &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff, 0x80, 0x80, 0x80, 0xff, 0x08, 0x08, 0x08</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; palettetype pal;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* get default palette and change 1st entry */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_getpalette( &amp;pal );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pal&#91; 1 &#93;.color = 12;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; memcpy( pal&#91; 1 &#93;.fill, bricks, 8 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* use new palette */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_setpalette( &amp;pal );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* reset palette to default */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_resetpalette();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_resetstyleset"> _pg_resetstyleset </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>void _FAR _pg_resetstyleset( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_resetstyleset</tt> function resets the internal style-set of the presentation graphics system to default values.
&nbsp; The style-set is a set of line styles used for drawing window borders and grid-lines.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_resetstyleset</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_getstyleset">_pg_getstyleset</a>,
 <a href="#_pg_setstyleset">_pg_setstyleset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; styleset style;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* turn on yaxis grid, and use style 2 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.yaxis.grid = 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.yaxis.gridstyle = 2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* get default style-set and change entry 2 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_getstyleset( &amp;style );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; style&#91; 2 &#93; = 0x8888;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* use new style-set */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_setstyleset( &amp;style );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* reset style-set to default */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_resetstyleset();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_setchardef"> _pg_setchardef </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_setchardef( short ch,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned char _FAR *def );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_setchardef</tt> function sets the current bit-map definition for the character<b> ch</b>.&nbsp; The bit-map is
 contained in the array<b> def</b>.&nbsp; The current font must be an 8-by-8 bit-mapped font.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_setchardef</tt> function returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_getchardef">_pg_getchardef</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>float x&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 5, 25, 45, 65</tt>
<br><tt>};</tt>
<br><br><tt>float y&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 5, 45, 25, 65</tt>
<br><tt>};</tt>
<br><br><tt>char diamond&#91; 8 &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x10, 0x28, 0x44, 0x82, 0x44, 0x28, 0x10, 0x00</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char old_def&#91; 8 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_SCATTERCHART, _PG_POINTANDLINE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Scatter Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* change asterisk character to diamond */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_getchardef( '*', old_def );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_setchardef( '*', diamond );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chartscatter( &amp;env, x, y, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_setchardef( '*', old_def );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_setpalette"> _pg_setpalette </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_setpalette( paletteentry _FAR *pal );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_setpalette</tt> function sets the internal palette of the presentation graphics system.&nbsp; The palette controls
 the colors, line styles, fill patterns and plot characters used to display each series of data in a chart.
<br>The argument<b> pal</b> is an array of palette structures containing the new palette.&nbsp; Each element of the palette
 is a structure containing the following fields:
<dl>
<dt>color
<dd>color used to display series
<dt><br>style
<dd>line style used for line and scatter charts
<dt><br>fill
<dd>fill pattern used to fill interior of bar and pie sections
<dt><br>plotchar
<dd>character plotted on line and scatter charts
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_setpalette</tt> function returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_getpalette">_pg_getpalette</a>,
 <a href="#_pg_resetpalette">_pg_resetpalette</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>char bricks&#91; 8 &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff, 0x80, 0x80, 0x80, 0xff, 0x08, 0x08, 0x08</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; palettetype pal;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* get default palette and change 1st entry */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_getpalette( &amp;pal );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pal&#91; 1 &#93;.color = 12;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; memcpy( pal&#91; 1 &#93;.fill, bricks, 8 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* use new palette */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_setpalette( &amp;pal );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* reset palette to default */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_resetpalette();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_setstyleset"> _pg_setstyleset </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>void _FAR _pg_setstyleset( unsigned short _FAR *style );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_setstyleset</tt> function retrieves the internal style-set of the presentation graphics system.&nbsp; The style-set
 is a set of line styles used for drawing window borders and grid-lines.&nbsp; The argument<b> style</b> is an array containing
 the new style-set.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_setstyleset</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_getstyleset">_pg_getstyleset</a>,
 <a href="#_pg_resetstyleset">_pg_resetstyleset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; styleset style;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* turn on yaxis grid, and use style 2 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.yaxis.grid = 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; env.yaxis.gridstyle = 2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* get default style-set and change entry 2 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_getstyleset( &amp;style );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; style&#91; 2 &#93; = 0x8888;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* use new style-set */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_setstyleset( &amp;style );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* reset style-set to default */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_resetstyleset();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_vlabelchart"> _pg_vlabelchart </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>short _FAR _pg_vlabelchart( chartenv _FAR *env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x, short y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short color,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char _FAR *label );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_vlabelchart</tt> function displays the text string<b> label</b> on the chart described by the<b> env</b> chart
 structure.&nbsp; The string is displayed vertically starting at the point<tt> (x,y),</tt> relative to the upper left corner
 of the chart.&nbsp; The<b> color</b> specifies the palette color used to display the string.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_vlabelchart</tt> function returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_hlabelchart">_pg_hlabelchart</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;pgchart.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>#if defined ( __386__ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR</tt>
<br><tt>#else</tt>
<br><tt>&nbsp;&nbsp;&nbsp; #define _FAR&nbsp;&nbsp;&nbsp; __far</tt>
<br><tt>#endif</tt>
<br><br><tt>#define NUM_VALUES 4</tt>
<br><br><tt>char _FAR *categories&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;</tt>
<br><tt>};</tt>
<br><br><tt>float values&#91; NUM_VALUES &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 20, 45, 30, 25</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; chartenv env;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_initchart();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_defaultchart( &amp;env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( env.maintitle.title, &quot;Column Chart&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_chart( &amp;env, categories, values, NUM_VALUES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_hlabelchart( &amp;env, 64, 32, 1, &quot;Horizontal label&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pg_vlabelchart( &amp;env, 48, 32, 1, &quot;Vertical label&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pie"> _pie, _pie_w, _pie_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _pie( short fill, short x1, short y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x2, short y2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x3, short y3,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short x4, short y4 );</tt>
<br><br><tt>short _FAR _pie_w( short fill, double x1, double y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x2, double y2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x3, double y3,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x4, double y4 );</tt>
<br><br><tt>short _FAR _pie_wxy( short fill,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; struct _wxycoord _FAR *p1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; struct _wxycoord _FAR *p2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; struct _wxycoord _FAR *p3,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; struct _wxycoord _FAR *p4 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pie</tt> functions draw pie-shaped wedges.&nbsp; The<tt> _pie</tt> function uses the view coordinate system.&nbsp;
 The<tt> _pie_w</tt> and<tt> _pie_wxy</tt> functions use the window coordinate system.
<br>The pie wedges are drawn by drawing an elliptical arc (in the way described for the <tt> _arc</tt> functions) and then
 joining the center of the rectangle that contains the ellipse to the two endpoints of the arc.
<br><br>The elliptical arc is drawn with its center at the center of the rectangle established by the points<tt> (x1,y1)</tt>
 and<tt> (x2,y2).</tt>&nbsp; The arc is a segment of the ellipse drawn within this bounding rectangle.&nbsp; The arc starts
 at the point on this ellipse that intersects the vector from the centre of the ellipse to the point<tt> (x3,y3).</tt>&nbsp;
 The arc ends at the point on this ellipse that intersects the vector from the centre of the ellipse to the point<tt> (x4,y4).</tt>
&nbsp; The arc is drawn in a counter-clockwise direction with the current plot action using the current color and the current
 line style.
<br><br>The following picture illustrates the way in which the bounding rectangle and the vectors specifying the start and
 end points are defined.
<br><br><img src="pic2.bmp" style="vertical-align:middle">
<br>When the coordinates<tt> (x1,y1)</tt> and<tt> (x2,y2)</tt> establish a line or a point (this happens when one or more
 of the x-coordinates or y-coordinates are equal), nothing is drawn.
<br><br>The argument<b> fill</b> determines whether the figure is filled in or has only its outline drawn.&nbsp; The argument
 can have one of two values:
<dl>
<dt>_GFILLINTERIOR
<dd>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<dt><br>_GBORDER
<dd>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
 style
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pie</tt> functions return a non-zero value when the figure was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_arc">_arc</a>, <a href="#_ellipse">_ellipse</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_setfillmask">_setfillmask</a>,
 <a href="#_setlinestyle">_setlinestyle</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pie( _GBORDER, 120, 90, 520, 390,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 140, 20, 190, 460 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_pie.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _pie - DOS, QNX</tt>
<br><tt>_pie_w - DOS, QNX</tt>
<br><tt>_pie_wxy - DOS, QNX</tt>
</dl>
<h2 id="_pipe"> _pipe </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int _pipe( int *phandles, unsigned psize, int textmode );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pipe</tt> function creates a pipe (an unnamed FIFO) and places a file descriptor for the read end of the pipe in<b>
 phandles&#91;0&#93;</b> and a file descriptor for the write end of the pipe in<b> phandles&#91;1&#93;</b>.&nbsp; Their integer
 values are the two lowest available at the time of the<tt> _pipe</tt> function call.&nbsp; The <tt> O_NONBLOCK</tt> flag
 is cleared for both file descriptors.&nbsp; (The <tt> fcntl</tt> call can be used to set the <tt> O_NONBLOCK</tt> flag.)
<br>Data can be written to file descriptor<b> phandles&#91;1&#93;</b> and read from file descriptor<b> phandles&#91;0&#93;</b>.
&nbsp; A read on file descriptor<b> phandles&#91;0&#93;</b> returns the data written to<b> phandles&#91;1&#93;</b> on a first-in-first-out
 (FIFO) basis.
<br><br>This function is typically used to connect together standard utilities to act as filters, passing the write end of
 the pipe to the data producing process as its <tt> STDOUT_FILENO</tt> and the read end of the pipe to the data consuming
 process as its <tt> STDIN_FILENO</tt>.&nbsp; (either via the traditional fork/dup2/exec or the more efficient spawn calls).
<br><br>If successful,<tt> _pipe</tt> marks for update the<b> st_ftime, st_ctime, st_atime</b> and<b> st_mtime</b> fields
 of the pipe for updating.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pipe</tt> function returns zero on success.&nbsp; Otherwise, (-1) is returned and <tt> errno</tt> is set to indicate
 the error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.&nbsp; If
 any of the following conditions occur, the<tt> _pipe</tt> function shall return (-1) and set <tt> errno</tt> to the corresponding
 value:
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EMFILE
<dd>The calling process does not have at least 2 unused file descriptors available.
<dt><br>ENFILE
<dd>The number of simultaneously open files in the system would exceed the configured limit.
<dt><br>ENOSPC
<dd>There is insufficient space available to allocate the pipe buffer.
<dt><br>EROFS
<dd>The pipe pathname space is a read-only filesystem.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#open">open</a>, <a href="#_pclose">_pclose</a>, <a href="#perror">perror</a>, <a href="#_popen">_popen</a>, <a href="#read">read</a>,
 <a href="#write">write</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;stddef.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>#include &lt;process.h&gt;</tt>
<br><br><tt>static int handles&#91;2&#93; = { 0, 0 };</tt>
<br><tt>static int pid;</tt>
<br><br><tt>create_pipe()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( _pipe( (int *)&amp;handles, 2048, _O_BINARY ) == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;create_pipe&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br><tt>create_child( char *name )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buff&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; itoa( handles&#91;0&#93;, buff, 10 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; pid = spawnl( P_NOWAIT, name,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;_pipe&quot;,
 buff, NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; close( handles&#91;0&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( pid == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;create_child&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handles&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br><tt>fill_pipe()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 10; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Child, what is 5 times %d\n&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = write( handles&#91;1&#93;, &amp;i, sizeof( int ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc &lt; sizeof( int ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;fill_pipe&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handles&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* indicate that we are done */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; i = -1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; write( handles&#91;1&#93;, &amp;i, sizeof( int ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; close( handles&#91;1&#93; );</tt>
<br><tt>}</tt>
<br><br><tt>empty_pipe( int in_pipe )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int amt;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for(;;) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; amt = read( in_pipe, &amp;i, sizeof( int ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( amt != sizeof( int ) || i == -1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Parent, 5 times %d is %d\n&quot;, i, 5*i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( amt == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;empty_pipe&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; close( in_pipe );</tt>
<br><tt>}</tt>
<br><br><tt>void main( int argc, char *argv&#91;&#93; )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( argc &lt;= 1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* we are the spawning process */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; create_pipe();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; create_child( argv&#91;0&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fill_pipe();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* we are the spawned process */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; empty_pipe( atoi( argv&#91;1&#93; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; exit( EXIT_SUCCESS );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Child, what is 5 times 1</tt>
<br><tt>Child, what is 5 times 2</tt>
<br><tt>Parent, 5 times 1 is 5</tt>
<br><tt>Parent, 5 times 2 is 10</tt>
<br><tt>Child, what is 5 times 3</tt>
<br><tt>Child, what is 5 times 4</tt>
<br><tt>Parent, 5 times 3 is 15</tt>
<br><tt>Parent, 5 times 4 is 20</tt>
<br><tt>Child, what is 5 times 5</tt>
<br><tt>Child, what is 5 times 6</tt>
<br><tt>Parent, 5 times 5 is 25</tt>
<br><tt>Parent, 5 times 6 is 30</tt>
<br><tt>Child, what is 5 times 7</tt>
<br><tt>Child, what is 5 times 8</tt>
<br><tt>Parent, 5 times 7 is 35</tt>
<br><tt>Parent, 5 times 8 is 40</tt>
<br><tt>Child, what is 5 times 9</tt>
<br><tt>Child, what is 5 times 10</tt>
<br><tt>Parent, 5 times 9 is 45</tt>
<br><tt>Parent, 5 times 10 is 50</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="_polygon"> _polygon, _polygon_w, _polygon_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _polygon( short fill, short numpts,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; struct xycoord _FAR *points );</tt>
<br><br><tt>short _FAR _polygon_w( short fill, short numpts,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double _FAR *points );</tt>
<br><br><tt>short _FAR _polygon_wxy( short fill, short numpts,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *points );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _polygon</tt> functions draw polygons.&nbsp; The<tt> _polygon</tt> function uses the view coordinate system.&nbsp;
 The<tt> _polygon_w</tt> and<tt> _polygon_wxy</tt> functions use the window coordinate system.
<br>The polygon is defined as containing<b> numpts</b> points whose coordinates are given in the array<b> points</b>.
<br><br>The argument<b> fill</b> determines whether the polygon is filled in or has only its outline drawn.&nbsp; The argument
 can have one of two values:
<dl>
<dt>_GFILLINTERIOR
<dd>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<dt><br>_GBORDER
<dd>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
 style
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _polygon</tt> functions return a non-zero value when the polygon was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setcolor">_setcolor</a>, <a href="#_setfillmask">_setfillmask</a>, <a href="#_setlinestyle">_setlinestyle</a>,
 <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>struct xycoord points&#91; 5 &#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 319, 140, 224, 209, 261, 320,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 378, 320, 415, 209</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _polygon( _GBORDER, 5, points );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_polyg.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>_polygon is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _polygon - DOS, QNX</tt>
<br><tt>_polygon_w - DOS, QNX</tt>
<br><tt>_polygon_wxy - DOS, QNX</tt>
</dl>
<h2 id="_popen"> _popen, _wpopen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>FILE *_popen( const char *command, const char *mode );</tt>
<br><tt>FILE *_wpopen( const wchar_t *command, const wchar_t *mode );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _popen</tt> function executes the command specified by<b> command</b> and creates a pipe between the calling process
 and the executed command.
<br>Depending on the<b> mode</b> argument, the stream pointer returned may be used to read from or write to the pipe.
<br><br>The executed command has an environment the same as its parents.&nbsp; The command will be started as follows:&nbsp;
 spawnl(&lt;shell_path&gt;, &lt;shell&gt;, &quot;-c&quot;, command, (char *)NULL);
<br><br>where<tt> &lt;shell_path&gt;</tt> is an unspecified path for the shell utility and<tt> &lt;shell&gt;</tt> is one of
 &quot;command.com&quot; (DOS, Windows 95) or &quot;cmd.exe&quot; (Windows NT/2000, OS/2).
<br><br>The<b> mode</b> argument to<tt> _popen</tt> is a string that specifies an I/O mode for the pipe.
<dl>
<dt>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>&quot;r&quot;
<dd>The calling process will read from the standard output of the child process using the stream pointer returned by<tt> _popen</tt>.
<dt><br>&quot;w&quot;
<dd>The calling process will write to the standard input of the child process using the stream pointer returned by<tt> _popen</tt>.
</dl>
<br>The letter &quot;t&quot; may be added to any of the above modes to indicate that the file is (or must be) a text file
 (i.e., CR/LF pairs are converted to newline characters).
<br><br>The letter &quot;b&quot; may be added to any of the above modes to indicate that the file is (or must be) a binary
 file (an ANSI requirement for portability to systems that make a distinction between text and binary files).
<br><br>When default file translation is specified (i.e., no &quot;t&quot; or &quot;b&quot; is specified), the value of the
 global variable <tt> _fmode</tt> establishes whether the file is to treated as a binary or a text file.&nbsp; Unless this
 value is changed by the program, the default will be text mode.
<br><br>A stream opened by<tt> _popen</tt> should be closed by the <tt> pclose</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _popen</tt> function returns a non-NULL stream pointer upon successful completion.&nbsp; If<tt> _popen</tt> is unable
 to create either the pipe or the subprocess, a<tt> NULL</tt> stream pointer is returned and <tt> errno</tt> is set appropriately.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt><b><i>Constant</i></b>
<dd><b><i>Meaning</i></b>
<dt><br>EINVAL
<dd>The<b> mode</b> argument is invalid.
</dl>
<br><tt>_popen</tt> may also set <tt> errno</tt> values as described by the <tt> _pipe</tt> and <tt> spawnl</tt> functions.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grow_handles">_grow_handles</a>, <a href="#_pclose">_pclose</a>, <a href="#perror">perror</a>, <a href="#_pipe">_pipe</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>/*</tt>
<br><tt> * Executes a given program, converting all</tt>
<br><tt> * output to upper case.</tt>
<br><tt> */</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char&nbsp;&nbsp; buffer&#91;256&#93;;</tt>
<br><br><tt>void main( int argc, char **argv )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp; c;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *f;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; argc; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcat( buffer, argv&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcat( buffer, &quot; &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( ( f = _popen( buffer, &quot;r&quot; ) ) == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perror( &quot;_popen&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( ( c = getc(f) ) != EOF ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( islower( c ) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = toupper( c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar( c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _pclose( f );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _popen - Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wpopen - Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="pow"> pow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double pow( double x, double y );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> pow</tt> function computes<b> x</b> raised to the power<b> y</b>.&nbsp; A domain error occurs if<b> x</b> is zero
 and<b> y</b> is less than or equal to 0, or if<b> x</b> is negative and<b> y</b> is not an integer.&nbsp; A range error may
 occur.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> pow</tt> function returns the value of<b> x</b> raised to the power<b> y</b>.&nbsp; When the argument is outside the
 permissible range, the <tt> matherr</tt> function is called.&nbsp; Unless the default <tt> matherr</tt> function is replaced,
 it will set the global variable <tt> errno</tt> to <tt> EDOM</tt>, and print a &quot;DOMAIN error&quot; diagnostic message
 using the <tt> stderr</tt> stream.
</dl>
<dl>
<dt>See Also:
<dd><a href="#exp">exp</a>, <a href="#log">log</a>, <a href="#sqrt">sqrt</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, pow( 1.5, 2.5 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>2.755676</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="printf"> printf, wprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int printf( const char *format, ... );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int wprintf( const wchar_t *format, ... );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#printf_s">printf_s</a> function which is a safer alternative to<tt> printf</tt>.
&nbsp; This newer<tt> printf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> printf</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> printf</tt> function writes output to the file designated by <tt> stdout</tt> under control of the argument<b> format</b>.
&nbsp; The<b> format</b> string is described below.
<br>The<tt> wprintf</tt> function is identical to<tt> printf</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> printf</tt> function returns the number of characters written, or a negative value if an output error occurred.
<br>The<tt> wprintf</tt> function returns the number of wide characters written, or a negative value if an output error occurred.
&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#sprintf">sprintf</a>,
 <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vprintf">vprintf</a>,
 <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *weekday, *month;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; weekday = &quot;Saturday&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; month = &quot;April&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s, %s %d, %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, 18, 1987 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;f1 = %8.4f f2 = %10.2E x = %#08x i = %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 23.45,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3141.5926,
&nbsp;&nbsp; 0x1db,&nbsp;&nbsp;&nbsp;&nbsp; -1 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Saturday, April 18, 1987</tt>
<br><tt>f1 =&nbsp; 23.4500 f2 =&nbsp; 3.14E+003 x = 0x0001db i = -1</tt>
</dl>
<dl>
<dt>Format Control String:
<dd>The format control string consists of<b> ordinary characters,</b> that are written exactly as they occur in the format string,
 and<b> conversion specifiers,</b> that cause argument values to be written as they are encountered during the processing
 of the format string.&nbsp; An ordinary character in the format string is any character, other than a percent character (%),
 that is not part of a conversion specifier.&nbsp; A conversion specifier is a sequence of characters in the format string
 that begins with a percent character (%) and is followed, in sequence, by the following:
<ul>
<li>zero or more<b> format control flags</b> that can modify the final effect of the format directive;
<li>an optional decimal integer, or an asterisk character ('*'), that specifies a<b> minimum field width</b> to be reserved
 for the formatted item;
<li>an optional<b> precision</b> specification in the form of a period character (.), followed by an optional decimal integer
 or an asterisk character (*);
<li>an optional<b> type length</b> specification:&nbsp; one of &quot;hh&quot;, &quot;h&quot;, &quot;l&quot;, &quot;ll&quot;,
 &quot;j&quot;, &quot;z&quot;, &quot;t&quot;, &quot;L&quot;, &quot;I64&quot;, &quot;w&quot;, &quot;N&quot; or &quot;W&quot;;
 and
<li>a character that specifies the type of conversion to be performed:&nbsp; one of the characters &quot;bcCdeEfFgGinopsSuxX&quot;.
</ul>
<br>The valid format control flags are:
<dl>
<dt>&quot;-&quot;
<dd>the formatted item is left-justified within the field; normally, items are right-justified
<dt><br>&quot;+&quot;
<dd>a signed, positive object will always start with a plus character (+); normally, only negative items begin with a sign
<dt><br>&quot; &quot;
<dd>a signed, positive object will always start with a space character; if both &quot;+&quot; and &quot; &quot; are specified,
 &quot;+&quot; overrides &quot; &quot;
<dt><br>&quot;#&quot;
<dd>an alternate conversion form is used:
<ul>
<li>for &quot;b&quot; (unsigned binary) and &quot;o&quot; (unsigned octal) conversions, the precision is incremented, if necessary,
 so that the first digit is &quot;0&quot;.
<li>for &quot;x&quot; or &quot;X&quot; (unsigned hexadecimal) conversions, a non-zero value is prepended with &quot;0x&quot;
 or &quot;0X&quot; respectively.
<li>for &quot;e&quot;, &quot;E&quot;, &quot;f&quot;, &quot;F&quot;, &quot;g&quot; or &quot;G&quot; (any floating-point) conversions,
 the result always contains a decimal-point character, even if no digits follow it; normally, a decimal-point character appears
 in the result only if there is a digit to follow it.
<li>in addition to the preceding, for &quot;g&quot; or &quot;G&quot; conversions, trailing zeros are not removed from the
 result.
</ul>
</dl>
<br>If no field width is specified, or if the value that is given is less than the number of characters in the converted value
 (subject to any precision value), a field of sufficient width to contain the converted value is used.&nbsp; If the converted
 value has fewer characters than are specified by the field width, the value is padded on the left (or right, subject to the
 left-justification flag) with spaces or zero characters (&quot;0&quot;).&nbsp; If the field width begins with &quot;0&quot;
 and no precision is specified, the value is padded with zeros; otherwise the value is padded with spaces.&nbsp; If the field
 width is &quot;*&quot;, a value of type<tt> int</tt> from the argument list is used (before a precision argument or a conversion
 argument) as the minimum field width.&nbsp; A negative field width value is interpreted as a left-justification flag, followed
 by a positive field width.
<br><br>As with the field width specifier, a precision specifier of &quot;*&quot; causes a value of type<tt> int</tt> from
 the argument list to be used as the precision specifier.&nbsp; If no precision value is given, a precision of 0 is used.
&nbsp; The precision value affects the following conversions:
<ul>
<li>For &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; and &quot;X&quot; (integer)
 conversions, the precision specifies the minimum number of digits to appear.
<li>For &quot;e&quot;, &quot;E&quot;, &quot;f&quot; and &quot;F&quot; (fixed-precision, floating-point) conversions, the precision
 specifies the number of digits to appear after the decimal-point character.
<li>For &quot;g&quot; and &quot;G&quot; (variable-precision, floating-point) conversions, the precision specifies the maximum
 number of significant digits to appear.
<li>For &quot;s&quot; or &quot;S&quot; (string) conversions, the precision specifies the maximum number of characters to appear.
</ul>
<br>A type length specifier affects the conversion as follows:
<ul>
<li>&quot;hh&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
 (integer) format conversion to treat the argument as a<tt> signed char</tt> or<tt> unsigned char</tt> argument.&nbsp; Note
 that, although the argument may have been promoted to an<tt> int</tt> as part of the function call, the value is converted
 to the smaller type before it is formatted.
<li>&quot;hh&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
 of type<tt> signed char.</tt>
<li>&quot;h&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
 (integer) format conversion to treat the argument as a<tt> short int</tt> or<tt> unsigned short int</tt> argument.&nbsp;
 Note that, although the argument may have been promoted to an<tt> int</tt> as part of the function call, the value is converted
 to the smaller type before it is formatted.
<li>&quot;h&quot; causes an &quot;f&quot; format conversion to interpret a<tt> long</tt> argument as a fixed-point number
 consisting of a 16-bit signed integer part and a 16-bit unsigned fractional part.&nbsp; The integer part is in the high 16
 bits and the fractional part is in the low 16 bits.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct fixpt {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short fraction; /* Intel architecture! */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed short integral;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct fixpt foo1 =</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 0x8000, 1234 }; /* represents 1234.5 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct fixpt foo2 =</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 0x8000, -1 };&nbsp;&nbsp; /* represents -0.5 (-1+.5) */</tt>
<br><br>The value is formatted with the same rules as for floating-point values.&nbsp; This is a Watcom extension.
<li>&quot;h&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
 of type<tt> short int.</tt>
<li>&quot;h&quot; causes an &quot;s&quot; operation to treat the argument string as an ASCII character string composed of
 8-bit characters.
<br><br>For <tt> printf</tt> and related byte input/output functions, this specifier is redundant.&nbsp; For <tt> wprintf</tt>
 and related wide character input/output functions, this specifier is required if the argument string is to be treated as
 an 8-bit ASCII character string; otherwise it will be treated as a wide character string.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; printf(&nbsp;&nbsp;&nbsp; &quot;%s%d&quot;, &quot;Num=&quot;, 12345 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; wprintf( L&quot;%hs%d&quot;, &quot;Num=&quot;, 12345 );</tt>
<li>&quot;l&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
 (integer) conversion to process a<tt> long int</tt> or<tt> unsigned long int</tt> argument.
<li>&quot;l&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
 of type<tt> long int.</tt>
<li>&quot;l&quot; or &quot;w&quot; cause an &quot;s&quot; operation to treat the argument string as a wide character string
 (a string composed of characters of type <tt> wchar_t</tt>).
<br><br>For <tt> printf</tt> and related byte input/output functions, this specifier is required if the argument string is
 to be treated as a wide character string; otherwise it will be treated as an 8-bit ASCII character string.&nbsp; For <tt>
 wprintf</tt> and related wide character input/output functions, this specifier is redundant.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; printf(&nbsp; &quot;%ls%d&quot;, L&quot;Num=&quot;, 12345 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; wprintf( L&quot;%s%d&quot;, L&quot;Num=&quot;, 12345 );</tt>
<li>&quot;ll&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
 (integer) conversion to process a<tt> long long</tt> or<tt> unsigned long long</tt> argument (e.g., %lld).
<li>&quot;ll&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
 of type<tt> long long int.</tt>
<li>&quot;j&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
 (integer) conversion to process an<tt> intmax_t</tt> or<tt> uintmax_t</tt> argument.
<li>&quot;j&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
 of type<tt> intmax_t.</tt>
<li>&quot;z&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
 (integer) conversion to process a<tt> size_t</tt> or the corresponding signed integer type argument.
<li>&quot;z&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
 of signed integer type corresponding to<tt> size_t.</tt>
<li>&quot;t&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
 (integer) conversion to process a<tt> ptrdiff_t</tt> or the corresponding unsigned integer type argument.
<li>&quot;t&quot; causes an &quot;n&quot; (converted length assignment) operation to assign the converted length to an object
 of type<tt> ptrdiff_t.</tt>
<li>&quot;I64&quot; causes a &quot;b&quot;, &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;, &quot;x&quot; or &quot;X&quot;
 (integer) conversion to process an<tt> __int64</tt> or<tt> unsigned __int64</tt> argument (e.g., %I64d).
<li>&quot;L&quot; causes an &quot;e&quot;, &quot;E&quot;, &quot;f&quot;, &quot;F&quot;, &quot;g&quot;, &quot;G&quot; (double)
 conversion to process a<tt> long double</tt> argument.
<li>&quot;W&quot; causes the pointer associated with &quot;n&quot;, &quot;p&quot;, &quot;s&quot; conversions to be treated
 as a far pointer.
<li>&quot;N&quot; causes the pointer associated with &quot;n&quot;, &quot;p&quot;, &quot;s&quot; conversions to be treated
 as a near pointer.
</ul>
<br>The valid conversion type specifiers are:
<dl>
<dt>b
<dd>An argument of type<tt> int</tt> is converted to an unsigned binary notation and written to the output stream.&nbsp; The default
 precision is 1, but if more digits are required, leading zeros are added.
<dt><br>c
<dd>An argument of type<tt> int</tt> is converted to a value of type<tt> char</tt> and the corresponding ASCII character code
 is written to the output stream.
<dt><br>C
<dd>An argument of type<tt> wchar_t</tt> is converted to a multibyte character and written to the output stream.
<dt><br>d, i
<dd>An argument of type<tt> int</tt> is converted to a signed decimal notation and written to the output stream.&nbsp; The default
 precision is 1, but if more digits are required, leading zeros are added.
<dt><br>e, E
<dd>An argument of type<tt> double</tt> is converted to a decimal notation in the form<tt> &#91;-&#93;d.ddde&#91;+|-&#93;ddd</tt>
 similar to FORTRAN exponential (E) notation.&nbsp; The leading sign appears (subject to the format control flags) only if
 the argument is negative.&nbsp; If the argument is non-zero, the digit before the decimal-point character is non-zero.&nbsp;
 The precision is used as the number of digits following the decimal-point character.&nbsp; If the precision is not specified,
 a default precision of six is used.&nbsp; If the precision is 0, the decimal-point character is suppressed.&nbsp; The value
 is rounded to the appropriate number of digits.&nbsp; For &quot;E&quot; conversions, the exponent begins with the character
 &quot;E&quot; rather than &quot;e&quot;.&nbsp; The exponent sign and a three-digit number (that indicates the power of ten
 by which the decimal fraction is multiplied) are always produced.
<dt><br>f, F
<dd>An argument of type<tt> double</tt> is converted to a decimal notation in the form<tt> &#91;-&#93;ddd.ddd</tt> similar to
 FORTRAN fixed-point (F) notation.&nbsp; The leading sign appears (subject to the format control flags) only if the argument
 is negative.&nbsp; The precision is used as the number of digits following the decimal-point character.&nbsp; If the precision
 is not specified, a default precision of six is used.&nbsp; If the precision is 0, the decimal-point character is suppressed,
 otherwise, at least one digit is produced before the decimal-point character.&nbsp; The value is rounded to the appropriate
 number of digits.
<dt><br>g, G
<dd>An argument of type<tt> double</tt> is converted using either the &quot;f&quot; or &quot;e&quot; (or &quot;F&quot; or &quot;E&quot;,
 for a &quot;G&quot; conversion) style of conversion depending on the value of the argument.&nbsp; In either case, the precision
 specifies the number of significant digits that are contained in the result.&nbsp; &quot;e&quot; style conversion is used
 only if the exponent from such a conversion would be less than -4 or greater than the precision.&nbsp; Trailing zeros are
 removed from the result and a decimal-point character only appears if it is followed by a digit.
<dt><br>n
<dd>The number of characters that have been written to the output stream is assigned to the integer pointed to by the argument.
&nbsp; No output is produced.
<dt><br>o
<dd>An argument of type<tt> int</tt> is converted to an unsigned octal notation and written to the output stream.&nbsp; The default
 precision is 1, but if more digits are required, leading zeros are added.
<dt><br>p, P
<dd>An argument of type<tt> void *</tt> is converted to a value of type<tt> int</tt> and the value is formatted as for a hexadecimal
 (&quot;x&quot;) conversion.
<dt><br>s
<dd>Characters from the string specified by an argument of type<tt> char *</tt> or<tt> wchar_t *</tt>, up to, but not including
 the terminating null character ('\0'), are written to the output stream.&nbsp; If a precision is specified, no more than
 that many characters (bytes) are written (e.g., %.7s)
<br>For<tt> printf</tt>, this specifier refers to an ASCII character string unless the &quot;l&quot; or &quot;w&quot; modifiers
 are used to indicate a wide character string.
<br><br>For<tt> wprintf</tt>, this specifier refers to a wide character string unless the &quot;h&quot; modifier is used to
 indicate an ASCII character string.
<dt><br>S
<dd>Characters from the string specified by an argument of type<tt> wchar_t *</tt>, up to, but not including the terminating null
 wide character (L'\0'), are converted to multibyte characters and written to the output stream.&nbsp; If a precision is specified,
 no more than that many characters (bytes) are written (e.g., %.7S)
<dt><br>u
<dd>An argument of type<tt> int</tt> is converted to an unsigned decimal notation and written to the output stream.&nbsp; The
 default precision is 1, but if more digits are required, leading zeros are added.
<dt><br>x, X
<dd>An argument of type<tt> int</tt> is converted to an unsigned hexadecimal notation and written to the output stream.&nbsp;
 The default precision is 1, but if more digits are required, leading zeros are added.&nbsp; Hexadecimal notation uses the
 digits &quot;0&quot; through &quot;9&quot; and the characters &quot;a&quot; through &quot;f&quot; or &quot;A&quot; through
 &quot;F&quot; for &quot;x&quot; or &quot;X&quot; conversions respectively, as the hexadecimal digits.&nbsp; Subject to the
 alternate-form control flag, &quot;0x&quot; or &quot;0X&quot; is prepended to the output.
</dl>
<br>Any other conversion type specifier character, including another percent character (%), is written to the output stream
 with no special interpretation.
<br><br>The arguments must correspond with the conversion type specifiers, left to right in the string; otherwise, indeterminate
 results will occur.
<br><br>If the value corresponding to a floating-point specifier is infinity, or not a number (NaN), then the output will
 be &quot;inf&quot; or &quot;-inf&quot; for infinity, and &quot;nan&quot; or &quot;-nan&quot; for NaN's.&nbsp; If the conversion
 specifier is an uppercase character (ie.&nbsp; &quot;E&quot;, &quot;F&quot;, or &quot;G&quot;), the output will be uppercase
 as well (&quot;INF&quot;, &quot;NAN&quot;), otherwise the output will be lowercase as noted above.
<br><br>The pointer size specification (&quot;N&quot; or &quot;W&quot;) is only effective on platforms that use a segmented
 memory model, although it is always recognized.
<br><br>For example, a specifier of the form<tt> &quot;%8.*f&quot;</tt> will define a field to be at least 8 characters wide,
 and will get the next argument for the precision to be used in the conversion.
</dl>
<dl>
<dt>Classification:
<dd>ANSI (except for N, W pointer size modifiers and b, I64 specifiers)
</dl>
<dl>
<dt>Systems:
<dd><tt> printf - All, Netware</tt>
<br><tt>wprintf - All</tt>
</dl>
<h2 id="printf_s"> printf_s, wprintf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int printf_s( const char * restrict format, ... );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int wprintf_s( const wchar_t * restrict format, ... );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 printf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>The<b> format</b> argument shall not be a null pointer.&nbsp; The<tt> %n</tt> specifier (modified or not by flags, field
 width, or precision) shall not appear in the string pointed to by<b> format</b>.&nbsp; Any argument to<tt> printf_s</tt>
 corresponding to a<tt> %s</tt> specifier shall not be a null pointer.
<br><br>If there is a runtime-constraint violation, the<tt> printf_s</tt> function does not attempt to produce further output,
 and it is unspecified to what extent<tt> printf_s</tt> produced output before discovering the runtime-constraint violation.
</dl>
<dl>
<dt>Description:
<dd>The<tt> printf_s</tt> function is equivalent to the <tt> printf</tt> function except for the explicit runtime-constraints
 listed above.
<br>The<tt> wprintf_s</tt> function is identical to<tt> printf_s</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> printf_s</tt> function returns the number of characters written, or a negative value if an output error or runtime-constraint
 violation occurred.
<br>The<tt> wprintf_s</tt> function returns the number of wide characters written, or a negative value if an output error
 or runtime-constraint violation occurred.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>,
 <a href="#vprintf">vprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *weekday, *month;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; weekday = &quot;Saturday&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; month = &quot;April&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf_s( &quot;%s, %s %d, %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, 18, 1987 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf_s( &quot;f1 = %8.4f f2 = %10.2E x = %#08x i = %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 23.45, 3141.5926, 0x1db, -1 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Saturday, April 18, 1987</tt>
<br><tt>f1 =&nbsp; 23.4500 f2 =&nbsp; 3.14E+003 x = 0x0001db i = -1</tt>
</dl>
<dl>
<dt>Classification:
<dd>printf_s is TR 24731
<br>wprintf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> printf_s - All, Netware</tt>
<br><tt>wprintf_s - All</tt>
</dl>
<h2 id="putc"> putc, putwc </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int putc( int c, FILE *fp );</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wint_t putwc( wint_t c, FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> putc</tt> function is equivalent to <tt> fputc</tt>, except it may be implemented as a macro.&nbsp; The<tt> putc</tt>
 function writes the character specified by the argument<b> c</b> to the output stream designated by<b> fp</b>.
<br>The<tt> putwc</tt> function is identical to<tt> putc</tt> except that it converts the wide character specified by<b> c</b>
 to a multibyte character and writes it to the output stream.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> putc</tt> function returns the character written or, if a write error occurs, the error indicator is set and<tt> putc</tt>
 returns <tt> EOF</tt>.
<br>The<tt> putwc</tt> function returns the wide character written or, if a write error occurs, the error indicator is set
 and<tt> putwc</tt> returns <tt> WEOF</tt>.
<br><br>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#fputc">fputc</a>, <a href="#fputchar">fputchar</a>, <a href="#fputs">fputs</a>, <a href="#putchar">putchar</a>,
 <a href="#puts">puts</a>, <a href="#ferror">ferror</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetc( fp )) != EOF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putc( c, stdout );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>putc is ANSI
<br>putwc is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> putc - All, Netware</tt>
<br><tt>putwc - All</tt>
</dl>
<h2 id="putch"> putch </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>int putch( int c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> putch</tt> function writes the character specified by the argument<b> c</b> to the console.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> putch</tt> function returns the character written.
</dl>
<dl>
<dt>See Also:
<dd><a href="#getch">getch</a>, <a href="#getche">getche</a>, <a href="#kbhit">kbhit</a>, <a href="#ungetch">ungetch</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if ( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = fgetc( fp )) != EOF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putch( c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="putchar"> putchar, putwchar </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int putchar( int c );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wint_t putwchar( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> putchar</tt> function writes the character specified by the argument<b> c</b> to the output stream <tt> stdout</tt>.
<br>The function is equivalent to
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; fputc( c, stdout );</tt>
<br><br>The<tt> putwchar</tt> function is identical to<tt> putchar</tt> except that it converts the wide character specified
 by<b> c</b> to a multibyte character and writes it to the output stream.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> putchar</tt> function returns the character written or, if a write error occurs, the error indicator is set and<tt>
 putchar</tt> returns <tt> EOF</tt>.
<br>The<tt> putwchar</tt> function returns the wide character written or, if a write error occurs, the error indicator is
 set and<tt> putwchar</tt> returns <tt> WEOF</tt>.
<br><br>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#fputc">fputc</a>, <a href="#fputchar">fputchar</a>, <a href="#fputs">fputs</a>, <a href="#putc">putc</a>,
 <a href="#puts">puts</a>, <a href="#ferror">ferror</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; c = fgetc( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( c != EOF ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putchar( c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = fgetc( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>putchar is ANSI
<br>putwchar is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> putchar - All, Netware</tt>
<br><tt>putwchar - All</tt>
</dl>
<h2 id="putenv"> putenv, _putenv, _wputenv </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>int putenv( const char *env_name );</tt>
<br><tt>int _putenv( const char *env_name );</tt>
<br><tt>int _wputenv( const wchar_t *env_name );</tt>
</dl>
<dl>
<dt>Description:
<dd>The environment list consists of a number of environment names, each of which has a value associated with it.&nbsp; Entries
 can be added to the environment list with the DOS<tt> set</tt> command or with the<tt> putenv</tt> function.&nbsp; All entries
 in the environment list can be displayed by using the DOS<tt> set</tt> command with no arguments.&nbsp; A program can obtain
 the value for an environment variable by using the <tt> getenv</tt> function.
<br>When the value of<b> env_name</b> has the format
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env_name=value</tt>
<br><br>an environment name and its value is added to the environment list.&nbsp; When the value of<b> env_name</b> has the
 format
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env_name=</tt>
<br><br>the environment name and value is removed from the environment list.
<br><br>The matching is case-insensitive; all lowercase letters are treated as if they were in upper case.
<br><br>The space into which environment names and their values are placed is limited.&nbsp; Consequently, the<tt> putenv</tt>
 function can fail when there is insufficient space remaining to store an additional value.
<br><br>The<tt> _putenv</tt> function is identical to<tt> putenv</tt>.&nbsp; Use<tt> _putenv</tt> for ANSI naming conventions.
<br><br>The<tt> _wputenv</tt> function is a wide-character version of<tt> putenv</tt> the<b> env_name</b> argument to<tt>
 _wputenv</tt> is a wide-character string.
<br><br><tt>putenv</tt> and<tt> _wputenv</tt> affect only the environment that is local to the current process; you cannot
 use them to modify the command-level environment.&nbsp; That is, these functions operate only on data structures accessible
 to the run-time library and not on the environment &quot;segment&quot; created for a process by the operating system.&nbsp;
 When the current process terminates, the environment reverts to the level of the calling process (in most cases, the operating-system
 level).&nbsp; However, the modified environment can be passed to any new processes created by _spawn, _exec, or system, and
 these new processes get any new items added by<tt> putenv</tt> and<tt> _wputenv</tt>.
<br><br>With regard to environment entries, observe the following cautions:
<ul>
<li>Do not change an environment entry directly; instead, use<tt> putenv</tt> or<tt> _wputenv</tt> to change it.&nbsp; To
 modify the return value of<tt> putenv</tt> or<tt> _wputenv</tt> without affecting the environment table, use <tt> _strdup</tt>
 or <tt> strcpy</tt> to make a copy of the string.
<li>If the argument<b> env_name</b> is not a literal string, you should duplicate the string, since<tt> putenv</tt> does not
 copy the value; for example,
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; putenv( _strdup( buffer ) );</tt>
<li>Never free a pointer to an environment entry, because the environment variable will then point to freed space.&nbsp; A
 similar problem can occur if you pass<tt> putenv</tt> or<tt> _wputenv</tt> a pointer to a local variable, then exit the function
 in which the variable is declared.
</ul>
<br>To assign a string to a variable and place it in the environment list:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET INCLUDE=C:\WATCOM\H</tt>
<br><br>To see what variables are in the environment list, and their current assignments:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMSPEC=C:\COMMAND.COM</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PATH=C:\;C:\WATCOM</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE=C:\WATCOM\H</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> putenv</tt> function returns zero when it is successfully executed and returns -1 when it fails.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>ENOMEM
<dd>Not enough memory to allocate a new environment string.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#clearenv">clearenv</a>, <a href="#getenv">getenv</a>, <a href="#setenv">setenv</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>The following gets the string currently assigned to <tt> INCLUDE</tt> and displays it, assigns a new value to it, gets
 and displays it, and then removes the environment name and value.
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *path;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; path = getenv( &quot;INCLUDE&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( path != NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;INCLUDE=%s\n&quot;, path );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( putenv( &quot;INCLUDE=mylib;yourlib&quot; ) != 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;putenv failed&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; path = getenv( &quot;INCLUDE&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( path != NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;INCLUDE=%s\n&quot;, path );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( putenv( &quot;INCLUDE=&quot; ) != 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;putenv failed&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>INCLUDE=C:\WATCOM\H</tt>
<br><tt>INCLUDE=mylib;yourlib</tt>
</dl>
<dl>
<dt>Classification:
<dd>putenv is POSIX 1003.1
<br>_putenv is not POSIX
<br>_wputenv is not POSIX
</dl>
<dl>
<dt>Systems:
<dd><tt> putenv - All</tt>
<br><tt>_putenv - All</tt>
<br><tt>_wputenv - All</tt>
</dl>
<h2 id="_putimage"> _putimage, _putimage_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _putimage( short x, short y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; char _HUGE *image, short mode );</tt>
<br><br><tt>void _FAR _putimage_w( double x, double y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char _HUGE *image, short mode );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _putimage</tt> functions display the screen image indicated by the argument<b> image</b>.&nbsp; The<tt> _putimage</tt>
 function uses the view coordinate system.&nbsp; The<tt> _putimage_w</tt> function uses the window coordinate system.
<br>The image is displayed upon the screen with its top left corner located at the point with coordinates<tt> (x,y).</tt>
&nbsp; The image was previously saved using the <tt> _getimage</tt> functions.&nbsp; The image is displayed in a rectangle
 whose size is the size of the rectangular image saved by the <tt> _getimage</tt> functions.
<br><br>The image can be displayed in a number of ways, depending upon the value of the<b> mode</b> argument.&nbsp; This argument
 can have the following values:
<dl>
<dt>_GPSET
<dd>replace the rectangle on the screen by the saved image
<dt><br>_GPRESET
<dd>replace the rectangle on the screen with the pixel values of the saved image inverted; this produces a negative image
<dt><br>_GAND
<dd>produce a new image on the screen by ANDing together the pixel values from the screen with those from the saved image
<dt><br>_GOR
<dd>produce a new image on the screen by ORing together the pixel values from the screen with those from the saved image
<dt><br>_GXOR
<dd>produce a new image on the screen by exclusive ORing together the pixel values from the screen with those from the saved image;
 the original screen is restored by two successive calls to the<tt> _putimage</tt> function with this value, providing an
 efficient method to produce animated effects
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _putimage</tt> functions do not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getimage">_getimage</a>, <a href="#_imagesize">_imagesize</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *buf;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int y;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 100, 200, 200 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; buf = (char*) malloc(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _imagesize(
 100, 100, 201, 201 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( buf != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _getimage( 100, 100, 201, 201, buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 260, 200, buf, _GPSET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, 100, buf, _GPSET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( y = 100; y &lt; 300; ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, y, buf, _GXOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y += 20;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putimage( 420, y, buf, _GXOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>_putimage is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _putimage - DOS, QNX</tt>
<br><tt>_putimage_w - DOS, QNX</tt>
</dl>
<h2 id="puts"> puts, _putws </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int puts( const char *buf );</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int _putws( const wchar_t *bufs );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> puts</tt> function writes the character string pointed to by<b> buf</b> to the output stream designated by <tt> stdout</tt>,
 and appends a new-line character to the output.&nbsp; The terminating null character is not written.
<br>The<tt> _putws</tt> function is identical to<tt> puts</tt> except that it converts the wide character string specified
 by<b> buf</b> to a multibyte character string and writes it to the output stream.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> puts</tt> function returns <tt> EOF</tt> if an error occurs; otherwise, it returns a non-negative value (the number
 of characters written including the new-line character).&nbsp; The<tt> _putws</tt> function returns <tt> EOF</tt> if a write
 or encoding error occurs; otherwise, it returns a non-negative value (the number of characters written including the new-line
 character).&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been
 detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#fputc">fputc</a>, <a href="#fputchar">fputchar</a>, <a href="#fputs">fputs</a>, <a href="#putc">putc</a>,
 <a href="#putchar">putchar</a>, <a href="#ferror">ferror</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = freopen( &quot;file&quot;, &quot;r&quot;, stdin );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( gets( buffer ) != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>puts is ANSI
<br>_putws is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> puts - All, Netware</tt>
<br><tt>_putws - All</tt>
</dl>
<h2 id="_putw"> _putw </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int _putw( int binint, FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _putw</tt> function writes a binary value of type<b> int</b> to the current position of the stream<b> fp</b>.<tt>
&nbsp; _putw</tt> does not affect the alignment of items in the stream, nor does it assume any special alignment.
<br><tt>_putw</tt> is provided primarily for compatibility with previous libraries.&nbsp; Portability problems may occur with<tt>
 _putw</tt> because the size of an<b> int</b> and the ordering of bytes within an<b> int</b> differ across systems.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _putw</tt> function returns the value written or, if a write error occurs, the error indicator is set and<tt> _putw</tt>
 returns <tt> EOF</tt>.&nbsp; Since <tt> EOF</tt> is a legitimate value to write to<b> fp</b>, use <tt> ferror</tt> to verify
 that an error has occurred.
</dl>
<dl>
<dt>See Also:
<dd><a href="#ferror">ferror</a>, <a href="#fopen">fopen</a>, <a href="#fputc">fputc</a>, <a href="#fputchar">fputchar</a>, <a href="#fputs">fputs</a>,
 <a href="#putc">putc</a>, <a href="#putchar">putchar</a>, <a href="#puts">puts</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = _getw( fp )) != EOF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _putw( c, stdout );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="qsort"> qsort </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void qsort( void *base,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t num,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t width,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int (*compar) ( const void *,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const void *) );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#qsort_s">qsort_s</a> function which is a safer alternative to<tt> qsort</tt>.
&nbsp; This newer<tt> qsort_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> qsort</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> qsort</tt> function sorts an array of<b> num</b> elements, which is pointed to by<b> base</b>, using a modified version
 of Sedgewick's Quicksort algorithm.&nbsp; Each element in the array is<b> width</b> bytes in size.&nbsp; The comparison function
 pointed to by<b> compar</b> is called with two arguments that point to elements in the array.&nbsp; The comparison function
 shall return an integer less than, equal to, or greater than zero if the first argument is less than, equal to, or greater
 than the second argument.
<br>The version of the Quicksort algorithm that is employed was proposed by Jon Louis Bentley and M.&nbsp; Douglas McIlroy
 in the article &quot;Engineering a sort function&quot; published in<b><i> Software -- Practice and Experience,</i></b> 23(11):1249-1265,
 November 1993.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> qsort</tt> function returns no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#qsort_s">qsort_s</a>, <a href="#bsearch">bsearch</a>, <a href="#bsearch_s">bsearch_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char *CharVect&#91;&#93; = { &quot;last&quot;, &quot;middle&quot;, &quot;first&quot; };</tt>
<br><br><tt>int compare( const void *op1, const void *op2 )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char **p1 = (const char **) op1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char **p2 = (const char **) op2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( strcmp( *p1, *p2 ) );</tt>
<br><tt>}</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; qsort( CharVect, sizeof(CharVect)/sizeof(char *),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(char *), compare );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s %s %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CharVect&#91;0&#93;, CharVect&#91;1&#93;, CharVect&#91;2&#93;
 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>first last middle</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="qsort_s"> qsort_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>errno_t qsort_s( void *base,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t nmemb,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t size,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int (*compar)( const void *x, const void *y, void *context ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void *context );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 qsort_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> nmemb</b> nor<b> size</b> shall be greater than <tt> RSIZE_MAX</tt>.&nbsp; If<b> nmemb</b> is not equal to
 zero, then neither<b> base</b> nor<b> compar</b> shall be a null pointer.&nbsp; If there is a runtime-constraint violation,
 the<tt> qsort_s</tt> function does not sort the array.
</dl>
<dl>
<dt>Description:
<dd>The<tt> qsort_s</tt> function sorts an array of<b> nmemb</b> objects, the initial element of which is pointed to by<b> base</b>.
&nbsp; The size of each object is specified by<b> size</b>.&nbsp; The contents of the array are sorted into ascending order
 according to a comparison function pointed to by<b> compar</b>, which is called with three arguments.&nbsp; The first two
 point to the objects being compared.&nbsp; The function shall return an integer less than, equal to, or greater than zero
 if the first argument is considered to be respectively less than, equal to, or greater than the second.&nbsp; The third argument
 to the comparison function is the<b> context</b> argument passed to<tt> qsort_s</tt> The sole use of<b> context</b> by<tt>
 qsort_s</tt> is to pass it to the comparison function.&nbsp; If two elements compare as equal, their relative order in the
 resulting sorted array is unspecified.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> qsort_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#qsort">qsort</a>, <a href="#bsearch">bsearch</a>, <a href="#bsearch_s">bsearch_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char *CharVect&#91;&#93; = { &quot;last&quot;, &quot;middle&quot;, &quot;first&quot; };</tt>
<br><br><tt>int compare( const void *op1, const void *op2, void *context )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char **p1 = (const char **) op1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char **p2 = (const char **) op2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( strcmp( *p1, *p2 ) );</tt>
<br><tt>}</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; void * context = NULL;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; qsort_s( CharVect, sizeof(CharVect)/sizeof(char *),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(char *), compare, context );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s %s %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CharVect&#91;0&#93;, CharVect&#91;1&#93;, CharVect&#91;2&#93;
 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>first last middle</tt>
</dl>
<dl>
<dt>Classification:
<dd>TR 24731
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="raise"> raise </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;signal.h&gt;</tt>
<br><tt>int raise( int condition );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> raise</tt> function signals the exceptional condition indicated by the<b> condition</b> argument.&nbsp; The possible
 conditions are defined in the<tt> &lt;signal.h&gt;</tt> header file and are documented with the <tt> signal</tt> function.
&nbsp; The <tt> signal</tt> function can be used to specify the action which is to take place when such a condition occurs.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> raise</tt> function returns zero when the condition is successfully raised and a non-zero value otherwise.&nbsp; There
 may be no return of control following the function call if the action for that condition is to terminate the program or to
 transfer control using the <tt> longjmp</tt> function.
</dl>
<dl>
<dt>See Also:
<dd><a href="#signal">signal</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>/*</tt>
<br><tt> * This program waits until a SIGINT signal</tt>
<br><tt> * is received.</tt>
<br><tt> */</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;signal.h&gt;</tt>
<br><br><tt>sig_atomic_t signal_count;</tt>
<br><tt>sig_atomic_t signal_number;</tt>
<br><br><tt>static void alarm_handler( int signum )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ++signal_count;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; signal_number = signum;</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned long i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; signal_count = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; signal_number = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; signal( SIGINT, alarm_handler );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf(&quot;Signal will be auto-raised on iteration &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;10000 or hit CTRL-C.\n&quot;);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf(&quot;Iteration:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 100000; ++i )</tt>
<br><tt>&nbsp;&nbsp;&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\b\b\b\b\b%*d&quot;, 5, i);</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( i == 10000 ) raise(SIGINT);</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( signal_count &gt; 0 ) break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( i == 100000 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\nNo signal was raised.\n&quot;);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else if( i == 10000 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\nSignal %d was raised by the &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;raise() function.\n&quot;, signal_number);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\nUser raised the signal.\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal_number);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="rand"> rand </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>int rand( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> rand</tt> function computes a sequence of pseudo-random integers in the range 0 to <tt> RAND_MAX</tt> (32767).&nbsp;
 The sequence can be started at different values by calling the <tt> srand</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> rand</tt> function returns a pseudo-random integer.
</dl>
<dl>
<dt>See Also:
<dd><a href="#srand">srand</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i=1; i &lt; 10; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, rand() );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="read"> read, _read </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int read( int handle, void *buffer, unsigned len );</tt>
<br><tt>int _read( int handle, void *buffer, unsigned len );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> read</tt> function reads data at the operating system level.&nbsp; The number of bytes transmitted is given by<b>
 len</b> and the data is transmitted starting at the address specified by<b> buffer</b>.
<br>The<b> handle</b> value is returned by the <tt> open</tt> function.&nbsp; The access mode must have included either <tt>
 O_RDONLY</tt> or <tt> O_RDWR</tt> when the <tt> open</tt> function was invoked.&nbsp; The data is read starting at the current
 file position for the file in question.&nbsp; This file position can be determined with the <tt> tell</tt> function and can
 be set with the <tt> lseek</tt> function.
<br><br>When <tt> O_BINARY</tt> is included in the access mode, the data is transmitted unchanged.&nbsp; When <tt> O_TEXT</tt>
 is included in the access mode, the data is transmitted with the extra carriage return character removed before each linefeed
 character encountered in the original data.
<br><br>The<tt> _read</tt> function is identical to<tt> read</tt>.&nbsp; Use<tt> _read</tt> for ANSI/ISO naming conventions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> read</tt> function returns the number of bytes of data transmitted from the file to the buffer (this does not include
 any carriage-return characters that were removed during the transmission).&nbsp; Normally, this is the number given by the<b>
 len</b> argument.&nbsp; When the end of the file is encountered before the read completes, the return value will be less
 than the number of bytes requested.
<br>A value of -1 is returned when an input/output error is detected.&nbsp; When an error has occurred, <tt> errno</tt> contains
 a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#close">close</a>, <a href="#creat">creat</a>, <a href="#fread">fread</a>, <a href="#open">open</a>, <a href="#write">write</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp; handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp; size_read;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* open a file for input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDONLY | O_TEXT );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* read the text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_read = read( handle, buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof( buffer ) );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* test for error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( size_read == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error reading file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* close the file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>read is POSIX 1003.1
<br>_read is not POSIX
<br>_read conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> read - All, Netware</tt>
<br><tt>_read - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="readdir"> readdir, _wreaddir </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><tt>struct dirent *readdir( struct dirent *dirp );</tt>
<br><tt>struct _wdirent *_wreaddir( _wdirent *dirp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> readdir</tt> function obtains information about the next matching file name from the argument<b> dirp</b>.&nbsp; The
 argument<b> dirp</b> is the value returned from the <tt> opendir</tt> function.&nbsp; The<tt> readdir</tt> function can be
 called repeatedly to obtain the list of file names contained in the directory specified by the pathname given to <tt> opendir</tt>.
&nbsp; The function <tt> closedir</tt> must be called to close the directory and free the memory allocated by <tt> opendir</tt>.
<br>The file<tt> &lt;direct.h&gt;</tt> contains definitions for the structure <tt> dirent</tt>.
<br><br><tt>#if defined(__OS2__) || defined(__NT__)</tt>
<br><tt>#define NAME_MAX 255&nbsp;&nbsp;&nbsp; /* maximum for HPFS or NTFS */</tt>
<br><tt>#else</tt>
<br><tt>#define NAME_MAX&nbsp; 12&nbsp;&nbsp;&nbsp; /* 8 chars + '.' +&nbsp; 3 chars */</tt>
<br><tt>#endif</tt>
<br><br><tt>typedef struct dirent {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_dta&#91; 21 &#93;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disk transfer
 area */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_attr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; /* file's attribute */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short int d_time;&nbsp; /* file's time */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short int d_date;&nbsp; /* file's date */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; d_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; /* file's size */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_name&#91; NAME_MAX + 1 &#93;; /* file's name */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short d_ino;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* serial number */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_first;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 /* flag for 1st time */</tt>
<br><tt>} DIR;</tt>
<br>The file attribute field <tt> d_attr</tt> field is a set of bits representing the following attributes.
<br><br><tt>_A_RDONLY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Read-only file */</tt>
<br><tt>_A_HIDDEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Hidden file */</tt>
<br><tt>_A_SYSTEM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* System file */</tt>
<br><tt>_A_VOLID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Volume-ID entry (only MSFT knows) */</tt>
<br><tt>_A_SUBDIR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Subdirectory */</tt>
<br><tt>_A_ARCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Archive file */</tt>
<br>If the<tt> _A_RDONLY</tt> bit is off, then the file is read/write.
<br><br>The format of the <tt> d_time</tt> field is described by the following structure (this structure is not defined in
 any Watcom header file).
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; twosecs : 5;&nbsp;&nbsp;&nbsp; /* seconds / 2 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; minutes : 6;&nbsp;&nbsp;&nbsp; /* minutes (0,59) */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; hours&nbsp;&nbsp; : 5;&nbsp;&nbsp;&nbsp; /* hours (0,23) */</tt>
<br><tt>} ftime_t;</tt>
<br>The format of the <tt> d_date</tt> field is described by the following structure (this structure is not defined in any
 Watcom header file).
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; day&nbsp;&nbsp;&nbsp;&nbsp; : 5;&nbsp;&nbsp;&nbsp; /* day (1,31) */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; month&nbsp;&nbsp; : 4;&nbsp;&nbsp;&nbsp; /* month (1,12) */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; year&nbsp;&nbsp;&nbsp; : 7;&nbsp;&nbsp;&nbsp; /* 0 is 1980 */</tt>
<br><tt>} fdate_t;</tt>
<br>See the sample program below for an example of the use of these structures.
<br><br>The<tt> _wreaddir</tt> function is identical to<tt> readdir</tt> except that it reads a directory of wide-character
 filenames.
<br><br>The file<tt> &lt;direct.h&gt;</tt> contains definitions for the structure <tt> _wdirent</tt>.
<br><br><tt>struct _wdirent {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_dta&#91;21&#93;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* disk transfer area */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_attr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file's attribute
 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short int d_time;/* file's time */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short int d_date;/* file's date */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; d_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file's size */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wchar_t d_name&#91;NAME_MAX+1&#93;;/* file's name */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short d_ino;&nbsp;&nbsp; /* serial number (not used) */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; d_first;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* flag for 1st time
 */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Returns:
<dd>When successful,<tt> readdir</tt> returns a pointer to an object of type<b> struct dirent.</b>&nbsp; When an error occurs,<tt>
 readdir</tt> returns the value<tt> NULL</tt> and <tt> errno</tt> is set to indicate the error.&nbsp; When the end of the
 directory is encountered,<tt> readdir</tt> returns the value<tt> NULL</tt> and <tt> errno</tt> is unchanged.
<br>When successful,<tt> _wreaddir</tt> returns a pointer to an object of type<b> struct _wdirent.</b>&nbsp; When an error
 occurs,<tt> _wreaddir</tt> returns the value<tt> NULL</tt> and <tt> errno</tt> is set to indicate the error.&nbsp; When the
 end of the directory is encountered,<tt> _wreaddir</tt> returns the value<tt> NULL</tt> and <tt> errno</tt> is unchanged.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>EBADF
<dd>The argument<b> dirp</b> does not refer to an open directory stream.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#closedir">closedir</a>, <a href="#_dos_find___">_dos_find...</a>, <a href="#opendir">opendir</a>, <a href="#rewinddir">rewinddir</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>To get a list of files contained in the directory<tt> \watcom\h</tt> on your default disk:
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; twosecs : 5;&nbsp;&nbsp;&nbsp; /* seconds / 2 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; minutes : 6;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; hours&nbsp;&nbsp; : 5;</tt>
<br><tt>} ftime_t;</tt>
<br><br><tt>typedef struct {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; day&nbsp;&nbsp;&nbsp;&nbsp; : 5;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; month&nbsp;&nbsp; : 4;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned short&nbsp; year&nbsp;&nbsp;&nbsp; : 7;</tt>
<br><tt>} fdate_t;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; DIR *dirp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct dirent *direntp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ftime_t *f_time;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fdate_t *f_date;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; dirp = opendir( &quot;\\watcom\\h&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( dirp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp = readdir( dirp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( direntp == NULL ) break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time = (ftime_t *)&amp;direntp-&gt;d_time;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date = (fdate_t *)&amp;direntp-&gt;d_date;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%-12s %d/%2.2d/%2.2d &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%2.2d:%2.2d:%2.2d
 \n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp-&gt;d_name,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;year + 1980,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;month,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_date-&gt;day,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;hours,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;minutes,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f_time-&gt;twosecs * 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; closedir( dirp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</dl>
<dl>
<dt>Classification:
<dd>readdir is POSIX 1003.1
<br>_wreaddir is not POSIX
</dl>
<dl>
<dt>Systems:
<dd><tt> readdir - All, Netware</tt>
<br><tt>_wreaddir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="realloc"> realloc Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;&nbsp; For ANSI compatibility (realloc only)</tt>
<br><tt>#include &lt;malloc.h&gt;&nbsp; Required for other function prototypes</tt>
<br><tt>void * realloc( void *old_blk, size_t size );</tt>
<br><tt>void __based(void) *_brealloc( __segment seg,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void __based(void) *old_blk,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</tt>
<br><tt>void __far&nbsp; *_frealloc( void __far&nbsp; *old_blk,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</tt>
<br><tt>void __near *_nrealloc( void __near *old_blk,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</tt>
</dl>
<dl>
<dt>Description:
<dd>When the value of the<b> old_blk</b> argument is<tt> NULL,</tt> a new block of memory of<b> size</b> bytes is allocated.
<br>If the value of<b> size</b> is zero, the corresponding <tt> free</tt> function is called to release the memory pointed
 to by<b> old_blk</b>.
<br><br>Otherwise, the<tt> realloc</tt> function re-allocates space for an object of<b> size</b> bytes by either:
<ul>
<li>shrinking the allocated size of the allocated memory block<b> old_blk</b> when<b> size</b> is sufficiently smaller than
 the size of<b> old_blk</b>.
<li>extending the allocated size of the allocated memory block<b> old_blk</b> if there is a large enough block of unallocated
 memory immediately following<b> old_blk</b>.
<li>allocating a new block and copying the contents of<b> old_blk</b> to the new block.
</ul>
<br>Because it is possible that a new block will be allocated, any pointers into the old memory should not be maintained.
&nbsp; These pointers will point to freed memory, with possible disastrous results, when a new block is allocated.
<br><br>The function returns<tt> NULL</tt> when the memory pointed to by<b> old_blk</b> cannot be re-allocated.&nbsp; In this
 case, the memory pointed to by<b> old_blk</b> is not freed so care should be exercised to maintain a pointer to the old memory
 block.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; buffer = (char *) realloc( buffer, 100 );</tt>
<br><br>In the above example,<tt> buffer</tt> will be set to<tt> NULL</tt> if the function fails and will no longer point
 to the old memory block.&nbsp; If<tt> buffer</tt> was your only pointer to the memory block then you will have lost access
 to this memory.
<br><br>Each function reallocates memory from a particular heap, as listed below:
<dl>
<dt>Function&nbsp;&nbsp;&nbsp;&nbsp; Heap
<dt>realloc
<dd>Depends on data model of the program
<dt><br>_brealloc
<dd>Based heap specified by<b> seg</b> value
<dt><br>_frealloc
<dd>Far heap (outside the default data segment)
<dt><br>_nrealloc
<dd>Near heap (inside the default data segment)
</dl>
<br>In a small data memory model, the<tt> realloc</tt> function is equivalent to the <tt> _nrealloc</tt> function; in a large
 data memory model, the<tt> realloc</tt> function is equivalent to the <tt> _frealloc</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> realloc</tt> functions return a pointer to the start of the re-allocated memory.&nbsp; The return value is<tt> NULL</tt>
 if there is insufficient memory available or if the value of the<b> size</b> argument is zero.&nbsp; The <tt> _brealloc</tt>
 function returns <tt> _NULLOFF</tt> if there is insufficient memory available or if the requested size is zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#calloc">calloc</a> Functions, <a href="#_expand">_expand</a> Functions, <a href="#free">free</a> Functions, <a href="#halloc">halloc</a>,
 <a href="#hfree">hfree</a>, <a href="#malloc">malloc</a> Functions, <a href="#_msize">_msize</a> Functions, <a href="#sbrk">sbrk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *buffer;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *new_buffer;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; buffer = (char *) malloc( 80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; new_buffer = (char *) realloc( buffer, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( new_buffer == NULL ) {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* not able to allocate larger buffer */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buffer = new_buffer;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>realloc is ANSI
<br>_frealloc is not ANSI
<br>_brealloc is not ANSI
<br>_nrealloc is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> realloc - All, Netware</tt>
<br><tt>_brealloc - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_frealloc - DOS/16, Windows, QNX/16, OS/2 1.x(all)</tt>
<br><tt>_nrealloc - DOS, Windows, Win386, Win32, QNX, OS/2 1.x, OS/2 1.x(MT), OS/2-32</tt>
</dl>
<h2 id="_rectangle"> _rectangle, _rectangle_w, _rectangle_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _rectangle( short fill,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; short x1, short y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; short x2, short y2 );</tt>
<br><br><tt>short _FAR _rectangle_w( short fill,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x1, double y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double x2, double y2 );</tt>
<br><br><tt>short _FAR _rectangle_wxy( short fill,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *p1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; struct _wxycoord _FAR *p2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _rectangle</tt> functions draw rectangles.&nbsp; The<tt> _rectangle</tt> function uses the view coordinate system.
&nbsp; The<tt> _rectangle_w</tt> and<tt> _rectangle_wxy</tt> functions use the window coordinate system.
<br>The rectangle is defined with opposite corners established by the points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>
<br><br>The argument<b> fill</b> determines whether the rectangle is filled in or has only its outline drawn.&nbsp; The argument
 can have one of two values:
<dl>
<dt>_GFILLINTERIOR
<dd>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<dt><br>_GBORDER
<dd>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
 style
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _rectangle</tt> functions return a non-zero value when the rectangle was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setcolor">_setcolor</a>, <a href="#_setfillmask">_setfillmask</a>, <a href="#_setlinestyle">_setlinestyle</a>,
 <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_rect.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>_rectangle is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _rectangle - DOS, QNX</tt>
<br><tt>_rectangle_w - DOS, QNX</tt>
<br><tt>_rectangle_wxy - DOS, QNX</tt>
</dl>
<h2 id="_registerfonts"> _registerfonts </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _registerfonts( char _FAR *path );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _registerfonts</tt> function initializes the font graphics system.&nbsp; Fonts must be registered, and a font selected,
 before text can be displayed with the <tt> _outgtext</tt> function.
<br>The argument<b> path</b> specifies the location of the font files.&nbsp; This argument is a file specification, and can
 contain drive and directory components and may contain wildcard characters.&nbsp; The<tt> _registerfonts</tt> function opens
 each of the font files specified and reads the font information.&nbsp; Memory is allocated to store the characteristics of
 the font.&nbsp; These font characteristics are used by the <tt> _setfont</tt> function when selecting a font.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _registerfonts</tt> function returns the number of fonts that were registered if the function is successful; otherwise,
 a negative number is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_setfont">_setfont</a>, <a href="#_getfontinfo">_getfontinfo</a>,
 <a href="#_outgtext">_outgtext</a>, <a href="#_getgtextextent">_getgtextextent</a>, <a href="#_setgtextvector">_setgtextvector</a>,
 <a href="#_getgtextvector">_getgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i, n;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 10 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; n = _registerfonts( &quot;*.fon&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; n; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;n%d&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setfont( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _clearscreen( _GCLEARSCREEN );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _unregisterfonts();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_remapallpalette"> _remapallpalette </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _remapallpalette( long _FAR *colors );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _remapallpalette</tt> function sets (or remaps) all of the colors in the palette.&nbsp; The color values in the palette
 are replaced by the array of color values given by the argument<b> colors</b>.&nbsp; This function is supported in all video
 modes, but only works with EGA, MCGA and VGA adapters.
<br>The array<b> colors</b> must contain at least as many elements as there are supported colors.&nbsp; The newly mapped palette
 will cause the complete screen to change color wherever there is a pixel value of a changed color in the palette.
<br><br>The representation of colors depends upon the hardware being used.&nbsp; The number of colors in the palette can be
 determined by using the <tt> _getvideoconfig</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _remapallpalette</tt> function returns (-1) if the palette is remapped successfully and zero otherwise.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_remappalette">_remappalette</a>, <a href="#_getvideoconfig">_getvideoconfig</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>long colors&#91; 16 &#93; = {</tt>
<br><tt>&nbsp;&nbsp; _BRIGHTWHITE, _YELLOW, _LIGHTMAGENTA, _LIGHTRED,</tt>
<br><tt>&nbsp;&nbsp; _LIGHTCYAN, _LIGHTGREEN, _LIGHTBLUE, _GRAY, _WHITE,</tt>
<br><tt>&nbsp;&nbsp; _BROWN, _MAGENTA, _RED, _CYAN, _GREEN, _BLUE, _BLACK,</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int x, y;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( y = 0; y &lt; 4; ++y ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( x = 0; x &lt; 4; ++x ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setcolor( x + 4 * y );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 x * 160, y * 120,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 ( x + 1 ) * 160, ( y + 1 ) * 120 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _remapallpalette( colors );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_remappalette"> _remappalette </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>long _FAR _remappalette( short pixval, long color );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _remappalette</tt> function sets (or remaps) the palette color<b> pixval</b> to be the color<b> color</b>.&nbsp; This
 function is supported in all video modes, but only works with EGA, MCGA and VGA adapters.
<br>The argument<b> pixval</b> is an index in the color palette of the current video mode.&nbsp; The argument<b> color</b>
 specifies the actual color displayed on the screen by pixels with pixel value<b> pixval</b>.&nbsp; Color values are selected
 by specifying the red, green and blue intensities that make up the color.&nbsp; Each intensity can be in the range from 0
 to 63, resulting in 262144 possible different colors.&nbsp; A given color value can be conveniently specified as a value
 of type<tt> long.</tt>&nbsp; The color value is of the form<tt> 0x00bbggrr,</tt> where<tt> bb</tt> is the blue intensity,<tt>
 gg</tt> is the green intensity and<tt> rr</tt> is the red intensity of the selected color.&nbsp; The file<tt> graph.h</tt>
 defines constants containing the color intensities of each of the 16 default colors.
<br><br>The<tt> _remappalette</tt> function takes effect immediately.&nbsp; All pixels on the complete screen which have a
 pixel value equal to the value of<b> pixval</b> will now have the color indicated by the argument<b> color</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _remappalette</tt> function returns the previous color for the pixel value if the palette is remapped successfully;
 otherwise, (-1) is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_remapallpalette">_remapallpalette</a>, <a href="#_setvideomode">_setvideomode</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>long colors&#91; 16 &#93; = {</tt>
<br><tt>&nbsp;&nbsp; _BLACK, _BLUE, _GREEN, _CYAN,</tt>
<br><tt>&nbsp;&nbsp; _RED, _MAGENTA, _BROWN, _WHITE,</tt>
<br><tt>&nbsp;&nbsp; _GRAY, _LIGHTBLUE, _LIGHTGREEN, _LIGHTCYAN,</tt>
<br><tt>&nbsp;&nbsp; _LIGHTRED, _LIGHTMAGENTA, _YELLOW, _BRIGHTWHITE</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int col;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( col = 0; col &lt; 16; ++col ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _remappalette( 0, colors&#91; col &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="remove"> remove, _wremove </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int remove( const char *filename );</tt>
<br><tt>int _wremove( const wchar_t *filename );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> remove</tt> function deletes the file whose name is the string pointed to by<b> filename</b>.
<br>The<tt> _wremove</tt> function is identical to<tt> remove</tt> except that it accepts a wide-character string argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> remove</tt> function returns zero if the operation succeeds, non-zero if it fails.&nbsp; When an error has occurred,
 <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; remove( &quot;vm.tmp&quot; );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>remove is ANSI
<br>_wremove is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> remove - All, Netware</tt>
<br><tt>_wremove - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="rename"> rename, _wrename </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int rename( const char *old, const char *new );</tt>
<br><tt>int _wrename( const wchar_t *old, const wchar_t *new );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> rename</tt> function causes the file whose name is indicated by the string<b> old</b> to be renamed to the name given
 by the string<b> new</b>.&nbsp; The<tt> _wrename</tt> function is identical to<tt> rename</tt> except that it accepts wide-character
 string arguments.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> rename</tt> function returns zero if the operation succeeds, a non-zero value if it fails.&nbsp; When an error has
 occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rename( &quot;old.dat&quot;, &quot;new.dat&quot; );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>rename is ANSI
<br>_wrename is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> rename - All, Netware</tt>
<br><tt>_wrename - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="rewind"> rewind </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>void rewind( FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> rewind</tt> function sets the file position indicator for the stream indicated to by<b> fp</b> to the beginning of
 the file.&nbsp; It is equivalent to
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fseek( fp, 0L, SEEK_SET );</tt>
<br><br>except that the error indicator for the stream is cleared.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> rewind</tt> function returns no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#clearerr">clearerr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>static assemble_pass( int passno )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Pass %d\n&quot;, passno );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( (fp = fopen( &quot;program.asm&quot;, &quot;r&quot;)) != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assemble_pass( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewind( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assemble_pass( 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="rewinddir"> rewinddir, _wrewinddir </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><tt>void rewinddir( struct dirent *dirp );</tt>
<br><tt>void _wrewinddir( _wdirent *dirp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> rewinddir</tt> function resets the position of the directory stream to which<b> dirp</b> refers to the beginning of
 the directory.&nbsp; It also causes the directory stream to refer to the current state of the corresponding directory, as
 a call to <tt> opendir</tt> would have done.
<br>The<tt> _wrewinddir</tt> function is identical to<tt> rewinddir</tt> except that it rewinds a directory of wide-character
 filenames opened by <tt> _wopendir</tt>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> rewinddir</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#closedir">closedir</a>, <a href="#_dos_find___">_dos_find...</a>, <a href="#opendir">opendir</a>, <a href="#readdir">readdir</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>The following example lists all the files in a directory, creates a new file, and then relists the directory.
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; DIR *dirp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct dirent *direntp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; dirp = opendir( &quot;\\watcom\\h\\*.*&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( dirp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Old directory listing\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp = readdir( dirp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( direntp == NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, direntp-&gt;d_name );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handle = creat( &quot;\\watcom\\h\\file.new&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rewinddir( dirp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;New directory listing\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(;;) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; direntp = readdir( dirp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( direntp == NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, direntp-&gt;d_name );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; closedir( dirp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</dl>
<dl>
<dt>Classification:
<dd>rewinddir is POSIX 1003.1
<br>_wrewinddir is not POSIX
</dl>
<dl>
<dt>Systems:
<dd><tt> rewinddir - All</tt>
<br><tt>_wrewinddir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="rmdir"> rmdir, _rmdir, _wrmdir </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><tt>int rmdir( const char *path );</tt>
<br><tt>int _rmdir( const char *path );</tt>
<br><tt>int _wrmdir( const wchar_t *path );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> rmdir</tt> function removes (deletes) the specified directory.&nbsp; The directory must not contain any files or directories.
&nbsp; The<b> path</b> can be either relative to the current working directory or it can be an absolute path name.
<br>The<tt> _rmdir</tt> function is identical to<tt> rmdir</tt>.&nbsp; Use<tt> _rmdir</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _wrmdir</tt> function is identical to<tt> rmdir</tt> except that it accepts a wide-character string argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> rmdir</tt> function returns zero if successful and -1 otherwise.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#chdir">chdir</a>, <a href="#chmod">chmod</a>, <a href="#getcwd">getcwd</a>, <a href="#mkdir">mkdir</a>, <a href="#stat">stat</a>,
 <a href="#umask">umask</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>To remove the directory called<tt> \watcom</tt> on drive<tt> C:</tt>
<br><br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;direct.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rmdir( &quot;c:\\watcom&quot; );</tt>
<br><tt>}</tt>
<br><br>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</dl>
<dl>
<dt>Classification:
<dd>rmdir is POSIX 1003.1
<br>_rmdir is not POSIX
<br>_wrmdir is not POSIX
<br>_rmdir conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> rmdir - All, Netware</tt>
<br><tt>_rmdir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wrmdir - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_rotl"> _rotl </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>unsigned int _rotl( unsigned int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 unsigned int shift );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _rotl</tt> function rotates the unsigned integer, determined by<b> value</b>, to the left by the number of bits specified
 in<b> shift</b>.&nbsp; If you port an application using<tt> _rotl</tt> between a 16-bit and a 32-bit environment, you will
 get different results because of the difference in the size of integers.
</dl>
<dl>
<dt>Returns:
<dd>The rotated value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_lrotl">_lrotl</a>, <a href="#_lrotr">_lrotr</a>, <a href="#_rotr">_rotr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>unsigned int mask = 0x0F00;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mask = _rotl( mask, 4 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%04X\n&quot;, mask );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>F000</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_rotr"> _rotr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>unsigned int _rotr( unsigned int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 unsigned int shift );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _rotr</tt> function rotates the unsigned integer, determined by<b> value</b>, to the right by the number of bits specified
 in<b> shift</b>.&nbsp; If you port an application using<tt> _rotr</tt> between a 16-bit and a 32-bit environment, you will
 get different results because of the difference in the size of integers.
</dl>
<dl>
<dt>Returns:
<dd>The rotated value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_lrotl">_lrotl</a>, <a href="#_lrotr">_lrotr</a>, <a href="#_rotl">_rotl</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>unsigned int mask = 0x1230;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mask = _rotr( mask, 4 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%04X\n&quot;, mask );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0123</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="sbrk"> sbrk </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void *sbrk( int increment );</tt>
</dl>
<dl>
<dt>Description:
<dd>Under 16-bit DOS and Phar Lap's 386|DOS-Extender, the data segment is grown contiguously.&nbsp; The &quot;break&quot; value
 is the address of the first byte of unallocated memory.&nbsp; When a program starts execution, the break value is placed
 following the code and constant data for the program.&nbsp; As memory is allocated, this pointer will advance when there
 is no freed block large enough to satisfy an allocation request.&nbsp; The<tt> sbrk</tt> function can be used to set a new
 &quot;break&quot; value for the program by adding the value of<b> increment</b> to the current break value.&nbsp; This increment
 may be positive or negative.
<br>Under other systems, heap allocation is discontiguous.&nbsp; The<tt> sbrk</tt> function can only be used to allocate additional
 discontiguous blocks of memory.&nbsp; The value of<b> increment</b> is used to determine the minimum size of the block to
 be allocated and may not be zero or negative.&nbsp; The actual size of the block that is allocated is rounded up to a multiple
 of 4K.
<br><br>The variable <tt> _amblksiz</tt> defined in<tt> &lt;stdlib.h&gt;</tt> contains the default increment by which the
 &quot;break&quot; pointer for memory allocation will be advanced when there is no freed block large enough to satisfy a request
 to allocate a block of memory.&nbsp; This value may be changed by a program at any time.
<br><br>Under 16-bit DOS, a new process started with one of the <tt> spawn...</tt>&nbsp; or <tt> exec...</tt>&nbsp; functions
 is loaded following the break value.&nbsp; Consequently, decreasing the break value leaves more space available to the new
 process.&nbsp; Similarly, for a resident program (a program which remains in memory while another program executes), increasing
 the break value will leave more space available to be allocated by the resident program after other programs are loaded.
</dl>
<dl>
<dt>Returns:
<dd>If the call to<tt> sbrk</tt> succeeds, a pointer to the start of the new block of memory is returned.&nbsp; Under 16-bit DOS,
 this corresponds to the old break value.&nbsp; If the call to<tt> sbrk</tt> fails, -1 is returned.&nbsp; When an error has
 occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#calloc">calloc</a> Functions, <a href="#_expand">_expand</a> Functions, <a href="#free">free</a> Functions, <a href="#halloc">halloc</a>,
 <a href="#hfree">hfree</a>, <a href="#malloc">malloc</a> Functions, <a href="#_msize">_msize</a> Functions, <a href="#realloc">realloc</a>
 Functions
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>#if defined(M_I86)</tt>
<br><tt>#define alloc( x, y ) sbrk( x ); y = sbrk( 0 );</tt>
<br><tt>#else</tt>
<br><tt>#define alloc( x, y ) y = sbrk( x );</tt>
<br><tt>#endif</tt>
<br><br><tt>void main()</tt>
<br><tt> {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; void *brk;</tt>
<br><br><tt>#if defined(M_I86)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; alloc( 0x0000, brk );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* calling printf will cause an allocation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Original break value %p\n&quot;, brk );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Current amblksiz value %x\n&quot;, _amblksiz );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; alloc( 0x0000, brk );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;New break value after printf \t\t%p\n&quot;, brk );</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp; alloc( 0x3100, brk );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;New break value after sbrk( 0x3100 ) \t%p\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brk );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; alloc( 0x0200, brk );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;New break value after sbrk( 0x0200 ) \t%p\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brk );</tt>
<br><tt>#if defined(M_I86)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; alloc( -0x0100, brk );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;New break value after sbrk( -0x0100 ) \t%p\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brk );</tt>
<br><tt>#endif</tt>
<br><tt> }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, QNX, OS/2 1.x, OS/2 1.x(MT), OS/2-32
</dl>
<h2 id="scanf"> scanf, wscanf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int scanf( const char *format, ... );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int wscanf( const wchar_t *format, ... );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#scanf_s">scanf_s</a> function which is a safer alternative to<tt> scanf</tt>.
&nbsp; This newer<tt> scanf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> scanf</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> scanf</tt> function scans input from the file designated by <tt> stdin</tt> under control of the argument<b> format</b>.
&nbsp; The<b> format</b> string is described below.&nbsp; Following the format string is the list of addresses of items to
 receive values.
<br>The<tt> wscanf</tt> function is identical to<tt> scanf</tt> except that it accepts a wide-character string argument for<b>
 format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> scanf</tt> function returns <tt> EOF</tt> if an input failure occured before any conversion.&nbsp; Otherwise, the
 number of input arguments for which values were successfully scanned and stored is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cscanf">cscanf</a>, <a href="#fscanf">fscanf</a>, <a href="#sscanf">sscanf</a>, <a href="#vcscanf">vcscanf</a>,
 <a href="#vfscanf">vfscanf</a>, <a href="#vscanf">vscanf</a>, <a href="#vsscanf">vsscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>To scan a date in the form &quot;Saturday April 18 1987&quot;:
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; scanf( &quot;%s %s %d %d&quot;, weekday, month, &amp;day, &amp;year );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Format Control String:
<dd>The format control string consists of zero or more<b> format directives</b> that specify acceptable input file data.&nbsp;
 Subsequent arguments are pointers to various types of objects that are assigned values as the format string is processed.
<br>A format directive can be a sequence of one or more white-space characters, an<b> ordinary character,</b> or a<b> conversion
 specifier.</b>&nbsp; An ordinary character in the format string is any character, other than a white-space character or the
 percent character (%), that is not part of a conversion specifier.&nbsp; A conversion specifier is a sequence of characters
 in the format string that begins with a percent character (%) and is followed, in sequence, by the following:
<ul>
<li>an optional assignment suppression indicator:&nbsp; the asterisk character (*);
<li>an optional decimal integer that specifies the<b> maximum field width</b> to be scanned for the conversion;
<li>an optional<b> pointer-type</b> specification:&nbsp; one of &quot;N&quot; or &quot;W&quot;;
<li>an optional<b> type length</b> specification:&nbsp; one of &quot;hh&quot;, &quot;h&quot;, &quot;l&quot;, &quot;ll&quot;,
 &quot;j&quot;, &quot;z&quot;, &quot;t&quot;, &quot;L&quot; or &quot;I64&quot;;
<li>a character that specifies the type of conversion to be performed:&nbsp; one of the characters &quot;cCdeEfFgGinopsSuxX&#91;&quot;.
</ul>
<br>As each format directive in the format string is processed, the directive may successfully complete, fail because of a
 lack of input data, or fail because of a matching error as defined by the particular directive.&nbsp; If end-of-file is encountered
 on the input data before any characters that match the current directive have been processed (other than leading white-space
 where permitted), the directive fails for lack of data.&nbsp; If end-of-file occurs after a matching character has been processed,
 the directive is completed (unless a matching error occurs), and the function returns without processing the next directive.
&nbsp; If a directive fails because of an input character mismatch, the character is left unread in the input stream.&nbsp;
 Trailing white-space characters, including new-line characters, are not read unless matched by a directive.&nbsp; When a
 format directive fails, or the end of the format string is encountered, the scanning is completed and the function returns.
<br><br>When one or more white-space characters (space &quot; &quot;, horizontal tab &quot;\t&quot;, vertical tab &quot;\v&quot;,
 form feed &quot;\f&quot;, carriage return &quot;\r&quot;, new line or linefeed &quot;\n&quot;) occur in the format string,
 input data up to the first non-white-space character is read, or until no more data remains.&nbsp; If no white-space characters
 are found in the input data, the scanning is complete and the function returns.
<br><br>An ordinary character in the format string is expected to match the same character in the input stream.
<br><br>A conversion specifier in the format string is processed as follows:
<ul>
<li>for conversion types other than &quot;&#91;&quot;, &quot;c&quot;, &quot;C&quot; and &quot;n&quot;, leading white-space
 characters are skipped
<li>for conversion types other than &quot;n&quot;, all input characters, up to any specified maximum field length, that can
 be matched by the conversion type are read and converted to the appropriate type of value; the character immediately following
 the last character to be matched is left unread; if no characters are matched, the format directive fails
<li>unless the assignment suppression indicator (&quot;*&quot;) was specified, the result of the conversion is assigned to
 the object pointed to by the next unused argument (if assignment suppression was specified, no argument is skipped); the
 arguments must correspond in number, type and order to the conversion specifiers in the format string
</ul>
<br>A pointer-type specification is used to indicate the type of pointer used to locate the next argument to be scanned:
<dl>
<dt>W
<dd>pointer is a far pointer
<dt><br>N
<dd>pointer is a near pointer
</dl>
<br>The pointer-type specification is only effective on platforms that use a segmented memory model, although it is always
 recognized.
<br><br>The pointer type defaults to that used for data in the memory model for which the program has been compiled.
<br><br>A type length specifier affects the conversion as follows:
<ul>
<li>&quot;hh&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
 to assign the converted value to an object of type<tt> signed char</tt> or<tt> unsigned char.</tt>
<li>&quot;hh&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
 been read to an object of type<tt> signed char.</tt>
<li>&quot;h&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
 to assign the converted value to an object of type<tt> short int</tt> or<tt> unsigned short int.</tt>
<li>&quot;h&quot; causes an &quot;f&quot; conversion to assign a fixed-point number to an object of type<tt> long</tt> consisting
 of a 16-bit signed integer part and a 16-bit unsigned fractional part.&nbsp; The integer part is in the high 16 bits and
 the fractional part is in the low 16 bits.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct fixpt {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned short fraction; /* Intel architecture! */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed short integral;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct fixpt foo1 =</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 0x8000, 1234 }; /* represents 1234.5 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; struct fixpt foo2 =</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { 0x8000, -1 };&nbsp;&nbsp; /* represents -0.5 (-1+.5) */</tt>
<li>&quot;h&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
 been read to an object of type<tt> short int.</tt>
<li>&quot;h&quot; causes an &quot;s&quot; operation to convert the input string to an ASCII character string.&nbsp; For<tt>
 scanf</tt>, this specifier is redundant.&nbsp; For<tt> wscanf</tt>, this specifier is required if the wide character input
 string is to be converted to an ASCII character string; otherwise it will not be converted.
<li>&quot;l&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
 to assign the converted value to an object of type<tt> long int</tt> or<tt> unsigned long int.</tt>
<li>&quot;l&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
 been read to an object of type<tt> long int.</tt>
<li>&quot;l&quot; causes an &quot;e&quot;, &quot;f&quot; or &quot;g&quot; (floating-point) conversion to assign the converted
 value to an object of type<tt> double.</tt>
<li>&quot;l&quot; or &quot;w&quot; cause an &quot;s&quot; operation to convert the input string to a wide character string.
&nbsp; For<tt> scanf</tt>, this specifier is required if the input ASCII string is to be converted to a wide character string;
 otherwise it will not be converted.
<li>&quot;ll&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
 to assign the converted value to an object of type<tt> long long</tt> or<tt> unsigned long long</tt> (e.g., %lld).
<li>&quot;ll&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
 been read to an object of type<tt> long long int.</tt>
<li>&quot;j&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
 to assign the converted value to an object of type<tt> intmax_t</tt> or<tt> uintmax_t.</tt>
<li>&quot;j&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
 been read to an object of type<tt> intmax_t.</tt>
<li>&quot;z&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
 to assign the converted value to an object of type<tt> size_t</tt> or the corresponding signed integer type.
<li>&quot;z&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
 been read to an object of signed integer type corresponding to<tt> size_t.</tt>
<li>&quot;t&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
 to assign the converted value to an object of type<tt> ptrdiff_t</tt> or the corresponding unsigned integer type.
<li>&quot;t&quot; causes an &quot;n&quot; (read length assignment) operation to assign the number of characters that have
 been read to an object of type<tt> ptrdiff_t.</tt>
<li>&quot;I64&quot; causes a &quot;d&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; or &quot;x&quot; (integer) conversion
 to assign the converted value to an object of type<tt> __int64</tt> or<tt> unsigned __int64</tt> (e.g., %I64d).
<li>&quot;L&quot; causes an &quot;e&quot;, &quot;f&quot; or &quot;g&quot; (floating-point) conversion to assign the converted
 value to an object of type<tt> long double.</tt>
</ul>
<br>The valid conversion type specifiers are:
<dl>
<dt>c
<dd>Any sequence of characters in the input stream of the length specified by the field width, or a single character if no field
 width is specified, is matched.&nbsp; The argument is assumed to point to the first element of a character array of sufficient
 size to contain the sequence, without a terminating null character ('\0').&nbsp; For a single character assignment, a pointer
 to a single object of type<tt> char</tt> is sufficient.
<dt><br>C
<dd>A sequence of multibyte characters in the input stream is matched.&nbsp; Each multibyte character is converted to a wide character
 of type<tt> wchar_t.</tt>&nbsp; The number of wide characters matched is specified by the field width (1 if no field width
 is specified).&nbsp; The argument is assumed to point to the first element of an array of<tt> wchar_t</tt> of sufficient
 size to contain the sequence.&nbsp; No terminating null wide character (L'\0') is added.&nbsp; For a single wide character
 assignment, a pointer to a single object of type<tt> wchar_t</tt> is sufficient.
<dt><br>d
<dd>A decimal integer, consisting of an optional sign, followed by one or more decimal digits, is matched.&nbsp; The argument
 is assumed to point to an object of type<tt> int.</tt>
<dt><br>e, f, g
<dd>A floating-point number, consisting of an optional sign (&quot;+&quot; or &quot;-&quot;), followed by one or more decimal
 digits, optionally containing a decimal-point character, followed by an optional exponent of the form &quot;e&quot; or &quot;E&quot;,
 an optional sign and one or more decimal digits, is matched.&nbsp; The exponent, if present, specifies the power of ten by
 which the decimal fraction is multiplied.&nbsp; The argument is assumed to point to an object of type<tt> float.</tt>
<dt><br>i
<dd>An optional sign, followed by an octal, decimal or hexadecimal constant is matched.&nbsp; An octal constant consists of &quot;0&quot;
 and zero or more octal digits.&nbsp; A decimal constant consists of a non-zero decimal digit and zero or more decimal digits.
&nbsp; A hexadecimal constant consists of the characters &quot;0x&quot; or &quot;0X&quot; followed by one or more (upper-
 or lowercase) hexadecimal digits.&nbsp; The argument is assumed to point to an object of type<tt> int.</tt>
<dt><br>n
<dd>No input data is processed.&nbsp; Instead, the number of characters that have already been read is assigned to the object
 of type<tt> unsigned int</tt> that is pointed to by the argument.&nbsp; The number of items that have been scanned and assigned
 (the return value) is not affected by the &quot;n&quot; conversion type specifier.
<dt><br>o
<dd>An octal integer, consisting of an optional sign, followed by one or more (zero or non-zero) octal digits, is matched.&nbsp;
 The argument is assumed to point to an object of type<tt> int.</tt>
<dt><br>p
<dd>A hexadecimal integer, as described for &quot;x&quot; conversions below, is matched.&nbsp; The converted value is further
 converted to a value of type<tt> void*</tt> and then assigned to the object pointed to by the argument.
<dt><br>s
<dd>A sequence of non-white-space characters is matched.&nbsp; The argument is assumed to point to the first element of a character
 array of sufficient size to contain the sequence and a terminating null character, which is added by the conversion operation.
<dt><br>S
<dd>A sequence of multibyte characters is matched.&nbsp; None of the multibyte characters in the sequence may be single byte white-space
 characters.&nbsp; Each multibyte character is converted to a wide character.&nbsp; The argument is assumed to point to the
 first element of an array of<tt> wchar_t</tt> of sufficient size to contain the sequence and a terminating null wide character,
 which is added by the conversion operation.
<dt><br>u
<dd>An unsigned decimal integer, consisting of one or more decimal digits, is matched.&nbsp; The argument is assumed to point
 to an object of type<tt> unsigned int.</tt>
<dt><br>x
<dd>A hexadecimal integer, consisting of an optional sign, followed by an optional prefix &quot;0x&quot; or &quot;0X&quot;, followed
 by one or more (upper- or lowercase) hexadecimal digits, is matched.&nbsp; The argument is assumed to point to an object
 of type<tt> int.</tt>
<dt><br>&#91;c1c2...&#93;
<dd>The longest, non-empty sequence of characters, consisting of any of the characters<tt> c1, c2, ...</tt>&nbsp; called the<b>
 scanset,</b> in any order, is matched.<tt>&nbsp; c1</tt> cannot be the caret character ('^').&nbsp; If<tt> c1</tt> is &quot;&#93;&quot;,
 that character is considered to be part of the scanset and a second &quot;&#93;&quot; is required to end the format directive.
&nbsp; The argument is assumed to point to the first element of a character array of sufficient size to contain the sequence
 and a terminating null character, which is added by the conversion operation.
<dt><br>&#91;^c1c2...&#93;
<dd>The longest, non-empty sequence of characters, consisting of any characters<b> other than</b> the characters between the &quot;^&quot;
 and &quot;&#93;&quot;, is matched.&nbsp; As with the preceding conversion, if<tt> c1</tt> is &quot;&#93;&quot;, it is considered
 to be part of the scanset and a second &quot;&#93;&quot; ends the format directive.&nbsp; The argument is assumed to point
 to the first element of a character array of sufficient size to contain the sequence and a terminating null character, which
 is added by the conversion operation.
<br>For example, the specification<tt> %&#91;^\n&#93;</tt> will match an entire input line up to but not including the newline
 character.
</dl>
<br>A conversion type specifier of &quot;%&quot; is treated as a single ordinary character that matches a single &quot;%&quot;
 character in the input data.&nbsp; A conversion type specifier other than those listed above causes scanning to terminate
 and the function to return.
<br><br>Conversion type specifiers &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;X&quot; have meaning identical to their
 lowercase equivalents.
<br><br>The line
<br><br><tt>scanf( &quot;%s%*f%3hx%d&quot;, name, &amp;hexnum, &amp;decnum )</tt>
<br><br>with input
<br><br><tt>some_string 34.555e-3 abc1234</tt>
<br><br>will copy<tt> &quot;some_string&quot;</tt> into the array<tt> name,</tt> skip<tt> 34.555e-3</tt>, assign<tt> 0xabc</tt>
 to<tt> hexnum</tt> and<tt> 1234</tt> to<tt> decnum.</tt>&nbsp; The return value will be 3.
<br>The program
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char string1&#91;80&#93;, string2&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; scanf( &quot;%&#91;abcdefghijklmnopqrstuvwxyz&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;ABCDEFGHIJKLMNOPQRSTUVWZ &#93;%*2s%&#91;^\n&#93;&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string1, string2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n%s\n&quot;, string1, string2 );</tt>
<br><tt>}</tt>
<br><br>with input
<br><br><tt>They may look alike, but they don't perform alike.</tt>
<br><br>will assign
<br><br><tt>&quot;They may look alike&quot;</tt>
<br><br>to<tt> string1,</tt> skip the comma (the<tt> &quot;%*2s&quot;</tt> will match only the comma; the following blank
 terminates that field), and assign
<br><br><tt>&quot; but they don't perform alike.&quot;</tt>
<br><br>to<tt> string2.</tt>
</dl>
<dl>
<dt>Classification:
<dd>scanf is ISO C90
<br>wscanf is ISO C95
<br>The N, W pointer size modifiers and the I64 modifier are extensions to ISO C.
</dl>
<dl>
<dt>Systems:
<dd><tt> scanf - All, Netware</tt>
<br><tt>wscanf - All</tt>
</dl>
<h2 id="scanf_s"> scanf_s, wscanf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int scanf_s( const char * restrict format, ... );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int wscanf_s( const wchar_t * restrict format, ... );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 scanf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>The<b> format</b> argument shall not be a null pointer.&nbsp; Any argument indirected through in order to store converted
 input shall not be a null pointer.
<br><br>If there is a runtime-constraint violation, the<tt> scanf_s</tt> function does not attempt to perform further input,
 and it is unspecified to what extent<tt> scanf_s</tt> performed input before discovering the runtime-constraint violation.
</dl>
<dl>
<dt>Description:
<dd>The<tt> scanf_s</tt> function is equivalent to <tt> fscanf_s</tt> with the argument<b> stdin</b> interposed before the arguments
 to<tt> scanf_s</tt>
<br>The<tt> wscanf_s</tt> function is identical to<tt> scanf_s</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> scanf_s</tt> function returns <tt> EOF</tt> if an input failure occurred before any conversion or if there was a runtime-constraint
 violation.&nbsp; Otherwise, the<tt> scanf_s</tt> function returns the number of input items successfully assigned, which
 can be fewer than provided for, or even zero.
<br>When a file input error occurs, the <tt> errno</tt> global variable may be set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cscanf">cscanf</a>, <a href="#fscanf">fscanf</a>, <a href="#scanf">scanf</a>, <a href="#sscanf">sscanf</a>, <a href="#vcscanf">vcscanf</a>,
 <a href="#vfscanf">vfscanf</a>, <a href="#vscanf">vscanf</a>, <a href="#vsscanf">vsscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>To scan a date in the form &quot;Friday August 13 2004&quot;:
<br><br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; scanf_s( &quot;%s %s %d %d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, sizeof( weekday ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; month, sizeof( month ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;day, &amp;year );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>scanf_s is TR 24731
<br>wscanf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> scanf_s - All, Netware</tt>
<br><tt>wscanf_s - All</tt>
</dl>
<h2 id="_scrolltextwindow"> _scrolltextwindow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _scrolltextwindow( short rows );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _scrolltextwindow</tt> function scrolls the lines in the current text window.&nbsp; A text window is defined with
 the <tt> _settextwindow</tt> function.&nbsp; By default, the text window is the entire screen.
<br>The argument<b> rows</b> specifies the number of rows to scroll.&nbsp; A positive value means to scroll the text window
 up or towards the top of the screen.&nbsp; A negative value means to scroll the text window down or towards the bottom of
 the screen.&nbsp; Specifying a number of rows greater than the height of the text window is equivalent to clearing the text
 window with the <tt> _clearscreen</tt> function.
<br><br>Two constants are defined that can be used with the<tt> _scrolltextwindow</tt> function:
<dl>
<dt>_GSCROLLUP
<dd>the contents of the text window are scrolled up (towards the top of the screen) by one row
<dt><br>_GSCROLLDOWN
<dd>the contents of the text window are scrolled down (towards the bottom of the screen) by one row
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _scrolltextwindow</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextwindow">_settextwindow</a>, <a href="#_clearscreen">_clearscreen</a>, <a href="#_outtext">_outtext</a>,
 <a href="#_outmem">_outmem</a>, <a href="#_settextposition">_settextposition</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 80 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextwindow( 5, 20, 20, 40 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 10; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Line %d\n&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _scrolltextwindow( _GSCROLLDOWN );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _scrolltextwindow( _GSCROLLUP );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>_scrolltextwindow is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_searchenv"> _searchenv, _wsearchenv </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void _searchenv( const char *name,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *env_var,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char *pathname );</tt>
<br><tt>void _wsearchenv( const wchar_t *name,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
 *env_var,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *pathname );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _searchenv</tt> function searches for the file specified by<b> name</b> in the list of directories assigned to the
 environment variable specified by<b> env_var</b>.&nbsp; Common values for<b> env_var</b> are PATH, LIB and INCLUDE.
<br>The current directory is searched first to find the specified file.&nbsp; If the file is not found in the current directory,
 each of the directories specified by the environment variable is searched.
<br><br>The full pathname is placed in the buffer pointed to by the argument<b> pathname</b>.&nbsp; If the specified file
 cannot be found, then<b> pathname</b> will contain an empty string.
<br><br>The<tt> _wsearchenv</tt> function is a wide-character version of<tt> _searchenv</tt> that operates with wide-character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _searchenv</tt> function returns no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#getenv">getenv</a>, <a href="#setenv">setenv</a>, <a href="#_splitpath">_splitpath</a>, <a href="#putenv">putenv</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void display_help( FILE *fp )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;display_help T.B.I.\n&quot; );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *help_file;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char full_path&#91; _MAX_PATH &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _searchenv( &quot;watcomc.hlp&quot;, &quot;PATH&quot;, full_path );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( full_path&#91;0&#93; == '\0' ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to find help file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; help_file = fopen( full_path, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display_help( help_file );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( help_file );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _searchenv - All</tt>
<br><tt>_wsearchenv - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="segread"> segread </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>void segread( struct SREGS *seg_regs );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> segread</tt> function places the values of the segment registers into the structure located by<b> seg_regs</b>.
</dl>
<dl>
<dt>Returns:
<dd>No value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#FP_OFF">FP_OFF</a>, <a href="#FP_SEG">FP_SEG</a>, <a href="#MK_FP">MK_FP</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct SREGS sregs;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; segread( &amp;sregs );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Current value of CS is %04X\n&quot;, sregs.cs );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_selectpalette"> _selectpalette </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _selectpalette( short palnum );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _selectpalette</tt> function selects the palette indicated by the argument<b> palnum</b> from the color palettes available.
&nbsp; This function is only supported by the video modes<tt> _MRES4COLOR</tt> and<tt> _MRESNOCOLOR.</tt>
<br>Mode<tt> _MRES4COLOR</tt> supports four palettes of four colors.&nbsp; In each palette, color 0, the background color,
 can be any of the 16 possible colors.&nbsp; The color values associated with the other three pixel values, (1, 2 and 3),
 are determined by the selected palette.
<br><br>The following table outlines the available color palettes:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Palette&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pixel
 Values</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Number&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; green&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; red&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brown</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; cyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; magenta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; white</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; light green&nbsp;&nbsp;&nbsp;&nbsp; light red
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yellow</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; light cyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; light
 magenta&nbsp;&nbsp; bright white</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _selectpalette</tt> function returns the number of the previously selected palette.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setvideomode">_setvideomode</a>, <a href="#_getvideoconfig">_getvideoconfig</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int x, y, pal;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _MRES4COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( y = 0; y &lt; 2; ++y ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( x = 0; x &lt; 2; ++x ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setcolor( x + 2 * y );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 x * 160, y * 100,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 ( x + 1 ) * 160, ( y + 1 ) * 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( pal = 0; pal &lt; 4; ++pal ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _selectpalette( pal );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="set_constraint_handler_s"> set_constraint_handler_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>constraint_handler_t set_constraint_handler_s(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constraint_handler_t handler );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> set_constraint_handler_s</tt> function sets the runtime-constraint handler to be<b> handler</b>.&nbsp; The runtime-constraint
 handler is the function called when a library function detect a runtime-constraint violation.&nbsp; Only the most recent
 handler registered with<tt> set_constraint_handler_s</tt> is called when a runtime-constraint violation occurs.
<br>When the handler is called, it is passed the following arguments:
<ol>
<li>A pointer to a character string describing the runtime-constraint violation.
<li>A null pointer or a pointer to an implementation defined object.&nbsp; This implementation passes a null pointer.
<li>If the function calling the handler has a return type declared as <tt> errno_t</tt>, the return value of the function
 is passed.&nbsp; Otherwise, a positive value of type <tt> errno_t</tt> is passed.
</ol>
<br>If no calls to the<tt> set_constraint_handler_s</tt> function have been made, a default constraint handler is used.&nbsp;
 This handler will display an error message and abort the program.
<br><br>If the<b> handler</b> argument to<tt> set_constraint_handler_s</tt> is a null pointer, the default handler becomes
 the current constraint handler.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> set_constraint_handler_s</tt> function returns a pointer to the previously registered handler.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abort_handler_s">abort_handler_s</a>, <a href="#ignore_handler_s">ignore_handler_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void my_handler( const char *msg, void *ptr, errno_t error )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;rt-constraint violation caught :&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( stderr, msg );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;\n&quot; );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; constraint_handler_t&nbsp;&nbsp;&nbsp; old_handler;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; old_handler = set_constraint_handler_s( my_handler );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( getenv_s( NULL, NULL, 0, NULL ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;getenv_s failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; set_constraint_handler_s( old_handler );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>rt-constraint violation caught: getenv_s, name == NULL.</tt>
<br><tt>getenv_s failed</tt>
</dl>
<dl>
<dt>Classification:
<dd>TR 24731
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_setactivepage"> _setactivepage </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _setactivepage( short pagenum );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setactivepage</tt> function selects the page (in memory) to which graphics output is written.&nbsp; The page to be
 selected is given by the<b> pagenum</b> argument.
<br>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple pages
 are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
 what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
 can be constructed without affecting the screen by setting the active page to be different than the visual page.
<br><br>The number of available video pages can be determined by using the <tt> _getvideoconfig</tt> function.&nbsp; The default
 video page is 0.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setactivepage</tt> function returns the number of the previous page when the active page is set successfully; otherwise,
 a negative number is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getactivepage">_getactivepage</a>, <a href="#_setvisualpage">_setvisualpage</a>, <a href="#_getvisualpage">_getvisualpage</a>,
 <a href="#_getvideoconfig">_getvideoconfig</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_apage;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_vpage;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _HRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_apage = _getactivepage();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* draw an ellipse on page 0 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setactivepage( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvisualpage( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 50, 540, 150 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* draw a rectangle on page 1 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setactivepage( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 50, 540, 150 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* display page 1 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvisualpage( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setactivepage( old_apage );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvisualpage( old_vpage );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setbkcolor"> _setbkcolor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>long _FAR _setbkcolor( long color );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setbkcolor</tt> function sets the current background color to be that of the<b> color</b> argument.&nbsp; In text
 modes, the background color controls the area behind each individual character.&nbsp; In graphics modes, the background refers
 to the entire screen.&nbsp; The default background color is 0.
<br>When the current video mode is a graphics mode, any pixels with a zero pixel value will change to the color of the<b>
 color</b> argument.&nbsp; When the current video mode is a text mode, nothing will immediately change; only subsequent output
 is affected.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setbkcolor</tt> function returns the previous background color.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getbkcolor">_getbkcolor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>long colors&#91; 16 &#93; = {</tt>
<br><tt>&nbsp;&nbsp; _BLACK, _BLUE, _GREEN, _CYAN,</tt>
<br><tt>&nbsp;&nbsp; _RED, _MAGENTA, _BROWN, _WHITE,</tt>
<br><tt>&nbsp;&nbsp; _GRAY, _LIGHTBLUE, _LIGHTGREEN, _LIGHTCYAN,</tt>
<br><tt>&nbsp;&nbsp; _LIGHTRED, _LIGHTMAGENTA, _YELLOW, _BRIGHTWHITE</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long old_bk;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int bk;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( bk = 0; bk &lt; 16; ++bk ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setbkcolor( colors&#91; bk &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setbkcolor( old_bk );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="setbuf"> setbuf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>void setbuf( FILE *fp, char *buffer );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> setbuf</tt> function can be used to associate a buffer with the file designated by<b> fp</b>.&nbsp; If this function
 is used, it must be called after the file has been opened and before it has been read or written.&nbsp; If the argument<b>
 buffer</b> is<tt> NULL,</tt> then all input/output for the file<b> fp</b> will be completely unbuffered.&nbsp; If the argument<b>
 buffer</b> is not<tt> NULL,</tt> then it must point to an array that is at least <tt> BUFSIZ</tt> characters in length, and
 all input/output will be fully buffered.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> setbuf</tt> function returns no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#setvbuf">setvbuf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *buffer;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; buffer = (char *) malloc( BUFSIZ );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; setbuf( fp, buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_setcharsize"> _setcharsize, _setcharsize_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _setcharsize( short height, short width );</tt>
<br><br><tt>void _FAR _setcharsize_w( double height, double width );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setcharsize</tt> functions set the character height and width to the values specified by the arguments<b> height</b>
 and<b> width</b>.&nbsp; For the<tt> _setcharsize</tt> function, the arguments<b> height</b> and<b> width</b> represent a
 number of pixels.&nbsp; For the<tt> _setcharsize_w</tt> function, the arguments<b> height</b> and<b> width</b> represent
 lengths along the y-axis and x-axis in the window coordinate system.
<br>These sizes are used when displaying text with the <tt> _grtext</tt> function.&nbsp; The default character sizes are dependent
 on the graphics mode selected, and can be determined by the <tt> _gettextsettings</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setcharsize</tt> functions do not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_gettextsettings">_gettextsettings</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct textsettings ts;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _gettextsettings( &amp;ts );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 100, 100, &quot;WATCOM&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setcharsize( 2 * ts.height, 2 * ts.width );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 100, 300, &quot;Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setcharsize( ts.height, ts.width );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_getts.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _setcharsize - DOS, QNX</tt>
<br><tt>_setcharsize_w - DOS, QNX</tt>
</dl>
<h2 id="_setcharspacing"> _setcharspacing, _setcharspacing_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _setcharspacing( short space );</tt>
<br><br><tt>void _FAR _setcharspacing_w( double space );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setcharspacing</tt> functions set the current character spacing to have the value of the argument<b> space</b>.&nbsp;
 For the<tt> _setcharspacing</tt> function,<b> space</b> represents a number of pixels.&nbsp; For the<tt> _setcharspacing_w</tt>
 function,<b> space</b> represents a length along the x-axis in the window coordinate system.
<br>The character spacing specifies the additional space to leave between characters when a text string is displayed with
 the <tt> _grtext</tt> function.&nbsp; A negative value can be specified to cause the characters to be drawn closer together.
&nbsp; The default value of the character spacing is 0.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setcharspacing</tt> functions do not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_gettextsettings">_gettextsettings</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 100, 100, &quot;WATCOM&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setcharspacing( 20 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 100, 300, &quot;Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_setcs.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _setcharspacing - DOS, QNX</tt>
<br><tt>_setcharspacing_w - DOS, QNX</tt>
</dl>
<h2 id="_setcliprgn"> _setcliprgn </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _setcliprgn( short x1, short y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; short x2, short y2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setcliprgn</tt> function restricts the display of graphics output to the clipping region.&nbsp; This region is a
 rectangle whose opposite corners are established by the physical points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>
<br>The<tt> _setcliprgn</tt> function does not affect text output using the <tt> _outtext</tt> and <tt> _outmem</tt> functions.
&nbsp; To control the location of text output, see the <tt> _settextwindow</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setcliprgn</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextwindow">_settextwindow</a>, <a href="#_setvieworg">_setvieworg</a>, <a href="#_setviewport">_setviewport</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; short x1, y1, x2, y2;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _getcliprgn( &amp;x1, &amp;y1, &amp;x2, &amp;y2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setcliprgn( 130, 100, 510, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _ellipse( _GBORDER, 120, 90, 520, 390 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setcliprgn( x1, y1, x2, y2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setcolor"> _setcolor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _setcolor( short pixval );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setcolor</tt> function sets the pixel value for the current color to be that indicated by the<b> pixval</b> argument.
&nbsp; The current color is only used by the functions that produce graphics output; text output with <tt> _outtext</tt> uses
 the current text color (see the <tt> _settextcolor</tt> function).&nbsp; The default color value is one less than the maximum
 number of colors in the current video mode.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setcolor</tt> function returns the previous value of the current color.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getcolor">_getcolor</a>, <a href="#_settextcolor">_settextcolor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int col, old_col;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_col = _getcolor();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( col = 0; col &lt; 16; ++col ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setcolor( col );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setcolor( old_col );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="setenv"> setenv, _setenv, _wsetenv </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;env.h&gt;</tt>
<br><tt>int setenv( const char *name,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *newvalue,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int overwrite );</tt>
<br><tt>int _setenv( const char *name,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *newvalue,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int overwrite );</tt>
<br><tt>int _wsetenv( const wchar_t *name,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *newvalue,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int overwrite );</tt>
</dl>
<dl>
<dt>Description:
<dd>The environment list consists of a number of environment names, each of which has a value associated with it.&nbsp; Entries
 can be added to the environment list with the DOS<tt> set</tt> command or with the<tt> setenv</tt> function.&nbsp; All entries
 in the environment list can be displayed by using the DOS<tt> set</tt> command with no arguments.&nbsp; A program can obtain
 the value for an environment variable by using the <tt> getenv</tt> function.
<br>The<tt> setenv</tt> function searches the environment list for an entry of the form<b> name=value</b>.&nbsp; If no such
 string is present,<tt> setenv</tt> adds an entry of the form<b> name=newvalue</b> to the environment list.&nbsp; Otherwise,
 if the<b> overwrite</b> argument is non-zero,<tt> setenv</tt> either will change the existing value to<b> newvalue</b> or
 will delete the string<b> name=value</b> and add the string<b> name=newvalue</b>.
<br><br>If the<b> newvalue</b> pointer is NULL, all strings of the form<b> name=value</b> in the environment list will be
 deleted.
<br><br>The value of the pointer <tt> environ</tt> may change across a call to the<tt> setenv</tt> function.
<br><br>The<tt> setenv</tt> function will make copies of the strings associated with<b> name</b> and<b> newvalue</b>.
<br><br>The matching is case-insensitive; all lowercase letters are treated as if they were in upper case.
<br><br>Entries can also be added to the environment list with the DOS<tt> set</tt> command or with the <tt> putenv</tt> or<tt>
 setenv</tt> functions.&nbsp; All entries in the environment list can be obtained by using the <tt> getenv</tt> function.
<br><br>To assign a string to a variable and place it in the environment list:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET INCLUDE=C:\WATCOM\H</tt>
<br><br>To see what variables are in the environment list, and their current assignments:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;SET</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COMSPEC=C:\COMMAND.COM</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PATH=C:\;C:\WATCOM</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INCLUDE=C:\WATCOM\H</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C&gt;</tt>
<br><br>The<tt> _setenv</tt> function is identical to<tt> setenv</tt>.&nbsp; Use<tt> _setenv</tt> for ANSI naming conventions.
<br><br>The<tt> _wsetenv</tt> function is a wide-character version of<tt> setenv</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> setenv</tt> function returns zero upon successful completion.&nbsp; Otherwise, it will return a non-zero value and
 set <tt> errno</tt> to indicate the error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>ENOMEM
<dd>Not enough memory to allocate a new environment string.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#clearenv">clearenv</a>, <a href="#exec___">exec...</a>, <a href="#getenv">getenv</a>, <a href="#getenv_s">getenv_s</a>,
 <a href="#putenv">putenv</a>, <a href="#_searchenv">_searchenv</a>, <a href="#spawn___">spawn...</a>, <a href="#system">system</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>The following will change the string assigned to <tt> INCLUDE</tt> and then display the new string.
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;env.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *path;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( setenv( &quot;INCLUDE&quot;, &quot;D:\\WATCOM\\H&quot;, 1 ) == 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( (path = getenv( &quot;INCLUDE&quot; )) != NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;INCLUDE=%s\n&quot;, path );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> setenv - All</tt>
<br><tt>_setenv - All</tt>
<br><tt>_wsetenv - All</tt>
</dl>
<h2 id="_setfillmask"> _setfillmask </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _setfillmask( char _FAR *mask );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setfillmask</tt> function sets the current fill mask to the value of the argument<b> mask</b>.&nbsp; When the value
 of the<b> mask</b> argument is<tt> NULL,</tt> there will be no fill mask set.
<br>The fill mask is an eight-byte array which is interpreted as a square pattern (8 by 8) of 64 bits.&nbsp; Each bit in the
 mask corresponds to a pixel.&nbsp; When a region is filled, each point in the region is mapped onto the fill mask.&nbsp;
 When a bit from the mask is one, the pixel value of the corresponding point is set using the current plotting action with
 the current color; when the bit is zero, the pixel value of that point is not affected.
<br><br>When the fill mask is not set, a fill operation will set all points in the fill region to have a pixel value of the
 current color.&nbsp; By default, no fill mask is set.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setfillmask</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getfillmask">_getfillmask</a>, <a href="#_ellipse">_ellipse</a>, <a href="#_floodfill">_floodfill</a>, <a href="#_rectangle">_rectangle</a>,
 <a href="#_polygon">_polygon</a>, <a href="#_pie">_pie</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>char old_mask&#91; 8 &#93;;</tt>
<br><tt>char new_mask&#91; 8 &#93; = { 0x81, 0x42, 0x24, 0x18,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 0x18, 0x24, 0x42, 0x81 };</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _getfillmask( old_mask );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setfillmask( new_mask );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setfillmask( old_mask );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_getfm.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>_setfillmask is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setfont"> _setfont </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _setfont( char _FAR *opt );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setfont</tt> function selects a font from the list of registered fonts (see the <tt> _registerfonts</tt> function).
&nbsp; The font selected becomes the current font and is used whenever text is displayed with the <tt> _outgtext</tt> function.
&nbsp; The function will fail if no fonts have been registered, or if a font cannot be found that matches the given characteristics.
<br>The argument<b> opt</b> is a string of characters specifying the characteristics of the desired font.&nbsp; These characteristics
 determine which font is selected.&nbsp; The options may be separated by blanks and are not case-sensitive.&nbsp; Any number
 of options may be specified and in any order.&nbsp; The available options are:
<dl>
<dt>hX
<dd>character height X (in pixels)
<dt><br>wX
<dd>character width X (in pixels)
<dt><br>f
<dd>choose a fixed-width font
<dt><br>p
<dd>choose a proportional-width font
<dt><br>r
<dd>choose a raster (bit-mapped) font
<dt><br>v
<dd>choose a vector font
<dt><br>b
<dd>choose the font that best matches the options
<dt><br>nX
<dd>choose font number X (the number of fonts is returned by the <tt> _registerfonts</tt> function)
<dt><br>t'facename'
<dd>choose a font with specified facename
</dl>
<br>The facename option is specified as a &quot;t&quot; followed by a facename enclosed in single quotes.&nbsp; The available
 facenames are:
<dl>
<dt>Courier
<dd>fixed-width raster font with serifs
<dt><br>Helv
<dd>proportional-width raster font without serifs
<dt><br>Tms Rmn
<dd>proportional-width raster font with serifs
<dt><br>Script
<dd>proportional-width vector font that appears similar to hand-writing
<dt><br>Modern
<dd>proportional-width vector font without serifs
<dt><br>Roman
<dd>proportional-width vector font with serifs
</dl>
<br>When &quot;nX&quot; is specified to select a particular font, the other options are ignored.
<br><br>If the best fit option (&quot;b&quot;) is specified,<tt> _setfont</tt> will always be able to select a font.&nbsp;
 The font chosen will be the one that best matches the options specified.&nbsp; The following precedence is given to the options
 when selecting a font:
<ol>
<li>Pixel height (higher precedence is given to heights less than the specified height)
<li>Facename
<li>Pixel width
<li>Font type (fixed or proportional)
</ol>
<br>When a pixel height or width does not match exactly and a vector font has been selected, the font will be stretched appropriately
 to match the given size.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setfont</tt> function returns zero if successful; otherwise, (-1) is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_getfontinfo">_getfontinfo</a>,
 <a href="#_outgtext">_outgtext</a>, <a href="#_getgtextextent">_getgtextextent</a>, <a href="#_setgtextvector">_setgtextvector</a>,
 <a href="#_getgtextvector">_getgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i, n;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 10 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; n = _registerfonts( &quot;*.fon&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; n; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;n%d&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setfont( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _clearscreen( _GCLEARSCREEN );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _unregisterfonts();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setgtextvector"> _setgtextvector </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>struct xycoord _FAR _setgtextvector( short x, short y );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setgtextvector</tt> function sets the orientation for text output used by the <tt> _outgtext</tt> function to the
 vector specified by the arguments<tt> (x,y).</tt>&nbsp; Each of the arguments can have a value of -1, 0 or 1, allowing for
 text to be displayed at any multiple of a 45-degree angle.&nbsp; The default text orientation, for normal left-to-right text,
 is the vector<tt> (1,0).</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setgtextvector</tt> function returns, as an<tt> xycoord</tt> structure, the previous value of the text orientation
 vector.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_setfont">_setfont</a>,
 <a href="#_getfontinfo">_getfontinfo</a>, <a href="#_outgtext">_outgtext</a>, <a href="#_getgtextextent">_getgtextextent</a>,
 <a href="#_getgtextvector">_getgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct xycoord old_vec;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_vec = _getgtextvector();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setgtextvector( 0, -1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setgtextvector( old_vec.xcoord, old_vec.ycoord );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="setjmp"> setjmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;setjmp.h&gt;</tt>
<br><tt>int setjmp( jmp_buf env );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> setjmp</tt> function saves its calling environment in its <tt> jmp_buf</tt> argument, for subsequent use by the <tt>
 longjmp</tt> function.
<br>In some cases, error handling can be implemented by using<tt> setjmp</tt> to record the point to which a return will occur
 following an error.&nbsp; When an error is detected in a called function, that function uses <tt> longjmp</tt> to jump back
 to the recorded position.&nbsp; The original function which called<tt> setjmp</tt> must still be active (it cannot have returned
 to the function which called it).
<br><br>Special care must be exercised to ensure that any side effects that are left undone (allocated memory, opened files,
 etc.) are satisfactorily handled.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> setjmp</tt> function returns zero when it is initially called.&nbsp; The return value will be non-zero if the return
 is the result of a call to the <tt> longjmp</tt> function.&nbsp; An<tt> if</tt> statement is often used to handle these two
 returns.&nbsp; When the return value is zero, the initial call to<tt> setjmp</tt> has been made; when the return value is
 non-zero, a return from a <tt> longjmp</tt> has just occurred.
</dl>
<dl>
<dt>See Also:
<dd><a href="#longjmp">longjmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;setjmp.h&gt;</tt>
<br><br><tt>jmp_buf env;</tt>
<br><br><tt>rtn()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;about to longjmp\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; longjmp( env, 14 );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int ret_val = 293;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( 0 == ( ret_val = setjmp( env ) ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;after setjmp %d\n&quot;, ret_val );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rtn();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;back from rtn %d\n&quot;, ret_val );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;back from longjmp %d\n&quot;, ret_val );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>after setjmp 0</tt>
<br><tt>about to longjmp</tt>
<br><tt>back from longjmp 14</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_setlinestyle"> _setlinestyle </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _setlinestyle( unsigned short style );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setlinestyle</tt> function sets the current line-style mask to the value of the<b> style</b> argument.
<br>The line-style mask determines the style by which lines and arcs are drawn.&nbsp; The mask is treated as an array of 16
 bits.&nbsp; As a line is drawn, a pixel at a time, the bits in this array are cyclically tested.&nbsp; When a bit in the
 array is 1, the pixel value for the current point is set using the current color according to the current plotting action;
 otherwise, the pixel value for the point is left unchanged.&nbsp; A solid line would result from a value of<tt> 0xFFFF</tt>
 and a dashed line would result from a value of<tt> 0xF0F0</tt>
<br><br>The default line style mask is<tt> 0xFFFF</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setlinestyle</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getlinestyle">_getlinestyle</a>, <a href="#_lineto">_lineto</a>, <a href="#_rectangle">_rectangle</a>, <a href="#_polygon">_polygon</a>,
 <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>#define DASHED 0xf0f0</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned old_style;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_style = _getlinestyle();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setlinestyle( DASHED );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setlinestyle( old_style );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_getls.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="setlocale"> setlocale, _wsetlocale </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;locale.h&gt;</tt>
<br><tt>char *setlocale( int category, const char *locale );</tt>
<br><tt>wchar_t *_wsetlocale( int category, const wchar_t *locale);</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> setlocale</tt> function selects a portion of a program's<b> locale</b> according to the category given by<b> category</b>
 and the locale specified by<b> locale</b>.&nbsp; A<b> locale</b> affects the collating sequence (the order in which characters
 compare with one another), the way in which certain character-handling functions operate, the decimal-point character that
 is used in formatted input/output and string conversion, and the format and names used in the time string produced by the
 <tt> strftime</tt> function.
<br>Potentially, there may be many such environments.&nbsp; Watcom C/C++ supports only the<tt> &quot;C&quot;</tt> locale and
 so invoking this function will have no effect upon the behavior of a program at present.
<br><br>The possible values for the argument<b> category</b> are as follows:
<dl>
<dt>Category&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>LC_ALL
<dd>select entire environment
<dt><br>LC_COLLATE
<dd>select collating sequence
<dt><br>LC_CTYPE
<dd>select the character-handling
<dt><br>LC_MONETARY
<dd>select monetary formatting information
<dt><br>LC_NUMERIC
<dd>select the numeric-format environment
<dt><br>LC_TIME
<dd>select the time-related environment
</dl>
<br>At the start of a program, the equivalent of the following statement is executed.
<br><br><tt>&nbsp;&nbsp;&nbsp; setlocale( LC_ALL, &quot;C&quot; );</tt>
<br>The<tt> _wsetlocale</tt> function is a wide-character version of<tt> setlocale</tt> that operates with wide-character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>If the selection is successful, a string is returned to indicate the locale that was in effect before the function was invoked;
 otherwise, a<tt> NULL</tt> pointer is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcoll">strcoll</a>, <a href="#strftime">strftime</a>, <a href="#strxfrm">strxfrm</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;locale.h&gt;</tt>
<br><br><tt>char src&#91;&#93; = { &quot;A sample STRING&quot; };</tt>
<br><tt>char dst&#91;20&#93;;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *prev_locale;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t len;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* set native locale */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; prev_locale = setlocale( LC_ALL, &quot;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, prev_locale );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; len = strxfrm( dst, src, 20 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s (%u)\n&quot;, dst, len );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>C</tt>
<br><tt>A sample STRING (15)</tt>
</dl>
<dl>
<dt>Classification:
<dd>setlocale is ANSI, POSIX 1003.1
<br>_wsetlocale is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> setlocale - All, Netware</tt>
<br><tt>_wsetlocale - All</tt>
</dl>
<h2 id="_set_matherr"> _set_matherr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>void _set_matherr( int (*rtn)( struct _exception *err_info ) )</tt>
</dl>
<dl>
<dt>Description:
<dd>The default <tt> matherr</tt> function supplied in the library can be replaced so that the application can handle mathematical
 errors.&nbsp; To do this, the<tt> _set_matherr</tt> function must be called with the address of the new mathematical error
 handling routine.
<br><b><i>Note:</i></b>&nbsp; Under some systems, the default math error handler can be replaced by providing a user-written
 function of the same name, <tt> matherr</tt>, and using linking strategies to replace the default handler.&nbsp; Under PenPoint,
 the default handler is bound into a dynamic link library and can only be replaced by notifying the C library with a call
 to the<tt> _set_matherr</tt> function.
<br><br>A program may contain a user-written version of <tt> matherr</tt> to take any appropriate action when an error is
 detected.&nbsp; When zero is returned by the user-written routine, an error message will be printed upon <tt> stderr</tt>
 and <tt> errno</tt> will be set as was the case with the default function.&nbsp; When a non-zero value is returned, no message
 is printed and <tt> errno</tt> is not changed.&nbsp; The value<tt> err_info-&gt;retval</tt> is used as the return value for
 the function in which the error was detected.
<br><br>When called, the user-written math error handler is passed a pointer to a structure of type<tt> struct _exception</tt>
 which contains information about the error that has been detected:
<br><br><tt>struct _exception</tt>
<br><tt>{ int type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* TYPE OF ERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; char *name;&nbsp;&nbsp;&nbsp; /* NAME OF FUNCTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; double arg1;&nbsp;&nbsp; /* FIRST ARGUMENT TO FUNCTION&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; double arg2;&nbsp;&nbsp; /* SECOND ARGUMENT TO FUNCTION&nbsp; */</tt>
<br><tt>&nbsp; double retval; /* DEFAULT RETURN VALUE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>};</tt>
<br><br>The<tt> type</tt> field will contain one of the following values:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>DOMAIN
<dd>A domain error has occurred, such as<tt> sqrt(-1e0).</tt>
<dt><br>SING
<dd>A singularity will result, such as<tt> pow(0e0,-2).</tt>
<dt><br>OVERFLOW
<dd>An overflow will result, such as<tt> pow(10e0,100).</tt>
<dt><br>UNDERFLOW
<dd>An underflow will result, such as<tt> pow(10e0,-100).</tt>
<dt><br>TLOSS
<dd>Total loss of significance will result, such as<tt> exp(1000).</tt>
<dt><br>PLOSS
<dd>Partial loss of significance will result, such as<tt> sin(10e70).</tt>
</dl>
<br>The<tt> name</tt> field points to a string containing the name of the function which detected the error.&nbsp; The fields<tt>
 arg1</tt> and<tt> arg2</tt> (if required) give the values which caused the error.&nbsp; The field<tt> retval</tt> contains
 the value which will be returned by the function.&nbsp; This value may be changed by a user-supplied version of the<tt> _set_matherr</tt>
 function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _set_matherr</tt> function returns no value.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>/* Demonstrate error routine in which negative */</tt>
<br><tt>/* arguments to &quot;sqrt&quot; are treated as positive */</tt>
<br><br><tt>int my_matherr( struct _exception *err )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( strcmp( err-&gt;name, &quot;sqrt&quot; ) == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( err-&gt;type == DOMAIN ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; err-&gt;retval = sqrt( -(err-&gt;arg1) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _set_matherr( &amp;my_matherr );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%e\n&quot;, sqrt( -5e0 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; exit( 0 );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="_setmbcp"> _setmbcp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>int _setmbcp( int codepage );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setmbcp</tt> function sets the current code page number.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setmbcp</tt> function returns zero if the code page is set successfully.&nbsp; If an invalid code page value is supplied
 for<b> codepage</b>, the function returns -1 and the code page setting is unchanged.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getmbcp">_getmbcp</a>, <a href="#_mbbtombc">_mbbtombc</a>, <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>,
 <a href="#_mbctombb">_mbctombb</a>, <a href="#_ismbbalnum">_ismbbalnum</a>, <a href="#_ismbbalpha">_ismbbalpha</a>, <a href="#_ismbbgraph">_ismbbgraph</a>,
 <a href="#_ismbbkalnum">_ismbbkalnum</a>, <a href="#_ismbbkalpha">_ismbbkalpha</a>, <a href="#_ismbbkana">_ismbbkana</a>,
 <a href="#_ismbbkprint">_ismbbkprint</a>, <a href="#_ismbbkpunct">_ismbbkpunct</a>, <a href="#_ismbblead">_ismbblead</a>,
 <a href="#_ismbbprint">_ismbbprint</a>, <a href="#_ismbbpunct">_ismbbpunct</a>, <a href="#_ismbbtrail">_ismbbtrail</a>, <a href="#_mbbtombc">_mbbtombc</a>,
 <a href="#_mbcjistojms">_mbcjistojms</a>, <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbbtype">_mbbtype</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, _setmbcp( 932 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, _getmbcp() );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0</tt>
<br><tt>932</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="setmode"> setmode, _setmode </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>int setmode( int handle, int mode );</tt>
<br><tt>int _setmode( int handle, int mode );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> setmode</tt> function sets, at the operating system level, the translation mode to be the value of<b> mode</b> for
 the file whose file handle is given by<b> handle</b>.&nbsp; The mode, defined in the<tt> &lt;fcntl.h&gt;</tt> header file,
 can be one of:
<dl>
<dt>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>O_TEXT
<dd>On input, a carriage-return character that immediately precedes a linefeed character is removed from the data that is read.
&nbsp; On output, a carriage-return character is inserted before each linefeed character.
<dt><br>O_BINARY
<dd>Data is read or written unchanged.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>If successful, the<tt> setmode</tt> function returns the previous mode that was set for the file; otherwise, -1 is returned.
&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#chsize">chsize</a>, <a href="#close">close</a>, <a href="#creat">creat</a>, <a href="#dup">dup</a>, <a href="#dup2">dup2</a>,
 <a href="#eof">eof</a>, <a href="#exec___">exec...</a>, <a href="#fdopen">fdopen</a>, <a href="#filelength">filelength</a>,
 <a href="#fileno">fileno</a>, <a href="#fstat">fstat</a>, <a href="#_grow_handles">_grow_handles</a>, <a href="#isatty">isatty</a>,
 <a href="#lseek">lseek</a>, <a href="#open">open</a>, <a href="#read">read</a>, <a href="#sopen">sopen</a>, <a href="#stat">stat</a>,
 <a href="#tell">tell</a>, <a href="#write">write</a>, <a href="#umask">umask</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long count;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;rb&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setmode( fileno( fp ), O_BINARY );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count = 0L;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( fgetc( fp ) != EOF ) ++count;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File contains %lu characters\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> setmode - All, Netware</tt>
<br><tt>_setmode - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32, Netware</tt>
</dl>
<h2 id="set_new_handler"> set_new_handler, _set_new_handler </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;new.h&gt;</tt>
<br><tt>PFV set_new_handler( PFV pNewHandler );</tt>
<br><tt>PFU _set_new_handler( PFU pNewHandler );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> set_new_handler</tt> functions are used to transfer control to a user-defined error handler if the <tt> new</tt> operator
 fails to allocate memory.&nbsp; The argument<b> pNewHandler</b> is the name of a function of type <tt> PFV</tt> or <tt> PFU</tt>.
<dl>
<dt>Type&nbsp;&nbsp;&nbsp;&nbsp; Description
<dt>PFV
<dd>Pointer to a function that returns <tt> void</tt> (i.e., returns nothing) and takes an argument of type <tt> void</tt> (i.e.,
 takes no argument).
<dt><br>PFU
<dd>Pointer to a function that returns <tt> int</tt> and takes an argument of type <tt> unsigned</tt> which is the amount of space
 to be allocated.
</dl>
<br>In a multi-threaded environment, handlers are maintained separately for each process and thread.&nbsp; Each new process
 lacks installed handlers.&nbsp; Each new thread gets a copy of its parent thread's new handlers.&nbsp; Thus, each process
 and thread is in charge of its own free-store error handling.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> set_new_handler</tt> functions return a pointer to the previous error handler so that the previous error handler can
 be reinstated at a later time.
<br>The error handler specified as the argument to<tt> _set_new_handler</tt> returns zero indicating that further attempts
 to allocate memory should be halted or non-zero to indicate that an allocation request should be re-attempted.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bfreeseg">_bfreeseg</a>, <a href="#_bheapseg">_bheapseg</a>, <a href="#calloc">calloc</a>, <a href="#free">free</a>,
 <a href="#malloc">malloc</a>, <a href="#realloc">realloc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;new.h&gt;</tt>
<br><br><tt>#if defined(__386__)</tt>
<br><tt>const size_t MemBlock = 8192;</tt>
<br><tt>#else</tt>
<br><tt>const size_t MemBlock = 2048;</tt>
<br><tt>#endif</tt>
<br><br><tt>/*</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Pre-allocate a memory block for demonstration</tt>
<br><tt>&nbsp;&nbsp;&nbsp; purposes. The out-of-memory handler will return</tt>
<br><tt>&nbsp;&nbsp;&nbsp; it to the system so that &quot;new&quot; can use it.</tt>
<br><tt>*/</tt>
<br><br><tt>long *failsafe = new long&#91;MemBlock&#93;;</tt>
<br><br><tt>/*</tt>
<br><tt>&nbsp;&nbsp;&nbsp; Declare a customized function to handle memory</tt>
<br><tt>&nbsp;&nbsp;&nbsp; allocation failure.</tt>
<br><tt>*/</tt>
<br><br><tt>int out_of_memory_handler( unsigned size )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Allocation failed, &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%u bytes not available.\n&quot;, size );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* Release pre-allocated memory if we can */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( failsafe == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Halting allocation.\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Tell new to stop allocation attempts */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete failsafe;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; failsafe = NULL;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Retrying allocation.\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Tell new to retry allocation attempt */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main( void )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* Register existence of a new memory handler */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _set_new_handler( out_of_memory_handler );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long *pmemdump = new long&#91;MemBlock&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i=1 ; pmemdump != NULL; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pmemdump = new long&#91;MemBlock&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( pmemdump != NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Another block allocated %d\n&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> set_new_handler - All, Netware</tt>
<br><tt>_set_new_handler - All, Netware</tt>
</dl>
<h2 id="_setpixel"> _setpixel, _setpixel_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _setpixel( short x, short y );</tt>
<br><br><tt>short _FAR _setpixel_w( double x, double y );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setpixel</tt> function sets the pixel value of the point<tt> (x,y)</tt> using the current plotting action with the
 current color.&nbsp; The<tt> _setpixel</tt> function uses the view coordinate system.&nbsp; The<tt> _setpixel_w</tt> function
 uses the window coordinate system.
<br>A pixel value is associated with each point.&nbsp; The values range from 0 to the number of colors (less one) that can
 be represented in the palette for the current video mode.&nbsp; The color displayed at the point is the color in the palette
 corresponding to the pixel number.&nbsp; For example, a pixel value of 3 causes the fourth color in the palette to be displayed
 at the point in question.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setpixel</tt> functions return the previous value of the indicated pixel if the pixel value can be set; otherwise,
 (-1) is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getpixel">_getpixel</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int x, y;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GBORDER, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt;= 60000; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 101 + rand() % 439;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 101 + rand() % 279;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setcolor( _getpixel( x, y ) + 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setpixel( x, y );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>_setpixel is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _setpixel - DOS, QNX</tt>
<br><tt>_setpixel_w - DOS, QNX</tt>
</dl>
<h2 id="_setplotaction"> _setplotaction </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _setplotaction( short action );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setplotaction</tt> function sets the current plotting action to the value of the<b> action</b> argument.
<br>The drawing functions cause pixels to be set with a pixel value.&nbsp; By default, the value to be set is obtained by
 replacing the original pixel value with the supplied pixel value.&nbsp; Alternatively, the replaced value may be computed
 as a function of the original and the supplied pixel values.
<br><br>The plotting action can have one of the following values:
<dl>
<dt>_GPSET
<dd>replace the original screen pixel value with the supplied pixel value
<dt><br>_GAND
<dd>replace the original screen pixel value with the<b> bitwise and</b> of the original pixel value and the supplied pixel value
<dt><br>_GOR
<dd>replace the original screen pixel value with the<b> bitwise or</b> of the original pixel value and the supplied pixel value
<dt><br>_GXOR
<dd>replace the original screen pixel value with the<b> bitwise exclusive-or</b> of the original pixel value and the supplied
 pixel value.&nbsp; Performing this operation twice will restore the original screen contents, providing an efficient method
 to produce animated effects.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The previous value of the plotting action is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getplotaction">_getplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_act;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_act = _getplotaction();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setplotaction( _GPSET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setplotaction( _GXOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 100, 540, 380 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setplotaction( old_act );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextalign"> _settextalign </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _settextalign( short horiz, short vert );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextalign</tt> function sets the current text alignment to the values specified by the arguments<b> horiz</b>
 and<b> vert</b>.&nbsp; When text is displayed with the <tt> _grtext</tt> function, it is aligned (justified) horizontally
 and vertically about the given point according to the current text alignment settings.
<br>The horizontal component of the alignment can have one of the following values:
<dl>
<dt>_NORMAL
<dd>use the default horizontal alignment for the current setting of the text path
<dt><br>_LEFT
<dd>the text string is left justified at the given point
<dt><br>_CENTER
<dd>the text string is centred horizontally about the given point
<dt><br>_RIGHT
<dd>the text string is right justified at the given point
</dl>
<br>The vertical component of the alignment can have one of the following values:
<dl>
<dt>_NORMAL
<dd>use the default vertical alignment for the current setting of the text path
<dt><br>_TOP
<dd>the top of the text string is aligned at the given point
<dt><br>_CAP
<dd>the cap line of the text string is aligned at the given point
<dt><br>_HALF
<dd>the text string is centred vertically about the given point
<dt><br>_BASE
<dd>the base line of the text string is aligned at the given point
<dt><br>_BOTTOM
<dd>the bottom of the text string is aligned at the given point
</dl>
<br>The default is to use<tt> _LEFT</tt> alignment for the horizontal component unless the text path is<tt> _PATH_LEFT,</tt>
 in which case<tt> _RIGHT</tt> alignment is used.&nbsp; The default value for the vertical component is<tt> _TOP</tt> unless
 the text path is<tt> _PATH_UP,</tt> in which case<tt> _BOTTOM</tt> alignment is used.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _settextalign</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_gettextsettings">_gettextsettings</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 200, 100, &quot;WATCOM&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setpixel( 200, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextalign( _CENTER, _HALF );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 200, 200, &quot;Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setpixel( 200, 200 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_setta.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextcolor"> _settextcolor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _settextcolor( short pixval );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextcolor</tt> function sets the current text color to be the color indicated by the pixel value of the<b> pixval</b>
 argument.&nbsp; This is the color value used for displaying text with the <tt> _outtext</tt> and <tt> _outmem</tt> functions.
&nbsp; Use the <tt> _setcolor</tt> function to change the color of graphics output.&nbsp; The default text color value is
 set to 7 whenever a new video mode is selected.
<br>The pixel value<b> pixval</b> is a number in the range 0-31.&nbsp; Colors in the range 0-15 are displayed normally.&nbsp;
 In text modes, blinking colors are specified by adding 16 to the normal color values.&nbsp; The following table specifies
 the default colors in color text modes.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Pixel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pixel
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; value</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Black&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gray</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Blue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Blue</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Green&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Green</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Cyan</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Red&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Red</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Magenta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Magenta</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Brown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yellow</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; White&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bright White</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _settextcolor</tt> function returns the pixel value of the previous text color.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_gettextcolor">_gettextcolor</a>, <a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_setcolor">_setcolor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_col;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long old_bk;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_col = _gettextcolor();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextcolor( 7 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setbkcolor( _BLUE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( &quot; WATCOM \nGraphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextcolor( old_col );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setbkcolor( old_bk );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextcursor"> _settextcursor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _settextcursor( short cursor );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextcursor</tt> function sets the attribute, or shape, of the cursor in text modes.&nbsp; The argument<b> cursor</b>
 specifies the new cursor shape.&nbsp; The cursor shape is selected by specifying the top and bottom rows in the character
 matrix.&nbsp; The high byte of<b> cursor</b> specifies the top row of the cursor; the low byte specifies the bottom row.
<br>Some typical values for<b> cursor</b> are:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Cursor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x0607&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normal underline cursor</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x0007&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; full block cursor</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x0407&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; half-height block cursor</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 0x2000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no cursor</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _settextcursor</tt> function returns the previous cursor shape when the shape is set successfully; otherwise, (-1)
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_gettextcursor">_gettextcursor</a>, <a href="#_displaycursor">_displaycursor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_shape;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; old_shape = _gettextcursor();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextcursor( 0x0007 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( &quot;\nBlock cursor&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextcursor( 0x0407 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( &quot;\nHalf height cursor&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextcursor( 0x2000 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( &quot;\nNo cursor&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextcursor( old_shape );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextorient"> _settextorient </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _settextorient( short vecx, short vecy );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextorient</tt> function sets the current text orientation to the vector specified by the arguments<tt> (vecx,vecy).</tt>
&nbsp; The text orientation specifies the direction of the base-line vector when a text string is displayed with the <tt>
 _grtext</tt> function.&nbsp; The default text orientation, for normal left-to-right text, is the vector<tt> (1,0).</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _settextorient</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_gettextsettings">_gettextsettings</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 200, 100, &quot;WATCOM&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextorient( 1, 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 200, 200, &quot;Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_setto.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextpath"> _settextpath </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _settextpath( short path );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextpath</tt> function sets the current text path to have the value of the<b> path</b> argument.&nbsp; The text
 path specifies the writing direction of the text displayed by the <tt> _grtext</tt> function.&nbsp; The argument can have
 one of the following values:
<dl>
<dt>_PATH_RIGHT
<dd>subsequent characters are drawn to the right of the previous character
<dt><br>_PATH_LEFT
<dd>subsequent characters are drawn to the left of the previous character
<dt><br>_PATH_UP
<dd>subsequent characters are drawn above the previous character
<dt><br>_PATH_DOWN
<dd>subsequent characters are drawn below the previous character
</dl>
<br>The default value of the text path is<tt> _PATH_RIGHT.</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _settextpath</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_gettextsettings">_gettextsettings</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 200, 100, &quot;WATCOM&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextpath( _PATH_DOWN );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _grtext( 200, 200, &quot;Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><img src="eg_settx.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextposition"> _settextposition </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>struct rccoord _FAR _settextposition( short row,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short col );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextposition</tt> function sets the current output position for text to be<tt> (row,col)</tt> where this position
 is in terms of characters, not pixels.
<br>The text position is relative to the current text window.&nbsp; It defaults to the top left corner of the screen,<tt>
 (1,1),</tt> when a new video mode is selected, or when a new text window is set.&nbsp; The position is updated as text is
 drawn with the <tt> _outtext</tt> and <tt> _outmem</tt> functions.
<br><br>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
 graphics output can be set by use of the <tt> _moveto</tt> function.
<br><br>Also note that output to the standard output file, <tt> stdout</tt>, is line buffered by default.&nbsp; It may be
 necessary to flush the output stream using<tt> fflush( stdout )</tt> after a <tt> printf</tt> call if your output does not
 contain a newline character.&nbsp; Mixing of calls to <tt> _outtext</tt> and <tt> printf</tt> may cause overlapped text since
 <tt> _outtext</tt> uses the output position that was set by<tt> _settextposition</tt>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _settextposition</tt> function returns, as an<tt> rccoord</tt> structure, the previous output position for text.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_gettextposition">_gettextposition</a>, <a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_settextwindow">_settextwindow</a>,
 <a href="#_moveto">_moveto</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct rccoord old_pos;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_pos = _gettextposition();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextposition( 10, 40 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( &quot;WATCOM Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextposition( old_pos.row, old_pos.col );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextrows"> _settextrows </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _settextrows( short rows );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextrows</tt> function selects the number of rows of text displayed on the screen.&nbsp; The number of rows is
 specified by the argument<b> rows</b>.&nbsp; Computers equipped with EGA, MCGA and VGA adapters can support different numbers
 of text rows.&nbsp; The number of rows that can be selected depends on the current video mode and the type of monitor attached.
<br>If the argument<b> rows</b> has the value<b> _MAXTEXTROWS</b>, the maximum number of text rows will be selected for the
 current video mode and hardware configuration.&nbsp; In text modes the maximum number of rows is 43 for EGA adapters, and
 50 for MCGA and VGA adapters.&nbsp; Some graphics modes will support 43 rows for EGA adapters and 60 rows for MCGA and VGA
 adapters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _settextrows</tt> function returns the number of screen rows when the number of rows is set successfully; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getvideoconfig">_getvideoconfig</a>, <a href="#_setvideomode">_setvideomode</a>, <a href="#_setvideomoderows">_setvideomoderows</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>int valid_rows&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 14, 25, 28, 30,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 34, 43, 50, 60</tt>
<br><tt>};</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i, j, rows;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 80 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 8; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = valid_rows&#91; i &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _settextrows( rows ) == rows ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( j = 1; j &lt;= rows; ++j ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Line
 %d&quot;, j );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _settextposition( j, 1
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextwindow"> _settextwindow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _settextwindow( short row1, short col1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short row2, short col2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextwindow</tt> function sets the text window to be the rectangle with a top left corner at<tt> (row1,col1)</tt>
 and a bottom right corner at<tt> (row2,col2).</tt>&nbsp; These coordinates are in terms of characters not pixels.
<br>The initial text output position is<tt> (1,1).</tt>&nbsp; Subsequent text positions are reported (by the <tt> _gettextposition</tt>
 function) and set (by the <tt> _outtext</tt>, <tt> _outmem</tt> and <tt> _settextposition</tt> functions) relative to this
 rectangle.
<br><br>Text is displayed from the current output position for text proceeding along the current row and then downwards.&nbsp;
 When the window is full, the lines scroll upwards one line and then text is displayed on the last line of the window.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _settextwindow</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_gettextposition">_gettextposition</a>, <a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_settextposition">_settextposition</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; short r1, c1, r2, c2;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 80 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _gettextwindow( &amp;r1, &amp;c1, &amp;r2, &amp;c2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextwindow( 5, 20, 20, 40 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 20; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Line %d\n&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextwindow( r1, c1, r2, c2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="setvbuf"> setvbuf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int setvbuf( FILE *fp,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int mode,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t size );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> setvbuf</tt> function can be used to associate a buffer with the file designated by<b> fp</b>.&nbsp; If this function
 is used, it must be called after the file has been opened and before it has been read or written.&nbsp; The argument<b> mode</b>
 determines how the file<b> fp</b> will be buffered, as follows:
<dl>
<dt>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>_IOFBF
<dd>causes input/output to be fully buffered.
<dt><br>_IOLBF
<dd>causes output to be line buffered (the buffer will be flushed when a new-line character is written, when the buffer is full,
 or when input is requested on a line buffered or unbuffered stream).
<dt><br>_IONBF
<dd>causes input/output to be completely unbuffered.
</dl>
<br>If the argument<b> buf</b> is not<tt> NULL,</tt> the array to which it points will be used instead of an automatically
 allocated buffer.&nbsp; The argument<b> size</b> specifies the size of the array.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> setvbuf</tt> function returns zero on success, or a non-zero value if an invalid value is given for<b> mode</b> or<b>
 size</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#setbuf">setbuf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp; char *buf;</tt>
<br><tt>&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp; buf = (char *) malloc( 1024 );</tt>
<br><tt>&nbsp; setvbuf( fp, buf, _IOFBF, 1024 );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_setvideomode"> _setvideomode </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _setvideomode( short mode );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setvideomode</tt> function sets the video mode according to the value of the<b> mode</b> argument.&nbsp; The value
 of<b> mode</b> can be one of the following:&nbsp; uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2
 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2
 uindex=2 uindex=2 uindex=2 
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp; Size
&nbsp;&nbsp;&nbsp; Colors&nbsp;&nbsp;&nbsp; Adapter</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _MAXRESMODE&nbsp;&nbsp; (graphics mode with highest resolution)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _MAXCOLORMODE (graphics mode with most colors)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _DEFAULTMODE&nbsp; (restores screen to original mode)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTBW40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,T&nbsp;&nbsp;&nbsp; 40 x 25&nbsp;&nbsp;&nbsp; 16
&nbsp;&nbsp; MDPA,HGC,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTC40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C,T&nbsp;&nbsp;&nbsp; 40 x 25&nbsp;&nbsp;&nbsp;
 16&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTBW80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,T&nbsp;&nbsp;&nbsp; 80 x 25&nbsp;&nbsp;&nbsp; 16
&nbsp;&nbsp; MDPA,HGC,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTC80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C,T&nbsp;&nbsp;&nbsp; 80 x 25&nbsp;&nbsp;&nbsp;
 16&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _MRES4COLOR&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _MRESNOCOLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _HRESBW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 200&nbsp;&nbsp;&nbsp;
 2&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTMONO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,T&nbsp;&nbsp;&nbsp; 80 x 25&nbsp;&nbsp;&nbsp; 16
&nbsp;&nbsp; MDPA,HGC,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _HERCMONO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,G&nbsp;&nbsp; 720 x 350&nbsp;&nbsp;&nbsp; 2&nbsp;
&nbsp; HGC</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _MRES16COLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp;&nbsp; 16&nbsp;&nbsp; EGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _HRES16COLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 200&nbsp;&nbsp; 16&nbsp;&nbsp; EGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _ERESNOCOLOR&nbsp;&nbsp; M,G&nbsp;&nbsp; 640 x 350&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; EGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _ERESCOLOR&nbsp;&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 350&nbsp; 4/16&nbsp; EGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _VRES2COLOR&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 480&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _VRES16COLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 480&nbsp;&nbsp; 16&nbsp;&nbsp; VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _MRES256COLOR&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp; 256&nbsp;&nbsp; MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _URES256COLOR&nbsp; C,G&nbsp;&nbsp; 640 x 400&nbsp; 256&nbsp;&nbsp; SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _VRES256COLOR&nbsp; C,G&nbsp;&nbsp; 640 x 480&nbsp; 256&nbsp;&nbsp; SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _SVRES16COLOR&nbsp; C,G&nbsp;&nbsp; 800 x 600&nbsp;&nbsp; 16&nbsp;&nbsp; SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _SVRES256COLOR C,G&nbsp;&nbsp; 800 x 600&nbsp; 256&nbsp;&nbsp; SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _XRES16COLOR&nbsp;&nbsp; C,G&nbsp; 1024 x 768&nbsp;&nbsp; 16&nbsp;&nbsp; SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _XRES256COLOR&nbsp; C,G&nbsp; 1024 x 768&nbsp; 256&nbsp;&nbsp; SVGA</tt>
<br><br>In the preceding table, the Type column contains the following letters:
<dl>
<dt>M
<dd>indicates monochrome; multiple colors are shades of grey
<dt><br>C
<dd>indicates color
<dt><br>G
<dd>indicates graphics mode; size is in pixels
<dt><br>T
<dd>indicates text mode; size is in columns and rows of characters
</dl>
<br>The Adapter column contains the following codes:
<dl>
<dt>MDPA
<dd>IBM Monochrome Display/Printer Adapter
<dt><br>CGA
<dd>IBM Color Graphics Adapter
<dt><br>EGA
<dd>IBM Enhanced Graphics Adapter
<dt><br>VGA
<dd>IBM Video Graphics Array
<dt><br>MCGA
<dd>IBM Multi-Color Graphics Array
<dt><br>HGC
<dd>Hercules Graphics Adapter
<dt><br>SVGA
<dd>SuperVGA adapters
</dl>
<br>The modes<tt> _MAXRESMODE</tt> and<tt> _MAXCOLORMODE</tt> will select from among the video modes supported by the current
 graphics adapter the one that has the highest resolution or the greatest number of colors.&nbsp; The video mode will be selected
 from the standard modes, not including the SuperVGA modes.
<br><br>Selecting a new video mode resets the current output positions for graphics and text to be the top left corner of
 the screen.&nbsp; The background color is reset to black and the default color value is set to be one less than the number
 of colors in the selected mode.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setvideomode</tt> function returns the number of text rows when the new mode is successfully selected; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getvideoconfig">_getvideoconfig</a>, <a href="#_settextrows">_settextrows</a>, <a href="#_setvideomoderows">_setvideomoderows</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int mode;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct videoconfig vc;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 80 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _getvideoconfig( &amp;vc );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* select &quot;best&quot; video mode */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; switch( vc.adapter ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _VGA :</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _SVGA :</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _VRES16COLOR;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _MCGA :</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES256COLOR;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _EGA :</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( vc.monitor == _MONO ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESNOCOLOR;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESCOLOR;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _CGA :</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES4COLOR;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; case _HERCULES :</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _HERCMONO;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; default :</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; puts( &quot;No graphics adapter&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( _setvideomode( mode ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _getvideoconfig( &amp;vc );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;%d x %d x %d\n&quot;, vc.numxpixels,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vc.numypixels, vc.numcolors );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setvideomoderows"> _setvideomoderows </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _setvideomoderows( short mode, short rows );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setvideomoderows</tt> function selects a video mode and the number of rows of text displayed on the screen.&nbsp;
 The video mode is specified by the argument<b> mode</b> and is selected with the <tt> _setvideomode</tt> function.&nbsp;
 The number of rows is specified by the argument<b> rows</b> and is selected with the <tt> _settextrows</tt> function.
<br>Computers equipped with EGA, MCGA and VGA adapters can support different numbers of text rows.&nbsp; The number of rows
 that can be selected depends on the video mode and the type of monitor attached.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setvideomoderows</tt> function returns the number of screen rows when the mode and number of rows are set successfully;
 otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getvideoconfig">_getvideoconfig</a>, <a href="#_setvideomode">_setvideomode</a>, <a href="#_settextrows">_settextrows</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int rows;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 80 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rows = _setvideomoderows( _TEXTC80, _MAXTEXTROWS );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( rows != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Number of rows is %d\n&quot;, rows );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setvieworg"> _setvieworg </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>struct xycoord _FAR _setvieworg( short x, short y );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setvieworg</tt> function sets the origin of the view coordinate system,<tt> (0,0),</tt> to be located at the physical
 point<tt> (x,y).</tt>&nbsp; This causes subsequently drawn images to be translated by the amount<tt> (x,y).</tt>
<br><b>Note:</b>&nbsp; In previous versions of the software, the<tt> _setvieworg</tt> function was called<tt> _setlogorg.</tt>
&nbsp; uindex=2 
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setvieworg</tt> function returns, as an<tt> xycoord</tt> structure, the physical coordinates of the previous origin.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getviewcoord">_getviewcoord</a>, <a href="#_getphyscoord">_getphyscoord</a>, <a href="#_setcliprgn">_setcliprgn</a>,
 <a href="#_setviewport">_setviewport</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvieworg( 320, 240 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _ellipse( _GBORDER, -200, -150, 200, 150 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setviewport"> _setviewport </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _setviewport( short x1, short y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; short x2, short y2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setviewport</tt> function restricts the display of graphics output to the clipping region and then sets the origin
 of the view coordinate system to be the top left corner of the region.&nbsp; This region is a rectangle whose opposite corners
 are established by the physical points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>
<br>The<tt> _setviewport</tt> function does not affect text output using the <tt> _outtext</tt> and <tt> _outmem</tt> functions.
&nbsp; To control the location of text output, see the <tt> _settextwindow</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setviewport</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setcliprgn">_setcliprgn</a>, <a href="#_setvieworg">_setvieworg</a>, <a href="#_settextwindow">_settextwindow</a>,
 <a href="#_setwindow">_setwindow</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>#define XSIZE 380</tt>
<br><tt>#define YSIZE 280</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setviewport( 130, 100, 130 + XSIZE, 100 + YSIZE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _ellipse( _GBORDER, 0, 0, XSIZE, YSIZE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setvisualpage"> _setvisualpage </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _setvisualpage( short pagenum );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setvisualpage</tt> function selects the page (in memory) from which graphics output is displayed.&nbsp; The page
 to be selected is given by the<b> pagenum</b> argument.
<br>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple pages
 are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
 what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
 can be constructed without affecting the screen by setting the active page to be different than the visual page.
<br><br>The number of available video pages can be determined by using the <tt> _getvideoconfig</tt> function.&nbsp; The default
 video page is 0.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setvisualpage</tt> function returns the number of the previous page when the visual page is set successfully; otherwise,
 a negative number is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getvisualpage">_getvisualpage</a>, <a href="#_setactivepage">_setactivepage</a>, <a href="#_getactivepage">_getactivepage</a>,
 <a href="#_getvideoconfig">_getvideoconfig</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_apage;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_vpage;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _HRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_apage = _getactivepage();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* draw an ellipse on page 0 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setactivepage( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvisualpage( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _ellipse( _GFILLINTERIOR, 100, 50, 540, 150 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* draw a rectangle on page 1 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setactivepage( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle( _GFILLINTERIOR, 100, 50, 540, 150 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* display page 1 */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvisualpage( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setactivepage( old_apage );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvisualpage( old_vpage );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setwindow"> _setwindow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _setwindow( short invert,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double x1, double y1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; double x2, double y2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setwindow</tt> function defines a window for the window coordinate system.&nbsp; Window coordinates are specified
 as a user-defined range of values.&nbsp; This allows for consistent pictures regardless of the video mode.
<br>The window is defined as the region with opposite corners established by the points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>
&nbsp; The argument<b> invert</b> specifies the direction of the y-axis.&nbsp; If the value is non-zero, the y values increase
 from the bottom of the screen to the top, otherwise, the y values increase as you move down the screen.
<br><br>The window defined by the<tt> _setwindow</tt> function is displayed in the current viewport.&nbsp; A viewport is defined
 by the <tt> _setviewport</tt> function.
<br><br>By default, the window coordinate system is defined with the point<tt> (0.0,0.0)</tt> located at the lower left corner
 of the screen, and the point<tt> (1.0,1.0)</tt> at the upper right corner.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setwindow</tt> function returns a non-zero value when the window is set successfully; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setviewport">_setviewport</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _MAXRESMODE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; draw_house( &quot;Default window&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setwindow( 1, -0.5, -0.5, 1.5, 1.5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; draw_house( &quot;Larger window&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setwindow( 1, 0.0, 0.0, 0.5, 1.0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; draw_house( &quot;Left side&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
<br><br><tt>draw_house( char *msg )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _clearscreen( _GCLEARSCREEN );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _outtext( msg );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle_w( _GBORDER, 0.2, 0.1, 0.8, 0.6 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _moveto_w( 0.1, 0.5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _lineto_w( 0.5, 0.9 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _lineto_w( 0.9, 0.5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _arc_w( 0.4, 0.5, 0.6, 0.3, 0.6, 0.4, 0.4, 0.4 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _rectangle_w( _GBORDER, 0.4, 0.1, 0.6, 0.4 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="signal"> signal </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;signal.h&gt;</tt>
<br><tt>void ( *signal(int sig, void (*func)(int)) )( int );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> signal</tt> function is used to specify an action to take place when certain conditions are detected while a program
 executes.&nbsp; These conditions are defined to be:
<dl>
<dt>Condition&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>SIGABRT
<dd>abnormal termination, such as caused by the <tt> abort</tt> function
<dt><br>SIGBREAK
<dd>an interactive attention (CTRL/BREAK on keyboard) is signalled
<dt><br>SIGFPE
<dd>an erroneous floating-point operation occurs (such as division by zero, overflow and underflow)
<dt><br>SIGILL
<dd>illegal instruction encountered
<dt><br>SIGINT
<dd>an interactive attention (CTRL/C on keyboard) is signalled
<dt><br>SIGSEGV
<dd>an illegal memory reference is detected
<dt><br>SIGTERM
<dd>a termination request is sent to the program
<dt><br>SIGUSR1
<dd>OS/2 process flag A via DosFlagProcess
<dt><br>SIGUSR2
<dd>OS/2 process flag B via DosFlagProcess
<dt><br>SIGUSR3
<dd>OS/2 process flag C via DosFlagProcess
</dl>
<br>An action can be specified for each of the conditions, depending upon the value of the<b> func</b> argument:
<dl>
<dt>function
<dd>When<b> func</b> is a function name, that function will be called equivalently to the following code sequence.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* &quot;sig_no&quot; is condition being signalled */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( sig_no, SIG_DFL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*func)( sig_no );</tt>
<br><br>The<b> func</b> function may terminate the program by calling the <tt> exit</tt> or <tt> abort</tt> functions or call
 the <tt> longjmp</tt> function.&nbsp; Because the next signal will be handled with default handling, the program must again
 call<tt> signal</tt> if it is desired to handle the next condition of the type that has been signalled.
<br><br>After returning from the signal-catching function, the receiving process will resume execution at the point at which
 it was interrupted.
<br><br>The signal catching function is described as follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void func( int sig_no )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* body of function */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><br>Since signal-catching functions are invoked asynchronously with process execution, the type <tt> sig_atomic_t</tt>
 may be used to define variables on which an atomic operation (e.g., incrementation, decrementation) may be performed.
<dt><br>SIG_DFL
<dd>This value causes the default action for the condition to occur.
<dt><br>SIG_IGN
<dd>This value causes the indicated condition to be ignored.
</dl>
<br>When a condition is detected, it may be handled by a program, it may be ignored, or it may be handled by the usual default
 action (often causing an error message to be printed upon the<tt> stderr</tt> stream followed by program termination).
<br><br>When the program begins execution, the equivalent of
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGABRT, SIG_DFL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGFPE, SIG_DFL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGILL, SIG_DFL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGINT, SIG_DFL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGSEGV, SIG_DFL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGTERM, SIG_DFL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGBREAK, SIG_DFL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGUSR1, SIG_IGN );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGUSR2, SIG_IGN );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGUSR3, SIG_IGN );</tt>
<br><br>is executed.
<br><br>The <tt> SIGINT</tt> signal is generated by pressing the CTRL/C or CTRL/BREAK key combination on the keyboard.&nbsp;
 Under DOS, if &quot;BREAK=ON&quot;, a signal will be delivered at the next DOS call; otherwise, if &quot;BREAK=OFF&quot;,
 a signal will be delivered only at the next standard input/output DOS call.&nbsp; The <tt> BREAK</tt> setting is configured
 in the<tt> CONFIG.SYS</tt> file.
<br><br>Under OS/2, the <tt> SIGBREAK</tt> signal can only be received if CTRL/BREAK is pressed and the keyboard is in binary
 (raw) mode.&nbsp; In ASCII (cooked) mode, which is the default, both CTRL/C and CTRL/BREAK combinations will raise the <tt>
 SIGINT</tt> signal.
<br><br>A condition can be generated by a program using the <tt> raise</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>A return value of <tt> SIG_ERR</tt> indicates that the request could not be handled, and <tt> errno</tt> is set to the value
 <tt> EINVAL</tt>.
<br>Otherwise, the previous value of<b> func</b> for the indicated condition is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#break___">break...</a>, <a href="#raise">raise</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;signal.h&gt;</tt>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>/* SIGINT Test */</tt>
<br><br><tt>sig_atomic_t signal_count;</tt>
<br><tt>sig_atomic_t signal_number;</tt>
<br><br><tt>void MyIntHandler( int signo )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; signal_count++;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; signal_number = signo;</tt>
<br><tt>}</tt>
<br><br><tt>void MyBreakHandler( int signo )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; signal_count++;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; signal_number = signo;</tt>
<br><tt>}</tt>
<br><br><tt>int main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; signal_count = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; signal_number = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; signal( SIGINT, MyIntHandler );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; signal( SIGBREAK, MyBreakHandler );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Press Ctrl/C or Ctrl/Break\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 50; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Iteration # %d\n&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delay( 500 ); /* sleep for 1/2 second */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( signal_count &gt; 0 ) break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;SIGINT count %d number %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 signal_count, signal_number );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; signal_count = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; signal_number = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; signal( SIGINT, SIG_DFL );&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Default action */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; signal( SIGBREAK, SIG_DFL );&nbsp;&nbsp;&nbsp; /* Default action */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Default signal handling\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 50; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Iteration # %d\n&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delay( 500 ); /* sleep for 1/2 second */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( signal_count &gt; 0 ) break; /* Won't happen */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( signal_count );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="signbit"> signbit </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>int signbit( x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> signbit</tt> macro determines whether the sign of its argument value is negative.
<br>The argument<b> x</b> must be an expression of real floating type.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> signbit</tt> macro returns a nonzero value if and only if the sign of its argument has value is negative.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fpclassify">fpclassify</a>, <a href="#isfinite">isfinite</a>, <a href="#isinf">isinf</a>, <a href="#isnan">isnan</a>,
 <a href="#isnormal">isnormal</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;-4.5 %s negative\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signbit( -4.5 ) ? &quot;is&quot; : &quot;is not&quot; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>-4.5 is negative</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="sin"> sin </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double sin( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> sin</tt> function computes the sine of<b> x</b> (measured in radians).&nbsp; A large magnitude argument may yield
 a result with little or no significance.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> sin</tt> function returns the sine value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#acos">acos</a>, <a href="#asin">asin</a>, <a href="#atan">atan</a>, <a href="#atan2">atan2</a>, <a href="#cos">cos</a>,
 <a href="#tan">tan</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, sin(.5) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.479426</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="sinh"> sinh </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double sinh( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> sinh</tt> function computes the hyperbolic sine of<b> x</b>.&nbsp; A range error occurs if the magnitude of<b> x</b>
 is too large.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> sinh</tt> function returns the hyperbolic sine value.&nbsp; When the argument is outside the permissible range, the
 <tt> matherr</tt> function is called.&nbsp; Unless the default <tt> matherr</tt> function is replaced, it will set the global
 variable <tt> errno</tt> to <tt> ERANGE</tt>, and print a &quot;RANGE error&quot; diagnostic message using the <tt> stderr</tt>
 stream.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cosh">cosh</a>, <a href="#tanh">tanh</a>, <a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, sinh(.5) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.521095</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="mbsinit"> mbsinit, sisinit </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int mbsinit( const mbstate_t *ps );</tt>
<br><tt>int sisinit( const mbstate_t *ps );</tt>
</dl>
<dl>
<dt>Description:
<dd>If<b> ps</b> is not a null pointer, the<tt> mbsinit</tt> function determines whether the pointed-to <tt> mbstate_t</tt> object
 describes an initial conversion state.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> mbsinit</tt> function returns nonzero if<b> ps</b> is a null pointer or if the pointed-to object describes an initial
 conversion state; otherwise, it returns zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>,
 <a href="#mbrlen">mbrlen</a>, <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>,
 <a href="#mbstowcs">mbstowcs</a>, <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>,
 <a href="#wcrtomb">wcrtomb</a>, <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>,
 <a href="#wcstombs">wcstombs</a>, <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>,
 <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;errno.h&gt;</tt>
<br><br><tt>const char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wchar_t&nbsp;&nbsp;&nbsp;&nbsp; pwc;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mbstate_t&nbsp;&nbsp; pstate = { 0 };</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; j = 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; j &gt; 0; i += j ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;We are %sin an initial conversion state\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mbsinit( &amp;pstate ) ? &quot;not
 &quot; : &quot;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mbrtowc( &amp;pwc, &amp;chars&#91;i&#93;, MB_CUR_MAX, &amp;pstate );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character &quot;, j );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( errno == EILSEQ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; - illegal multibyte character\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars&#91;i&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = chars&#91;i&#93;&lt;&lt;8 | chars&#91;i+1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;(%#6.4x-&gt;%#6.4x)\n&quot;, k, pwc );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>We are in an initial conversion state</tt>
<br><tt>1 bytes in character (0x0020-&gt;0x0020)</tt>
<br><tt>We are in an initial conversion state</tt>
<br><tt>1 bytes in character (0x002e-&gt;0x002e)</tt>
<br><tt>We are in an initial conversion state</tt>
<br><tt>1 bytes in character (0x0031-&gt;0x0031)</tt>
<br><tt>We are in an initial conversion state</tt>
<br><tt>1 bytes in character (0x0041-&gt;0x0041)</tt>
<br><tt>We are in an initial conversion state</tt>
<br><tt>2 bytes in character (0x8140-&gt;0x3000)</tt>
<br><tt>We are in an initial conversion state</tt>
<br><tt>2 bytes in character (0x8260-&gt;0xff21)</tt>
<br><tt>We are in an initial conversion state</tt>
<br><tt>2 bytes in character (0x82a6-&gt;0x3048)</tt>
<br><tt>We are in an initial conversion state</tt>
<br><tt>2 bytes in character (0x8342-&gt;0x30a3)</tt>
<br><tt>We are in an initial conversion state</tt>
<br><tt>1 bytes in character (0x00a1-&gt;0xff61)</tt>
<br><tt>We are in an initial conversion state</tt>
<br><tt>1 bytes in character (0x00a6-&gt;0xff66)</tt>
<br><tt>We are in an initial conversion state</tt>
<br><tt>1 bytes in character (0x00df-&gt;0xff9f)</tt>
<br><tt>We are in an initial conversion state</tt>
<br><tt>2 bytes in character (0xe0a1-&gt;0x720d)</tt>
<br><tt>We are in an initial conversion state</tt>
<br><tt>0 bytes in character (&nbsp; 0000-&gt;&nbsp; 0000)</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> mbsinit - All, Netware</tt>
<br><tt>sisinit - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="sleep"> sleep </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><tt>unsigned sleep( unsigned seconds );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> sleep</tt> function suspends execution by the specified number of<b> seconds</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> sleep</tt> function always returns zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#delay">delay</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>/*</tt>
<br><tt> * The following program sleeps for the</tt>
<br><tt> * number of seconds specified in argv&#91;1&#93;.</tt>
<br><tt> */</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main( int argc, char *argv&#91;&#93; )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned seconds;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; seconds = (unsigned) strtol( argv&#91;1&#93;, NULL, 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; sleep( seconds );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_snprintf"> _snprintf, _snwprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int _snprintf( char *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format, ... );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int _snwprintf( wchar_t *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,
 ... );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _snprintf</tt> function is equivalent to the <tt> fprintf</tt> function, except that the argument<b> buf</b> specifies
 a character array into which the generated output is placed, rather than to a file.&nbsp; The maximum number of characters
 to store is specified by<b> count</b>.&nbsp; A null character is placed at the end of the generated character string if fewer
 than<b> count</b> characters were stored.&nbsp; The<b> format</b> string is described under the description of the <tt> printf</tt>
 function.
<br>The<tt> _snwprintf</tt> function is identical to<tt> _snprintf</tt> except that the argument<b> buf</b> specifies an array
 of wide characters into which the generated output is to be written, rather than converted to multibyte characters and written
 to a stream.&nbsp; The maximum number of wide characters to store is specified by<b> count</b>.&nbsp; A null wide character
 is placed at the end of the generated wide character string if fewer than<b> count</b> wide characters were stored.&nbsp;
 The<tt> _snwprintf</tt> function accepts a wide-character string argument for<b> format</b>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _snprintf</tt> function returns the number of characters written into the array, not counting the terminating null
 character, or a negative value if more than<b> count</b> characters were requested to be generated.&nbsp; An error can occur
 while converting a value for output.&nbsp; The<tt> _snwprintf</tt> function returns the number of wide characters written
 into the array, not counting the terminating null wide character, or a negative value if more than<b> count</b> wide characters
 were requested to be generated.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of
 error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>,
 <a href="#vprintf">vprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>/* Create temporary file names using a counter */</tt>
<br><br><tt>char namebuf&#91;13&#93;;</tt>
<br><tt>int&nbsp; TempCount = 0;</tt>
<br><br><tt>char *make_temp_name()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _snprintf( namebuf, 13, &quot;ZZ%.6o.TMP&quot;, TempCount++ );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( namebuf );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *tf1, *tf2;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; tf1 = fopen( make_temp_name(), &quot;w&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tf2 = fopen( make_temp_name(), &quot;w&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fputs( &quot;temp file 1&quot;, tf1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fputs( &quot;temp file 2&quot;, tf2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( tf1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( tf2 );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _snprintf - All, Netware</tt>
<br><tt>_snwprintf - All</tt>
</dl>
<h2 id="snprintf"> snprintf, snwprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int snprintf( char *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format, ... );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int snwprintf( wchar_t *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format, ... );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#snprintf_s">snprintf_s</a> function which is a safer alternative to<tt>
 snprintf</tt>.&nbsp; This newer<tt> snprintf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 snprintf</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> snprintf</tt> function is equivalent to the <tt> fprintf</tt> function, except that the argument<b> buf</b> specifies
 a character array into which the generated output is placed, rather than to a file.&nbsp; A null character is placed at the
 end of the generated character string.&nbsp; The maximum number of characters to store, including a terminating null character,
 is specified by<b> count</b>.&nbsp; The<b> format</b> string is described under the description of the <tt> printf</tt> function.
<br>The<tt> snwprintf</tt> function is identical to<tt> snprintf</tt> except that the argument<b> buf</b> specifies an array
 of wide characters into which the generated output is to be written, rather than converted to multibyte characters and written
 to a stream.&nbsp; The maximum number of wide characters to store, including a terminating null wide character, is specified
 by<b> count</b>.&nbsp; The<tt> snwprintf</tt> function accepts a wide-character string argument for<b> format</b>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> snprintf</tt> function returns the number of characters that would have been written had<b> count</b> been sufficiently
 large, not counting the terminating null character, or a negative value if an encoding error occurred.&nbsp; Thus, the null-terminated
 output has been completely written if and only if the returned value is nonnegative and less than<b> count</b>.&nbsp; The<tt>
 snwprintf</tt> function returns the number of wide characters that would have been written had<b> count</b> been sufficiently
 large, not counting the terminating null wide character, or a negative value if an encoding error occurred.&nbsp; Thus, the
 null-terminated output has been completely written if and only if the returned value is nonnegative and less than<b> count</b>.
&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>,
 <a href="#vprintf">vprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>/* Format output into a buffer after determining its size */</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; bufsize;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *buffer;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; bufsize = snprintf( NULL, 0, &quot;%3d %P&quot;, 42, 42 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; buffer&nbsp; = malloc( bufsize + 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; snprintf( buffer, bufsize + 1, &quot;%3d %P&quot;, 42, 42 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; free( buffer );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>snprintf is ANSI
<br>snwprintf is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> snprintf - All, Netware</tt>
<br><tt>snwprintf - All</tt>
</dl>
<h2 id="snprintf_s"> snprintf_s, snwprintf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int snprintf_s( char * restrict s, rsize_t n</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, ... );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int snwprintf_s( char * restrict s, rsize_t n,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, ... );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 snprintf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> s</b> nor<b> format</b> shall be a null pointer.&nbsp; The<b> n</b> argument shall neither equal zero nor be
 greater than<tt> RSIZE_MAX.</tt>&nbsp; The number of characters (including the trailing null) required for the result to
 be written to the array pointed to by<b> s</b> shall not be greater than<b> n</b>.&nbsp; The<tt> %n</tt> specifier (modified
 or not by flags, field width, or precision) shall not appear in the string pointed to by<b> format</b>.&nbsp; Any argument
 to<tt> snprintf_s</tt> corresponding to a<tt> %s</tt> specifier shall not be a null pointer.&nbsp; No encoding error shall
 occur.
<br><br>If there is a runtime-constraint violation, then if<b> s</b> is not a null pointer and<b> n</b> is greater than zero
 and less than<tt> RSIZE_MAX,</tt> then the<tt> snprintf_s</tt> function sets<b> s&#91;0&#93;</b> to the null character.
</dl>
<dl>
<dt>Description:
<dd>The<tt> snprintf_s</tt> function is equivalent to the <tt> snprintf</tt> function except for the explicit runtime-constraints
 listed above.
<br>The<tt> snprintf_s</tt> function, unlike <tt> sprintf_s</tt>, will truncate the result to fit within the array pointed
 to by<b> s</b>.
<br><br>The<tt> snwprintf_s</tt> function is identical to<tt> snprintf_s</tt> except that it accepts a wide-character string
 argument for<b> format</b> and produces wide character output.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> snprintf_s</tt> function returns the number of characters that would have been written had<b> n</b> been sufficiently
 large, not counting the terminating null character, or a negative value if a runtime-constraint violation occurred.&nbsp;
 Thus, the null-terminated output has been completely written if and only if the returned value is nonnegative and less than<b>
 n</b>.
<br>The<tt> snwprintf_s</tt> function returns the number of wide characters that would have been written had<b> n</b> been
 sufficiently large, not counting the terminating wide null character, or a negative value if a runtime-constraint violation
 occurred.&nbsp; Thus, the null-terminated output has been completely written if and only if the returned value is nonnegative
 and less than<b> n</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>,
 <a href="#vprintf">vprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>/* Format output into a buffer after determining its size */</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; bufsize;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *buffer;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; bufsize = snprintf( NULL, 0, &quot;%3d %P&quot;, 42, 42 ) + 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; buffer&nbsp; = malloc( bufsize );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; snprintf_s( buffer, bufsize, &quot;%3d %P&quot;, 42, 42 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; free( buffer );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>snprintf_s is TR 24731
<br>snwprintf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> snprintf_s - All, Netware</tt>
<br><tt>snwprintf_s - All</tt>
</dl>
<h2 id="sopen"> sopen, _sopen, _wsopen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;share.h&gt;</tt>
<br><tt>int sopen( const char *filename,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access, int share, ... );</tt>
<br><tt>int _sopen( const char *filename,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access, int share, ... );</tt>
<br><tt>int _wsopen( const wchar_t *filename,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int access, int share, ... );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> sopen</tt> function opens a file at the operating system level for shared access.&nbsp; The name of the file to be
 opened is given by<b> filename</b>.&nbsp; The file will be accessed according to the access mode specified by<b> access</b>.
&nbsp; When the file is to be created, the optional argument must be given which establishes the future access permissions
 for the file.&nbsp; Additionally, the sharing mode of the file is given by the<b> share</b> argument.&nbsp; The optional
 argument is the file permissions to be used when <tt> O_CREAT</tt> flag is on in the<b> access</b> mode.
<br>The<tt> _sopen</tt> function is identical to<tt> sopen</tt>.&nbsp; Use<tt> _sopen</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _wsopen</tt> function is identical to<tt> sopen</tt> except that it accepts a wide character string argument.
<br><br>The access mode is established by a combination of the bits defined in the<tt> &lt;fcntl.h&gt;</tt> header file.&nbsp;
 The following bits may be set:
<dl>
<dt>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>O_RDONLY
<dd>permit the file to be only read.
<dt><br>O_WRONLY
<dd>permit the file to be only written.
<dt><br>O_RDWR
<dd>permit the file to be both read and written.
<dt><br>O_APPEND
<dd>causes each record that is written to be written at the end of the file.
<dt><br>O_CREAT
<dd>has no effect when the file indicated by<b> filename</b> already exists; otherwise, the file is created;
<dt><br>O_TRUNC
<dd>causes the file to be truncated to contain no data when the file exists; has no effect when the file does not exist.
<dt><br>O_BINARY
<dd>causes the file to be opened in binary mode which means that data will be transmitted to and from the file unchanged.
<dt><br>O_TEXT
<dd>causes the file to be opened in text mode which means that carriage-return characters are written before any linefeed character
 that is written and causes carriage-return characters to be removed when encountered during reads.
<dt><br>O_NOINHERIT
<dd>indicates that this file is not to be inherited by a child process.
<dt><br>O_EXCL
<dd>indicates that this file is to be opened for exclusive access.&nbsp; If the file exists and <tt> O_CREAT</tt> was also specified
 then the open will fail (i.e., use <tt> O_EXCL</tt> to ensure that the file does not already exist).
</dl>
<br>When neither <tt> O_TEXT</tt> nor <tt> O_BINARY</tt> are specified, the default value in the global variable <tt> _fmode</tt>
 is used to set the file translation mode.&nbsp; When the program begins execution, this variable has a value of <tt> O_TEXT</tt>.
<br><br><tt> O_CREAT</tt> must be specified when the file does not exist and it is to be written.
<br><br>When the file is to be created (<tt> O_CREAT</tt> is specified), an additional argument must be passed which contains
 the file permissions to be used for the new file.&nbsp; The access permissions for the file or directory are specified as
 a combination of bits (defined in the<tt> &lt;sys\stat.h&gt;</tt> header file).
<br><br>The following bits define permissions for the owner.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXU
<dd>Read, write, execute/search
<dt><br>S_IRUSR
<dd>Read permission
<dt><br>S_IWUSR
<dd>Write permission
<dt><br>S_IXUSR
<dd>Execute/search permission
</dl>
<br>The following bits define permissions for the group.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXG
<dd>Read, write, execute/search
<dt><br>S_IRGRP
<dd>Read permission
<dt><br>S_IWGRP
<dd>Write permission
<dt><br>S_IXGRP
<dd>Execute/search permission
</dl>
<br>The following bits define permissions for others.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXO
<dd>Read, write, execute/search
<dt><br>S_IROTH
<dd>Read permission
<dt><br>S_IWOTH
<dd>Write permission
<dt><br>S_IXOTH
<dd>Execute/search permission
</dl>
<br>The following bits define miscellaneous permissions used by other implementations.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IREAD
<dd>is equivalent to S_IRUSR (read permission)
<dt><br>S_IWRITE
<dd>is equivalent to S_IWUSR (write permission)
<dt><br>S_IEXEC
<dd>is equivalent to S_IXUSR (execute/search permission)
</dl>
<br>All files are readable with DOS; however, it is a good idea to set <tt> S_IREAD</tt> when read permission is intended
 for the file.
<br><br>The<tt> sopen</tt> function applies the current file permission mask to the specified permissions (see <tt> umask</tt>).
<br><br>The shared access for the file,<b> share</b>, is established by a combination of bits defined in the<tt> &lt;share.h&gt;</tt>
 header file.&nbsp; The following values may be set:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>SH_COMPAT
<dd>Set compatibility mode.
<dt><br>SH_DENYRW
<dd>Prevent read or write access to the file.
<dt><br>SH_DENYWR
<dd>Prevent write access of the file.
<dt><br>SH_DENYRD
<dd>Prevent read access to the file.
<dt><br>SH_DENYNO
<dd>Permit both read and write access to the file.
</dl>
<br>You should consult the technical documentation for the DOS system that you are using for more detailed information about
 these sharing modes.
</dl>
<dl>
<dt>Returns:
<dd>If successful,<tt> sopen</tt> returns a handle for the file.&nbsp; When an error occurs while opening the file, -1 is returned.
&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EACCES
<dd>Access denied because<b> path</b> specifies a directory or a volume ID, or sharing mode denied due to a conflicting open.
<dt><br>EMFILE
<dd>No more handles available (too many open files)
<dt><br>ENOENT
<dd>Path or file not found
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#chsize">chsize</a>, <a href="#close">close</a>, <a href="#creat">creat</a>, <a href="#dup">dup</a>, <a href="#dup2">dup2</a>,
 <a href="#eof">eof</a>, <a href="#exec___">exec...</a>, <a href="#fdopen">fdopen</a>, <a href="#filelength">filelength</a>,
 <a href="#fileno">fileno</a>, <a href="#fstat">fstat</a>, <a href="#_grow_handles">_grow_handles</a>, <a href="#isatty">isatty</a>,
 <a href="#lseek">lseek</a>, <a href="#open">open</a>, <a href="#read">read</a>, <a href="#setmode">setmode</a>, <a href="#stat">stat</a>,
 <a href="#tell">tell</a>, <a href="#write">write</a>, <a href="#umask">umask</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;share.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* open a file for output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* replace existing file if it exists&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = sopen( &quot;file&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SH_DENYWR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
 | S_IWGRP );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* read a file which is assumed to exist&nbsp;&nbsp; */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = sopen( &quot;file&quot;, O_RDONLY, SH_DENYWR );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* append to the end of an existing file&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* write a new file if file does not exist */</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = sopen( &quot;file&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_APPEND,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SH_DENYWR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
 | S_IWGRP );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> sopen - All, Netware</tt>
<br><tt>_sopen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wsopen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="sound"> sound </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><tt>void sound( unsigned frequency );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> sound</tt> function turns on the PC's speaker at the specified<b> frequency</b>.&nbsp; The frequency is in Hertz (cycles
 per second).&nbsp; The speaker can be turned off by calling the <tt> nosound</tt> function after an appropriate amount of
 time.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> sound</tt> function has no return value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#delay">delay</a>, <a href="#nosound">nosound</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;i86.h&gt;</tt>
<br><br><tt>/*</tt>
<br><tt>&nbsp;&nbsp;&nbsp; The numbers in this table are the timer divisors</tt>
<br><tt>&nbsp;&nbsp;&nbsp; necessary to produce the pitch indicated in the</tt>
<br><tt>&nbsp;&nbsp;&nbsp; lowest octave that is supported by the &quot;sound&quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; function.</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; To raise the pitch by N octaves, simply divide the</tt>
<br><tt>&nbsp;&nbsp;&nbsp; number in the table by 2**N since a pitch which is</tt>
<br><tt>&nbsp;&nbsp;&nbsp; an octave above another has double the frequency of</tt>
<br><tt>&nbsp;&nbsp;&nbsp; the original pitch.</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; The frequency obtained by these numbers is given by</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 1193180 / X where X is the number obtained in the</tt>
<br><tt>&nbsp;&nbsp;&nbsp; table.</tt>
<br><tt>*/</tt>
<br><br><tt>unsigned short Notes&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19327 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* C b&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18242 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* C&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 17218 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* C #&nbsp;&nbsp; (
 D b )&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16252 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* D&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15340 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* D #&nbsp;&nbsp; (
 E b )&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14479 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* E&nbsp;&nbsp;&nbsp;
&nbsp; ( F b )&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13666 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* F&nbsp;&nbsp;&nbsp;
&nbsp; ( E # )&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12899 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* F #&nbsp;&nbsp; (
 G b )&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12175 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* G&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11492 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* G #&nbsp;&nbsp; (
 A b )&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10847 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* A&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10238 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* A #&nbsp;&nbsp; (
 B b )&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9664 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* B&nbsp;&nbsp;
&nbsp;&nbsp; ( C b )&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9121 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* B #&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</tt>
<br><tt>};</tt>
<br><br><tt>#define FACTOR&nbsp; 1193180</tt>
<br><tt>#define OCTAVE&nbsp; 4</tt>
<br><br><tt>void main()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* play the scale */</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; Notes&#91;i&#93;; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sound( FACTOR / (Notes&#91;i&#93; / (1 &lt;&lt; OCTAVE)) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delay( 200 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nosound();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, QNX
</dl>
<h2 id="spawn___"> spawn...&nbsp; Functions </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;process.h&gt;</tt>
<br><tt>int spawnl(&nbsp;&nbsp; mode, path, arg0, arg1..., argn, NULL );</tt>
<br><tt>int spawnle(&nbsp; mode, path, arg0, arg1..., argn, NULL, envp);</tt>
<br><tt>int spawnlp(&nbsp; mode, file, arg0, arg1..., argn, NULL );</tt>
<br><tt>int spawnlpe( mode, file, arg0, arg1..., argn, NULL, envp);</tt>
<br><tt>int spawnv(&nbsp;&nbsp; mode, path, argv );</tt>
<br><tt>int spawnve(&nbsp; mode, path, argv, envp );</tt>
<br><tt>int spawnvp(&nbsp; mode, file, argv );</tt>
<br><tt>int spawnvpe( mode, file, argv, envp );</tt>
<br><tt>&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; /* mode for parent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; const char *path;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name incl.
 path */</tt>
<br><tt>&nbsp; const char *file;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; const char *arg0, ..., *argn; /* arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 */</tt>
<br><tt>&nbsp; const char *const argv&#91;&#93;;&nbsp;&nbsp;&nbsp;&nbsp; /* array of arguments&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; const char *const envp&#91;&#93;;&nbsp;&nbsp;&nbsp;&nbsp; /* environment strings&nbsp; */</tt>
<br><tt>int _wspawnl(&nbsp;&nbsp; mode, path, arg0, arg1..., argn, NULL );</tt>
<br><tt>int _wspawnle(&nbsp; mode, path, arg0, arg1..., argn, NULL, envp);</tt>
<br><tt>int _wspawnlp(&nbsp; mode, file, arg0, arg1..., argn, NULL );</tt>
<br><tt>int _wspawnlpe( mode, file, arg0, arg1..., argn, NULL, envp);</tt>
<br><tt>int _wspawnv(&nbsp;&nbsp; mode, path, argv );</tt>
<br><tt>int _wspawnve(&nbsp; mode, path, argv, envp );</tt>
<br><tt>int _wspawnvp(&nbsp; mode, file, argv );</tt>
<br><tt>int _wspawnvpe( mode, file, argv, envp );</tt>
<br><tt>&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* mode for parent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; const wchar_t *path;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name incl.
 path */</tt>
<br><tt>&nbsp; const wchar_t *file;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* file name&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; const wchar_t *arg0, ..., *argn; /* arguments&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 */</tt>
<br><tt>&nbsp; const wchar_t *const argv&#91;&#93;;&nbsp;&nbsp;&nbsp;&nbsp; /* array of arguments&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; const wchar_t *const envp&#91;&#93;;&nbsp;&nbsp;&nbsp;&nbsp; /* environment strings&nbsp; */</tt>
</dl>
<dl>
<dt>Description:
<dd>The<b> spawn...</b>&nbsp; functions create and execute a new child process, named by<b> pgm</b>.&nbsp; The value of<b> mode</b>
 determines how the program is loaded and how the invoking program will behave after the invoked program is initiated:
<dl>
<dt>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>P_WAIT
<dd>The invoked program is loaded into available memory, is executed, and then the original program resumes execution.&nbsp; This
 option is supported under DOS, OS/2, Win32 and QNX.
<dt><br>P_NOWAIT
<dd>Causes the current program to execute concurrently with the new child process.&nbsp; This option is supported under OS/2,
 Win32 and QNX.
<dt><br>P_NOWAITO
<dd>Causes the current program to execute concurrently with the new child process.&nbsp; This option is supported under OS/2,
 Win32 and QNX.&nbsp; The <tt> wait</tt> and <tt> cwait</tt> functions cannot be used to obtain the exit code.
<dt><br>P_OVERLAY
<dd>The invoked program replaces the original program in memory and is executed.&nbsp; No return is made to the original program.
&nbsp; This option is supported under DOS (16-bit only), OS/2, Win32, and QNX.&nbsp; This is equivalent to calling the appropriate
 <tt> exec...</tt>&nbsp; function.
</dl>
<br>The program is located by using the following logic in sequence:
<ol>
<li>An attempt is made to locate the program in the current working directory if no directory specification precedes the program
 name; otherwise, an attempt is made in the specified directory.
<li>If no file extension is given, an attempt is made to find the program name, in the directory indicated in the first point,
 with<tt> .COM</tt> concatenated to the end of the program name.
<li>If no file extension is given, an attempt is made to find the program name, in the directory indicated in the first point,
 with<tt> .EXE</tt> concatenated to the end of the program name.
<li>When no directory specification is given as part of the program name, the <tt> spawnlp</tt>, <tt> spawnlpe</tt>, <tt>
 spawnvp</tt>, and <tt> spawnvpe</tt> functions will repeat the preceding three steps for each of the directories specified
 by the <tt> PATH</tt> environment variable.&nbsp; The command
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; path c:\myapps;d:\lib\applns</tt>
<br><br>indicates that the two directories
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; c:\myapps</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; d:\lib\applns</tt>
<br><br>are to be searched.&nbsp; The DOS<tt> PATH</tt> command (without any directory specification) will cause the current
 path definition to be displayed.
</ol>
<br>An error is detected when the program cannot be found.
<br><br>Arguments are passed to the child process by supplying one or more pointers to character strings as arguments in the<b>
 spawn...</b>&nbsp; call.&nbsp; These character strings are concatenated with spaces inserted to separate the arguments to
 form one argument string for the child process.&nbsp; The length of this concatenated string must not exceed 128 bytes for
 DOS systems.
<br><br>The arguments may be passed as a list of arguments (<tt> spawnl</tt>, <tt> spawnle</tt>, <tt> spawnlp</tt> and <tt>
 spawnlpe</tt>) or as a vector of pointers (<tt> spawnv</tt>, <tt> spawnve</tt>, <tt> spawnvp</tt>, and <tt> spawnvpe</tt>).
&nbsp; At least one argument,<b> arg0</b> or<b> argv&#91;0&#93;</b>, must be passed to the child process.&nbsp; By convention,
 this first argument is a pointer to the name of the program.
<br><br>If the arguments are passed as a list, there must be a<tt> NULL</tt> pointer to mark the end of the argument list.
&nbsp; Similarly, if a pointer to an argument vector is passed, the argument vector must be terminated by a<tt> NULL</tt>
 pointer.
<br><br>The environment for the invoked program is inherited from the parent process when you use the <tt> spawnl</tt>, <tt>
 spawnlp</tt>, <tt> spawnv</tt> and <tt> spawnvp</tt> functions.&nbsp; The <tt> spawnle</tt>, <tt> spawnlpe</tt>, <tt> spawnve</tt>
 and <tt> spawnvpe</tt> functions allow a different environment to be passed to the child process through the<b> envp</b>
 argument.&nbsp; The argument<b> envp</b> is a pointer to an array of character pointers, each of which points to a string
 defining an environment variable.&nbsp; The array is terminated with a<tt> NULL</tt> pointer.&nbsp; Each pointer locates
 a character string of the form
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; variable=value</tt>
<br><br>that is used to define an environment variable.&nbsp; If the value of<b> envp</b> is<tt> NULL</tt>, then the child
 process inherits the environment of the parent process.
<br><br>The environment is the collection of environment variables whose values that have been defined with the DOS<tt> SET</tt>
 command or by the successful execution of the <tt> putenv</tt> function.&nbsp; A program may read these values with the <tt>
 getenv</tt> function.&nbsp; The wide-character <tt> _wspawnl</tt>, <tt> _wspawnle</tt>, <tt> _wspawnlp</tt>, <tt> _wspawnlpe</tt>,
 <tt> _wspawnv</tt>, <tt> _wspawnve</tt>, <tt> _wspawnvp</tt> and <tt> _wspawnvpe</tt> functions are similar to their counterparts
 but operate on wide-character strings.
<br><br>The following example invokes &quot;myprog&quot; as if<tt> myprog ARG1 ARG2</tt> had been entered as a command to
 DOS.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; spawnl( P_WAIT, &quot;myprog&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;myprog&quot;, &quot;ARG1&quot;, &quot;ARG2&quot;,
 NULL );</tt>
<br><br>The program will be found if one of &quot;myprog.&quot;, &quot;myprog.com&quot;, or &quot;myprog.exe&quot; is found
 in the current working directory.
<br><br>The following example includes a new environment for &quot;myprog&quot;.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; char *env_list&#91;&#93; = { &quot;SOURCE=MYDATA&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;TARGET=OUTPUT&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;lines=65&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; spawnle( P_WAIT, &quot;myprog&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;myprog&quot;, &quot;ARG1&quot;, &quot;ARG2&quot;,
 NULL,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env_list );</tt>
<br><br>The environment for the invoked program will consist of the three environment variables<tt> SOURCE, TARGET</tt> and<tt>
 lines.</tt>
<br><br>The following example is another variation on the first example.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; char *arg_list&#91;&#93; = { &quot;myprog&quot;, &quot;ARG1&quot;, &quot;ARG2&quot;, NULL
 };</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; spawnv( P_WAIT, &quot;myprog&quot;, arg_list );</tt>
</dl>
<dl>
<dt>Returns:
<dd>When the value of<b> mode</b> is:
<dl>
<dt>Mode&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>P_WAIT
<dd>then the return value from<b> spawn...</b>&nbsp; is the exit status of the child process.
<dt><br>P_NOWAIT
<dd>then the return value from<b> spawn...</b>&nbsp; is the process id (or process handle under Win32) of the child process.&nbsp;
 To obtain the exit code for a process spawned with <tt> P_NOWAIT</tt>, you must call the <tt> wait</tt> (under OS/2 or QNX)
 or <tt> cwait</tt> (under OS/2 or Win32) function specifying the process id/handle.&nbsp; If the child process terminated
 normally, then the low order byte of the returned status word will be set to 0, and the high order byte will contain the
 low order byte of the return code that the child process passed to the <tt> DOSEXIT</tt> function.
<dt><br>P_NOWAITO
<dd>then the return value from<b> spawn...</b>&nbsp; is the process id of the child process.&nbsp; The exit code cannot be obtained
 for a process spawned with <tt> P_NOWAITO</tt>.
</dl>
<br>When an error is detected while invoking the indicated program,<b> spawn...</b>&nbsp; returns -1 and <tt> errno</tt> is
 set to indicate the error.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>E2BIG
<dd>The argument list exceeds 128 bytes, or the space required for the environment information exceeds 32K.
<dt><br>EINVAL
<dd>The<b> mode</b> argument is invalid.
<dt><br>ENOENT
<dd>Path or file not found
<dt><br>ENOMEM
<dd>Not enough memory is available to execute the child process.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#abort">abort</a>, <a href="#atexit">atexit</a>, <a href="#cwait">cwait</a>, <a href="#exec___">exec...</a>, <a href="#exit">exit</a>,
 <a href="#_exit">_exit</a>, <a href="#getcmd">getcmd</a>, <a href="#getenv">getenv</a>, <a href="#main">main</a>, <a href="#putenv">putenv</a>,
 <a href="#system">system</a>, <a href="#wait">wait</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;process.h&gt;</tt>
<br><tt>#include &lt;errno.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; process_id;</tt>
<br><tt>#if defined(__OS2__) || defined(__NT__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; status, rc;</tt>
<br><tt>#endif</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; process_id = spawnl( P_NOWAIT, &quot;child.exe&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;child&quot;, &quot;5&quot;, NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( process_id == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;spawn failed - %s\n&quot;, strerror( errno ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Process id = %d\n&quot;, process_id );</tt>
<br><br><tt>#if defined(__OS2__) || defined(__NT__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = cwait( &amp;status, process_id, WAIT_CHILD );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( rc == -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;wait failed - %s\n&quot;, strerror( errno ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;wait succeeded - %x\n&quot;, status );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch( status &amp; 0xff ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 0:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal termination exit code = %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 status &gt;&gt; 8 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 1:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hard-error abort\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 2:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Trap operation\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 3:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;SIGTERM signal not intercepted\n&quot;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Bogus return status\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>#endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;spawn completed\n&quot; );</tt>
<br><tt>}</tt>
<br><br><tt>/*</tt>
<br><tt>&#91;child.c&#93;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;dos.h&gt;</tt>
<br><br><tt>void main( int argc, char *argv&#91;&#93; )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int delay;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( argc &lt;= 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit( EXIT_FAILURE );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; delay = atoi( argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;I am a child going to sleep &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;for %d seconds\n&quot;, delay );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; sleep( delay );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;I am a child awakening\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; exit( 123 );</tt>
<br><br><tt>}</tt>
<br><tt>*/</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> spawnl - DOS, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>spawnle - DOS, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>spawnlp - DOS, Win32, QNX, OS/2 1.x(all), OS/2-32, Netware</tt>
<br><tt>spawnlpe - DOS, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>spawnv - DOS, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>spawnve - DOS, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>spawnvp - DOS, Win32, QNX, OS/2 1.x(all), OS/2-32, Netware</tt>
<br><tt>spawnvpe - DOS, Win32, QNX, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wspawnl - DOS, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wspawnle - DOS, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wspawnlp - DOS, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wspawnlpe - DOS, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wspawnv - DOS, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wspawnve - DOS, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wspawnvp - DOS, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wspawnvpe - DOS, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_splitpath"> _splitpath, _wsplitpath </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void _splitpath( const char *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char *drive,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char *dir,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char *fname,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char *ext );</tt>
<br><tt>void _wsplitpath( const wchar_t *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *drive,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *dir,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *fname,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *ext );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _splitpath</tt> function splits up a full pathname into four components consisting of a drive letter, directory path,
 file name and file name extension.&nbsp; The argument<b> path</b> points to a buffer containing the full pathname to be split
 up.
<br>The<tt> _wsplitpath</tt> function is a wide-character version of<tt> _splitpath</tt> that operates with wide-character
 strings.
<br><br>The maximum size required for each buffer is specified by the manifest constants <tt> _MAX_PATH</tt>, <tt> _MAX_DRIVE</tt>
 (or <tt> _MAX_VOLUME</tt> for Netware applications), <tt> _MAX_DIR</tt>, <tt> _MAX_FNAME</tt>, and <tt> _MAX_EXT</tt> which
 are defined in<tt> &lt;stdlib.h&gt;.</tt>
<dl>
<dt>drive
<dd>The<b> drive</b> argument points to a buffer that will be filled in with the drive letter (e.g., A, B, C, etc.) followed by
 a colon if a drive is specified in the full pathname (filled in by<tt> _splitpath</tt>).
<br>For Netware applications, the<b> drive</b> argument points to a buffer that will be filled in with the volume identifier
 (e.g., \\NAME_SPACE) if a volume is specified in the full pathname (filled in by<tt> _splitpath</tt>).
<dt><br>dir
<dd>The<b> dir</b> argument points to a buffer that will be filled in with the pathname including the trailing slash.&nbsp; Either
 forward slashes (/) or backslashes (\) may be used.
<dt><br>fname
<dd>The<b> fname</b> argument points to a buffer that will be filled in with the base name of the file without any extension (suffix)
 if a file name is specified in the full pathname (filled in by<tt> _splitpath</tt>).
<dt><br>ext
<dd>The<b> ext</b> argument points to a buffer that will be filled in with the filename extension (suffix) including the leading
 period if an extension is specified in the full pathname (filled in by<tt> _splitpath</tt>).
</dl>
<br>The arguments<b> drive</b>,<b> dir</b>,<b> fname</b> and<b> ext</b> will not be filled in if they are NULL pointers.
<br><br>For each component of the full pathname that is not present, its corresponding buffer will be set to an empty string.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _splitpath</tt> function returns no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_fullpath">_fullpath</a>, <a href="#_makepath">_makepath</a>, <a href="#_splitpath2">_splitpath2</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char full_path&#91; _MAX_PATH &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char drive&#91; _MAX_DRIVE &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char dir&#91; _MAX_DIR &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char fname&#91; _MAX_FNAME &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char ext&#91; _MAX_EXT &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _makepath(full_path,&quot;c&quot;,&quot;watcomc\\h\\&quot;,&quot;stdio&quot;,&quot;h&quot;);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Full path is: %s\n\n&quot;, full_path );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _splitpath( full_path, drive, dir, fname, ext );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Components after _splitpath\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;drive: %s\n&quot;, drive );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;dir:&nbsp;&nbsp; %s\n&quot;, dir );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;fname: %s\n&quot;, fname );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;ext:&nbsp;&nbsp; %s\n&quot;, ext );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Full path is: c:watcomc\h\stdio.h</tt>
<br><br><tt>Components after _splitpath</tt>
<br><tt>drive: c:</tt>
<br><tt>dir:&nbsp;&nbsp; watcomc\h\</tt>
<br><tt>fname: stdio</tt>
<br><tt>ext:&nbsp;&nbsp; .h</tt>
<br><br>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _splitpath - All, Netware</tt>
<br><tt>_wsplitpath - All</tt>
</dl>
<h2 id="_splitpath2"> _splitpath2, _wsplitpath2 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void _splitpath2( const char *inp,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; char *outp,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; char **drive,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; char **dir,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; char **fname,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; char **ext );</tt>
<br><tt>void _wsplitpath2( const wchar_t *inp,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *outp,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **drive,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **dir,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **fname,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **ext );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _splitpath2</tt> function splits up a full pathname into four components consisting of a drive letter, directory path,
 file name and file name extension.
<dl>
<dt>inp
<dd>The argument<b> inp</b> points to a buffer containing the full pathname to be split up.
<dt><br>outp
<dd>The argument<b> outp</b> points to a buffer that will contain all the components of the path, each separated by a null character.
&nbsp; The maximum size required for this buffer is specified by the manifest constant <tt> _MAX_PATH2</tt> which is defined
 in<tt> &lt;stdlib.h&gt;.</tt>
<dt><br>drive
<dd>The<b> drive</b> argument is the location that is to contain the pointer to the drive letter (e.g., A, B, C, etc.) followed
 by a colon if a drive is specified in the full pathname (filled in by<tt> _splitpath2</tt>).
<dt><br>dir
<dd>The<b> dir</b> argument is the location that is to contain the pointer to the directory path including the trailing slash
 if a directory path is specified in the full pathname (filled in by<tt> _splitpath2</tt>).&nbsp; Either forward slashes (/)
 or backslashes (\) may be used.
<dt><br>fname
<dd>The<b> fname</b> argument is the location that is to contain the pointer to the base name of the file without any extension
 (suffix) if a file name is specified in the full pathname (filled in by<tt> _splitpath2</tt>).
<dt><br>ext
<dd>The<b> ext</b> argument is the location that is to contain the pointer to the filename extension (suffix) including the leading
 period if an extension is specified in the full pathname (filled in by<tt> _splitpath2</tt>).
</dl>
<br>The arguments<b> drive</b>,<b> dir</b>,<b> fname</b> and<b> ext</b> will not be filled in if they are NULL pointers.
<br><br>For each component of the full pathname that is not present, its corresponding pointer will be set to point at a NULL
 string ('\0').
<br><br>This function reduces the amount of memory space required when compared to the <tt> splitpath</tt> function.
<br><br>The<tt> _wsplitpath2</tt> function is a wide-character version of<tt> _splitpath2</tt> that operates with wide-character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _splitpath2</tt> function returns no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_fullpath">_fullpath</a>, <a href="#_makepath">_makepath</a>, <a href="#_splitpath">_splitpath</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char full_path&#91; _MAX_PATH &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char tmp_path&#91; _MAX_PATH2 &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *drive;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *dir;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *fname;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *ext;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _makepath(full_path,&quot;c&quot;,&quot;watcomc\\h&quot;,&quot;stdio&quot;,&quot;h&quot;);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Full path is: %s\n\n&quot;, full_path );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _splitpath2( full_path, tmp_path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;drive, &amp;dir,
 &amp;fname, &amp;ext );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Components after _splitpath2\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;drive: %s\n&quot;, drive );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;dir:&nbsp;&nbsp; %s\n&quot;, dir );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;fname: %s\n&quot;, fname );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;ext:&nbsp;&nbsp; %s\n&quot;, ext );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Full path is: c:watcomc\h\stdio.h</tt>
<br><br><tt>Components after _splitpath2</tt>
<br><tt>drive: c:</tt>
<br><tt>dir:&nbsp;&nbsp; watcomc\h\</tt>
<br><tt>fname: stdio</tt>
<br><tt>ext:&nbsp;&nbsp; .h</tt>
<br><br>Note the use of two adjacent backslash characters (\) within character-string constants to signify a single backslash.
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _splitpath2 - All</tt>
<br><tt>_wsplitpath2 - All</tt>
</dl>
<h2 id="sprintf"> sprintf, swprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int sprintf( char *buf, const char *format, ... );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int swprintf( wchar_t *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format, ... );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#sprintf_s">sprintf_s</a> function which is a safer alternative to<tt>
 sprintf</tt>.&nbsp; This newer<tt> sprintf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 sprintf</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> sprintf</tt> function is equivalent to the <tt> fprintf</tt> function, except that the argument<b> buf</b> specifies
 a character array into which the generated output is placed, rather than to a file.&nbsp; A null character is placed at the
 end of the generated character string.&nbsp; The<b> format</b> string is described under the description of the <tt> printf</tt>
 function.
<br>The<tt> swprintf</tt> function is identical to<tt> sprintf</tt> except that the argument<b> buf</b> specifies an array
 of wide characters into which the generated output is to be written, rather than converted to multibyte characters and written
 to a stream.&nbsp; The maximum number of wide characters to write, including a terminating null wide character, is specified
 by<b> n</b>.&nbsp; The<tt> swprintf</tt> function accepts a wide-character string argument for<b> format</b>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> sprintf</tt> function returns the number of characters written into the array, not counting the terminating null character.
&nbsp; An error can occur while converting a value for output.&nbsp; The<tt> swprintf</tt> function returns the number of
 wide characters written into the array, not counting the terminating null wide character, or a negative value if<b> n</b>
 or more wide characters were requested to be generated.&nbsp; When an error has occurred, <tt> errno</tt> contains a value
 indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vprintf">vprintf</a>,
 <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>/* Create temporary file names using a counter */</tt>
<br><br><tt>char namebuf&#91;13&#93;;</tt>
<br><tt>int&nbsp; TempCount = 0;</tt>
<br><br><tt>char *make_temp_name( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; sprintf( namebuf, &quot;zz%.6o.tmp&quot;, TempCount++ );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( namebuf );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *tf1, *tf2;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; tf1 = fopen( make_temp_name(), &quot;w&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tf2 = fopen( make_temp_name(), &quot;w&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fputs( &quot;temp file 1&quot;, tf1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fputs( &quot;temp file 2&quot;, tf2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( tf1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( tf2 );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>sprintf is ANSI
<br>swprintf is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> sprintf - All, Netware</tt>
<br><tt>swprintf - All</tt>
</dl>
<h2 id="sprintf_s"> sprintf_s, swprintf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int sprintf_s( char * restrict s, rsize_t n</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, ... );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int swprintf_s( char * restrict s, rsize_t n,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, ... );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 sprintf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> s</b> nor<b> format</b> shall be a null pointer.&nbsp; The<b> n</b> argument shall neither equal zero nor be
 greater than<tt> RSIZE_MAX.</tt>&nbsp; The number of characters (including the trailing null) required for the result to
 be written to the array pointed to by<b> s</b> shall not be greater than<b> n</b>.&nbsp; The<tt> %n</tt> specifier (modified
 or not by flags, field width, or precision) shall not appear in the string pointed to by<b> format</b>.&nbsp; Any argument
 to<tt> sprintf_s</tt> corresponding to a<tt> %s</tt> specifier shall not be a null pointer.&nbsp; No encoding error shall
 occur.
<br><br>If there is a runtime-constraint violation, then if<b> s</b> is not a null pointer and<b> n</b> is greater than zero
 and less than<tt> RSIZE_MAX,</tt> then the<tt> sprintf_s</tt> function sets<b> s&#91;0&#93;</b> to the null character.
</dl>
<dl>
<dt>Description:
<dd>The<tt> sprintf_s</tt> function is equivalent to the <tt> sprintf</tt> function except for the explicit runtime-constraints
 listed above.
<br>The<tt> sprintf_s</tt> function, unlike <tt> snprintf_s</tt>, treats a result too big for the array pointed to by<b> s</b>
 as a runtime-constraint violation.
<br><br>The<tt> swprintf_s</tt> function is identical to<tt> sprintf_s</tt> except that it accepts a wide-character string
 argument for<b> format</b> and produces wide character output.
</dl>
<dl>
<dt>Returns:
<dd>If no runtime-constraint violation occurred, the<tt> sprintf_s</tt> function returns the number of characters written in the
 array, not counting the terminating null character.&nbsp; If an encoding error occurred,<tt> sprintf_s</tt> returns a negative
 value.&nbsp; If any other runtime-constraint violation occurred,<tt> sprintf_s</tt> returns zero.
<br>If no runtime-constraint violation occurred, the<tt> swprintf_s</tt> function returns the number of wide characters written
 in the array, not counting the terminating null wide character.&nbsp; If an encoding error occurred or if<b> n</b> or more
 wide characters are requested to be written,<tt> swprintf_s</tt> returns a negative value.&nbsp; If any other runtime-constraint
 violation occurred,<tt> swprintf_s</tt> returns zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>,
 <a href="#vprintf">vprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>/* Create temporary file names using a counter */</tt>
<br><br><tt>char namebuf&#91;13&#93;;</tt>
<br><tt>int&nbsp; TempCount = 0;</tt>
<br><br><tt>char *make_temp_name( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; sprintf_s( namebuf, sizeof( namebuf ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;zz%.6o.tmp&quot;, TempCount++
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( namebuf );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *tf1, *tf2;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; tf1 = fopen( make_temp_name(), &quot;w&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tf2 = fopen( make_temp_name(), &quot;w&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fputs( &quot;temp file 1&quot;, tf1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fputs( &quot;temp file 2&quot;, tf2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( tf1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( tf2 );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>sprintf_s is TR 24731
<br>swprintf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> sprintf_s - All, Netware</tt>
<br><tt>swprintf_s - All</tt>
</dl>
<h2 id="sqrt"> sqrt </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double sqrt( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> sqrt</tt> function computes the non-negative square root of<b> x</b>.&nbsp; A domain error occurs if the argument
 is negative.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> sqrt</tt> function returns the value of the square root.&nbsp; When the argument is outside the permissible range,
 the <tt> matherr</tt> function is called.&nbsp; Unless the default <tt> matherr</tt> function is replaced, it will set the
 global variable <tt> errno</tt> to <tt> EDOM</tt>, and print a &quot;DOMAIN error&quot; diagnostic message using the <tt>
 stderr</tt> stream.
</dl>
<dl>
<dt>See Also:
<dd><a href="#exp">exp</a>, <a href="#log">log</a>, <a href="#pow">pow</a>, <a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, sqrt(.5) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.707107</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="srand"> srand </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void srand( unsigned int seed );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> srand</tt> function uses the argument<b> seed</b> to start a new sequence of pseudo-random integers to be returned
 by subsequent calls to <tt> rand</tt>.&nbsp; A particular sequence of pseudo-random integers can be repeated by calling<tt>
 srand</tt> with the same<b> seed</b> value.&nbsp; The default sequence of pseudo-random integers is selected with a<b> seed</b>
 value of 1.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> srand</tt> function returns no value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#rand">rand</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; srand( 982 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; 10; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, rand() );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; srand( 982 );&nbsp; /* start sequence over again */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt; 10; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, rand() );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="sscanf"> sscanf, swscanf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int sscanf( const char *in_string,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format, ... );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int swscanf( const wchar_t *in_string,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format, ... );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#sscanf_s">sscanf_s</a> function which is a safer alternative to<tt> sscanf</tt>.
&nbsp; This newer<tt> sscanf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> sscanf</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> sscanf</tt> function scans input from the character string<b> in_string</b> under control of the argument<b> format</b>.
&nbsp; Following the format string is the list of addresses of items to receive values.
<br>The<b> format</b> string is described under the description of the <tt> scanf</tt> function.
<br><br>The<tt> swscanf</tt> function is identical to<tt> sscanf</tt> except that it accepts a wide-character string argument
 for<b> format</b> and the input string<b> in_string</b> consists of wide characters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> sscanf</tt> function returns <tt> EOF</tt> if the end of the input string was reached before any input conversion.
&nbsp; Otherwise, the number of input arguments for which values were successfully scanned and stored is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cscanf">cscanf</a>, <a href="#fscanf">fscanf</a>, <a href="#scanf">scanf</a>, <a href="#vcscanf">vcscanf</a>, <a href="#vfscanf">vfscanf</a>,
 <a href="#vscanf">vscanf</a>, <a href="#vsscanf">vsscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>/* Scan a date in the form &quot;Saturday April 18 1987&quot; */</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; sscanf( &quot;Friday August 0014 1987&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%s %s %d&nbsp; %d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day, &amp;year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s %s %d %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Friday August 14 1987</tt>
</dl>
<dl>
<dt>Classification:
<dd>sscanf is ISO C90
<br>swscanf is ISO C95
</dl>
<dl>
<dt>Systems:
<dd><tt> sscanf - All, Netware</tt>
<br><tt>swscanf - All</tt>
</dl>
<h2 id="sscanf_s"> sscanf_s, swscanf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int sscanf_s( const char * restrict s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, ... );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int swscanf_s( const wchar_t * restrict s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format,
 ... );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 sscanf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> s</b> not<b> format</b> shall be a null pointer.&nbsp; Any argument indirected through in order to store converted
 input shall not be a null pointer.
<br><br>If there is a runtime-constraint violation, the<tt> sscanf_s</tt> function does not attempt to perform further input,
 and it is unspecified to what extent<tt> sscanf_s</tt> performed input before discovering the runtime-constraint violation.
</dl>
<dl>
<dt>Description:
<dd>The<tt> sscanf_s</tt> function is equivalent to <tt> fscanf_s</tt>, except that input is obtained from a string (specified
 by the argument<b> s</b>) rather than from a stream.&nbsp; Reaching the end of the string is equivalent to encountering end-of-file
 for the <tt> fscanf_s</tt> function.&nbsp; If copying takes place between objects that overlap, the objects take on unspecified
 values.
<br>The<tt> swscanf_s</tt> function is identical to<tt> sscanf_s</tt> except that it accepts wide-character string arguments
 for<b> s</b> and<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> sscanf_s</tt> function returns <tt> EOF</tt> if an input failure occurred before any conversion or if there was a
 runtime-constraint violation.&nbsp; Otherwise, the<tt> sscanf_s</tt> function returns the number of input items successfully
 assigned, which can be fewer than provided for, or even zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cscanf">cscanf</a>, <a href="#fscanf">fscanf</a>, <a href="#scanf">scanf</a>, <a href="#sscanf">sscanf</a>, <a href="#vcscanf">vcscanf</a>,
 <a href="#vfscanf">vfscanf</a>, <a href="#vscanf">vscanf</a>, <a href="#vsscanf">vsscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; sscanf_s( &quot;Friday August 0013 2004&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%s %s %d&nbsp; %d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, sizeof( weekday ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; month, sizeof( month ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;day, &amp;year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf_s( &quot;%s %s %d %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Friday August 13 2004</tt>
</dl>
<dl>
<dt>Classification:
<dd>sscanf_s is TR 24731
<br>swscanf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> sscanf_s - All, Netware</tt>
<br><tt>swscanf_s - All</tt>
</dl>
<h2 id="stackavail"> stackavail, _stackavail </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>size_t stackavail( void );</tt>
<br><tt>size_t _stackavail( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> stackavail</tt> function returns the number of bytes currently available in the stack.&nbsp; This value is usually
 used to determine an appropriate amount to allocate using alloca.
<br>The<tt> _stackavail</tt> function is identical to<tt> stackavail</tt>.&nbsp; Use<tt> _stackavail</tt> for ANSI/ISO naming
 conventions.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> stackavail</tt> function returns the number of bytes currently available in the stack.
</dl>
<dl>
<dt>See Also:
<dd><a href="#alloca">alloca</a>, <a href="#calloc">calloc</a> Functions, <a href="#malloc">malloc</a> Functions
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;malloc.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>long char_count( FILE *fp )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *buffer;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; size_t&nbsp; bufsiz;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp; count;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; /* allocate half of stack for temp buffer */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; bufsiz = stackavail() &gt;&gt; 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; buffer = (char *) alloca( bufsiz );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; setvbuf( fp, buffer, _IOFBF, bufsiz );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; count = 0L;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; while( fgetc( fp ) != EOF ) ++count;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; return( count );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;rb&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; setmode( fileno( fp ), O_BINARY );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File contains %lu characters\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char_count( fp ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_stackavail conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> stackavail - All, Netware</tt>
<br><tt>_stackavail - All, Netware</tt>
</dl>
<h2 id="stat"> stat, _stat, _stati64, _wstat, _wstati64, lstat </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>int stat( const char *path, struct stat *buf );</tt>
<br><tt>int _stat( const char *path, struct _stat *buf );</tt>
<br><tt>int _stati64( const char *path, struct _stati64 *buf );</tt>
<br><tt>int _wstat( const wchar_t *path, struct _stat *buf );</tt>
<br><tt>int _wstati64( const wchar_t *path, struct _stati64 *buf );</tt>
<br><tt>int lstat( const char *path, struct stat *buf );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> stat</tt> functions obtain information about the file or directory referenced in<b> path</b>.&nbsp; This information
 is placed in the structure located at the address indicated by<b> buf</b>.
<br>The file<tt> &lt;sys\stat.h&gt;</tt> contains definitions for the structure <tt> stat</tt>.
<dl>
<dt>Field&nbsp;&nbsp;&nbsp;&nbsp; Type/Meaning
<dt>st_dev
<dd>(dev_t) the disk drive the file resides on
<dt><br>st_ino
<dd>(ino_t) this inode's number (not used for DOS)
<dt><br>st_mode
<dd>(unsigned short) file mode
<dt><br>st_nlink
<dd>(short) number of hard links
<dt><br>st_uid
<dd>(unsigned long) user-id (always 'root' for DOS)
<dt><br>st_gid
<dd>(short) group-id (always 'root' for DOS)
<dt><br>st_rdev
<dd>(dev_t) this should be the device type but it is the same as st_dev for the time being
<dt><br>st_size
<dd>(off_t) total file size
<dt><br>st_atime
<dd>(time_t) this should be the file &quot;last accessed&quot; time if the file system supports it
<dt><br>st_mtime
<dd>(time_t) the file &quot;last modified&quot; time
<dt><br>st_ctime
<dd>(time_t) this should be the file &quot;last status change&quot; time if the file system supports it
<br><b>The following fields are Netware only:</b>
<dt><br>st_btime
<dd>(time_t) the file &quot;last archived&quot; time
<dt><br>st_attr
<dd>(unsigned long) the file's attributes
<dt><br>st_archivedID
<dd>(unsigned long) the user/object ID that last archived file
<dt><br>st_updatedID
<dd>(unsigned long) the user/object ID that last updated file
<dt><br>st_inheritedRightsMask
<dd>(unsigned short) the inherited rights mask
<dt><br>st_originatingNameSpace
<dd>(unsigned char) the originating name space
</dl>
<br>The structure <tt> _stati64</tt> differs from <tt> stat</tt> in the following way:
<dl>
<dt>st_size
<dd>(__int64) total file size (as a 64-bit value)
</dl>
<br>At least the following macros are defined in the<tt> &lt;sys\stat.h&gt;</tt> header file.
<dl>
<dt>Macro&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_ISFIFO(m)
<dd>Test for FIFO.
<dt><br>S_ISCHR(m)
<dd>Test for character special file.
<dt><br>S_ISDIR(m)
<dd>Test for directory file.
<dt><br>S_ISBLK(m)
<dd>Test for block special file.
<dt><br>S_ISREG(m)
<dd>Test for regular file.
</dl>
<br>The value<b> m</b> supplied to the macros is the value of the <tt> st_mode</tt> field of a <tt> stat</tt> structure.&nbsp;
 The macro evaluates to a non-zero value if the test is true and zero if the test is false.
<br><br>The following bits are encoded within the <tt> st_mode</tt> field of a <tt> stat</tt> structure.
<dl>
<dt>Mask&nbsp;&nbsp;&nbsp;&nbsp; Owner Permissions
<dt>S_IRWXU
<dd>Read, write, search (if a directory), or execute (otherwise)
<dt><br>S_IRUSR
<dd>Read permission bit
<dt><br>S_IWUSR
<dd>Write permission bit
<dt><br>S_IXUSR
<dd>Search/execute permission bit
<dt><br>S_IREAD
<dd>== <tt> S_IRUSR</tt> (for Microsoft compatibility)
<dt><br>S_IWRITE
<dd>== <tt> S_IWUSR</tt> (for Microsoft compatibility)
<dt><br>S_IEXEC
<dd>== <tt> S_IXUSR</tt> (for Microsoft compatibility)
</dl>
<br><tt> S_IRWXU</tt> is the bitwise inclusive OR of <tt> S_IRUSR</tt>, <tt> S_IWUSR</tt>, and <tt> S_IXUSR</tt>.
<dl>
<dt>Mask&nbsp;&nbsp;&nbsp;&nbsp; Group Permissions (same as owner's on DOS, OS/2 or Windows)
<dt>S_IRWXG
<dd>Read, write, search (if a directory), or execute (otherwise)
<dt><br>S_IRGRP
<dd>Read permission bit
<dt><br>S_IWGRP
<dd>Write permission bit
<dt><br>S_IXGRP
<dd>Search/execute permission bit
</dl>
<br><tt> S_IRWXG</tt> is the bitwise inclusive OR of <tt> S_IRGRP</tt>, <tt> S_IWGRP</tt>, and <tt> S_IXGRP</tt>.
<dl>
<dt>Mask&nbsp;&nbsp;&nbsp;&nbsp; Other Permissions (same as owner's on DOS, OS/2 or Windows)
<dt>S_IRWXO
<dd>Read, write, search (if a directory), or execute (otherwise)
<dt><br>S_IROTH
<dd>Read permission bit
<dt><br>S_IWOTH
<dd>Write permission bit
<dt><br>S_IXOTH
<dd>Search/execute permission bit
</dl>
<br><tt> S_IRWXO</tt> is the bitwise inclusive OR of <tt> S_IROTH</tt>, <tt> S_IWOTH</tt>, and <tt> S_IXOTH</tt>.
<dl>
<dt>Mask&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_ISUID
<dd>(Not supported by DOS, OS/2 or Windows) Set user ID on execution.&nbsp; The process's effective user ID shall be set to that
 of the owner of the file when the file is run as a program.&nbsp; On a regular file, this bit should be cleared on any write.
<dt><br>S_ISGID
<dd>(Not supported by DOS, OS/2 or Windows) Set group ID on execution.&nbsp; Set effective group ID on the process to the file's
 group when the file is run as a program.&nbsp; On a regular file, this bit should be cleared on any write.
</dl>
<br>The<tt> _stat</tt> function is identical to<tt> stat</tt>.&nbsp; Use<tt> _stat</tt> for ANSI/ISO naming conventions.&nbsp;
 The <tt> _stati64</tt>, <tt> _wstat</tt>, and <tt> _wstati64</tt> functions differ from<tt> stat</tt> in the type of structure
 that they are asked to fill in.&nbsp; The <tt> _wstat</tt> and <tt> _wstati64</tt> functions deal with wide character strings.
&nbsp; The differences in the structures are described above.&nbsp; The <tt> lstat</tt> function is identical to<tt> stat</tt>
 on non-UNIX platforms.
</dl>
<dl>
<dt>Returns:
<dd>All forms of the<tt> stat</tt> function return zero when the information is successfully obtained.&nbsp; Otherwise, -1 is
 returned.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>EACCES
<dd>Search permission is denied for a component of<b> path</b>.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#fstat">fstat</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct stat buf;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( stat( &quot;file&quot;, &amp;buf ) != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;File size = %d\n&quot;, buf.st_size );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>stat is POSIX
<br>_stat is not POSIX
<br>_stati64 is not POSIX
<br>_wstat is not POSIX
<br>_wstati64 is not POSIX
<br>_stat conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> stat - All, Netware</tt>
<br><tt>_stat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_stati64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wstat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wstati64 - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>lstat - All, Netware</tt>
</dl>
<h2 id="_status87"> _status87 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;float.h&gt;</tt>
<br><tt>unsigned int _status87( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _status87</tt> function returns the floating-point status word which is used to record the status of 8087/80287/80387/80486
 floating-point operations.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _status87</tt> function returns the floating-point status word which is used to record the status of 8087/80287/80387/80486
 floating-point operations.&nbsp; The description of this status is found in the<tt> &lt;float.h&gt;</tt> header file.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_clear87">_clear87</a>, <a href="#_control87">_control87</a>, <a href="#_controlfp">_controlfp</a>, <a href="#_finite">_finite</a>,
 <a href="#_fpreset">_fpreset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;float.h&gt;</tt>
<br><br><tt>#define TEST_FPU(x,y) printf( &quot;\t%s &quot; y &quot;\n&quot;, \</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((fp_status &amp; x) ?
 &quot;&nbsp; &quot; : &quot;No&quot;) )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned int fp_status;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp_status = _status87();</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;80x87 status\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; TEST_FPU( SW_INVALID, &quot;invalid operation&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; TEST_FPU( SW_DENORMAL, &quot;denormalized operand&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; TEST_FPU( SW_ZERODIVIDE, &quot;divide by zero&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; TEST_FPU( SW_OVERFLOW, &quot;overflow&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; TEST_FPU( SW_UNDERFLOW, &quot;underflow&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; TEST_FPU( SW_INEXACT, &quot;inexact result&quot; );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>Intel
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="strcasecmp"> strcasecmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strings.h&gt;</tt>
<br><tt>int strcasecmp( const char *s1, const char *s2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strcasecmp</tt> function compares, with case insensitivity, the string pointed to by<b> s1</b> to the string pointed
 to by<b> s2</b>.&nbsp; All uppercase characters from<b> s1</b> and<b> s2</b> are mapped to lowercase for the purposes of
 doing the comparison.
<br>The<tt> strcasecmp</tt> function is identical to the <tt> stricmp</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strcasecmp</tt> function returns an integer less than, equal to, or greater than zero, indicating that the string
 pointed to by<b> s1</b> is, ignoring case, less than, equal to, or greater than the string pointed to by<b> s2</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcmp">strcmp</a>, <a href="#strcmpi">strcmpi</a>, <a href="#stricmp">stricmp</a>, <a href="#strncmp">strncmp</a>,
 <a href="#strnicmp">strnicmp</a>, <a href="#strncasecmp">strncasecmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;strings.h&gt;</tt>
<br><br><tt>int main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcasecmp( &quot;AbCDEF&quot;, &quot;abcdef&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcasecmp( &quot;abcdef&quot;, &quot;ABC&quot;&nbsp;&nbsp;&nbsp; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcasecmp( &quot;abc&quot;,&nbsp;&nbsp;&nbsp; &quot;ABCdef&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcasecmp( &quot;Abcdef&quot;, &quot;mnopqr&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcasecmp( &quot;Mnopqr&quot;, &quot;abcdef&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>0</tt>
<br><tt>100</tt>
<br><tt>-100</tt>
<br><tt>-12</tt>
<br><tt>12</tt>
</dl>
<dl>
<dt>Classification:
<dd>POSIX
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="strcat"> strcat, _fstrcat, wcscat, _mbscat, _fmbscat </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strcat( char *dst, const char *src );</tt>
<br><tt>char __far *_fstrcat( char __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const char __far *src );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *wcscat( wchar_t *dst, const wchar_t *src );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbscat( unsigned char *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned
 char *src );</tt>
<br><tt>unsigned char __far *_fmbscat( unsigned char __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *src );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#strcat_s">strcat_s</a> function which is a safer alternative to<tt> strcat</tt>.
&nbsp; This newer<tt> strcat_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> strcat</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strcat</tt> function appends a copy of the string pointed to by<b> src</b> (including the terminating null character)
 to the end of the string pointed to by<b> dst</b>.&nbsp; The first character of<b> src</b> overwrites the null character
 at the end of<b> dst</b>.
<br>The<tt> _fstrcat</tt> function is a data model independent form of the<tt> strcat</tt> function.&nbsp; It accepts far
 pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcscat</tt> function is a wide-character version of<tt> strcat</tt> that operates with wide-character strings.
<br><br>The<tt> _mbscat</tt> function is a multibyte character version of<tt> strcat</tt> that operates with multibyte character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The value of<b> dst</b> is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strncat">strncat</a>, <a href="#strcat_s">strcat_s</a>, <a href="#strncat_s">strncat_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;Hello &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcat( buffer, &quot;world&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Hello world</tt>
</dl>
<dl>
<dt>Classification:
<dd>strcat is ANSI
<br>_fstrcat is not ANSI
<br>wcscat is ANSI
<br>_mbscat is not ANSI
<br>_fmbscat is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strcat - All, Netware</tt>
<br><tt>_fstrcat - All</tt>
<br><tt>wcscat - All</tt>
<br><tt>_mbscat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbscat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strcat_s"> strcat_s, wcscat_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>errno_t strcat_s( char * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char
 * restrict s2 );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>errno_t wcscat_s( wchar_t * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
 * restrict s2 );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 strcat_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Let<b> m</b> denote the value<b> s1max - strnlen_s(s1, s1max)</b> upon entry to <tt> strcat_s</tt>.&nbsp; Neither<b> s1</b>
 nor<b> s2</b> shall be a null pointer.<b>&nbsp; s1max</b> shall not be greater than <tt> RSIZE_MAX</tt>.<b>&nbsp; s1max</b>
 shall not equal zero.<b>&nbsp; m</b> shall not equal zero.<b>&nbsp; m</b> shall be greater than<b> strnlen_s(s2, m)</b>.
&nbsp; Copying shall not take place between objects that overlap.
<br><br>If there is a runtime-constraint violation, then if<b> s1</b> is not a null pointer and<b> s1max</b> is greater than
 zero and not greater than <tt> RSIZE_MAX</tt>, then <tt> strcat_s</tt> sets<b> s1&#91;0&#93;</b> to the null character.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strcat_s</tt> function appends a copy of the string pointed to by<b> s2</b> (including the terminating null character)
 to the end of the string pointed to by<b> s1</b>.&nbsp; The initial character from<b> s2</b> overwrites the null character
 at the end of<b> s1</b>.&nbsp; All elements following the terminating null character (if any) written by<tt> strcat_s</tt>
 in the array of<b> s1max</b> characters pointed to by<b> s1</b> take unspecified values when<tt> strcat_s</tt> returns.
<br>The<tt> wcscat_s</tt> function is a wide-character version of<tt> strcat_s</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strcat_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcat">strcat</a>, <a href="#strncat">strncat</a>, <a href="#strncat_s">strncat_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; strcpy_s( buffer, sizeof( buffer ), &quot;Hello &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcat_s( buffer, sizeof( buffer ), &quot;world&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Hello world</tt>
</dl>
<dl>
<dt>Classification:
<dd>strcat_s is TR 24731
<br>wcscat_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> strcat_s - All, Netware</tt>
<br><tt>wcscat_s - All</tt>
</dl>
<h2 id="strchr"> strchr, _fstrchr, wcschr, _mbschr, _fmbschr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strchr( const char *s, int c );</tt>
<br><tt>char __far *_fstrchr( const char __far *s, int c );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *wcschr( const wchar_t *s, wint_t c );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbschr( const unsigned char *s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned int c );</tt>
<br><tt>unsigned char __far *_fmbschr(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strchr</tt> function locates the first occurrence of<b> c</b> (converted to a char) in the string pointed to by<b>
 s</b>.&nbsp; The terminating null character is considered to be part of the string.
<br>The<tt> _fstrchr</tt> function is a data model independent form of the<tt> strchr</tt> function.&nbsp; It accepts far
 pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcschr</tt> function is a wide-character version of<tt> strchr</tt> that operates with wide-character strings.
<br><br>The<tt> _mbschr</tt> function is a multibyte character version of<tt> strchr</tt> that operates with multibyte character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strchr</tt> function returns a pointer to the located character, or<tt> NULL</tt> if the character does not occur
 in the string.
</dl>
<dl>
<dt>See Also:
<dd><a href="#memchr">memchr</a>, <a href="#strcspn">strcspn</a>, <a href="#strrchr">strrchr</a>, <a href="#strspn">strspn</a>,
 <a href="#strstr">strstr</a>, <a href="#strtok">strtok</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;80&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *where;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;video x-rays&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; where = strchr( buffer, 'x' );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( where == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;'x' not found\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>strchr is ANSI
<br>_fstrchr is not ANSI
<br>wcschr is ANSI
<br>_mbschr is not ANSI
<br>_fmbschr is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strchr - All, Netware</tt>
<br><tt>_fstrchr - All</tt>
<br><tt>wcschr - All</tt>
<br><tt>_mbschr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbschr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strcmp"> strcmp, _fstrcmp, wcscmp, _mbscmp, _fmbscmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>int strcmp( const char *s1, const char *s2 );</tt>
<br><tt>int _fstrcmp( const char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far *s2 );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int wcscmp( const wchar_t *s1, const wchar_t *s2 );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbscmp( const unsigned char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2 );</tt>
<br><tt>int _fmbscmp( const unsigned char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strcmp</tt> function compares the string pointed to by<b> s1</b> to the string pointed to by<b> s2</b>.
<br>The<tt> _fstrcmp</tt> function is a data model independent form of the<tt> strcmp</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcscmp</tt> function is a wide-character version of<tt> strcmp</tt> that operates with wide-character strings.
<br><br>The<tt> _mbscmp</tt> function is a multibyte character version of<tt> strcmp</tt> that operates with multibyte character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strcmp</tt> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
 to by<b> s1</b> is less than, equal to, or greater than the string pointed to by<b> s2</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcmpi">strcmpi</a>, <a href="#stricmp">stricmp</a>, <a href="#strncmp">strncmp</a>, <a href="#strnicmp">strnicmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmp( &quot;abcdef&quot;, &quot;abcdef&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmp( &quot;abcdef&quot;, &quot;abc&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmp( &quot;abc&quot;, &quot;abcdef&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmp( &quot;abcdef&quot;, &quot;mnopqr&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmp( &quot;mnopqr&quot;, &quot;abcdef&quot; ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0</tt>
<br><tt>1</tt>
<br><tt>-1</tt>
<br><tt>-1</tt>
<br><tt>1</tt>
</dl>
<dl>
<dt>Classification:
<dd>strcmp is ANSI
<br>_fstrcmp is not ANSI
<br>wcscmp is ANSI
<br>_mbscmp is not ANSI
<br>_fmbscmp is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strcmp - All, Netware</tt>
<br><tt>_fstrcmp - All</tt>
<br><tt>wcscmp - All</tt>
<br><tt>_mbscmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbscmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strcmpi"> strcmpi, wcscmpi </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>int strcmpi( const char *s1, const char *s2 );</tt>
<br><tt>int wcscmpi( const wchar_t *s1, const wchar_t *s2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strcmpi</tt> function compares, with case insensitivity, the string pointed to by<b> s1</b> to the string pointed
 to by<b> s2</b>.&nbsp; All uppercase characters from<b> s1</b> and<b> s2</b> are mapped to lowercase for the purposes of
 doing the comparison.&nbsp; The<tt> strcmpi</tt> function is identical to the <tt> stricmp</tt> function.
<br>The<tt> wcscmpi</tt> function is a wide-character version of<tt> strcmpi</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strcmpi</tt> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
 to by<b> s1</b> is less than, equal to, or greater than the string pointed to by<b> s2</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcmp">strcmp</a>, <a href="#stricmp">stricmp</a>, <a href="#strncmp">strncmp</a>, <a href="#strnicmp">strnicmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmpi( &quot;AbCDEF&quot;, &quot;abcdef&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmpi( &quot;abcdef&quot;, &quot;ABC&quot;&nbsp;&nbsp;&nbsp; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmpi( &quot;abc&quot;,&nbsp;&nbsp;&nbsp; &quot;ABCdef&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmpi( &quot;Abcdef&quot;, &quot;mnopqr&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcmpi( &quot;Mnopqr&quot;, &quot;abcdef&quot; ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0</tt>
<br><tt>100</tt>
<br><tt>-100</tt>
<br><tt>-12</tt>
<br><tt>12</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> strcmpi - All, Netware</tt>
<br><tt>wcscmpi - All</tt>
</dl>
<h2 id="strcoll"> strcoll, wcscoll, _mbscoll </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>int strcoll( const char *s1, const char *s2 );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int wcscoll( const wchar_t *s1, const wchar_t *s2 );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbscoll( const unsigned char *s1, const unsigned char *s2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strcoll</tt> function compares the string pointed to by<b> s1</b> to the string pointed to by<b> s2</b>.&nbsp; The
 comparison uses the collating sequence selected by the <tt> setlocale</tt> function.&nbsp; The function will be equivalent
 to the <tt> strcmp</tt> function when the collating sequence is selected from the<tt> &quot;C&quot;</tt> locale.
<br>The<tt> wcscoll</tt> function is a wide-character version of<tt> strcoll</tt> that operates with wide-character strings.
<br><br>The<tt> _mbscoll</tt> function is a multibyte character version of<tt> strcoll</tt> that operates with multibyte character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strcoll</tt> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
 to by<b> s1</b> is less than, equal to, or greater than the string pointed to by<b> s2</b>, according to the collating sequence
 selected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#setlocale">setlocale</a>, <a href="#strcmp">strcmp</a>, <a href="#strncmp">strncmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char buffer&#91;80&#93; = &quot;world&quot;;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( strcoll( buffer, &quot;Hello&quot; ) &lt; 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>strcoll is ANSI
<br>wcscoll is ANSI
<br>_mbscoll is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strcoll - All, Netware</tt>
<br><tt>wcscoll - All</tt>
<br><tt>_mbscoll - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strcpy"> strcpy, _fstrcpy, wcscpy, _mbscpy, _fmbscpy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strcpy( char *dst, const char *src );</tt>
<br><tt>char __far *_fstrcpy( char __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const char __far *src );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *wcscpy( wchar_t *dst, const wchar_t *src );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbscpy( unsigned char *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *src );</tt>
<br><tt>int _fmbscpy( unsigned char __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *src );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#strcpy_s">strcpy_s</a> function which is a safer alternative to<tt> strcpy</tt>.
&nbsp; This newer<tt> strcpy_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> strcpy</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strcpy</tt> function copies the string pointed to by<b> src</b> (including the terminating null character) into the
 array pointed to by<b> dst</b>.&nbsp; Copying of overlapping objects is not guaranteed to work properly.&nbsp; See the description
 for the <tt> memmove</tt> function to copy objects that overlap.
<br>The<tt> _fstrcpy</tt> function is a data model independent form of the<tt> strcpy</tt> function.&nbsp; It accepts far
 pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcscpy</tt> function is a wide-character version of<tt> strcpy</tt> that operates with wide-character strings.
<br><br>The<tt> _mbscpy</tt> function is a multibyte character version of<tt> strcpy</tt> that operates with multibyte character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The value of<b> dst</b> is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strdup">strdup</a>, <a href="#strncpy">strncpy</a>, <a href="#strcpy_s">strcpy_s</a>, <a href="#strncpy_s">strncpy_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;Hello &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcat( buffer, &quot;world&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Hello world</tt>
</dl>
<dl>
<dt>Classification:
<dd>strcpy is ANSI
<br>_fstrcpy is not ANSI
<br>wcscpy is ANSI
<br>_mbscpy is not ANSI
<br>_fmbscpy is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strcpy - All, Netware</tt>
<br><tt>_fstrcpy - All</tt>
<br><tt>wcscpy - All</tt>
<br><tt>_mbscpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbscpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strcpy_s"> strcpy_s, wcscpy_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>errno_t strcpy_s( char * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char
 * restrict s2 );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>errno_t wcscpy_s( wchar_t * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
 * restrict s2 );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 strcpy_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> s1</b> nor<b> s2</b> shall be a null pointer.<b>&nbsp; s1max</b> shall not be greater than <tt> RSIZE_MAX</tt>.<b>
&nbsp; s1max</b> shall not equal zero.<b>&nbsp; s1max</b> shall be greater than<b> strnlen_s(s2, s1max)</b>.&nbsp; Copying
 shall not take place between objects that overlap.
<br><br>If there is a runtime-constraint violation, then if<b> s1</b> is not a null pointer and<b> s1max</b> is greater than
 zero and not greater than <tt> RSIZE_MAX</tt> , then <tt> strcpy_s</tt> sets<b> s1&#91;0&#93;</b> to the null character.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strcpy_s</tt> function copies the string pointed to by<b> s2</b> (including the terminating null character) into the
 array pointed to by<b> s1</b>.&nbsp; All elements following the terminating null character (if any) written by<tt> strcpy_s</tt>
 in the array of<b> s1max</b> characters pointed to by<b> s1</b> take unspecified values when<tt> strcpy_s</tt> returns.
<br>The<tt> wcscpy_s</tt> function is a wide-character version of<tt> strcpy_s</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strcpy_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcpy">strcpy</a>, <a href="#strdup">strdup</a>, <a href="#strncpy">strncpy</a>, <a href="#strncpy_s">strncpy_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; strcpy_s( buffer, sizeof( buffer ), &quot;Hello &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcat_s( buffer, sizeof( buffer ), &quot;world&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Hello world</tt>
</dl>
<dl>
<dt>Classification:
<dd>strcpy_s is TR 24731
<br>wcscpy_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> strcpy_s - All, Netware</tt>
<br><tt>wcscpy_s - All</tt>
</dl>
<h2 id="strcspn"> strcspn, _fstrcspn, wcscspn, _mbscspn, _fmbscspn </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>size_t strcspn( const char *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *charset );</tt>
<br><tt>size_t _fstrcspn( const char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char
 __far *charset );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>size_t wcscspn( const wchar_t *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *charset
 );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>size_t _mbscpsn( const unsigned char *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char
 *charset );</tt>
<br><tt>size_t _fmbscpsn( const unsigned char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned
 char __far *charset );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strcspn</tt> function computes the length, in bytes, of the initial segment of the string pointed to by<b> str</b>
 which consists entirely of characters<b> not</b> from the string pointed to by<b> charset</b>.&nbsp; The terminating null
 character is not considered part of<b> str</b>.
<br>The<tt> _fstrcspn</tt> function is a data model independent form of the<tt> strcspn</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcscspn</tt> function is a wide-character version of<tt> strcspn</tt> that operates with wide-character strings.
<br><br>The<tt> _mbscspn</tt> function is a multibyte character version of<tt> strcspn</tt> that operates with multibyte character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The length, in bytes, of the initial segment is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strspn">strspn</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcspn( &quot;abcbcadef&quot;, &quot;cba&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcspn( &quot;xxxbcadef&quot;, &quot;cba&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strcspn( &quot;123456789&quot;, &quot;cba&quot; ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0</tt>
<br><tt>3</tt>
<br><tt>9</tt>
</dl>
<dl>
<dt>Classification:
<dd>strcspn is ANSI
<br>_fstrcspn is not ANSI
<br>wcscspn is ANSI
<br>_mbscspn is not ANSI
<br>_fmbscspn is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strcspn - All, Netware</tt>
<br><tt>_fstrcspn - All</tt>
<br><tt>wcscspn - All</tt>
<br><tt>_mbscspn - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbscspn - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_strdate"> _strdate, _wstrdate </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>char *_strdate( char *datestr )</tt>
<br><tt>wchar_t _wstrdate( wchar_t *datestr );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _strdate</tt> function copies the current date to the buffer pointed to by<b> datestr</b>.&nbsp; The date is formatted
 as &quot;MM/DD/YY&quot; where &quot;MM&quot; is two digits representing the month, where &quot;DD&quot; is two digits representing
 the day, and where &quot;YY&quot; is two digits representing the year.&nbsp; The buffer must be at least 9 bytes long.
<br>The<tt> _wstrdate</tt> function is a wide-character version of<tt> _strdate</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _strdate</tt> function returns a pointer to the resulting text string<b> datestr</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#ctime">ctime</a> Functions, <a href="#gmtime">gmtime</a>, <a href="#localtime">localtime</a>,
 <a href="#mktime">mktime</a>, <a href="#_strtime">_strtime</a>, <a href="#time">time</a>, <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char datebuff&#91;9&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, _strdate( datebuff ) );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _strdate - All</tt>
<br><tt>_wstrdate - All</tt>
</dl>
<h2 id="_strdec"> _strdec, _wcsdec, _mbsdec, _fmbsdec </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;tchar.h&gt;</tt>
<br><tt>char *_strdec( const char *start, const char *current );</tt>
<br><tt>wchar_t *_wcsdec( const wchar_t *start,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
 *current );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsdec( const unsigned char *start,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *current );</tt>
<br><tt>unsigned char *_fmbsdec( const unsigned char __far *start,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const unsigned char __far *current );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _strdec</tt> function returns a pointer to the previous character (single-byte, wide, or multibyte) in the string
 pointed to by<b> start</b> which must precede<b> current</b>.&nbsp; The current character in the string is pointed to by<b>
 current</b>.&nbsp; You must ensure that<b> current</b> does not point into the middle of a multibyte or wide character.
<br>The function is a data model independent form of the<tt> _strdec</tt> function that accepts far pointer arguments.&nbsp;
 It is most useful in mixed memory model applications.
<br><br>The<tt> _wcsdec</tt> function is a wide-character version of<tt> _strdec</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsdec</tt> function is a multibyte character version of<tt> _strdec</tt> that operates with multibyte character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _strdec</tt> function returns a pointer to the previous character (single-byte, wide, or multibyte depending on the
 function used).
</dl>
<dl>
<dt>See Also:
<dd><a href="#_strinc">_strinc</a>, <a href="#_strninc">_strninc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>const unsigned char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned char )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 j, k;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const unsigned char *prev;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; prev = &amp;chars&#91; SIZE - 1 &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; do {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; prev = _mbsdec( chars, prev );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mblen( prev, MB_CUR_MAX );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = *prev;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = *(prev)&lt;&lt;8 | *(prev+1);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Previous character %#6.4x\n&quot;, k );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } while( prev != chars );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Previous character 0xe0a1</tt>
<br><tt>Previous character 0x00df</tt>
<br><tt>Previous character 0x00a6</tt>
<br><tt>Previous character 0x00a1</tt>
<br><tt>Previous character 0x8342</tt>
<br><tt>Previous character 0x82a6</tt>
<br><tt>Previous character 0x8260</tt>
<br><tt>Previous character 0x8140</tt>
<br><tt>Previous character 0x0041</tt>
<br><tt>Previous character 0x0031</tt>
<br><tt>Previous character 0x002e</tt>
<br><tt>Previous character 0x0020</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _strdec - MACRO</tt>
<br><tt>_wcsdec - MACRO</tt>
<br><tt>_mbsdec - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsdec - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strdup"> strdup, _strdup, _fstrdup, _wcsdup, _mbsdup, _fmbsdup </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strdup( const char *src );</tt>
<br><tt>char *_strdup( const char *src );</tt>
<br><tt>char __far *_fstrdup( const char __far *src );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *_wcsdup( const wchar_t *src );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsdup( unsigned char *src );</tt>
<br><tt>unsigned char __far *_fmbsdup( unsigned char __far *src );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strdup</tt> function creates a duplicate copy of the string pointed to by<b> src</b> and returns a pointer to the
 new copy.&nbsp; For<tt> strdup</tt>, the memory for the new string is obtained by using the <tt> malloc</tt> function and
 can be freed using the <tt> free</tt> function.&nbsp; For<tt> _fstrdup</tt>, the memory for the new string is obtained by
 using the <tt> _fmalloc</tt> function and can be freed using the <tt> _ffree</tt> function.
<br>The<tt> _strdup</tt> function is identical to<tt> strdup</tt>.&nbsp; Use<tt> _strdup</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _fstrdup</tt> function is a data model independent form of the<tt> strdup</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> _wcsdup</tt> function is a wide-character version of<tt> strdup</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsdup</tt> function is a multibyte character version of<tt> strdup</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbsdup</tt> function is a data model independent form of the<tt> _mbsdup</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strdup</tt> function returns the pointer to the new copy of the string if successful, otherwise it returns<tt> NULL.</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#free">free</a>, <a href="#malloc">malloc</a>, <a href="#strcpy">strcpy</a>, <a href="#strncpy">strncpy</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *dup;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; dup = strdup( &quot;Make a copy&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, dup );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_strdup conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> strdup - All, Netware</tt>
<br><tt>_strdup - All, Netware</tt>
<br><tt>_fstrdup - All</tt>
<br><tt>_wcsdup - All</tt>
<br><tt>_mbsdup - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsdup - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strerror"> strerror, wcserror </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strerror( int errnum );</tt>
<br><tt>wchar_t *wcserror( int errnum );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#strerror_s">strerror_s</a> function which is a safer alternative to<tt>
 strerror</tt>.&nbsp; This newer<tt> strerror_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 strerror</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strerror</tt> function maps the error number contained in<b> errnum</b> to an error message.
<br>The<tt> wcserror</tt> function is identical to<tt> strerror</tt> except that the message it points to is a wide-character
 string.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strerror</tt> function returns a pointer to the error message.&nbsp; The array containing the error string should
 not be modified by the program.&nbsp; This array may be overwritten by a subsequent call to the<tt> strerror</tt> function.
</dl>
<dl>
<dt>See Also:
<dd><a href="#clearerr">clearerr</a>, <a href="#feof">feof</a>, <a href="#ferror">ferror</a>, <a href="#perror">perror</a>, <a href="#strerror_s">strerror_s</a>,
 <a href="#strerrorlen_s">strerrorlen_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;errno.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file.nam&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file: %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strerror( errno )
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>strerror is ANSI
<br>wcserror is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strerror - All, Netware</tt>
<br><tt>wcserror - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strerror_s"> strerror_s, wcserror_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>errno_t strerror_s( char * s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 rsize_t maxsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 errno_t errnum );</tt>
<br><tt>errno_t wcserror_s( wchar_t * s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 rsize_t maxsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 errno_t errnum );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 strerror_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br><b>s</b> shall not be a null pointer.<b>&nbsp; maxsize</b> shall not be greater than <tt> RSIZE_MAX</tt>.<b>&nbsp; maxsize</b>
 shall not equal zero.
<br><br>If there is a runtime-constraint violation, then the array (if any) pointed to by<b> s</b> is not modified.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strerror_s</tt> function maps the number in<b> errnum</b> to a locale-specific message string.&nbsp; Typically,the
 values for<b> errnum</b> come from errno, but<tt> strerror_s</tt> shall map any value of type int to a message.&nbsp; If
 the length of the desired string is less than<b> maxsize</b>, then the string is copied to the array pointed to by<b> s</b>.
&nbsp; Otherwise, if<b> maxsize</b> is greater than zero, then<b> maxsize-1</b> characters are copied from the string to the
 array pointed to by<b> s</b> and then<b> s&#91;maxsize-1&#93;</b> is set to the null character.&nbsp; Then, if<b> maxsize</b>
 is greater than 3, then<b> s&#91;maxsize-2&#93;, s&#91;maxsize-3&#93;</b>, and<b> s&#91;maxsize-4&#93;</b> are set to the
 character period (.).
<br>The<tt> wcserror_s</tt> function is a wide-character version of<tt> strerror_s</tt> that operates with wide-character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strerror_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#clearerr">clearerr</a>, <a href="#feof">feof</a>, <a href="#ferror">ferror</a>, <a href="#perror">perror</a>, <a href="#strerror">strerror</a>,
 <a href="#strerrorlen_s">strerrorlen_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;errno.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char emsg&#91; 100 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file.nam&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strerror_s( emsg, sizeof( emsg ), errno );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file: %s\n&quot;, emsg );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>strerror_s is TR 24731
<br>wcserror_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> strerror_s - All, Netware</tt>
<br><tt>wcserror_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strerrorlen_s"> strerrorlen_s, wcserrorlen_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>size_t strerrorlen_s( errno_t errnum );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>size_t wcserrorlen_s( errno errnum );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>None.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strerrorlen_s</tt> function calculates the length of the (untruncated) locale-specific message string that the <tt>
 strerror_s</tt> function maps to<b> errnum</b>.
<br>The<tt> wcserrorlen_s</tt> function is a wide-character version of<tt> strerrorlen_s</tt> that operates with wide-character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strerrorlen_s</tt> function returns the number of characters (not including the null character) in the full message
 string.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strerror">strerror</a>, <a href="#strerror_s">strerror_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;errno.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; emsg&#91; 100 &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t&nbsp; emsglen;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file.nam&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( fp == NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; emsglen = strerrorlen_s( errno );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Length of errormessage: %d\n&quot;, emsglen );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strerror_s( emsg, sizeof( emsg ), errno );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to open file: %s\n&quot;, emsg );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>strerrorlen_s is TR 24731
<br>wcserrorlen_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> strerrorlen_s - All, Netware</tt>
<br><tt>wcserrorlen_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strftime"> strftime, wcsftime, _wstrftime_ms </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>size_t strftime( char *s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t maxsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct tm *timeptr
 );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>size_t wcsftime( wchar_t *s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t maxsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct tm *timeptr
 );</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>size_t _wstrftime_ms( wchar_t *s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; size_t maxsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const char *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const struct tm *timeptr );</tt>
<br><br><tt>struct&nbsp; tm {</tt>
<br><tt>&nbsp; int tm_sec;&nbsp;&nbsp; /* seconds after the minute -- &#91;0,61&#93; */</tt>
<br><tt>&nbsp; int tm_min;&nbsp;&nbsp; /* minutes after the hour&nbsp;&nbsp; -- &#91;0,59&#93; */</tt>
<br><tt>&nbsp; int tm_hour;&nbsp; /* hours after midnight&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,23&#93; */</tt>
<br><tt>&nbsp; int tm_mday;&nbsp; /* day of the month&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;1,31&#93; */</tt>
<br><tt>&nbsp; int tm_mon;&nbsp;&nbsp; /* months since January&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,11&#93; */</tt>
<br><tt>&nbsp; int tm_year;&nbsp; /* years since 1900&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; int tm_wday;&nbsp; /* days since Sunday&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,6&#93;&nbsp; */</tt>
<br><tt>&nbsp; int tm_yday;&nbsp; /* days since January 1&nbsp;&nbsp;&nbsp;&nbsp; -- &#91;0,365&#93;*/</tt>
<br><tt>&nbsp; int tm_isdst; /* Daylight Savings Time flag */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strftime</tt> function formats the time in the argument<b> timeptr</b> into the array pointed to by the argument<b>
 s</b> according to the<b> format</b> argument.
<br>The<tt> wcsftime</tt> function is a wide-character version of<tt> strftime</tt> that operates with wide-character strings.
<br><br>The <tt> _wstrftime_ms</tt> function is identical to<tt> wcsftime</tt> except that the<b> format</b> is not a wide-character
 string.
<br><br>The<b> format</b> string consists of zero or more directives and ordinary characters.&nbsp; A directive consists of
 a '%' character followed by a character that determines the substitution that is to take place.&nbsp; All ordinary characters
 are copied unchanged into the array.&nbsp; No more than<b> maxsize</b> characters are placed in the array.&nbsp; The format
 directives %D, %h, %n, %r, %t, and %T are from POSIX.
<dl>
<dt>Directive&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>%a
<dd>locale's abbreviated weekday name
<dt><br>%A
<dd>locale's full weekday name
<dt><br>%b
<dd>locale's abbreviated month name
<dt><br>%B
<dd>locale's full month name
<dt><br>%c
<dd>locale's appropriate date and time representation
<dt><br>%C
<dd>is replaced by the year devided by 100 and truncated to an integer (00-99)
<dt><br>%d
<dd>day of the month as a decimal number (01-31)
<dt><br>%D
<dd>date in the format mm/dd/yy (POSIX)
<dt><br>%e
<dd>day of the month as a decimal number ( 1-31), a single digit is preceded by a blank
<dt><br>%F
<dd>is equivalent to '%Y-%m-%d' (the ISO 8601 date format)
<dt><br>%g
<dd>is replaced by the last 2 digits of the week-based year as a decimal number (00-99)
<dt><br>%G
<dd>is replaced by the week-based year as a decimal number (e.g.&nbsp; 2006)
<dt><br>%h
<dd>locale's abbreviated month name (POSIX)
<dt><br>%H
<dd>hour (24-hour clock) as a decimal number (00-23)
<dt><br>%I
<dd>hour (12-hour clock) as a decimal number (01-12)
<dt><br>%j
<dd>day of the year as a decimal number (001-366)
<dt><br>%m
<dd>month as a decimal number (01-12)
<dt><br>%M
<dd>minute as a decimal number (00-59)
<dt><br>%n
<dd>newline character (POSIX)
<dt><br>%p
<dd>locale's equivalent of either AM or PM
<dt><br>%r
<dd>12-hour clock time (01-12) using the AM/PM notation in the format HH:MM:SS (AM|PM) (POSIX)
<dt><br>%S
<dd>second as a decimal number (00-59)
<dt><br>%t
<dd>tab character (POSIX)
<dt><br>%T
<dd>24-hour clock time in the format HH:MM:SS (POSIX)
<dt><br>%u
<dd>is replaced by the ISO 8601 weekday as a decimal number (1-7), where Monday is 1
<dt><br>%U
<dd>week number of the year as a decimal number (00-52) where Sunday is the first day of the week
<dt><br>%V
<dd>is replaced by the ISO 8601 week number as a decimal number (01-53)
<dt><br>%w
<dd>weekday as a decimal number (0-6) where 0 is Sunday
<dt><br>%W
<dd>week number of the year as a decimal number (00-52) where Monday is the first day of the week
<dt><br>%x
<dd>locale's appropriate date representation
<dt><br>%X
<dd>locale's appropriate time representation
<dt><br>%y
<dd>year without century as a decimal number (00-99)
<dt><br>%Y
<dd>year with century as a decimal number
<dt><br>%z
<dd>offset from UTC in the ISO 8601 format '-0430' (meaning 4 hours 30 minutes behind UTC, west of Greenwich), or by no characters,
 if no timezone is determinable
<dt><br>%Z
<dd>timezone name, or by no characters if no timezone exists
<dt><br>%%
<dd>character %
</dl>
<br>When the<tt> %Z</tt> or<tt> %z</tt> directive is specified, the <tt> tzset</tt> function is called.
<br><br>% g, %G, %V give values according to the ISO 8601 week-based year.&nbsp; In this system, weeks begin on a monday and
 week 1 of the year is the week that includes January 4th, which is also the week that includes the first Thursday of the
 year, and is also the first week that contains at least four days in the year.&nbsp; If the first Monday of January is the
 2nd, 3rd, or 4th, the preceding days are part of the last week of the preceding year; thus, for Saturday 2nd January 1999,
 %G is replaced by 1998 and %V is replaced by 53.&nbsp; If december 29th, 30th, or 31st is a Monday, it and any following
 days are part of week 1 of the following year.&nbsp; Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V
 is replaced by 01.
<br><br>The format modifiers E and O are ignored.&nbsp; (eg.&nbsp; %EY is the same as %Y)
</dl>
<dl>
<dt>Returns:
<dd>If the number of characters to be placed into the array is less than<b> maxsize</b>, the<tt> strftime</tt> function returns
 the number of characters placed into the array pointed to by<b> s</b> not including the terminating null character.&nbsp;
 Otherwise, zero is returned.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error
 that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#setlocale">setlocale</a>, <a href="#asctime">asctime</a> Functions, <a href="#asctime_s">asctime_s</a>, <a href="#clock">clock</a>,
 <a href="#ctime">ctime</a> Functions, <a href="#ctime_s">ctime_s</a>, <a href="#difftime">difftime</a>, <a href="#gmtime">gmtime</a>,
 <a href="#gmtime_s">gmtime_s</a>, <a href="#localtime">localtime</a>, <a href="#localtime_s">localtime_s</a>, <a href="#mktime">mktime</a>,
 <a href="#time">time</a>, <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t time_of_day;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91; 80 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strftime( buffer, 80, &quot;Today is %A %B %d, %Y&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; localtime( &amp;time_of_day )
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>&nbsp; }</tt>
<br>produces the following:
<br><br><tt>Today is Friday December 25, 1987</tt>
</dl>
<dl>
<dt>Classification:
<dd>strftime is ANSI, POSIX
<br>wcsftime is ANSI
<br>_wstrftime_ms is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strftime - All, Netware</tt>
<br><tt>wcsftime - All</tt>
<br><tt>_wstrftime_ms - All</tt>
</dl>
<h2 id="stricmp"> stricmp, _stricmp, _fstricmp, _wcsicmp, _mbsicmp, _fmbsicmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>int stricmp( const char *s1, const char *s2 );</tt>
<br><tt>int _stricmp( const char *s1, const char *s2 );</tt>
<br><tt>int _fstricmp( const char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far *s2 );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int _wcsicmp( const wchar_t *s1, const wchar_t *s2 );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbsicmp( const unsigned char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2 );</tt>
<br><tt>int _fmbsicmp( const unsigned char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s2
 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> stricmp</tt> function compares, with case insensitivity, the string pointed to by<b> s1</b> to the string pointed
 to by<b> s2</b>.&nbsp; All uppercase characters from<b> s1</b> and<b> s2</b> are mapped to lowercase for the purposes of
 doing the comparison.
<br>The<tt> _stricmp</tt> function is identical to<tt> stricmp</tt>.&nbsp; Use<tt> _stricmp</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _fstricmp</tt> function is a data model independent form of the<tt> stricmp</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> _wcsicmp</tt> function is a wide-character version of<tt> stricmp</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsicmp</tt> function is a multibyte character version of<tt> stricmp</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbsicmp</tt> function is a data model independent form of the<tt> _mbsicmp</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> stricmp</tt> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
 to by<b> s1</b> is less than, equal to, or greater than the string pointed to by<b> s2</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcmp">strcmp</a>, <a href="#strcmpi">strcmpi</a>, <a href="#strncmp">strncmp</a>, <a href="#strnicmp">strnicmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, stricmp( &quot;AbCDEF&quot;, &quot;abcdef&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, stricmp( &quot;abcdef&quot;, &quot;ABC&quot;&nbsp;&nbsp;&nbsp; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, stricmp( &quot;abc&quot;,&nbsp;&nbsp;&nbsp; &quot;ABCdef&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, stricmp( &quot;Abcdef&quot;, &quot;mnopqr&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, stricmp( &quot;Mnopqr&quot;, &quot;abcdef&quot; ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0</tt>
<br><tt>100</tt>
<br><tt>-100</tt>
<br><tt>-12</tt>
<br><tt>12</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_stricmp conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> stricmp - All, Netware</tt>
<br><tt>_stricmp - All, Netware</tt>
<br><tt>_fstricmp - All</tt>
<br><tt>_wcsicmp - All</tt>
<br><tt>_mbsicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_stricoll"> _stricoll, _wcsicoll, _mbsicoll </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>int _stricoll( const char *s1, const char *s2 );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int _wcsicoll( const wchar_t *s1, const wchar_t *s2 );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbsicoll( const unsigned char *s1, const unsigned char *s2 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _stricoll</tt> function performs a case insensitive comparison of the string pointed to by<b> s1</b> to the string
 pointed to by<b> s2</b>.&nbsp; The comparison uses the current code page which can be selected by the <tt> _setmbcp</tt>
 function.
<br>The<tt> _wcsicoll</tt> function is a wide-character version of<tt> _stricoll</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsicoll</tt> function is a multibyte character version of<tt> _stricoll</tt> that operates with multibyte
 character strings.
</dl>
<dl>
<dt>Returns:
<dd>These functions return an integer less than, equal to, or greater than zero, indicating that the string pointed to by<b> s1</b>
 is less than, equal to, or greater than the string pointed to by<b> s2</b>, according to the collating sequence selected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setmbcp">_setmbcp</a>, <a href="#strcoll">strcoll</a>, <a href="#stricmp">stricmp</a>, <a href="#strncmp">strncmp</a>,
 <a href="#_strncoll">_strncoll</a>, <a href="#strnicmp">strnicmp</a>, <a href="#_strnicoll">_strnicoll</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char buffer&#91;80&#93; = &quot;world&quot;;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int test;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; test = _stricoll( buffer, &quot;world2&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( test &lt; 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else if( test == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Equal\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Greater than\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _stricoll - All, Netware</tt>
<br><tt>_wcsicoll - All</tt>
<br><tt>_mbsicoll - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_strinc"> _strinc, _wcsinc, _mbsinc, _fmbsinc </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;tchar.h&gt;</tt>
<br><tt>char *_strinc( const char *current );</tt>
<br><tt>wchar_t *_wcsinc( const wchar_t *current );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsinc( const unsigned char *current );</tt>
<br><tt>unsigned char *_fmbsinc(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const unsigned char __far *current );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _strinc</tt> function returns a pointer to the next character (single-byte, wide, or multibyte) in the string pointed
 to by<b> current</b>.&nbsp; You must ensure that<b> current</b> does not point into the middle of a multibyte or wide character.
<br>The function is a data model independent form of the<tt> _strinc</tt> function that accepts far pointer arguments.&nbsp;
 It is most useful in mixed memory model applications.
<br><br>The<tt> _wcsinc</tt> function is a wide-character version of<tt> _strinc</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsinc</tt> function is a multibyte character version of<tt> _strinc</tt> that operates with multibyte character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _strinc</tt> function returns a pointer to the next character (single-byte, wide, or multibyte depending on the function
 used).
</dl>
<dl>
<dt>See Also:
<dd><a href="#_strdec">_strdec</a>, <a href="#_strninc">_strninc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><br><tt>const unsigned char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned char )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 j, k;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const unsigned char *next;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; next = chars;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; do {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next = _mbsinc( next );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mblen( next, MB_CUR_MAX );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = *next;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = *(next)&lt;&lt;8 | *(next+1);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Next character %#6.4x\n&quot;, k );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } while( next != &amp;chars&#91; SIZE - 1 &#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Next character 0x002e</tt>
<br><tt>Next character 0x0031</tt>
<br><tt>Next character 0x0041</tt>
<br><tt>Next character 0x8140</tt>
<br><tt>Next character 0x8260</tt>
<br><tt>Next character 0x82a6</tt>
<br><tt>Next character 0x8342</tt>
<br><tt>Next character 0x00a1</tt>
<br><tt>Next character 0x00a6</tt>
<br><tt>Next character 0x00df</tt>
<br><tt>Next character 0xe0a1</tt>
<br><tt>Next character&nbsp;&nbsp; 0000</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _strinc - MACRO</tt>
<br><tt>_wcsinc - MACRO</tt>
<br><tt>_mbsinc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsinc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strlcat"> strlcat, wcslcat </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>size_t strlcat( char *dst, const char *src, size_t n );</tt>
<br><tt>size_t *wcslcat( wchar_t *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strlcat</tt> function appends characters of the string pointed to by<b> src</b> to the end of the string in a buffer
 pointed to by<b> dst</b> that can hold up to<b> n</b> characters.&nbsp; The first character of<b> src</b> overwrites the
 null character at the end of<b> dst</b>.&nbsp; A terminating null character is always appended to the result, unless<b> n</b>
 characters of<b> dst</b> are scanned and no null character is found.
<br>The<tt> wcslcat</tt> function is a wide-character version of<tt> strlcat</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strlcat</tt> function returns the total length of string it tried to create, that is the number of characters in both<b>
 src</b> and<b> dst</b> strings, not counting the terminating null characters.&nbsp; If<b> n</b> characters of<b> dst</b>
 were scanned without finding a null character,<b> n</b> is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strlcpy">strlcpy</a>, <a href="#strncat">strncat</a>, <a href="#strcat">strcat</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char buffer&#91;80&#93;;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;Hello &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strlcat( buffer, &quot;world&quot;, 12 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strlcat( buffer, &quot;*************&quot;, 16 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Hello world</tt>
<br><tt>Hello world****</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> strlcat - All, Netware</tt>
<br><tt>wcslcat - All</tt>
</dl>
<h2 id="strlcpy"> strlcpy, wcslcpy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>size_t strlcpy( char *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>size_t wcslcpy( wchar_t *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strlcpy</tt> function copies no more than<b> n</b> characters from the string pointed to by<b> src</b> into the array
 pointed to by<b> dst</b>.&nbsp; Copying of overlapping objects is not guaranteed to work properly.&nbsp; See the <tt> memmove</tt>
 function if you wish to copy objects that overlap.
<br>If the string pointed to by<b> src</b> is longer than<b> n</b> characters, then only<b> n</b> - 1 characters will be copied
 and the result will be null terminated.
<br><br>The<tt> wcslcpy</tt> function is a wide-character version of<tt> strlcpy</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strlcpy</tt> function returns the number of characters in the<b> src</b> string, not including the terminating null
 character.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strlcat">strlcat</a>, <a href="#strncpy">strncpy</a>, <a href="#strcpy">strcpy</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; buffer&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d:'%s'\n&quot;, strlcpy( buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;Buffer overflow&quot;, sizeof( buffer ) ), buffer );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>15:'Buffer ov'</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> strlcpy - All, Netware</tt>
<br><tt>wcslcpy - All</tt>
</dl>
<h2 id="strlen"> strlen, _fstrlen, wcslen, _mbslen, _fmbslen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>size_t strlen( const char *s );</tt>
<br><tt>size_t _fstrlen( const char __far *s );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>size_t wcslen( const wchar_t *s );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>size_t _mbslen( const unsigned char *s );</tt>
<br><tt>size_t _fmbslen( const unsigned char __far *s );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the function which is a safer alternative to<tt> strlen</tt>.&nbsp; This newer<tt>
 strlen_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> strlen</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strlen</tt> function computes the length of the string pointed to by<b> s</b>.
<br>The<tt> _fstrlen</tt> function is a data model independent form of the<tt> strlen</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcslen</tt> function is a wide-character version of<tt> strlen</tt> that operates with wide-character strings.
<br><br>The<tt> _mbslen</tt> function is a multibyte character version of<tt> strlen</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbslen</tt> function is a data model independent form of the<tt> _mbslen</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strlen</tt> function returns the number of characters that precede the terminating null character.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strnlen_s">strnlen_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strlen( &quot;Howdy&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strlen( &quot;Hello world\n&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strlen( &quot;&quot; ) );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>5</tt>
<br><tt>12</tt>
<br><tt>0</tt>
</dl>
<dl>
<dt>Classification:
<dd>strlen is ANSI
<br>_fstrlen is not ANSI
<br>wcslen is ANSI
<br>_mbslen is not ANSI
<br>_fmbslen is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strlen - All, Netware</tt>
<br><tt>_fstrlen - All</tt>
<br><tt>wcslen - All</tt>
<br><tt>_mbslen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbslen - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strnlen_s"> strnlen_s, wcsnlen_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>size_t strnlen_s( const char * s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t maxsize
 );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>size_t wcsnlen_s( const wchar_t * s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t maxsize
 );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>None.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strnlen_s</tt> function calculates the length of the string pointed to by<b> s</b>.
<br>The<tt> wcsnlen_s</tt> function is a wide-character version of<tt> strnlen_s</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>If<b> s</b> is a null pointer, then the<tt> strnlen_s</tt> function returns zero.&nbsp; Otherwise, the<tt> strnlen_s</tt>
 function returns the number of characters that precede the terminating null character.&nbsp; If there is no null character
 in the first<b> maxsize</b> characters of<b> s</b> then<tt> strnlen_s</tt> returns<b> maxsize</b>.&nbsp; At most the first<b>
 maxsize</b> characters of<b> s</b> shall be accessed by<tt> strnlen_s</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#strlen">strlen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; buffer&#91; 30 &#93; = &quot;Hello world.&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t&nbsp; len;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; len = strnlen_s( buffer, sizeof( buffer ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Length of text: %d\n&quot;, emsglen );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Text: %s\n&quot;, buffer );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>strnlen_s is TR 24731
<br>wcsnlen_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> strnlen_s - All, Netware</tt>
<br><tt>wcsnlen_s - All</tt>
</dl>
<h2 id="strlwr"> strlwr, _strlwr, _fstrlwr, _wcslwr, _mbslwr, _fmbslwr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strlwr( char *s1 );</tt>
<br><tt>char *_strlwr( char *s1 );</tt>
<br><tt>char __far *_fstrlwr( char __far *s1 );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *_wcslwr( wchar_t *s1 );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbslwr( unsigned char *s1 );</tt>
<br><tt>unsigned char __far *_fmbslwr( unsigned char __far *s1 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strlwr</tt> function replaces the string<b> s1</b> with lowercase characters by invoking the <tt> tolower</tt> function
 for each character in the string.
<br>The<tt> _strlwr</tt> function is identical to<tt> strlwr</tt>.&nbsp; Use<tt> _strlwr</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _fstrlwr</tt> function is a data model independent form of the<tt> strlwr</tt> function.&nbsp; It accepts
 far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> _wcslwr</tt> function is a wide-character version of<tt> strlwr</tt> that operates with wide-character strings.
<br><br>The<tt> _mbslwr</tt> function is a multibyte character version of<tt> strlwr</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbslwr</tt> function is a data model independent form of the<tt> _mbslwr</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The address of the original string<b> s1</b> is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strupr">strupr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char source&#91;&#93; = { &quot;A mixed-case STRING&quot; };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strlwr( source ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>A mixed-case STRING</tt>
<br><tt>a mixed-case string</tt>
<br><tt>a mixed-case string</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_strlwr conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> strlwr - All, Netware</tt>
<br><tt>_strlwr - All, Netware</tt>
<br><tt>_fstrlwr - All</tt>
<br><tt>_wcslwr - All</tt>
<br><tt>_mbslwr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbslwr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strncasecmp"> strncasecmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strings.h&gt;</tt>
<br><tt>int strncasecmp( const char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strncasecmp</tt> function compares, without case sensitivity, the string pointed to by<b> s1</b> to the string pointed
 to by<b> s2</b>, for at most<b> len</b> characters.
<br>The<tt> strncasecmp</tt> function is identical to the <tt> strnicmp</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strncasecmp</tt> function returns an integer less than, equal to, or greater than zero, indicating that the string
 pointed to by<b> s1</b> is, ignoring case, less than, equal to, or greater than the string pointed to by<b> s2</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcmp">strcmp</a>, <a href="#stricmp">stricmp</a>, <a href="#strncmp">strncmp</a>, <a href="#strcasecmp">strcasecmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;strings.h&gt;</tt>
<br><br><tt>int main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncasecmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;, 10 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncasecmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;,&nbsp; 6 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncasecmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;,&nbsp; 3 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncasecmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;,&nbsp; 0 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>-20</tt>
<br><tt>-20</tt>
<br><tt>0</tt>
<br><tt>0</tt>
</dl>
<dl>
<dt>Classification:
<dd>POSIX
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="strncat"> strncat, _fstrncat, wcsncat, _mbsncat, _fmbsncat </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strncat( char *dst, const char *src, size_t n );</tt>
<br><tt>char __far *_fstrncat( char __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far
 *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *wcsncat( wchar_t *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsncat( unsigned char *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 unsigned char *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>unsigned char __far *_fmbsncat( unsigned char __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#strncat_s">strncat_s</a> function which is a safer alternative to<tt>
 strncat</tt>.&nbsp; This newer<tt> strncat_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 strncat</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strncat</tt> function appends not more than<b> n</b> characters of the string pointed to by<b> src</b> to the end
 of the string pointed to by<b> dst</b>.&nbsp; The first character of<b> src</b> overwrites the null character at the end
 of<b> dst</b>.&nbsp; A terminating null character is always appended to the result.
<br>The<tt> _fstrncat</tt> function is a data model independent form of the<tt> strncat</tt> function.&nbsp; It accepts far
 pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcsncat</tt> function is a wide-character version of<tt> strncat</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsncat</tt> function is a multibyte character version of<tt> strncat</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbsncat</tt> function is a data model independent form of the<tt> _mbsncat</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strncat</tt> function returns the value of<b> dst</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcat">strcat</a>, <a href="#strlcat">strlcat</a>, <a href="#strncat_s">strncat_s</a>, <a href="#strcat_s">strcat_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char buffer&#91;80&#93;;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;Hello &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strncat( buffer, &quot;world&quot;, 8 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strncat( buffer, &quot;*************&quot;, 4 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Hello world</tt>
<br><tt>Hello world****</tt>
</dl>
<dl>
<dt>Classification:
<dd>strncat is ANSI
<br>_fstrncat is not ANSI
<br>wcsncat is ANSI
<br>_mbsncat is not ANSI
<br>_fmbsncat is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strncat - All, Netware</tt>
<br><tt>_fstrncat - All</tt>
<br><tt>wcsncat - All</tt>
<br><tt>_mbsncat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsncat - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strncat_s"> strncat_s, wcsncat_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>errno_t strncat_s( char * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 char * restrict s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 n )</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>errno_t wcsncat_s( wchar_t * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 wchar_t * restrict s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 n )</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 strncat_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Let<b> m</b> denote the value<b> s1max - strnlen_s(s1, s1max)</b> upon entry to<tt> strncat_s</tt>
<br><br>Neither<b> s1</b> nor<b> s2</b> shall be a null pointer.&nbsp; Neither<b> s1max</b> nor<b> n</b> shall be greater
 than <tt> RSIZE_MAX</tt>.<b>&nbsp; s1max</b> shall not equal zero.<b>&nbsp; m</b> shall not equal zero.&nbsp; If<b> n</b>
 is not less than<b> m, then m</b> shall be greater than<b> strnlen_s(s2, m)</b>.&nbsp; Copying shall not take place between
 objects that overlap.
<br><br>If there is a runtime-constraint violation, then if<b> s1</b> is not a null pointer and<b> s1max</b> is greater than
 zero and not greater than <tt> RSIZE_MAX</tt>, then<tt> strncat_s</tt> sets<b> s1&#91;0&#93;</b> to the null character.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strncat_s</tt> function appends not more than<b> n</b> successive characters (characters that follow a null character
 are not copied) from the array pointed to by<b> s2</b> to the end of the string pointed to by<b> s1</b>.&nbsp; The initial
 character from<b> s2</b> overwrites the null character at the end of<b> s1</b>.&nbsp; If no null character was copied from<b>
 s2,then s1&#91;s1max-m+n&#93;</b> is set to a null character.&nbsp; All elements following the terminating null character
 (if any) written by<tt> strncat_s</tt> in the array of<b> s1max</b> characters pointed to by<b> s1</b> take unspecified values
 when<tt> strncat_s</tt> returns.
<br>The<tt> wcsncat_s</tt> function is a wide-character version of<tt> strncat_s</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strncat_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcat">strcat</a>, <a href="#strlcat">strlcat</a>, <a href="#strcat_s">strcat_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char buffer&#91;80&#93;;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( buffer, &quot;Hello &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strncat_s( buffer, sizeof( buffer ), &quot;world&quot;, 8 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strncat( buffer, &quot;*************&quot;, 4 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Hello world</tt>
<br><tt>Hello world****</tt>
</dl>
<dl>
<dt>Classification:
<dd>strncat_s is TR 24731
<br>wcsncat_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> strncat_s - All, Netware</tt>
<br><tt>wcsncat_s - All</tt>
</dl>
<h2 id="strncmp"> strncmp, _fstrncmp, wcsncmp, _mbsncmp, _fmbsncmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>int strncmp( const char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>int _fstrncmp( const char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int wcsncmp( const wchar_t *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbsncmp( const unsigned char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>int _fmbsncmp( const unsigned char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strncmp</tt> compares not more than<b> n</b> characters from the string pointed to by<b> s1</b> to the string pointed
 to by<b> s2</b>.
<br>The<tt> _fstrncmp</tt> function is a data model independent form of the<tt> strncmp</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcsncmp</tt> function is a wide-character version of<tt> strncmp</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsncmp</tt> function is a multibyte character version of<tt> strncmp</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbsncmp</tt> function is a data model independent form of the<tt> _mbsncmp</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strncmp</tt> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
 to by<b> s1</b> is less than, equal to, or greater than the string pointed to by<b> s2</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcmp">strcmp</a>, <a href="#stricmp">stricmp</a>, <a href="#strnicmp">strnicmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncmp( &quot;abcdef&quot;, &quot;abcDEF&quot;, 10 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncmp( &quot;abcdef&quot;, &quot;abcDEF&quot;,&nbsp; 6 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncmp( &quot;abcdef&quot;, &quot;abcDEF&quot;,&nbsp; 3 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strncmp( &quot;abcdef&quot;, &quot;abcDEF&quot;,&nbsp; 0 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>1</tt>
<br><tt>1</tt>
<br><tt>0</tt>
<br><tt>0</tt>
</dl>
<dl>
<dt>Classification:
<dd>strncmp is ANSI
<br>_fstrncmp is not ANSI
<br>wcsncmp is ANSI
<br>_mbsncmp is not ANSI
<br>_fmbsncmp is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strncmp - All, Netware</tt>
<br><tt>_fstrncmp - All</tt>
<br><tt>wcsncmp - All</tt>
<br><tt>_mbsncmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsncmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_strncoll"> _strncoll, _wcsncoll, _mbsncoll </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>int _strncoll( const char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int _wcsncoll( const wchar_t *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbsncoll( const unsigned char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</tt>
</dl>
<dl>
<dt>Description:
<dd>These functions compare the first<b> count</b> characters of the string pointed to by<b> s1</b> to the string pointed to by<b>
 s2</b>.&nbsp; The comparison uses the current code page which can be selected by the <tt> _setmbcp</tt> function.
<br>The<tt> _wcsncoll</tt> function is a wide-character version of<tt> _strncoll</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsncoll</tt> function is a multibyte character version of<tt> _strncoll</tt> that operates with multibyte
 character strings.
</dl>
<dl>
<dt>Returns:
<dd>These functions return an integer less than, equal to, or greater than zero, indicating that the string pointed to by<b> s1</b>
 is less than, equal to, or greater than the string pointed to by<b> s2</b>, according to the collating sequence selected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setmbcp">_setmbcp</a>, <a href="#strcoll">strcoll</a>, <a href="#stricmp">stricmp</a>, <a href="#_stricoll">_stricoll</a>,
 <a href="#strncmp">strncmp</a>, <a href="#strnicmp">strnicmp</a>, <a href="#_strnicoll">_strnicoll</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char buffer&#91;80&#93; = &quot;world&quot;;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int test;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; test = _strncoll( buffer, &quot;world2&quot;, 5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( test &lt; 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else if( test == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Equal\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Greater than\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _strncoll - All, Netware</tt>
<br><tt>_wcsncoll - All</tt>
<br><tt>_mbsncoll - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strncpy"> strncpy, _fstrncpy, wcsncpy, _mbsncpy, _fmbsncpy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strncpy( char *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>char __far *_fstrncpy( char __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const char __far *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *wcsncpy( wchar_t *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
 *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsncpy( unsigned char *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 unsigned char *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>unsigned char __far *_fmbsncpy( unsigned char __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#strncpy_s">strncpy_s</a> function which is a safer alternative to<tt>
 strncpy</tt>.&nbsp; This newer<tt> strncpy_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 strncpy</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strncpy</tt> function copies no more than<b> n</b> characters from the string pointed to by<b> src</b> into the array
 pointed to by<b> dst</b>.&nbsp; Copying of overlapping objects is not guaranteed to work properly.&nbsp; See the <tt> memmove</tt>
 function if you wish to copy objects that overlap.
<br>If the string pointed to by<b> src</b> is shorter than<b> n</b> characters, null characters are appended to the copy in
 the array pointed to by<b> dst</b>, until<b> n</b> characters in all have been written.&nbsp; If the string pointed to by<b>
 src</b> is longer than<b> n</b> characters, then the result will not be terminated by a null character.
<br><br>The<tt> _fstrncpy</tt> function is a data model independent form of the<tt> strncpy</tt> function.&nbsp; It accepts
 far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcsncpy</tt> function is a wide-character version of<tt> strncpy</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsncpy</tt> function is a multibyte character version of<tt> strncpy</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbsncpy</tt> function is a data model independent form of the<tt> _mbsncpy</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strncpy</tt> function returns the value of<b> dst</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strlcpy">strlcpy</a>, <a href="#strcpy">strcpy</a>, <a href="#strdup">strdup</a>, <a href="#strncpy_s">strncpy_s</a>,
 <a href="#strcpy_s">strcpy_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;15&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strncpy( buffer, &quot;abcdefg&quot;, 10 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strncpy( buffer, &quot;1234567&quot;,&nbsp; 6 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strncpy( buffer, &quot;abcdefg&quot;,&nbsp; 3 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strncpy( buffer, &quot;*******&quot;,&nbsp; 0 ) );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>abcdefg</tt>
<br><tt>123456g</tt>
<br><tt>abc456g</tt>
<br><tt>abc456g</tt>
</dl>
<dl>
<dt>Classification:
<dd>strncpy is ANSI
<br>_fstrncpy is not ANSI
<br>wcsncpy is ANSI
<br>_mbsncpy is not ANSI
<br>_fmbsncpy is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strncpy - All, Netware</tt>
<br><tt>_fstrncpy - All</tt>
<br><tt>wcsncpy - All</tt>
<br><tt>_mbsncpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsncpy - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strncpy_s"> strncpy_s, wcsncpy_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>errno_t strncpy_s( char * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 char * restrict s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 n );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>errno_t wcsncpy_s( wchar_t * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 wchar_t * restrict s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 n );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 strncpy_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> s1</b> nor<b> s2</b> shall be a null pointer.&nbsp; Neither<b> s1max</b> nor<b> n</b> shall be greater than
 <tt> RSIZE_MAX</tt>.<b>&nbsp; s1max</b> shall not equal zero.&nbsp; If<b> n</b> is not less than<b> s1max</b>, then<b> s1max</b>
 shall be greater than<b> strnlen_s(s2, s1max)</b>.
<br><br>Copying shall not take place between objects that overlap.
<br><br>If there is a runtime-constraint violation, then if<b> s1</b> is not a null pointer and<b> s1max</b> is greater than
 zero and not greater than <tt> RSIZE_MAX</tt>, then <tt> strncpy_s</tt> sets<b> s1&#91;0&#93;</b> to the null character.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strncpy_s</tt> function copies not more than<b> n</b> successive characters (characters that follow a null character
 are not copied) from the array pointed to by<b> s2</b> to the array pointed to by<b> s1</b>.&nbsp; If no null character was
 copied from<b> s2</b>, then<b> s1&#91;n&#93;</b> is set to a null character.
<br>All elements following the terminating null character (if any) written by <tt> strncpy_s</tt> in the array of<b> s1max</b>
 characters pointed to by<b> s1</b> take unspecified values when <tt> strncpy_s</tt> returns.
<br><br>The<tt> wcsncpy_s</tt> function is a wide-character version of<tt> strncpy_s</tt> that operates with wide-character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strncpy_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strncpy">strncpy</a>, <a href="#strlcpy">strlcpy</a>, <a href="#strcpy">strcpy</a>, <a href="#strdup">strdup</a>,
 <a href="#strcpy_s">strcpy_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;15&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; strncpy_s( buffer, sizeof( buffer ), &quot;abcdefg&quot;, 10 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; strncpy_s( buffer, sizeof( buffer ), &quot;1234567&quot;,&nbsp; 6 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; strncpy_s( buffer, sizeof( buffer ), &quot;abcdefg&quot;,&nbsp; 3 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; strncpy_s( buffer, sizeof( buffer ), &quot;*******&quot;,&nbsp; 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>abcdefg</tt>
<br><tt>123456</tt>
<br><tt>abc</tt>
<br><tt>(nothing)</tt>
</dl>
<dl>
<dt>Classification:
<dd>strncpy_s is TR 24731
<br>wcsncpy_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> strncpy_s - All, Netware</tt>
<br><tt>wcsncpy_s - All</tt>
</dl>
<h2 id="strnicmp"> strnicmp, _strnicmp, _fstrnicmp, _wcsnicmp, _mbsnicmp, _fmbsnicmp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>int strnicmp( const char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len );</tt>
<br><tt>int _strnicmp( const char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len );</tt>
<br><tt>int _fstrnicmp( const char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int _wcsnicmp( const wchar_t *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t len );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbsnicmp( const unsigned char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>int _fmbsnicmp( const unsigned char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far
 *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strnicmp</tt> function compares, without case sensitivity, the string pointed to by<b> s1</b> to the string pointed
 to by<b> s2</b>, for at most<b> len</b> characters.
<br>The<tt> _strnicmp</tt> function is identical to<tt> strnicmp</tt>.&nbsp; Use<tt> _strnicmp</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _fstrnicmp</tt> function is a data model independent form of the<tt> strnicmp</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> _wcsnicmp</tt> function is a wide-character version of<tt> strnicmp</tt> that operates with wide-character
 strings.
<br><br>The<tt> _mbsnicmp</tt> function is a multibyte character version of<tt> strnicmp</tt> that operates with multibyte
 character strings.
<br><br>The<tt> _fmbsnicmp</tt> function is a data model independent form of the<tt> _mbsnicmp</tt> function that accepts
 far pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strnicmp</tt> function returns an integer less than, equal to, or greater than zero, indicating that the string pointed
 to by<b> s1</b> is less than, equal to, or greater than the string pointed to by<b> s2</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcmp">strcmp</a>, <a href="#stricmp">stricmp</a>, <a href="#strncmp">strncmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strnicmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;, 10 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strnicmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;,&nbsp; 6 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strnicmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;,&nbsp; 3 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strnicmp( &quot;abcdef&quot;, &quot;ABCXXX&quot;,&nbsp; 0 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>-20</tt>
<br><tt>-20</tt>
<br><tt>0</tt>
<br><tt>0</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_strnicmp conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> strnicmp - All, Netware</tt>
<br><tt>_strnicmp - All, Netware</tt>
<br><tt>_fstrnicmp - All</tt>
<br><tt>_wcsnicmp - All</tt>
<br><tt>_mbsnicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsnicmp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_strnicoll"> _strnicoll, _wcsnicoll, _mbsnicoll </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>int _strnicoll( const char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int _wcsnicoll( const wchar_t *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _mbsnicoll( const unsigned char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</tt>
</dl>
<dl>
<dt>Description:
<dd>These functions perform a case insensitive comparison of the first<b> count</b> characters of the string pointed to by<b>
 s1</b> to the string pointed to by<b> s2</b>.&nbsp; The comparison uses the current code page which can be selected by the
 <tt> _setmbcp</tt> function.
<br>The<tt> _wcsnicoll</tt> function is a wide-character version of<tt> _strnicoll</tt> that operates with wide-character
 strings.
<br><br>The<tt> _mbsnicoll</tt> function is a multibyte character version of<tt> _strnicoll</tt> that operates with multibyte
 character strings.
</dl>
<dl>
<dt>Returns:
<dd>These functions return an integer less than, equal to, or greater than zero, indicating that the string pointed to by<b> s1</b>
 is less than, equal to, or greater than the string pointed to by<b> s2</b>, according to the collating sequence selected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setmbcp">_setmbcp</a>, <a href="#strcoll">strcoll</a>, <a href="#stricmp">stricmp</a>, <a href="#_stricoll">_stricoll</a>,
 <a href="#strncmp">strncmp</a>, <a href="#_strncoll">_strncoll</a>, <a href="#strnicmp">strnicmp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char buffer&#91;80&#93; = &quot;world&quot;;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int test;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; test = _strnicoll( buffer, &quot;World2&quot;, 5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( test &lt; 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Less than\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else if( test == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Equal\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Greater than\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _strnicoll - All, Netware</tt>
<br><tt>_wcsnicoll - All</tt>
<br><tt>_mbsnicoll - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_strninc"> _strninc, _wcsninc, _mbsninc, _fmbsninc </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#ninclude &lt;tchar.h&gt;</tt>
<br><tt>char *_strninc( const char *str, size_t count );</tt>
<br><tt>wchar_t *_wcsninc( const wchar_t *str, size_t count );</tt>
<br><tt>#ninclude &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsninc( const unsigned char *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</tt>
<br><tt>unsigned char __far *_fmbsninc(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _mbsninc</tt> function increments<b> str</b> by<b> count</b> multibyte characters.<tt>&nbsp; _mbsninc</tt> recognizes
 multibyte-character sequences according to the multibyte code page currently in use.&nbsp; The header file<tt> &lt;tchar.h&gt;</tt>
 defines the generic-text routine <tt> _tcsninc</tt>.&nbsp; This macro maps to<tt> _mbsninc</tt> if <tt> _MBCS</tt> has been
 defined, or to<tt> _wcsninc</tt> if <tt> _UNICODE</tt> has been defined.&nbsp; Otherwise <tt> _tcsninc</tt> maps to<tt> _strninc</tt>.<tt>
&nbsp; _strninc</tt> and<tt> _wcsninc</tt> are single-byte-character string and wide-character string versions of<tt> _mbsninc</tt>.<tt>
&nbsp; _wcsninc</tt> and<tt> _strninc</tt> are provided only for this mapping and should not be used otherwise.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _strninc</tt> function returns a pointer to<b> str</b> after it has been incremented by<b> count</b> characters or
 <tt> NULL</tt> if<b> str</b> was <tt> NULL</tt>.&nbsp; If<b> count</b> exceeds the number of characters remaining in the
 string, the result is undefined.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_strdec">_strdec</a>, <a href="#_strinc">_strinc</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#ninclude &lt;stdio.h&gt;</tt>
<br><tt>#ninclude &lt;mbctype.h&gt;</tt>
<br><tt>#ninclude &lt;mbstring.h&gt;</tt>
<br><br><tt>const unsigned char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ' ',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '.',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '1',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x81,0x40, /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0x60, /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x82,0xA6, /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x83,0x42, /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xA6,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xDF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xE0,0xA1, /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x00</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( unsigned char )</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 j, k;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const unsigned char *next;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; next = chars;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; do {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next = _mbsninc( next, 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = mblen( next, MB_CUR_MAX );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = *next;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = *(next)&lt;&lt;8 | *(next+1);</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Next character %#6.4x\n&quot;, k );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } while( next != &amp;chars&#91; SIZE - 1 &#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Next character 0x002e</tt>
<br><tt>Next character 0x0031</tt>
<br><tt>Next character 0x0041</tt>
<br><tt>Next character 0x8140</tt>
<br><tt>Next character 0x8260</tt>
<br><tt>Next character 0x82a6</tt>
<br><tt>Next character 0x8342</tt>
<br><tt>Next character 0x00a1</tt>
<br><tt>Next character 0x00a6</tt>
<br><tt>Next character 0x00df</tt>
<br><tt>Next character 0xe0a1</tt>
<br><tt>Next character&nbsp;&nbsp; 0000</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _strninc - MACRO</tt>
<br><tt>_wcsninc - MACRO</tt>
<br><tt>_mbsninc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsninc - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strnset"> strnset, _strnset, _fstrnset, _wcsnset, _mbsnset, _fmbsnset </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strnset( char *str, int fill, size_t count );</tt>
<br><tt>char *_strnset( char *str, int fill, size_t count );</tt>
<br><tt>char __far *_fstrnset( char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; int fill,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; size_t count );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *_wcsnset( wchar_t *str, int fill, size_t count );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsnset( unsigned char *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int fill,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count );</tt>
<br><tt>unsigned char __far *_fmbsnset( unsigned char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int fill,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t __n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strnset</tt> function fills the string<b> str</b> with the value of the argument<b> fill</b>, converted to be a character
 value.&nbsp; When the value of<b> count</b> is greater than the length of the string, the entire string is filled.&nbsp;
 Otherwise, that number of characters at the start of the string are set to the fill character.
<br>The<tt> _strnset</tt> function is identical to<tt> strnset</tt>.&nbsp; Use<tt> _strnset</tt> for ANSI naming conventions.
<br><br>The<tt> _fstrnset</tt> function is a data model independent form of the<tt> strnset</tt> function.&nbsp; It accepts
 far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> _wcsnset</tt> function is a wide-character version of<tt> strnset</tt> that operates with wide-character strings.
&nbsp; For<tt> _wcsnset</tt>, the value of<b> count</b> is the number of wide characters to fill.&nbsp; This is half the number
 of bytes.
<br><br>The<tt> _mbsnset</tt> function is a multibyte character version of<tt> strnset</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbsnset</tt> function is a data model independent form of the<tt> _mbsnset</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>For<tt> _mbsnset</tt>, the value of<b> count</b> is the number of multibyte characters to fill.&nbsp; If the number
 of bytes to be filled is odd and<b> fill</b> is a double-byte character, the partial byte at the end is filled with an ASCII
 space character.
</dl>
<dl>
<dt>Returns:
<dd>The address of the original string<b> str</b> is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strset">strset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char source&#91;&#93; = { &quot;A sample STRING&quot; };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strnset( source, '=', 100 ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strnset( source, '*', 7 ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>A sample STRING</tt>
<br><tt>===============</tt>
<br><tt>*******========</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> strnset - All, Netware</tt>
<br><tt>_strnset - All, Netware</tt>
<br><tt>_fstrnset - All</tt>
<br><tt>_wcsnset - All</tt>
<br><tt>_mbsnset - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsnset - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strpbrk"> strpbrk, _fstrpbrk, wcspbrk, _mbspbrk, _fmbspbrk </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strpbrk( const char *str, const char *charset );</tt>
<br><tt>char __far *_fstrpbrk( const char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const char __far *charset );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *wcspbrk( const wchar_t *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t
 *charset );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbspbrk( const unsigned char *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *charset );</tt>
<br><tt>unsigned char __far *_fmbspbrk(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const unsigned char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const unsigned char __far *charset );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strpbrk</tt> function locates the first occurrence in the string pointed to by<b> str</b> of any character from the
 string pointed to by<b> charset</b>.
<br>The<tt> _fstrpbrk</tt> function is a data model independent form of the<tt> strpbrk</tt> function.&nbsp; It accepts far
 pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcspbrk</tt> function is a wide-character version of<tt> strpbrk</tt> that operates with wide-character strings.
<br><br>The<tt> _mbspbrk</tt> function is a multibyte character version of<tt> strpbrk</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbspbrk</tt> function is a data model independent form of the<tt> _mbspbrk</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strpbrk</tt> function returns a pointer to the located character, or<tt> NULL</tt> if no character from<b> charset</b>
 occurs in<b> str</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strchr">strchr</a>, <a href="#strrchr">strrchr</a>, <a href="#strtok">strtok</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *p = &quot;Find all vowels&quot;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; while( p != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = strpbrk( p+1, &quot;aeiouAEIOU&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Find all vowels</tt>
<br><tt>ind all vowels</tt>
<br><tt>all vowels</tt>
<br><tt>owels</tt>
<br><tt>els</tt>
</dl>
<dl>
<dt>Classification:
<dd>strpbrk is ANSI
<br>_fstrpbrk is not ANSI
<br>wcspbrk is ANSI
<br>_mbspbrk is not ANSI
<br>_fmbspbrk is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strpbrk - All, Netware</tt>
<br><tt>_fstrpbrk - All</tt>
<br><tt>wcspbrk - All</tt>
<br><tt>_mbspbrk - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbspbrk - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strrchr"> strrchr, _fstrrchr, wcsrchr, _mbsrchr, _fmbsrchr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strrchr( const char *s, int c );</tt>
<br><tt>char __far *_fstrrchr( const char __far *s, int c );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *wcsrchr( const wchar_t *s, wint_t c );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsrchr( const unsigned char *s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int c );</tt>
<br><tt>unsigned char __far *_fmbsrchr(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned int c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strrchr</tt> function locates the last occurrence of<b> c</b> (converted to a char) in the string pointed to by<b>
 s</b>.&nbsp; The terminating null character is considered to be part of the string.
<br>The<tt> _fstrrchr</tt> function is a data model independent form of the<tt> strrchr</tt> function.&nbsp; It accepts far
 pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcsrchr</tt> function is a wide-character version of<tt> strrchr</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsrchr</tt> function is a multibyte character version of<tt> strrchr</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbsrchr</tt> function is a data model independent form of the<tt> _mbsrchr</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strrchr</tt> function returns a pointer to the located character, or a NULL pointer if the character does not occur
 in the string.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strchr">strchr</a>, <a href="#strpbrk">strpbrk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strrchr( &quot;abcdeaaklmn&quot;, 'a' ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( strrchr( &quot;abcdeaaklmn&quot;, 'x' ) == NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;NULL\n&quot; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>aklmn</tt>
<br><tt>NULL</tt>
</dl>
<dl>
<dt>Classification:
<dd>strrchr is ANSI
<br>_fstrrchr is not ANSI
<br>wcsrchr is ANSI
<br>_mbsrchr is not ANSI
<br>_fmbsrchr is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strrchr - All, Netware</tt>
<br><tt>_fstrrchr - All</tt>
<br><tt>wcsrchr - All</tt>
<br><tt>_mbsrchr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsrchr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strrev"> strrev, _strrev, _fstrrev, _wcsrev, _mbsrev, _fmbsrev </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strrev( char *s1 );</tt>
<br><tt>char *_strrev( char *s1 );</tt>
<br><tt>char __far *_fstrrev( char __far *s1 );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *_wcsrev( wchar_t *s1 );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsrev( unsigned char *s1 );</tt>
<br><tt>unsigned char __far *_fmbsrev( unsigned char __far *s1 );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strrev</tt> function replaces the string<b> s1</b> with a string whose characters are in the reverse order.
<br>The<tt> _strrev</tt> function is identical to<tt> strrev</tt>.&nbsp; Use<tt> _strrev</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _fstrrev</tt> function is a data model independent form of the<tt> strrev</tt> function.&nbsp; It accepts
 far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> _wcsrev</tt> function is a wide-character version of<tt> strrev</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsrev</tt> function is a multibyte character version of<tt> strrev</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbsrev</tt> function is a data model independent form of the<tt> _mbsrev</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The address of the original string<b> s1</b> is returned.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char source&#91;&#93; = { &quot;A sample STRING&quot; };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strrev( source ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strrev( source ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>A sample STRING</tt>
<br><tt>GNIRTS elpmas A</tt>
<br><tt>A sample STRING</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_strrev conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> strrev - All, Netware</tt>
<br><tt>_strrev - All, Netware</tt>
<br><tt>_fstrrev - All</tt>
<br><tt>_wcsrev - All</tt>
<br><tt>_mbsrev - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsrev - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strset"> strset, _strset, _fstrset, _wcsset, _mbsset, _fmbsset </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strset( char *s1, int fill );</tt>
<br><tt>char *_strset( char *s1, int fill );</tt>
<br><tt>char __far *_fstrset( char __far *s1, int fill );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *_wcsset( wchar_t *s1, int fill );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsset( unsigned char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; unsigned int fill );</tt>
<br><tt>unsigned char __far *_fmbsset( unsigned char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned int fill );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strset</tt> function fills the string pointed to by<b> s1</b> with the character<b> fill</b>.&nbsp; The terminating
 null character in the original string remains unchanged.
<br>The<tt> _strset</tt> function is identical to<tt> strset</tt>.&nbsp; Use<tt> _strset</tt> for ANSI naming conventions.
<br><br>The<tt> _fstrset</tt> function is a data model independent form of the<tt> strset</tt> function.&nbsp; It accepts
 far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> _wcsset</tt> function is a wide-character version of<tt> strset</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsset</tt> function is a multibyte character version of<tt> strset</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbsset</tt> function is a data model independent form of the<tt> _mbsset</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The address of the original string<b> s1</b> is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strnset">strnset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char source&#91;&#93; = { &quot;A sample STRING&quot; };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strset( source, '=' ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strset( source, '*' ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>A sample STRING</tt>
<br><tt>===============</tt>
<br><tt>***************</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> strset - All, Netware</tt>
<br><tt>_strset - All, Netware</tt>
<br><tt>_fstrset - All</tt>
<br><tt>_wcsset - All</tt>
<br><tt>_mbsset - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsset - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strspn"> strspn, _fstrspn, wcsspn, _mbsspn, _fmbsspn </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>size_t strspn( const char *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *charset );</tt>
<br><tt>size_t _fstrspn( const char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char __far
 *charset );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>size_t wcsspn( const wchar_t *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *charset );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>size_t _mbsspn( const unsigned char *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *charset
 );</tt>
<br><tt>size_t _fmbsspn( const unsigned char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char
 __far *charset );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strspn</tt> function computes the length, in bytes, of the initial segment of the string pointed to by<b> str</b>
 which consists of characters from the string pointed to by<b> charset</b>.&nbsp; The terminating null character is not considered
 to be part of<b> charset</b>.
<br>The<tt> _fstrspn</tt> function is a data model independent form of the<tt> strspn</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcsspn</tt> function is a wide-character version of<tt> strspn</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsspn</tt> function is a multibyte character version of<tt> strspn</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbsspn</tt> function is a data model independent form of the<tt> _mbsspn</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The length, in bytes, of the initial segment is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcspn">strcspn</a>, <a href="#strspnp">strspnp</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strspn( &quot;out to lunch&quot;, &quot;aeiou&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%d\n&quot;, strspn( &quot;out to lunch&quot;, &quot;xyz&quot; ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>2</tt>
<br><tt>0</tt>
</dl>
<dl>
<dt>Classification:
<dd>strspn is ANSI
<br>_fstrspn is not ANSI
<br>wcsspn is ANSI
<br>_mbsspn is not ANSI
<br>_fmbsspn is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strspn - All, Netware</tt>
<br><tt>_fstrspn - All</tt>
<br><tt>wcsspn - All</tt>
<br><tt>_mbsspn - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsspn - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strspnp"> strspnp, _strspnp, _fstrspnp, _wcsspnp, _mbsspnp, _fmbsspnp </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strspnp( const char *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *charset );</tt>
<br><tt>char *_strspnp( const char *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *charset );</tt>
<br><tt>char __far *_fstrspnp( const char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const char __far *charset );</tt>
<br><tt>#include &lt;tchar.h&gt;</tt>
<br><tt>wchar_t *_wcsspnp( const wchar_t *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 wchar_t *charset );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsspnp( const unsigned char *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *charset );</tt>
<br><tt>unsigned char __far *_fmbsspnp(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const unsigned char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const unsigned char __far *charset );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strspnp</tt> function returns a pointer to the first character in<b> str</b> that does not belong to the set of characters
 in<b> charset</b>.&nbsp; The terminating null character is not considered to be part of<b> charset</b>.
<br>The<tt> _strspnp</tt> function is identical to<tt> strspnp</tt>.&nbsp; Use<tt> _strspnp</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _fstrspnp</tt> function is a data model independent form of the<tt> strspnp</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> _wcsspnp</tt> function is a wide-character version of<tt> strspnp</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsspnp</tt> function is a multibyte character version of<tt> strspnp</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbsspnp</tt> function is a data model independent form of the<tt> _mbsspnp</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strspnp</tt> function returns<tt> NULL</tt> if<b> str</b> consists entirely of characters from<b> charset</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcspn">strcspn</a>, <a href="#strspn">strspn</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strspnp( &quot;out to lunch&quot;, &quot;aeiou&quot; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strspnp( &quot;out to lunch&quot;, &quot;xyz&quot; ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>t to lunch</tt>
<br><tt>out to lunch</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_strspnp conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> strspnp - All, Netware</tt>
<br><tt>_strspnp - All, Netware</tt>
<br><tt>_fstrspnp - All</tt>
<br><tt>_wcsspnp - All</tt>
<br><tt>_mbsspnp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsspnp - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strstr"> strstr, _fstrstr, wcsstr, _mbsstr, _fmbsstr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strstr( const char *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *substr );</tt>
<br><tt>char __far *_fstrstr( const char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const char __far *substr );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *wcsstr( const wchar_t *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *substr
 );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsstr( const unsigned char *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char *substr );</tt>
<br><tt>unsigned char __far *_fmbsstr(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const unsigned char __far *str,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const unsigned char __far *substr );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strstr</tt> function locates the first occurrence in the string pointed to by<b> str</b> of the sequence of characters
 (excluding the terminating null character) in the string pointed to by<b> substr</b>.
<br>The<tt> _fstrstr</tt> function is a data model independent form of the<tt> strstr</tt> function.&nbsp; It accepts far
 pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcsstr</tt> function is a wide-character version of<tt> strstr</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsstr</tt> function is a multibyte character version of<tt> strstr</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbsstr</tt> function is a data model independent form of the<tt> _mbsstr</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strstr</tt> function returns a pointer to the located string, or<tt> NULL</tt> if the string is not found.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcspn">strcspn</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strstr(&quot;This is an example&quot;, &quot;is&quot;) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>is is an example</tt>
</dl>
<dl>
<dt>Classification:
<dd>strstr is ANSI
<br>_fstrstr is not ANSI
<br>wcsstr is ANSI
<br>_mbsstr is not ANSI
<br>_fmbsstr is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strstr - All, Netware</tt>
<br><tt>_fstrstr - All</tt>
<br><tt>wcsstr - All</tt>
<br><tt>_mbsstr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsstr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="_strtime"> _strtime, _wstrtime </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>char *_strtime( char *timestr )</tt>
<br><tt>wchar_t _wstrtime( wchar_t *timestr );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _strtime</tt> function copies the current time to the buffer pointed to by<b> timestr</b>.&nbsp; The time is formatted
 as &quot;HH:MM:SS&quot; where &quot;HH&quot; is two digits representing the hour in 24-hour notation, where &quot;MM&quot;
 is two digits representing the minutes past the hour, and where &quot;SS&quot; is two digits representing seconds.&nbsp;
 The buffer must be at least 9 bytes long.
<br>The<tt> _wstrtime</tt> function is a wide-character version of<tt> _strtime</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _strtime</tt> function returns a pointer to the resulting text string<b> timestr</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#ctime">ctime</a> Functions, <a href="#gmtime">gmtime</a>, <a href="#localtime">localtime</a>,
 <a href="#mktime">mktime</a>, <a href="#_strdate">_strdate</a>, <a href="#time">time</a>, <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char timebuff&#91;9&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, _strtime( timebuff ) );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _strtime - All</tt>
<br><tt>_wstrtime - All</tt>
</dl>
<h2 id="strtod"> strtod, wcstod </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>double strtod( const char *ptr, char **endptr );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>double wcstod( const wchar_t *ptr, wchar_t **endptr );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strtod</tt> function converts the string pointed to by<b> ptr</b> to<tt> double</tt> representation.&nbsp; First,
 it decompose the input string into three parts:&nbsp; an initial, possibly empty, sequence of white-space characters (as
 specified by the<tt> isspace</tt> function), a subject sequence resembling a floating-point constant or representing an infinity
 or NaN; and a final string of one or more unrecognized characters, including the terminating null character of the input
 string.&nbsp; Then, it attempts to convert the subject sequence to a floating-point number, and return the result.
<br>The expected form of the subject sequence is an optional plus or minus sign, then one of the following:
<ul>
<li>a decimal floating-point number
<li>a hexadecimal floating-point number
<li><tt> INF</tt> or<tt> INFINITY</tt>, ignoring case
<li><tt> NAN</tt>, ignoring case, optionally followed by a sequence of digits and nondigits (upper- or lowercase characters
 or underscore) enclosed in parentheses.
</ul>
<br>The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-whitespace
 character, that is of the expected form.&nbsp; The subject sequence contains no characters if the input string is not of
 the expected form.
<br><br>A decimal floating-point number recognized by<tt> strtod</tt> (after optional sign was processed) is a string containing:
<ul>
<li>a sequence of digits containing an optional decimal point,
<li>an optional 'e' or 'E' followed by an optionally signed sequence of digits.
</ul>
<br>A hexadecimal floating-point number recognized by<tt> strtod</tt> (after optional sign was processed) is a string containing:
<ul>
<li>a<tt> 0X</tt> prefix, ignoring case,
<li>a sequence of hexadecimal digits containing an optional decimal point,
<li>an optional 'p' or 'P' followed by an optionally signed sequence of decimal digits.
</ul>
<br>The subject sequence is defined as the longest initial subsequence of the input string, starting with the first non-white-space
 character, that is of the expected form.&nbsp; The subject sequence contains no characters if the input string is not of
 the expected form.
<br><br>If the subject sequence contains<tt> NAN</tt>, a NaN (with appropriate sign) will be returned; the optional digit-nondigit
 sequence is ignored.&nbsp; If the subject sequence contains<tt> INF</tt>, the value of infinity (with appropriate sign) will
 be returned.&nbsp; This case can be distinguished from overflow by checking <tt> errno</tt>.
<br><br>For a hexadecimal floating-point number, the optional exponent is binary (that is, denotes a power of two), not decimal.
<br><br>A pointer to the final string (following the subject sequence) will be stored in the object to which<b> endptr</b>
 points if<b> endptr</b> is not<tt> NULL.</tt>&nbsp; By comparing the &quot;end&quot; pointer with<b> ptr</b>, it can be determined
 how much of the string, if any, was scanned by the<tt> strtod</tt> function.
<br><br>The<tt> wcstod</tt> function is a wide-character version of<tt> strtod</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strtod</tt> function returns the converted value, if any.&nbsp; If no conversion could be performed, zero is returned.
&nbsp; If the correct value would cause overflow, plus or minus <tt> HUGE_VAL</tt> is returned according to the sign, and
 <tt> errno</tt> is set to <tt> ERANGE</tt>.&nbsp; If the correct value would cause underflow, then zero is returned, and
 <tt> errno</tt> is set to <tt> ERANGE</tt>.&nbsp; Zero is returned when the input string cannot be converted.&nbsp; In this
 case, <tt> errno</tt> is not set.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type
 of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atof">atof</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; double pi;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; pi = strtod( &quot;3.141592653589793&quot;, NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;pi=%17.15f\n&quot;,pi );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>strtod is ISO C90
<br>wcstod is ISO C95
</dl>
<dl>
<dt>Systems:
<dd><tt> strtod - Math</tt>
<br><tt>wcstod - Math</tt>
</dl>
<h2 id="strtok"> strtok, _fstrtok, wcstok, _mbstok, _fmbstok </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strtok( char *s1, const char *s2 );</tt>
<br><tt>char __far *_fstrtok( char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const char __far *s2 );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *wcstok( wchar_t *s1, const wchar_t *s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **ptr );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbstok( unsigned char *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned
 char *s2 );</tt>
<br><tt>unsigned char __far *_fmbstok( unsigned char __far *s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const unsigned char __far *s2 );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#strtok_s">strtok_s</a> function which is a safer alternative to<tt> strtok</tt>.
&nbsp; This newer<tt> strtok_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> strtok</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> strtok</tt> function is used to break the string pointed to by<b> s1</b> into a sequence of tokens, each of which
 is delimited by a character from the string pointed to by<b> s2</b>.&nbsp; The first call to<tt> strtok</tt> will return
 a pointer to the first token in the string pointed to by<b> s1</b>.&nbsp; Subsequent calls to<tt> strtok</tt> must pass a
 NULL pointer as the first argument, in order to get the next token in the string.&nbsp; The set of delimiters used in each
 of these calls to<tt> strtok</tt> can be different from one call to the next.
<br>The first call in the sequence searches<b> s1</b> for the first character that is not contained in the current delimiter
 string<b> s2</b>.&nbsp; If no such character is found, then there are no tokens in<b> s1</b> and the<tt> strtok</tt> function
 returns a NULL pointer.&nbsp; If such a character is found, it is the start of the first token.
<br><br>The<tt> strtok</tt> function then searches from there for a character that is contained in the current delimiter string.
&nbsp; If no such character is found, the current token extends to the end of the string pointed to by<b> s1</b>.&nbsp; If
 such a character is found, it is overwritten by a null character, which terminates the current token.&nbsp; The<tt> strtok</tt>
 function saves a pointer to the following character, from which the next search for a token will start when the first argument
 is a NULL pointer.
<br><br>Because<tt> strtok</tt> may modify the original string, that string should be duplicated if the string is to be re-used.
<br><br>The<tt> _fstrtok</tt> function is a data model independent form of the<tt> strtok</tt> function.&nbsp; It accepts
 far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> wcstok</tt> function is a wide-character version of<tt> strtok</tt> that operates with wide-character strings.
&nbsp; The third argument<b> ptr</b> points to a caller-provided <tt> wchar_t</tt> pointer into which the<tt> wcstok</tt>
 function stores information necessary for it to continue scanning the same wide string.
<br><br>On the first call in the sequence of calls to<tt> wcstok</tt>,<b> s1</b> points to a wide string.&nbsp; In subsequent
 calls for the same string,<b> s1</b> must be NULL.&nbsp; If<b> s1</b> is NULL, the value pointed to by<b> ptr</b> matches
 that set by the previous call to<tt> wcstok</tt> for the same wide string.&nbsp; Otherwise, the value of<b> ptr</b> is ignored.
&nbsp; The list of delimiters pointed to by<b> s2</b> may be different from one call to the next.&nbsp; The tokenization of<b>
 s1</b> is similar to that for the<tt> strtok</tt> function.
<br><br>The<tt> _mbstok</tt> function is a multibyte character version of<tt> strtok</tt> that operates with multibyte character
 strings.
<br><br>The<tt> _fmbstok</tt> function is a data model independent form of the<tt> _mbstok</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strtok</tt> function returns a pointer to the first character of a token or<tt> NULL</tt> if there is no token found.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strcspn">strcspn</a>, <a href="#strpbrk">strpbrk</a>, <a href="#strtok_s">strtok_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *p;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *buffer;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *delims = { &quot; .,&quot; };</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; buffer = strdup( &quot;Find words, all of them.&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p = strtok( buffer, delims );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( p != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;word: %s\n&quot;, p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = strtok( NULL, delims );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Find words, all of them.</tt>
<br><tt>word: Find</tt>
<br><tt>word: words</tt>
<br><tt>word: all</tt>
<br><tt>word: of</tt>
<br><tt>word: them</tt>
<br><tt>Find</tt>
</dl>
<dl>
<dt>Classification:
<dd>strtok is ANSI
<br>_fstrtok is not ANSI
<br>wcstok is ANSI
<br>_mbstok is not ANSI
<br>_fmbstok is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strtok - All, Netware</tt>
<br><tt>_fstrtok - All</tt>
<br><tt>wcstok - All</tt>
<br><tt>_mbstok - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbstok - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strtok_s"> strtok_s, wcstok_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strtok_s( char * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t * restrict s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char ** restrict ptr);</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *wcstok_s( wchar_t * restrict s1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t
 * restrict s1max,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 wchar_t * restrict s2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t
 ** restrict ptr);</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 strtok_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>None of<b> s1max</b>,<b> s2</b>, or<b> ptr</b> shall be a null pointer.&nbsp; If<b> s1</b> is a null pointer,then<b> *ptr</b>
 shall not be a null pointer.&nbsp; The value of<b> *s1max</b> shall not be greater than <tt> RSIZE_MAX</tt>.&nbsp; The end
 of the token found shall occur within the first<b> *s1max</b> characters of<b> s1</b> for the first call, and shall occur
 within the first<b> *s1max</b> characters of where searching resumes on subsequent calls.&nbsp; If there is a runtime-constraint
 violation, the<tt> strtok_s</tt> function does not indirect through the<b> s1</b> or<b> s2</b> pointers, and does not store
 a value in the object pointed to by<b> ptr</b>.
</dl>
<dl>
<dt>Description:
<dd>A sequence of calls to the<tt> strtok_s</tt> function breaks the string pointed to by<b> s1</b> into a sequence of tokens,
 each of which is delimited by a character from the string pointed to by<b> s2</b>.&nbsp; The fourth argument points to a
 caller-provided char pointer into which the<tt> strtok_s</tt> function stores information necessary for it to continue scanning
 the same string.&nbsp; The first call in a sequence has a non-null first argument and<b> s1max</b> points to an object whose
 value is the number of elements in the character array pointed to by the first argument.&nbsp; The first call stores an initial
 value in the object pointed to by<b> ptr</b> and updates the value pointed to by<b> s1max</b> to reflect the number of elements
 that remain in relation to<b> ptr</b>.&nbsp; Subsequent calls in the sequence have a null first argument and the objects
 pointed to by<b> s1max</b> and<b> ptr</b> are required to have the values stored by the previous call in the sequence, which
 are then updated.&nbsp; The separator string pointed to by<b> s2</b> may be different from call to call.&nbsp; The first
 call in the sequence searches the string pointed to by<b> s1</b> for the first character that is not contained in the current
 separator string pointed to by<b> s2</b>.&nbsp; If no such character is found, then there are no tokens in the string pointed
 to by<b> s1</b> and the<tt> strtok_s</tt> function returns a null pointer.&nbsp; If such a character is found, it is the
 start of the first token.&nbsp; The<tt> strtok_s</tt> function then searches from there for the first character in<b> s1</b>
 that is contained in the current separator string.&nbsp; If no such character is found, the current token extends to the
 end of the string pointed to by<b> s1</b>, and subsequent searches in the same string for a token return a null pointer.
&nbsp; If such a character is found, it is overwritten by a null character, which terminates the current token.&nbsp; In all
 cases, the<tt> strtok_s</tt> function stores sufficient information in the pointer pointed to by<b> ptr</b> so that subsequent
 calls, with a null pointer for<b> s1</b> and the unmodified pointer value for<b> ptr</b>, shall start searching
<br>just past the element overwritten by a null character (if any).
<br><br>The<tt> wcstok_s</tt> function is a wide-character version of<tt> strtok_s</tt> that operates with wide-character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strtok_s</tt> function returns a pointer to the first character of a token, or a null pointer if there is no token
 or there is a runtime-constraint violation.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strtok">strtok</a>, <a href="#strcspn">strcspn</a>, <a href="#strpbrk">strpbrk</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *p;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *buffer;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *delims = { &quot; .,&quot; };</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t&nbsp; buflen;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *ptr;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; buffer = strdup( &quot;Find words, all of them.&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; buflen = strlen( buffer );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p = strtok_s( buffer, &amp;buflen, delims, &amp;ptr );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( p != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;word: %s\n&quot;, p );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p = strtok_s( NULL, &amp;buflen, delims, &amp;ptr );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Find words, all of them.</tt>
<br><tt>word: Find</tt>
<br><tt>word: words</tt>
<br><tt>word: all</tt>
<br><tt>word: of</tt>
<br><tt>word: them</tt>
<br><tt>Find</tt>
</dl>
<dl>
<dt>Classification:
<dd>strtok_s is TR 24731
<br>wcstok_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> strtok_s - All, Netware</tt>
<br><tt>wcstok_s - All</tt>
</dl>
<h2 id="strtol"> strtol, wcstol </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>long int strtol( const char *ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char **endptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int base );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>long int wcstol( const wchar_t *ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **endptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int base );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strtol</tt> function converts the string pointed to by<b> ptr</b> to an object of type<tt> long int.</tt>&nbsp; The<tt>
 strtol</tt> function recognizes a string containing:
<ul>
<li>optional white space,
<li>an optional plus or minus sign,
<li>a sequence of digits and letters.
</ul>
<br>The conversion ends at the first unrecognized character.&nbsp; A pointer to that character will be stored in the object
 to which<b> endptr</b> points if<b> endptr</b> is not<tt> NULL.</tt>
<br><br>If<b> base</b> is zero, the first characters after the optional sign determine the base used for the conversion.&nbsp;
 If the first characters are &quot;0x&quot; or &quot;0X&quot; the digits are treated as hexadecimal.&nbsp; If the first character
 is '0', the digits are treated as octal.&nbsp; Otherwise the digits are treated as decimal.
<br><br>If<b> base</b> is not zero, it must have a value between 2 and 36.&nbsp; The letters a-z and A-Z represent the values
 10 through 35.&nbsp; Only those letters whose designated values are less than<b> base</b> are permitted.&nbsp; If the value
 of<b> base</b> is 16, the characters &quot;0x&quot; or &quot;0X&quot; may optionally precede the sequence of letters and
 digits.
<br><br>The<tt> wcstol</tt> function is a wide-character version of<tt> strtol</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strtol</tt> function returns the converted value.&nbsp; If the correct value would cause overflow, <tt> LONG_MAX</tt>
 or <tt> LONG_MIN</tt> is returned according to the sign, and <tt> errno</tt> is set to <tt> ERANGE</tt>.&nbsp; If<b> base</b>
 is out of range, zero is returned and <tt> errno</tt> is set to <tt> EDOM</tt>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#atoll">atoll</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>,
 <a href="#lltoa">lltoa</a>, <a href="#sscanf">sscanf</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoul">strtoul</a>,
 <a href="#strtoull">strtoull</a>, <a href="#strtoimax">strtoimax</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ultoa">ultoa</a>,
 <a href="#ulltoa">ulltoa</a>, <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long int v;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; v = strtol( &quot;12345678&quot;, NULL, 10 );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>strtol is ANSI
<br>wcstol is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strtol - All, Netware</tt>
<br><tt>wcstol - All</tt>
</dl>
<h2 id="strtoll"> strtoll, wcstoll </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>long long int strtoll( const char *ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char **endptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; int base );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>long long int wcstoll( const wchar_t *ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; wchar_t **endptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; int base );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strtoll</tt> function converts the string pointed to by<b> ptr</b> to an object of type<tt> long long int.</tt>&nbsp;
 The<tt> strtoll</tt> function recognizes a string containing:
<ul>
<li>optional white space,
<li>an optional plus or minus sign,
<li>a sequence of digits and letters.
</ul>
<br>The conversion ends at the first unrecognized character.&nbsp; A pointer to that character will be stored in the object
 to which<b> endptr</b> points if<b> endptr</b> is not<tt> NULL.</tt>
<br><br>If<b> base</b> is zero, the first characters after the optional sign determine the base used for the conversion.&nbsp;
 If the first characters are &quot;0x&quot; or &quot;0X&quot; the digits are treated as hexadecimal.&nbsp; If the first character
 is '0', the digits are treated as octal.&nbsp; Otherwise the digits are treated as decimal.
<br><br>If<b> base</b> is not zero, it must have a value between 2 and 36.&nbsp; The letters a-z and A-Z represent the values
 10 through 35.&nbsp; Only those letters whose designated values are less than<b> base</b> are permitted.&nbsp; If the value
 of<b> base</b> is 16, the characters &quot;0x&quot; or &quot;0X&quot; may optionally precede the sequence of letters and
 digits.
<br><br>The<tt> wcstoll</tt> function is a wide-character version of<tt> strtoll</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strtoll</tt> function returns the converted value.&nbsp; If the correct value would cause overflow, <tt> LLONG_MAX</tt>
 or <tt> LLONG_MIN</tt> is returned according to the sign, and <tt> errno</tt> is set to <tt> ERANGE</tt>.&nbsp; If<b> base</b>
 is out of range, zero is returned and <tt> errno</tt> is set to <tt> EDOM</tt>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#atoll">atoll</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>,
 <a href="#lltoa">lltoa</a>, <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoul">strtoul</a>, <a href="#strtoull">strtoull</a>,
 <a href="#strtoimax">strtoimax</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ultoa">ultoa</a>, <a href="#ulltoa">ulltoa</a>,
 <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long long int v;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; v = strtol( &quot;12345678909876&quot;, NULL, 10 );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>strtoll is ANSI
<br>wcstoll is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strtoll - All, Netware</tt>
<br><tt>wcstoll - All</tt>
</dl>
<h2 id="strtoimax"> strtoimax, wcstoimax </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;inttypes.h&gt;</tt>
<br><tt>intmax_t strtoimax( const char *ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 char **endptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 int base );</tt>
<br><tt>intmax_t wcstoimax( const wchar_t *ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 wchar_t **endptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 int base );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strtoimax</tt> function converts the string pointed to by<b> ptr</b> to an object of type<tt> intmax_t.</tt>&nbsp;
 The<tt> strtoimax</tt> function recognizes a string containing:
<ul>
<li>optional white space,
<li>an optional plus or minus sign,
<li>a sequence of digits and letters.
</ul>
<br>The conversion ends at the first unrecognized character.&nbsp; A pointer to that character will be stored in the object
 to which<b> endptr</b> points if<b> endptr</b> is not<tt> NULL.</tt>
<br><br>If<b> base</b> is zero, the first characters after the optional sign determine the base used for the conversion.&nbsp;
 If the first characters are &quot;0x&quot; or &quot;0X&quot; the digits are treated as hexadecimal.&nbsp; If the first character
 is '0', the digits are treated as octal.&nbsp; Otherwise the digits are treated as decimal.
<br><br>If<b> base</b> is not zero, it must have a value between 2 and 36.&nbsp; The letters a-z and A-Z represent the values
 10 through 35.&nbsp; Only those letters whose designated values are less than<b> base</b> are permitted.&nbsp; If the value
 of<b> base</b> is 16, the characters &quot;0x&quot; or &quot;0X&quot; may optionally precede the sequence of letters and
 digits.
<br><br>The<tt> wcstoimax</tt> function is a wide-character version of<tt> strtoimax</tt> that operates with wide-character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strtoimax</tt> function returns the converted value.&nbsp; If the correct value would cause overflow, <tt> INTMAX_MAX</tt>
 or <tt> INTMAX_MIN</tt> is returned according to the sign, and <tt> errno</tt> is set to <tt> ERANGE</tt>.&nbsp; If<b> base</b>
 is out of range, zero is returned and <tt> errno</tt> is set to <tt> EDOM</tt>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#atoll">atoll</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>,
 <a href="#lltoa">lltoa</a>, <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoul">strtoul</a>,
 <a href="#strtoull">strtoull</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ultoa">ultoa</a>, <a href="#ulltoa">ulltoa</a>,
 <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;inttypes.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; intmax_t v;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; v = strtoimax( &quot;12345678909876&quot;, NULL, 10 );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>strtoimax is ANSI
<br>wcstoimax is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strtoimax - All, Netware</tt>
<br><tt>wcstoimax - All</tt>
</dl>
<h2 id="strtoul"> strtoul, wcstoul </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>unsigned long int strtoul( const char *ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char **endptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int base );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>unsigned long int wcstoul( const wchar_t *ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **endptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int base );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strtoul</tt> function converts the string pointed to by<b> ptr</b> to an<tt> unsigned long.</tt>&nbsp; The function
 recognizes a string containing optional white space, an optional sign (+ or -), followed by a sequence of digits and letters.
&nbsp; The conversion ends at the first unrecognized character.&nbsp; A pointer to that character will be stored in the object<b>
 endptr</b> points to if<b> endptr</b> is not<tt> NULL.</tt>
<br>If<b> base</b> is zero, the first characters determine the base used for the conversion.&nbsp; If the first characters
 are &quot;0x&quot; or &quot;0X&quot; the digits are treated as hexadecimal.&nbsp; If the first character is '0', the digits
 are treated as octal.&nbsp; Otherwise the digits are treated as decimal.
<br><br>If<b> base</b> is not zero, it must have a value of between 2 and 36.&nbsp; The letters a-z and A-Z represent the
 values 10 through 35.&nbsp; Only those letters whose designated values are less than<b> base</b> are permitted.&nbsp; If
 the value of<b> base</b> is 16, the characters &quot;0x&quot; or &quot;0X&quot; may optionally precede the sequence of letters
 and digits.
<br><br>If there is a leading minus sign in the string, the value is negated.
<br><br>The<tt> wcstoul</tt> function is a wide-character version of<tt> strtoul</tt> that operates with wide-character strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strtoul</tt> function returns the converted value.&nbsp; If the correct value would cause overflow, <tt> ULONG_MAX</tt>
 is returned and <tt> errno</tt> is set to <tt> ERANGE</tt>.&nbsp; If<b> base</b> is out of range, zero is returned and <tt>
 errno</tt> is set to <tt> EDOM</tt>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#atoll">atoll</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>,
 <a href="#lltoa">lltoa</a>, <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoull">strtoull</a>,
 <a href="#strtoimax">strtoimax</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ultoa">ultoa</a>, <a href="#ulltoa">ulltoa</a>,
 <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned long int v;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; v = strtoul( &quot;12345678&quot;, NULL, 10 );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>strtoul is ANSI
<br>wcstoul is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strtoul - All, Netware</tt>
<br><tt>wcstoul - All</tt>
</dl>
<h2 id="strtoull"> strtoull, wcstoull </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>unsigned long long int strtoull( const char *ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char **endptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int base );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>unsigned long long int wcstoull( const wchar_t *ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t **endptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int base );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strtoull</tt> function converts the string pointed to by<b> ptr</b> to an<tt> unsigned long long.</tt>&nbsp; The function
 recognizes a string containing optional white space, an optional sign (+ or -), followed by a sequence of digits and letters.
&nbsp; The conversion ends at the first unrecognized character.&nbsp; A pointer to that character will be stored in the object<b>
 endptr</b> points to if<b> endptr</b> is not<tt> NULL.</tt>
<br>If<b> base</b> is zero, the first characters determine the base used for the conversion.&nbsp; If the first characters
 are &quot;0x&quot; or &quot;0X&quot; the digits are treated as hexadecimal.&nbsp; If the first character is '0', the digits
 are treated as octal.&nbsp; Otherwise the digits are treated as decimal.
<br><br>If<b> base</b> is not zero, it must have a value of between 2 and 36.&nbsp; The letters a-z and A-Z represent the
 values 10 through 35.&nbsp; Only those letters whose designated values are less than<b> base</b> are permitted.&nbsp; If
 the value of<b> base</b> is 16, the characters &quot;0x&quot; or &quot;0X&quot; may optionally precede the sequence of letters
 and digits.
<br><br>If there is a leading minus sign in the string, the value is negated.
<br><br>The<tt> wcstoull</tt> function is a wide-character version of<tt> strtoull</tt> that operates with wide-character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strtoull</tt> function returns the converted value.&nbsp; If the correct value would cause overflow, <tt> ULLONG_MAX</tt>
 is returned and <tt> errno</tt> is set to <tt> ERANGE</tt>.&nbsp; If<b> base</b> is out of range, zero is returned and <tt>
 errno</tt> is set to <tt> EDOM</tt>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#atoll">atoll</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>,
 <a href="#lltoa">lltoa</a>, <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoul">strtoul</a>,
 <a href="#strtoimax">strtoimax</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ultoa">ultoa</a>, <a href="#ulltoa">ulltoa</a>,
 <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned long long int v;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; v = strtoul( &quot;12345678909876&quot;, NULL, 10 );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>strtoull is ANSI
<br>wcstoull is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strtoull - All, Netware</tt>
<br><tt>wcstoull - All</tt>
</dl>
<h2 id="strtoumax"> strtoumax, wcstoumax </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;inttypes.h&gt;</tt>
<br><tt>uintmax_t strtoumax( const char *ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; char **endptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; int base );</tt>
<br><tt>#include &lt;inttypes.h&gt;</tt>
<br><tt>uintmax_t wcstoumax( const wchar_t *ptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; wchar_t **endptr,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; int base );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strtoumax</tt> function converts the string pointed to by<b> ptr</b> to an<tt> uintmax_t.</tt>&nbsp; The function
 recognizes a string containing optional white space, an optional sign (+ or -), followed by a sequence of digits and letters.
&nbsp; The conversion ends at the first unrecognized character.&nbsp; A pointer to that character will be stored in the object<b>
 endptr</b> points to if<b> endptr</b> is not<tt> NULL.</tt>
<br>If<b> base</b> is zero, the first characters determine the base used for the conversion.&nbsp; If the first characters
 are &quot;0x&quot; or &quot;0X&quot; the digits are treated as hexadecimal.&nbsp; If the first character is '0', the digits
 are treated as octal.&nbsp; Otherwise the digits are treated as decimal.
<br><br>If<b> base</b> is not zero, it must have a value of between 2 and 36.&nbsp; The letters a-z and A-Z represent the
 values 10 through 35.&nbsp; Only those letters whose designated values are less than<b> base</b> are permitted.&nbsp; If
 the value of<b> base</b> is 16, the characters &quot;0x&quot; or &quot;0X&quot; may optionally precede the sequence of letters
 and digits.
<br><br>If there is a leading minus sign in the string, the value is negated.
<br><br>The<tt> wcstoumax</tt> function is a wide-character version of<tt> strtoumax</tt> that operates with wide-character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strtoumax</tt> function returns the converted value.&nbsp; If the correct value would cause overflow, <tt> UINTMAX_MAX</tt>
 is returned and <tt> errno</tt> is set to <tt> ERANGE</tt>.&nbsp; If<b> base</b> is out of range, zero is returned and <tt>
 errno</tt> is set to <tt> EDOM</tt>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#atoll">atoll</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>,
 <a href="#lltoa">lltoa</a>, <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoul">strtoul</a>,
 <a href="#strtoull">strtoull</a>, <a href="#strtoimax">strtoimax</a>, <a href="#ultoa">ultoa</a>, <a href="#ulltoa">ulltoa</a>,
 <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;inttypes.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; uintmax_t v;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; v = strtoumax( &quot;12345678909876&quot;, NULL, 10 );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>strtoumax is ANSI
<br>wcstoumax is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strtoumax - All, Netware</tt>
<br><tt>wcstoumax - All</tt>
</dl>
<h2 id="strupr"> strupr, _strupr, _fstrupr, _wcsupr, _mbsupr, _fmbsupr </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>char *strupr( char *s );</tt>
<br><tt>char *_strupr( char *s );</tt>
<br><tt>char __far *_fstrupr( char __far *s );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wchar_t *_wcsupr( wchar_t *s );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>unsigned char *_mbsupr( unsigned char *s );</tt>
<br><tt>unsigned char __far *_fmbsupr( unsigned char __far *s );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strupr</tt> function replaces the string<b> s</b> with uppercase characters by invoking the <tt> toupper</tt> function
 for each character in the string.
<br>The<tt> _strupr</tt> function is identical to<tt> strupr</tt>.&nbsp; Use<tt> _strupr</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _fstrupr</tt> function is a data model independent form of the<tt> strupr</tt> function.&nbsp; It accepts
 far pointer arguments and returns a far pointer.&nbsp; It is most useful in mixed memory model applications.
<br><br>The<tt> _wcsupr</tt> function is a wide-character version of<tt> strupr</tt> that operates with wide-character strings.
<br><br>The<tt> _mbsupr</tt> function is a multibyte character version of<tt> strupr</tt> that operates with multibyte character
 strings.
</dl>
<dl>
<dt>Returns:
<dd>The address of the original string<b> s</b> is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#strlwr">strlwr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char source&#91;&#93; = { &quot;A mixed-case STRING&quot; };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, strupr( source ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, source );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>A mixed-case STRING</tt>
<br><tt>A MIXED-CASE STRING</tt>
<br><tt>A MIXED-CASE STRING</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_strupr conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> strupr - All, Netware</tt>
<br><tt>_strupr - All, Netware</tt>
<br><tt>_fstrupr - All</tt>
<br><tt>_wcsupr - All</tt>
<br><tt>_mbsupr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fmbsupr - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="strxfrm"> strxfrm, wcsxfrm </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>size_t strxfrm( char *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>size_t wcsxfrm( wchar_t *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> strxfrm</tt> function transforms, for no more than<b> n</b> characters, the string pointed to by<b> src</b> to the
 buffer pointed to by<b> dst</b>.&nbsp; The transformation uses the collating sequence selected by the <tt> setlocale</tt>
 function so that two transformed strings will compare identically (using the <tt> strncmp</tt> function) to a comparison
 of the original two strings using the <tt> strcoll</tt> function.&nbsp; The function will be equivalent to the <tt> strncpy</tt>
 function (except there is no padding of the<b> dst</b> argument with null characters when the argument<b> src</b> is shorter
 than<b> n</b> characters) when the collating sequence is selected from the<tt> &quot;C&quot;</tt> locale.
<br>The<tt> wcsxfrm</tt> function is a wide-character version of<tt> strxfrm</tt> that operates with wide-character strings.
&nbsp; For<tt> wcsxfrm</tt>, after the string transformation, a call to <tt> wcscmp</tt> with the two transformed strings
 yields results identical to those of a call to <tt> wcscoll</tt> applied to the original two strings.<tt>&nbsp; wcsxfrm</tt>
 and<tt> strxfrm</tt> behave identically otherwise.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> strxfrm</tt> function returns the length of the transformed string.&nbsp; If this length is more than<b> n</b>, the
 contents of the array pointed to by<b> dst</b> are indeterminate.
</dl>
<dl>
<dt>See Also:
<dd><a href="#setlocale">setlocale</a>, <a href="#strcoll">strcoll</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;locale.h&gt;</tt>
<br><br><tt>char src&#91;&#93; = { &quot;A sample STRING&quot; };</tt>
<br><tt>char dst&#91;20&#93;;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t len;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; setlocale( LC_ALL, &quot;C&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, src );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; len = strxfrm( dst, src, 20 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s (%u)\n&quot;, dst, len );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>A sample STRING</tt>
<br><tt>A sample STRING (15)</tt>
</dl>
<dl>
<dt>Classification:
<dd>strxfrm is ANSI
<br>wcsxfrm is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> strxfrm - All, Netware</tt>
<br><tt>wcsxfrm - All</tt>
</dl>
<h2 id="swab"> swab </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>void swab( char *src, char *dest, int num );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> swab</tt> function copies<b> num</b> bytes (which should be even) from<b> src</b> to<b> dest</b> swapping every pair
 of characters.&nbsp; This is useful for preparing binary data to be transferred to another machine that has a different byte
 ordering.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> swab</tt> function has no return value.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>char *msg = &quot;hTsim seasegi&nbsp; swspaep.d&quot;;</tt>
<br><tt>#define NBYTES 24</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char buffer&#91;80&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, msg );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; memset( buffer, '\0', 80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; swab( msg, buffer, NBYTES );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, buffer );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>hTsim seasegi&nbsp; swspaep.d</tt>
<br><tt>This message is swapped.</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="system"> system, _wsystem </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>int system( const char *command );</tt>
<br><tt>int _wsystem( const wchar_t *command );</tt>
</dl>
<dl>
<dt>Description:
<dd>If the value of<b> command</b> is<tt> NULL,</tt> then the<tt> system</tt> function determines whether or not a command processor
 is present (&quot;COMMAND.COM&quot; in DOS and Windows 95/98 or &quot;CMD.EXE&quot; in OS/2 and Windows NT/2000).
<br>Otherwise, the<tt> system</tt> function invokes a copy of the command processor, and passes the string<b> command</b>
 to it for processing.&nbsp; This function uses <tt> spawnl</tt> to load a copy of the command processor identified by the
 <tt> COMSPEC</tt> environment variable.
<br><br>This means that any command that can be entered to DOS can be executed, including programs, DOS commands and batch
 files.&nbsp; The <tt> exec...</tt>&nbsp; and <tt> spawn...</tt>&nbsp; functions can only cause programs to be executed.
<br><br>The<tt> _wsystem</tt> function is identical to<tt> system</tt> except that it accepts a wide-character string argument.
</dl>
<dl>
<dt>Returns:
<dd>If the value of<b> command</b> is<tt> NULL,</tt> then the<tt> system</tt> function returns zero if the command processor is
 not present, a non-zero value if the command processor is present.&nbsp; Note that Microsoft Windows 3.x does not support
 a command shell and so the<tt> system</tt> function always returns zero when<b> command</b> is<tt> NULL.</tt>
<br>Otherwise, the<tt> system</tt> function returns the result of invoking a copy of the command processor.&nbsp; A non-zero
 value is returned if the command processor could not be loaded; otherwise, zero is returned.&nbsp; When an error has occurred,
 <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#abort">abort</a>, <a href="#atexit">atexit</a>, <a href="#_bgetcmd">_bgetcmd</a>, <a href="#exec___">exec...</a>,
 <a href="#exit">exit</a>, <a href="#_Exit">_Exit</a>, <a href="#_exit">_exit</a>, <a href="#getcmd">getcmd</a>, <a href="#getenv">getenv</a>,
 <a href="#main">main</a>, <a href="#onexit">onexit</a>, <a href="#putenv">putenv</a>, <a href="#spawn___">spawn...</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = system( &quot;dir&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( rc != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;shell could not be run\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>system is ANSI, POSIX 1003.2
<br>_wsystem is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> system - All, Netware</tt>
<br><tt>_wsystem - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="tan"> tan </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double tan( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> tan</tt> function computes the tangent of<b> x</b> (measured in radians).&nbsp; A large magnitude argument may yield
 a result with little or no significance.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> tan</tt> function returns the tangent value.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating
 the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atan">atan</a>, <a href="#atan2">atan2</a>, <a href="#cos">cos</a>, <a href="#sin">sin</a>, <a href="#tanh">tanh</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, tan(.5) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.546302</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="tanh"> tanh </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;math.h&gt;</tt>
<br><tt>double tanh( double x );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> tanh</tt> function computes the hyperbolic tangent of<b> x</b>.
<br>When the<b> x</b> argument is large, partial or total loss of significance may occur.&nbsp; The <tt> matherr</tt> function
 will be invoked in this case.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> tanh</tt> function returns the hyperbolic tangent value.&nbsp; When an error has occurred, <tt> errno</tt> contains
 a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cosh">cosh</a>, <a href="#sinh">sinh</a>, <a href="#matherr">matherr</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;math.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%f\n&quot;, tanh(.5) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>0.462117</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>Math
</dl>
<h2 id="tell"> tell, _tell, _telli64 </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>off_t tell( int handle );</tt>
<br><tt>off_t _tell( int handle );</tt>
<br><tt>__int64 _telli64( int handle );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> tell</tt> function reports the current file position at the operating system level.&nbsp; The<b> handle</b> value
 is the file handle returned by a successful execution of the <tt> open</tt> function.
<br>The returned value may be used in conjunction with the <tt> lseek</tt> function to reset the current file position.
<br><br>The<tt> _tell</tt> function is identical to<tt> tell</tt>.&nbsp; Use<tt> _tell</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _telli64</tt> function is similar to the<tt> tell</tt> function but returns a 64-bit file position.&nbsp;
 This value may be used in conjunction with the <tt> _lseeki64</tt> function to reset the current file position.
</dl>
<dl>
<dt>Returns:
<dd>If an error occurs in<tt> tell</tt>, (-1L) is returned.
<br>If an error occurs in<tt> _telli64</tt>, (-1I64) is returned.
<br><br>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<br><br>Otherwise, the current file position is returned in a system-dependent manner.&nbsp; A value of 0 indicates the start
 of the file.
</dl>
<dl>
<dt>See Also:
<dd><a href="#chsize">chsize</a>, <a href="#close">close</a>, <a href="#creat">creat</a>, <a href="#dup">dup</a>, <a href="#dup2">dup2</a>,
 <a href="#eof">eof</a>, <a href="#exec___">exec...</a>, <a href="#fdopen">fdopen</a>, <a href="#filelength">filelength</a>,
 <a href="#fileno">fileno</a>, <a href="#fstat">fstat</a>, <a href="#_grow_handles">_grow_handles</a>, <a href="#isatty">isatty</a>,
 <a href="#lseek">lseek</a>, <a href="#open">open</a>, <a href="#read">read</a>, <a href="#setmode">setmode</a>, <a href="#sopen">sopen</a>,
 <a href="#stat">stat</a>, <a href="#write">write</a>, <a href="#umask">umask</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><br><tt>char buffer&#91;&#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = { &quot;A text record to be written&quot; };</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int size_written;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* open a file for output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* replace existing file if it exists */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC
 | O_TEXT,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
 | S_IWGRP );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* print file position */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%ld\n&quot;, tell( handle ) );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* write the text */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_written = write( handle, buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof( buffer ) );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* print file position */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%ld\n&quot;, tell( handle ) );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* close the file */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>0</tt>
<br><tt>28</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> tell - All, Netware</tt>
<br><tt>_tell - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_telli64 - All</tt>
</dl>
<h2 id="_tempnam"> _tempnam, _wtempnam </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>char *_tempnam( char *dir, char *prefix );</tt>
<br><tt>wchar_t *_wtempnam( wchar_t *dir, wchar_t *prefix );</tt>
</dl>
<dl>
<dt>Description:
<dd><tt> _tempnam</tt> creates a temporary filename for use in another directory.&nbsp; This filename is different from that of
 any existing file.&nbsp; The<b> prefix</b> argument is the prefix to the filename.<tt>&nbsp; _tempnam</tt> uses <tt> malloc</tt>
 to allocate space for the filename; the program is responsible for freeing this space when it is no longer needed.<tt>&nbsp;
 _tempnam</tt> looks for the file with the given name in the following directories, listed in order of precedence.
<dl>
<dt>Directory Used
<dd>Conditions
<dt><br>Directory specified by TMP
<dd>The <tt> TMP</tt> environment variable must be set and the directory specified by <tt> TMP</tt> must exist.
<dt><br>dir (function argument)
<dd>The <tt> TMP</tt> environment variable must not be set or the directory specified by <tt> TMP</tt> does not exist.
<dt><br>_P_tmpdir (_wP_tmpdir) in STDIO.H
<dd>The<b> dir</b> argument is NULL or<b> dir</b> is the name of a nonexistent directory.&nbsp; The <tt> _wP_tmpdir</tt> string
 is used by<tt> _wtempnam</tt>.
<dt><br>Current working directory
<dd><tt> _tempnam</tt> uses the current working directory when <tt> _P_tmpdir</tt> does not exist.<tt>&nbsp; _wtempnam</tt> uses
 the current working directory when <tt> _wP_tmpdir</tt> does not exist.
</dl>
<br><tt>_tempnam</tt> automatically handles multibyte-character string arguments as appropriate, recognizing multibyte-character
 sequences according to the OEM code page obtained from the operating system.<tt>&nbsp; _wtempnam</tt> is a wide-character
 version of<tt> _tempnam</tt> the arguments and return value of<tt> _wtempnam</tt> are wide-character strings.<tt>&nbsp; _wtempnam</tt>
 and<tt> _tempnam</tt> behave identically except that<tt> _wtempnam</tt> does not handle multibyte-character strings.
<br><br>The function generates unique filenames for up to <tt> TMP_MAX</tt> calls.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _tempnam</tt> function returns a pointer to the name generated, unless it is impossible to create this name or the
 name is not unique.&nbsp; If the name cannot be created or if a file with that name already exists,<tt> _tempnam</tt> returns
 NULL.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#freopen">freopen</a>, <a href="#mkstemp">mkstemp</a>, <a href="#_mktemp">_mktemp</a>,
 <a href="#tmpfile">tmpfile</a>, <a href="#tmpnam">tmpnam</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>/*</tt>
<br><tt>&nbsp; Environment variable TMP=C:\WINDOWS\TEMP</tt>
<br><tt>*/</tt>
<br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *filename;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; filename = _tempnam( &quot;D:\\TEMP&quot;, &quot;_T&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( filename == NULL )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Can't obtain temp file name\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Temp file name is %s\n&quot;, filename );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp = fopen( filename, &quot;w+b&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove( filename );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; free( filename );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Temp file name is C:\WINDOWS\TEMP\_T1</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _tempnam - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wtempnam - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="time"> time </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>time_t time( time_t *tloc );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> time</tt> function determines the current calendar time and encodes it into the type <tt> time_t</tt>.
<br>The time represents the time since January 1, 1970 Coordinated Universal Time (UTC) (formerly known as Greenwich Mean
 Time (GMT)).
<br><br>The time set on the computer with the DOS<tt> time</tt> command and the DOS<tt> date</tt> command reflects the local
 time.&nbsp; The environment variable<tt> TZ</tt> is used to establish the time zone to which this local time applies.&nbsp;
 See the section<b> The TZ Environment Variable</b> for a discussion of how to set the time zone.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> time</tt> function returns the current calendar time.&nbsp; If<b> tloc</b> is not<tt> NULL,</tt> the current calendar
 time is also stored in the object pointed to by<b> tloc</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#asctime">asctime</a> Functions, <a href="#asctime_s">asctime_s</a>, <a href="#clock">clock</a>, <a href="#ctime">ctime</a>
 Functions, <a href="#ctime_s">ctime_s</a>, <a href="#difftime">difftime</a>, <a href="#gmtime">gmtime</a>, <a href="#gmtime_s">gmtime_s</a>,
 <a href="#localtime">localtime</a>, <a href="#localtime_s">localtime_s</a>, <a href="#mktime">mktime</a>, <a href="#strftime">strftime</a>,
 <a href="#tzset">tzset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t time_of_day;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; time_of_day = time( NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;It is now: %s&quot;, ctime( &amp;time_of_day ) );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>It is now: Fri Dec 25 15:58:42 1987</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI, POSIX 1003.1
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="tmpfile"> tmpfile </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>FILE *tmpfile( void );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#tmpfile_s">tmpfile_s</a> function which is a safer alternative to<tt>
 tmpfile</tt>.&nbsp; This newer<tt> tmpfile_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 tmpfile</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> tmpfile</tt> function creates a temporary binary file that will automatically be removed when it is closed or at program
 termination.&nbsp; The file is opened for update.&nbsp; For all systems except NetWare, the temporary file is located in
 the path specified by one of the following environment variables, if one is defined.&nbsp; Otherwise, the current working
 directory is used.&nbsp; They are listed in the order examined:&nbsp; <tt> TMP</tt>, <tt> TEMP</tt>, <tt> TMPDIR</tt>, and
 <tt> TEMPDIR</tt>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> tmpfile</tt> function returns a pointer to the stream of the file that it created.&nbsp; If the file cannot be created,
 the<tt> tmpfile</tt> function returns<tt> NULL.</tt>&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating
 the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#fopen_s">fopen_s</a>, <a href="#freopen">freopen</a>, <a href="#freopen_s">freopen_s</a>,
 <a href="#mkstemp">mkstemp</a>, <a href="#_mktemp">_mktemp</a>, <a href="#_tempnam">_tempnam</a>, <a href="#tmpfile_s">tmpfile_s</a>,
 <a href="#tmpnam">tmpnam</a>, <a href="#tmpnam_s">tmpnam_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>static FILE *TempFile;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; TempFile = tmpfile();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( TempFile );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="tmpfile_s"> tmpfile_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>errno_t tmpfile_s( FILE * restrict * restrict streamptr);</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 tmpfile_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br><b>streamptr</b> shall not be a null pointer.&nbsp; If there is a runtime-constraint violation,<tt> tmpfile_s</tt> does
 not attempt to create a file.
</dl>
<dl>
<dt>Description:
<dd>The<tt> tmpfile_s</tt> function creates a temporary binary file that is different from any other existing file and that will
 automatically be removed when it is closed or at program termination.&nbsp; If the program terminates abnormally, whether
 an open temporary file is removed is implementation-defined.&nbsp; The file is opened for update with &quot;wb+&quot; mode
 with the meaning that mode has in the fopen_s function (including the mode's effect on exclusive access and file permissions).
&nbsp; If the file was created successfully, then the pointer to FILE pointed to by<b> streamptr</b> will be set to the pointer
 to the object controlling the opened file.&nbsp; Otherwise, the pointer to FILE pointed to by<b> streamptr</b> will be set
 to a null pointer.&nbsp; For all systems except NetWare, the temporary file is located in the path specified by one of the
 following environment variables, if one is defined.&nbsp; Otherwise, the current working directory is used.&nbsp; They are
 listed in the order examined:&nbsp; <tt> TMP</tt>, <tt> TEMP</tt>, <tt> TMPDIR</tt>, and <tt> TEMPDIR</tt>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> tmpfile_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#fopen_s">fopen_s</a>, <a href="#freopen">freopen</a>, <a href="#freopen_s">freopen_s</a>,
 <a href="#mkstemp">mkstemp</a>, <a href="#_mktemp">_mktemp</a>, <a href="#_tempnam">_tempnam</a>, <a href="#tmpfile">tmpfile</a>,
 <a href="#tmpnam">tmpnam</a>, <a href="#tmpnam_s">tmpnam_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errno_t rc;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *TempFile;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = tmpfile_s( &amp;TempFile );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( rc == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( TempFile );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>TR 24731
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="tmpnam_s"> tmpnam_s, _wtmpnam_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>errno_t tmpnam_s( char * s, rsize_t maxsize );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>errno_t _wtmpnam_s( wchar_t * s, rsize_t maxsize );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 tmpnam_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br><b>s</b> shall not be a null pointer.<b>&nbsp; maxsize</b> shall be less than or equal to <tt> RSIZE_MAX</tt>.<b>&nbsp;
 maxsize</b> shall be greater than the length of the generated file name string.
</dl>
<dl>
<dt>Description:
<dd>The<tt> tmpnam_s</tt> function generates a string that is a valid file name and that is not the same as the name of an existing
 file.&nbsp; The function is potentially capable of generating <tt> TMP_MAX_S</tt> different strings, but any or all of them
 may already be in use by existing files and thus not be suitable return values.&nbsp; The lengths of these strings shall
 be less than the value of the <tt> L_tmpnam_s</tt> macro.&nbsp; The<tt> tmpnam_s</tt> function generates a different string
 each time it is called.
<br>The<tt> _wtmpnam_s</tt> function is identical to<tt> tmpnam_s</tt> except that it generates a unique wide-character string
 for the file name.
</dl>
<dl>
<dt>Returns:
<dd>If no suitable string can be generated, or if there is a runtime-constraint violation, the<tt> tmpnam_s</tt> function writes
 a null character to<b> s&#91;0&#93;</b> (only if<b> s</b> is not null and<b> maxsize</b> is greater than zero) and returns
 a non-zero value.&nbsp; Otherwise, the<tt> tmpnam_s</tt> function writes the string in the array pointed to by<b> s</b> and
 returns zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#fopen_s">fopen_s</a>, <a href="#freopen">freopen</a>, <a href="#freopen_s">freopen_s</a>,
 <a href="#mkstemp">mkstemp</a>, <a href="#_mktemp">_mktemp</a>, <a href="#_tempnam">_tempnam</a>, <a href="#tmpfile">tmpfile</a>,
 <a href="#tmpfile_s">tmpfile_s</a>, <a href="#tmpnam">tmpnam</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; filename&#91; L_tmpnam_s &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp; *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errno_t rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = tmpnam( filename, sizeof( filename ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( rc == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fp = fopen( filename, &quot;w+b&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remove( filename );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>tmpnam_s is TR 24731
<br>_wtmpnam_s is WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> tmpnam_s - All, Netware</tt>
<br><tt>_wtmpnam_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="tmpnam"> tmpnam, _wtmpnam </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>char *tmpnam( char *buffer );</tt>
<br><tt>wchar_t *_wtmpnam( wchar_t *buffer );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#tmpnam_s">tmpnam_s</a> function which is a safer alternative to<tt> tmpnam</tt>.
&nbsp; This newer<tt> tmpnam_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> tmpnam</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> tmpnam</tt> function generates a unique string for use as a valid file name.&nbsp; The<tt> _wtmpnam</tt> function
 is identical to<tt> tmpnam</tt> except that it generates a unique wide-character string for the file name.&nbsp; An internal
 static buffer is used to construct the filename.&nbsp; Subsequent calls to<tt> tmpnam</tt> reuse the internal buffer.
<br>The function generates unique filenames for up to <tt> TMP_MAX</tt> calls.
</dl>
<dl>
<dt>Returns:
<dd>If the argument<b> buffer</b> is a NULL pointer,<tt> tmpnam</tt> returns a pointer to an internal buffer containing the temporary
 file name.&nbsp; If the argument<b> buffer</b> is not a NULL pointer,<tt> tmpnam</tt> copies the temporary file name from
 the internal buffer to the specified buffer and returns a pointer to the specified buffer.&nbsp; It is assumed that the specified
 buffer is an array of at least <tt> L_tmpnam</tt> characters.
<br>If the argument<b> buffer</b> is a NULL pointer, you may wish to duplicate the resulting string since subsequent calls
 to<tt> tmpnam</tt> reuse the internal buffer.&nbsp; 
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; char *name1, *name2;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; name1 = strdup( tmpnam( NULL ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; name2 = strdup( tmpnam( NULL ) );</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#fopen">fopen</a>, <a href="#fopen_s">fopen_s</a>, <a href="#freopen">freopen</a>, <a href="#freopen_s">freopen_s</a>,
 <a href="#mkstemp">mkstemp</a>, <a href="#_mktemp">_mktemp</a>, <a href="#_tempnam">_tempnam</a>, <a href="#tmpfile">tmpfile</a>,
 <a href="#tmpfile_s">tmpfile_s</a>, <a href="#tmpnam_s">tmpnam_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char filename&#91; L_tmpnam &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; tmpnam( filename );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( filename, &quot;w+b&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* . */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; remove( filename );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>tmpnam is ANSI
<br>_wtmpnam is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> tmpnam - All, Netware</tt>
<br><tt>_wtmpnam - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="tolower"> tolower, _tolower, towlower </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int tolower( int c );</tt>
<br><tt>int _tolower( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>wint_t towlower( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> tolower</tt> function converts<b> c</b> to a lowercase letter if<b> c</b> represents an uppercase letter.
<br>The<tt> _tolower</tt> function is a version of<tt> tolower</tt> to be used only when<b> c</b> is known to be uppercase.
<br><br>The<tt> towlower</tt> function is similar to<tt> tolower</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> tolower</tt> function returns the corresponding lowercase letter when the argument is an uppercase letter; otherwise,
 the original character is returned.&nbsp; The<tt> towlower</tt> function returns the corresponding wide-character lowercase
 letter when the argument is a wide-character uppercase letter; otherwise, the original wide character is returned.
<br>The result of<tt> _tolower</tt> is undefined if<b> c</b> is not an uppercase letter.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>,
 <a href="#isprint">isprint</a>, <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>,
 <a href="#iswctype">iswctype</a>, <a href="#isxdigit">isxdigit</a>, <a href="#toupper">toupper</a>, <a href="#towctrans">towctrans</a>,
 <a href="#strlwr">strlwr</a>, <a href="#strupr">strupr</a>, <a href="#toupper">toupper</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'A',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '5',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '$',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'Z'</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c &quot;, tolower( chars&#91; i &#93; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>a 5 $ z</tt>
</dl>
<dl>
<dt>Classification:
<dd>tolower is ANSI
<br>_tolower is not ANSI
<br>towlower is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> tolower - All, Netware</tt>
<br><tt>_tolower - All, Netware</tt>
<br><tt>towlower - All, Netware</tt>
</dl>
<h2 id="toupper"> toupper, _toupper, towupper </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>int toupper( int c );</tt>
<br><tt>int _toupper( int c );</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>wint_t towupper( wint_t c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> toupper</tt> function converts<b> c</b> to a uppercase letter if<b> c</b> represents a lowercase letter.
<br>The<tt> _toupper</tt> function is a version of<tt> toupper</tt> to be used only when<b> c</b> is known to be lowercase.
<br><br>The<tt> towupper</tt> function is similar to<tt> toupper</tt> except that it accepts a wide-character argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> toupper</tt> function returns the corresponding uppercase letter when the argument is a lowercase letter; otherwise,
 the original character is returned.&nbsp; The<tt> towupper</tt> function returns the corresponding wide-character uppercase
 letter when the argument is a wide-character lowercase letter; otherwise, the original wide character is returned.
<br>The result of<tt> _toupper</tt> is undefined if<b> c</b> is not a lowercase letter.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>,
 <a href="#isprint">isprint</a>, <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>,
 <a href="#iswctype">iswctype</a>, <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#towctrans">towctrans</a>,
 <a href="#strlwr">strlwr</a>, <a href="#strupr">strupr</a>, <a href="#tolower">tolower</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>char chars&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'a',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '5',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; '$',</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 'z'</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( chars ) / sizeof( char )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; i;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%c &quot;, toupper( chars&#91; i &#93; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>A 5 $ Z</tt>
</dl>
<dl>
<dt>Classification:
<dd>toupper is ANSI
<br>_toupper is not ANSI
<br>towupper is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> toupper - All, Netware</tt>
<br><tt>_toupper - All, Netware</tt>
<br><tt>towupper - All, Netware</tt>
</dl>
<h2 id="towctrans"> towctrans </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>wint_t towctrans( wint_t wc, wctrans_t desc );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> towctrans</tt> function maps the wide character<b> wc</b> using the mapping described by<b> desc</b>.&nbsp; Valid
 values of<b> desc</b> are defined by the use of the <tt> wctrans</tt> function.
<br>The two expressions listed below behave the same as a call to the wide character case mapping function shown.
<dl>
<dt>Expression&nbsp;&nbsp;&nbsp;&nbsp; Equivalent
<dt>towctrans(wc, wctrans(&quot;tolower&quot;))
<dd>towlower(wc)
<dt><br>towctrans(wc, wctrans(&quot;toupper&quot;))
<dd>towupper(wc)
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> towctrans</tt> function returns the mapped value of<b> wc</b> using the mapping described by<b> desc</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>,
 <a href="#isprint">isprint</a>, <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>,
 <a href="#iswctype">iswctype</a>, <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><br><tt>char *translations&#91;2&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;tolower&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;toupper&quot;</tt>
<br><tt>};</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wint_t&nbsp; wc = 'A';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wint_t&nbsp; twc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 2; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; twc = towctrans( wc, wctrans( translations&#91;i&#93; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%lc): %lc\n&quot;, translations&#91;i&#93;, wc, twc );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>tolower(A): a</tt>
<br><tt>toupper(A): A</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="tzset"> tzset </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;time.h&gt;</tt>
<br><tt>void tzset( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> tzset</tt> function sets the global variables <tt> daylight</tt>, <tt> timezone</tt> and <tt> tzname</tt> according
 to the value of the <tt> TZ</tt> environment variable.&nbsp; The section<b> The TZ Environment Variable</b> describes how
 to set this variable.
<br>Under Win32,<tt> tzset</tt> also uses operating system supplied time zone information.&nbsp; The <tt> TZ</tt> environment
 variable can be used to override this information.
<br><br>The global variables have the following values after<tt> tzset</tt> is executed:
<dl>
<dt>daylight
<dd>Zero indicates that daylight saving time is not supported in the locale; a non-zero value indicates that daylight saving time
 is supported in the locale.&nbsp; This variable is cleared/set after a call to the<tt> tzset</tt> function depending on whether
 a daylight saving time abbreviation is specified in the <tt> TZ</tt> environment variable.
<dt><br>timezone
<dd>Contains the number of seconds that the local time zone is earlier than Coordinated Universal Time (UTC) (formerly known as
 Greenwich Mean Time (GMT)).
<dt><br>tzname
<dd>Two-element array pointing to strings giving the abbreviations for the name of the time zone when standard and daylight saving
 time are in effect.
</dl>
<br>The time set on the computer with the DOS<tt> time</tt> command and the DOS<tt> date</tt> command reflects the local time.
&nbsp; The environment variable<tt> TZ</tt> is used to establish the time zone to which this local time applies.&nbsp; See
 the section<b> The TZ Environment Variable</b> for a discussion of how to set the time zone.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> tzset</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#ctime">ctime</a> Functions, <a href="#localtime">localtime</a>, <a href="#mktime">mktime</a>, <a href="#strftime">strftime</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;env.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>void print_zone()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *tz;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;TZ: %s\n&quot;, (tz = getenv( &quot;TZ&quot; ))</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 ? tz : &quot;default EST5EDT&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; daylight: %d\n&quot;, daylight );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; timezone: %ld\n&quot;, timezone );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;&nbsp; time zone names: %s %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tzname&#91;0&#93;, tzname&#91;1&#93; );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_zone();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; setenv( &quot;TZ&quot;, &quot;PST8PDT&quot;, 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tzset();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_zone();</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>TZ: default EST5EDT</tt>
<br><tt>&nbsp; daylight: 1</tt>
<br><tt>&nbsp; timezone: 18000</tt>
<br><tt>&nbsp; time zone names: EST EDT</tt>
<br><tt>TZ: PST8PDT</tt>
<br><tt>&nbsp; daylight: 1</tt>
<br><tt>&nbsp; timezone: 28800</tt>
<br><tt>&nbsp; time zone names: PST PDT</tt>
</dl>
<dl>
<dt>Classification:
<dd>POSIX 1003.1
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="ulltoa"> ulltoa, _ulltoa, _ulltow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>char *ulltoa( unsigned long long int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
<br><tt>char *_ulltoa( unsigned long long int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
<br><tt>wchar_t *_ulltow( unsigned long long int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ulltoa</tt> function converts the unsigned binary integer<b> value</b> into the equivalent string in base<b> radix</b>
 notation storing the result in the character array pointed to by<b> buffer</b>.&nbsp; A null character is appended to the
 result.&nbsp; The size of<b> buffer</b> must be at least 65 bytes when converting values in base 2.&nbsp; The value of<b>
 radix</b> must satisfy the condition:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2 &lt;= radix &lt;= 36</tt>
<br><br>The<tt> _ulltoa</tt> function is identical to<tt> ulltoa</tt>.&nbsp; Use<tt> _ulltoa</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _ulltow</tt> function is identical to<tt> ulltoa</tt> except that it produces a wide-character string (which
 is twice as long).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ulltoa</tt> function returns the pointer to the result.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#atoll">atoll</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>,
 <a href="#lltoa">lltoa</a>, <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoul">strtoul</a>,
 <a href="#strtoull">strtoull</a>, <a href="#strtoimax">strtoimax</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ultoa">ultoa</a>,
 <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void print_value( unsigned long long int value )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int base;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;65&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( base = 2; base &lt;= 16; base = base + 2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2d %s\n&quot;, base,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ultoa( value, buffer, base
 ) );</tt>
<br><tt>}</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_value( (unsigned long long) 1234098765LL );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt> 2 1001001100011101101101001001101</tt>
<br><tt> 4 1021203231221031</tt>
<br><tt> 6 322243004113</tt>
<br><tt> 8 11143555115</tt>
<br><tt>10 1234098765</tt>
<br><tt>12 2a5369639</tt>
<br><tt>14 b9c8863b</tt>
<br><tt>16 498eda4d</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_ulltoa conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> ulltoa - All, Netware</tt>
<br><tt>_ulltoa - All, Netware</tt>
<br><tt>_ulltow - All</tt>
</dl>
<h2 id="ultoa"> ultoa, _ultoa, _ultow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>char *ultoa( unsigned long int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
<br><tt>char *_ultoa( unsigned long int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
<br><tt>wchar_t *_ultow( unsigned long int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ultoa</tt> function converts the unsigned binary integer<b> value</b> into the equivalent string in base<b> radix</b>
 notation storing the result in the character array pointed to by<b> buffer</b>.&nbsp; A null character is appended to the
 result.&nbsp; The size of<b> buffer</b> must be at least 33 bytes when converting values in base 2.&nbsp; The value of<b>
 radix</b> must satisfy the condition:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2 &lt;= radix &lt;= 36</tt>
<br><br>The<tt> _ultoa</tt> function is identical to<tt> ultoa</tt>.&nbsp; Use<tt> _ultoa</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _ultow</tt> function is identical to<tt> ultoa</tt> except that it produces a wide-character string (which
 is twice as long).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ultoa</tt> function returns the pointer to the result.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#atoll">atoll</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>,
 <a href="#lltoa">lltoa</a>, <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoul">strtoul</a>,
 <a href="#strtoull">strtoull</a>, <a href="#strtoimax">strtoimax</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ulltoa">ulltoa</a>,
 <a href="#utoa">utoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void print_value( unsigned long int value )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int base;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;33&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( base = 2; base &lt;= 16; base = base + 2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2d %s\n&quot;, base,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ultoa( value, buffer, base
 ) );</tt>
<br><tt>}</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; print_value( (unsigned) 12765L );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt> 2 11000111011101</tt>
<br><tt> 4 3013131</tt>
<br><tt> 6 135033</tt>
<br><tt> 8 30735</tt>
<br><tt>10 12765</tt>
<br><tt>12 7479</tt>
<br><tt>14 491b</tt>
<br><tt>16 31dd</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_ultoa conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> ultoa - All, Netware</tt>
<br><tt>_ultoa - All, Netware</tt>
<br><tt>_ultow - All</tt>
</dl>
<h2 id="umask"> umask, _umask </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int umask( int cmask );</tt>
<br><tt>int _umask( int cmask );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> umask</tt> function sets the process's file mode creation mask to<b> cmask</b>.&nbsp; The process's file mode creation
 mask is used during <tt> creat</tt>, <tt> open</tt> or <tt> sopen</tt> to turn off permission bits in the<b> permission</b>
 argument supplied.&nbsp; In other words, if a bit in the mask is on, then the corresponding bit in the file's requested permission
 value is disallowed.
<br>The<tt> _umask</tt> function is identical to<tt> umask</tt>.&nbsp; Use<tt> _umask</tt> for ANSI/ISO naming conventions.
<br><br>The argument<b> cmask</b> is a constant expression involving the constants described below.&nbsp; The access permissions
 for the file or directory are specified as a combination of bits (defined in the<tt> &lt;sys\stat.h&gt;</tt> header file).
<br><br>The following bits define permissions for the owner.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXU
<dd>Read, write, execute/search
<dt><br>S_IRUSR
<dd>Read permission
<dt><br>S_IWUSR
<dd>Write permission
<dt><br>S_IXUSR
<dd>Execute/search permission
</dl>
<br>The following bits define permissions for the group.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXG
<dd>Read, write, execute/search
<dt><br>S_IRGRP
<dd>Read permission
<dt><br>S_IWGRP
<dd>Write permission
<dt><br>S_IXGRP
<dd>Execute/search permission
</dl>
<br>The following bits define permissions for others.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IRWXO
<dd>Read, write, execute/search
<dt><br>S_IROTH
<dd>Read permission
<dt><br>S_IWOTH
<dd>Write permission
<dt><br>S_IXOTH
<dd>Execute/search permission
</dl>
<br>The following bits define miscellaneous permissions used by other implementations.
<dl>
<dt>Permission&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>S_IREAD
<dd>is equivalent to S_IRUSR (read permission)
<dt><br>S_IWRITE
<dd>is equivalent to S_IWUSR (write permission)
<dt><br>S_IEXEC
<dd>is equivalent to S_IXUSR (execute/search permission)
</dl>
<br>For example, if <tt> S_IRUSR</tt> is specified, then reading is not allowed (i.e., the file is write only).&nbsp; If <tt>
 S_IWUSR</tt> is specified, then writing is not allowed (i.e., the file is read only).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> umask</tt> function returns the previous value of<b> cmask</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#chmod">chmod</a>, <a href="#creat">creat</a>, <a href="#mkdir">mkdir</a>, <a href="#open">open</a>, <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;sys/types.h&gt;</tt>
<br><tt>#include &lt;sys/stat.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int old_mask;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* set mask to create read-only files */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; old_mask = umask( S_IWUSR | S_IWGRP | S_IWOTH |</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; S_IXUSR | S_IXGRP | S_IXOTH );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>umask is POSIX 1003.1
<br>_umask is not POSIX
<br>_umask conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> umask - All, Netware</tt>
<br><tt>_umask - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="ungetc"> ungetc, ungetwc </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int ungetc( int c, FILE *fp );</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>wint_t ungetwc( wint_t c, FILE *fp );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ungetc</tt> function pushes the character specified by<b> c</b> back onto the input stream pointed to by<b> fp</b>.
&nbsp; This character will be returned by the next read on the stream.&nbsp; The pushed-back character will be discarded if
 a call is made to the <tt> fflush</tt> function or to a file positioning function (<tt> fseek</tt>, <tt> fsetpos</tt> or
 <tt> rewind</tt>) before the next read operation is performed.
<br>Only one character (the most recent one) of pushback is remembered.
<br><br>The<tt> ungetc</tt> function clears the end-of-file indicator, unless the value of<b> c</b> is <tt> EOF</tt>.
<br><br>The<tt> ungetwc</tt> function is identical to<tt> ungetc</tt> except that it pushes the wide character specified by<b>
 c</b> back onto the input stream pointed to by<b> fp</b>.
<br><br>The<tt> ungetwc</tt> function clears the end-of-file indicator, unless the value of<b> c</b> is <tt> WEOF</tt>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ungetc</tt> function returns the character pushed back.
</dl>
<dl>
<dt>See Also:
<dd><a href="#fgetc">fgetc</a>, <a href="#fgetchar">fgetchar</a>, <a href="#fgets">fgets</a>, <a href="#fopen">fopen</a>, <a href="#getc">getc</a>,
 <a href="#getchar">getchar</a>, <a href="#gets">gets</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; FILE *fp;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long value;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fp = fopen( &quot;file&quot;, &quot;r&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; value = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; c = fgetc( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( isdigit(c) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = value*10 + c - '0';</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = fgetc( fp );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ungetc( c, fp ); /* put last character back */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Value=%ld\n&quot;, value );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fclose( fp );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ungetc is ANSI
<br>ungetwc is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> ungetc - All, Netware</tt>
<br><tt>ungetwc - All</tt>
</dl>
<h2 id="ungetch"> ungetch </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>int ungetch( int c );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> ungetch</tt> function pushes the character specified by<b> c</b> back onto the input stream for the console.&nbsp;
 This character will be returned by the next read from the console (with <tt> getch</tt> or <tt> getche</tt> functions) and
 will be detected by the function <tt> kbhit</tt>.&nbsp; Only the last character returned in this way is remembered.
<br>The<tt> ungetch</tt> function clears the end-of-file indicator, unless the value of<b> c</b> is <tt> EOF</tt>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> ungetch</tt> function returns the character pushed back.
</dl>
<dl>
<dt>See Also:
<dd><a href="#getch">getch</a>, <a href="#getche">getche</a>, <a href="#kbhit">kbhit</a>, <a href="#putch">putch</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;ctype.h&gt;</tt>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int c;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; long value;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; value = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; c = getche();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( isdigit( c ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; value = value*10 + c - '0';</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c = getche();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; ungetch( c );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Value=%ld\n&quot;, value );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="unlink"> unlink, _unlink, _wunlink </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int unlink( const char *path );</tt>
<br><tt>int _unlink( const char *path );</tt>
<br><tt>int _wunlink( const wchar_t *path );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> unlink</tt> function deletes the file whose name is the string pointed to by<b> path</b>.&nbsp; This function is equivalent
 to the <tt> remove</tt> function.
<br>The<tt> _unlink</tt> function is identical to<tt> unlink</tt>.&nbsp; Use<tt> _unlink</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _wunlink</tt> function is identical to<tt> unlink</tt> except that it accepts a wide-character string argument.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> unlink</tt> function returns zero if the operation succeeds, non-zero if it fails.
</dl>
<dl>
<dt>See Also:
<dd><a href="#chdir">chdir</a>, <a href="#chmod">chmod</a>, <a href="#close">close</a>, <a href="#getcwd">getcwd</a>, <a href="#mkdir">mkdir</a>,
 <a href="#open">open</a>, <a href="#remove">remove</a>, <a href="#rename">rename</a>, <a href="#rmdir">rmdir</a>, <a href="#stat">stat</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unlink( &quot;vm.tmp&quot; );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>unlink is POSIX 1003.1
<br>_unlink is not POSIX
<br>_wunlink is not POSIX
<br>_unlink conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> unlink - All, Netware</tt>
<br><tt>_unlink - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wunlink - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="unlock"> unlock </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int unlock( int handle,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long offset,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long nbytes );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> unlock</tt> function unlocks<b> nbytes</b> amount of previously locked data in the file designated by<b> handle</b>
 starting at byte<b> offset</b> in the file.&nbsp; This allows other processes to lock this region of the file.
<br>Multiple regions of a file can be locked, but no overlapping regions are allowed.&nbsp; You cannot unlock multiple regions
 in the same call, even if the regions are contiguous.&nbsp; All locked regions of a file should be unlocked before closing
 a file or exiting the program.
<br><br>With DOS, locking is supported by version 3.0 or later.&nbsp; Note that<tt> SHARE.COM</tt> or<tt> SHARE.EXE</tt> must
 be installed.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> unlock</tt> function returns zero if successful, and -1 when an error occurs.&nbsp; When an error has occurred, <tt>
 errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#lock">lock</a>, <a href="#locking">locking</a>, <a href="#open">open</a>, <a href="#sopen">sopen</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;20&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;, O_RDWR | O_TEXT );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( lock( handle, 0L, 20L ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Lock failed\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read( handle, buffer, 20 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* update the buffer here */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lseek( handle, 0L, SEEK_SET );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( handle, buffer, 20 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unlock( handle, 0L, 20L );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="_unregisterfonts"> _unregisterfonts </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>void _FAR _unregisterfonts( void );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _unregisterfonts</tt> function frees the memory previously allocated by the <tt> _registerfonts</tt> function.&nbsp;
 The currently selected font is also unloaded.
<br>Attempting to use the <tt> _setfont</tt> function after calling<tt> _unregisterfonts</tt> will result in an error.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _unregisterfonts</tt> function does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_setfont">_setfont</a>, <a href="#_getfontinfo">_getfontinfo</a>,
 <a href="#_outgtext">_outgtext</a>, <a href="#_getgtextextent">_getgtextextent</a>, <a href="#_setgtextvector">_setgtextvector</a>,
 <a href="#_getgtextvector">_getgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i, n;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 10 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _VRES16COLOR );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; n = _registerfonts( &quot;*.fon&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; n; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;n%d&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _setfont( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _moveto( 100, 100 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outgtext( &quot;WATCOM Graphics&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _clearscreen( _GCLEARSCREEN );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _unregisterfonts();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="utime"> utime, _utime, _wutime </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;sys/utime.h&gt;</tt>
<br><tt>int utime( const char *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct utimbuf *times );</tt>
<br><tt>int _utime( const char *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct utimbuf *times );</tt>
<br><tt>int _wutime( const wchar_t *path,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const struct utimbuf *times );</tt>
<br><br><tt>struct utimbuf {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp; actime;&nbsp;&nbsp;&nbsp; /* access time */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp; modtime;&nbsp;&nbsp; /* modification time */</tt>
<br><tt>};</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> utime</tt> function records the access and modification times for the file identified by<b> path</b>.
<br>The<tt> _utime</tt> function is identical to<tt> utime</tt>.&nbsp; Use<tt> _utime</tt> for ANSI naming conventions.
<br><br>If the<b> times</b> argument is<tt> NULL</tt>, the access and modification times of the file or directory are set
 to the current time.&nbsp; Write access to this file must be permitted for the time to be recorded.
<br><br>If the<b> times</b> argument is not<tt> NULL</tt>, it is interpreted as a pointer to a <tt> utimbuf</tt> structure
 and the access and modification times of the file or directory are set to the values contained in the designated structure.
&nbsp; The access and modification times are taken from the <tt> actime</tt> and <tt> modtime</tt> fields in this structure.
<br><br>The<tt> _wutime</tt> function is identical to<tt> utime</tt> except that<b> path</b> points to a wide-character string.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> utime</tt> function returns zero when the time was successfully recorded.&nbsp; A value of -1 indicates an error occurred.
</dl>
<dl>
<dt>Errors:
<dd>When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>EACCES
<dd>Search permission is denied for a component of<b> path</b> or the<b> times</b> argument is<tt> NULL</tt> and the effective
 user ID of the process does not match the owner of the file and write access is denied.
<dt><br>EINVAL
<dd>The date is before 1980 (DOS only).
<dt><br>EMFILE
<dd>There are too many open files.
<dt><br>ENOENT
<dd>The specified<b> path</b> does not exist or<b> path</b> is an empty string.
</dl>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;sys/utime.h&gt;</tt>
<br><br><tt>void main( int argc, char *argv&#91;&#93; )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( (utime( argv&#91;1&#93;, NULL ) != 0) &amp;&amp; (argc &gt; 1) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Unable to set time for %s\n&quot;, argv&#91;1&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>utime is POSIX 1003.1
<br>_utime is not POSIX
<br>_wutime is not POSIX
</dl>
<dl>
<dt>Systems:
<dd><tt> utime - All, Netware</tt>
<br><tt>_utime - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_wutime - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="utoa"> utoa, _utoa, _utow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>char *utoa( unsigned int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
<br><tt>char *_utoa( unsigned int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
<br><tt>wchar_t *_utow( unsigned int value,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t *buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int radix );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> utoa</tt> function converts the unsigned binary integer<b> value</b> into the equivalent string in base<b> radix</b>
 notation storing the result in the character array pointed to by<b> buffer</b>.&nbsp; A null character is appended to the
 result.&nbsp; The size of<b> buffer</b> must be at least (8 * sizeof(int) + 1) bytes when converting values in base 2.&nbsp;
 That makes the size 17 bytes on 16-bit machines, and 33 bytes on 32-bit machines.&nbsp; The value of<b> radix</b> must satisfy
 the condition:
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; 2 &lt;= radix &lt;= 36</tt>
<br><br>The<tt> _utoa</tt> function is identical to<tt> utoa</tt>.&nbsp; Use<tt> _utoa</tt> for ANSI/ISO naming conventions.
<br><br>The<tt> _utow</tt> function is identical to<tt> utoa</tt> except that it produces a wide-character string (which is
 twice as long).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> utoa</tt> function returns the pointer to the result.
</dl>
<dl>
<dt>See Also:
<dd><a href="#atoi">atoi</a>, <a href="#atol">atol</a>, <a href="#atoll">atoll</a>, <a href="#itoa">itoa</a>, <a href="#ltoa">ltoa</a>,
 <a href="#lltoa">lltoa</a>, <a href="#sscanf">sscanf</a>, <a href="#strtol">strtol</a>, <a href="#strtoll">strtoll</a>, <a href="#strtoul">strtoul</a>,
 <a href="#strtoull">strtoull</a>, <a href="#strtoimax">strtoimax</a>, <a href="#strtoumax">strtoumax</a>, <a href="#ultoa">ultoa</a>,
 <a href="#ulltoa">ulltoa</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int base;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buffer&#91;18&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( base = 2; base &lt;= 16; base = base + 2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%2d %s\n&quot;, base,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; utoa( (unsigned) 12765,
 buffer, base ) );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt> 2 11000111011101</tt>
<br><tt> 4 3013131</tt>
<br><tt> 6 135033</tt>
<br><tt> 8 30735</tt>
<br><tt>10 12765</tt>
<br><tt>12 7479</tt>
<br><tt>14 491b</tt>
<br><tt>16 31dd</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
<br>_utoa conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> utoa - All, Netware</tt>
<br><tt>_utoa - All, Netware</tt>
<br><tt>_utow - All</tt>
</dl>
<h2 id="va_arg"> va_arg </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>type va_arg( va_list param, type );</tt>
</dl>
<dl>
<dt>Description:
<dd><tt> va_arg</tt> is a macro that can be used to obtain the next argument in a list of variable arguments.&nbsp; It must be
 used with the associated macros <tt> va_start</tt> and <tt> va_end</tt>.&nbsp; A sequence such as
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; void example( char *dst, ... )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list curr_arg;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int next_arg;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( curr_arg, dst );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next_arg = va_arg( curr_arg, int );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .</tt>
<br><br>causes<tt> next_arg</tt> to be assigned the value of the next variable argument.&nbsp; The argument<b> type</b> (which
 is <tt> int</tt> in the example) is the type of the argument originally passed to the function.
<br><br>The macro <tt> va_start</tt> must be executed first in order to properly initialize the variable<tt> curr_arg</tt>
 and the macro <tt> va_end</tt> should be executed after all arguments have been obtained.
<br><br>The data item<tt> curr_arg</tt> is of type <tt> va_list</tt> which contains the information to permit successive acquisitions
 of the arguments.
</dl>
<dl>
<dt>Returns:
<dd>The macro returns the value of the next variable argument, according to type passed as the second parameter.
</dl>
<dl>
<dt>See Also:
<dd><a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vprintf">vprintf</a>,
 <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><br><tt>static void test_fn(</tt>
<br><tt>&nbsp; const char *msg,&nbsp;&nbsp; /* message to be printed&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; const char *types, /* parameter types (i,s)&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp; ... )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* variable arguments&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list&nbsp;&nbsp;&nbsp;&nbsp; argument;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg_int;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *arg_string;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const char&nbsp; *types_ptr;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; types_ptr = types;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n%s -- %s\n&quot;, msg, types );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_start( argument, types );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( *types_ptr != '\0' ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (*types_ptr == 'i') {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg_int = va_arg( argument, int );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;integer: %d\n&quot;, arg_int );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if (*types_ptr == 's') {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg_string = va_arg( argument, char * );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;string:&nbsp; %s\n&quot;, arg_string
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++types_ptr;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( argument );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;VA...TEST\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; test_fn( &quot;PARAMETERS: 1, \&quot;abc\&quot;, 546&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;isi&quot;, 1, &quot;abc&quot;, 546
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; test_fn( &quot;PARAMETERS: \&quot;def\&quot;, 789&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;si&quot;, &quot;def&quot;, 789 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>VA...TEST</tt>
<br><br><tt>PARAMETERS: 1, &quot;abc&quot;, 546 -- isi</tt>
<br><tt>integer: 1</tt>
<br><tt>string:&nbsp; abc</tt>
<br><tt>integer: 546</tt>
<br><br><tt>PARAMETERS: &quot;def&quot;, 789 -- si</tt>
<br><tt>string:&nbsp; def</tt>
<br><tt>integer: 789</tt>
</dl>
<dl>
<dt>Classification:
<dd>ISO C90
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="va_end"> va_end </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>void va_end( va_list param );</tt>
</dl>
<dl>
<dt>Description:
<dd><tt> va_end</tt> is a macro used to complete the acquisition of arguments from a list of variable arguments.&nbsp; It must
 be used with the associated macros <tt> va_start</tt> and <tt> va_arg</tt>.&nbsp; See the description for <tt> va_arg</tt>
 for complete documentation on these macros.
</dl>
<dl>
<dt>Returns:
<dd>The macro does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#va_arg">va_arg</a>, <a href="#va_start">va_start</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vprintf">vprintf</a>,
 <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>#define ESCAPE 27</tt>
<br><br><tt>void tprintf( int row, int col, char *fmt, ... )</tt>
<br><tt> {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto va_list ap;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *p1, *p2;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( ap, fmt );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p1 = va_arg( ap, char * );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p2 = va_arg( ap, char * );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%c&#91;%2.2d;%2.2dH&quot;, ESCAPE, row, col );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( fmt, p1, p2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( ap );</tt>
<br><tt> }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct tm&nbsp; time_of_day;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp; ltime;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char&nbsp; buf&#91;26&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; time( &amp;ltime );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _localtime( &amp;ltime, &amp;time_of_day );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tprintf( 12, 1, &quot;Date and time is: %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asctime( &amp;time_of_day, buf ) );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="va_start"> va_start </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>void va_start( va_list param, previous );</tt>
</dl>
<dl>
<dt>Description:
<dd><tt> va_start</tt> is a macro used to start the acquisition of arguments from a list of variable arguments.&nbsp; The<b> param</b>
 argument is used by the <tt> va_arg</tt> macro to locate the current acquired argument.&nbsp; The<b> previous</b> argument
 is the argument that immediately precedes the<tt> &quot;...&quot;</tt> notation in the original function definition.&nbsp;
 It must be used with the associated macros <tt> va_arg</tt> and <tt> va_end</tt>.&nbsp; See the description of <tt> va_arg</tt>
 for complete documentation on these macros.
</dl>
<dl>
<dt>Returns:
<dd>The macro does not return a value.
</dl>
<dl>
<dt>See Also:
<dd><a href="#va_arg">va_arg</a>, <a href="#va_end">va_end</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vprintf">vprintf</a>,
 <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>#define ESCAPE 27</tt>
<br><br><tt>void tprintf( int row, int col, char *fmt, ... )</tt>
<br><tt> {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto va_list ap;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *p1, *p2;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( ap, fmt );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p1 = va_arg( ap, char * );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; p2 = va_arg( ap, char * );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%c&#91;%2.2d;%2.2dH&quot;, ESCAPE, row, col );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( fmt, p1, p2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( ap );</tt>
<br><tt> }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct tm&nbsp; time_of_day;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp; ltime;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char&nbsp; buf&#91;26&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; time( &amp;ltime );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _localtime( &amp;ltime, &amp;time_of_day );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tprintf( 12, 1, &quot;Date and time is: %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asctime( &amp;time_of_day, buf ) );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>MACRO
</dl>
<h2 id="_vbprintf"> _vbprintf, _vbwprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>int _vbprintf( char *buf, size_t bufsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format, va_list arg
 );</tt>
<br><tt>int _vbwprintf( wchar_t *buf, size_t bufsize,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,
 va_list arg );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _vbprintf</tt> function formats data under control of the<b> format</b> control string and writes the result to<b>
 buf</b>.&nbsp; The argument<b> bufsize</b> specifies the size of the character array<b> buf</b> into which the generated
 output is placed.&nbsp; The<b> format</b> string is described under the description of the <tt> printf</tt> function.&nbsp;
 The<tt> _vbprintf</tt> function is equivalent to the <tt> _bprintf</tt> function, with the variable argument list replaced
 with<b> arg</b>, which has been initialized by the <tt> va_start</tt> macro.
<br>The<tt> _vbwprintf</tt> function is identical to<tt> _vbprintf</tt> except that it accepts a wide-character string argument
 for<b> format</b> and produces wide-character output.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _vbprintf</tt> function returns the number of characters written, or a negative value if an output error occurred.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#va_arg">va_arg</a>, <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>,
 <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vprintf">vprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>The following shows the use of<tt> _vbprintf</tt> in a general error message routine.
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char msgbuf&#91;80&#93;;</tt>
<br><br><tt>char *fmtmsg( char *format, ... )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( msgbuf, &quot;Error: &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _vbprintf( &amp;msgbuf&#91;7&#93;, 73, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( msgbuf );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *msg;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; msg = fmtmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, msg );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _vbprintf - All, Netware</tt>
<br><tt>_vbwprintf - All</tt>
</dl>
<h2 id="vcprintf"> vcprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>int vcprintf( const char *format, va_list arg );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> vcprintf</tt> function writes output directly to the console under control of the argument<b> format</b>.&nbsp; The
 <tt> putch</tt> function is used to output characters to the console.&nbsp; The<b> format</b> string is described under the
 description of the <tt> printf</tt> function.&nbsp; The<tt> vcprintf</tt> function is equivalent to the <tt> cprintf</tt>
 function, with the variable argument list replaced with<b> arg</b>, which has been initialized by the <tt> va_start</tt>
 macro.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vcprintf</tt> function returns the number of characters written, or a negative value if an output error occurred.
&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#va_arg">va_arg</a>, <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>,
 <a href="#_vbprintf">_vbprintf</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vprintf">vprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;time.h&gt;</tt>
<br><br><tt>#define ESCAPE 27</tt>
<br><br><tt>void tprintf( int row, int col, char *format, ... )</tt>
<br><tt> {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; cprintf( &quot;%c&#91;%2.2d;%2.2dH&quot;, ESCAPE, row, col );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vcprintf( format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt> }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; struct tm&nbsp; time_of_day;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; time_t&nbsp;&nbsp;&nbsp;&nbsp; ltime;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; auto char&nbsp; buf&#91;26&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; time( &amp;ltime );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _localtime( &amp;ltime, &amp;time_of_day );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; tprintf( 12, 1, &quot;Date and time is: %s\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _asctime( &amp;time_of_day, buf ) );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="vcscanf"> vcscanf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>int vcscanf( const char *format, va_list args )</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> vcscanf</tt> function scans input from the console under control of the argument<b> format</b>.&nbsp; The<tt> vcscanf</tt>
 function uses the function <tt> getche</tt> to read characters from the console.&nbsp; The<b> format</b> string is described
 under the description of the <tt> scanf</tt> function.
<br>The<tt> vcscanf</tt> function is equivalent to the <tt> cscanf</tt> function, with a variable argument list replaced with<b>
 arg</b>, which has been initialized using the <tt> va_start</tt> macro.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vcscanf</tt> function returns <tt> EOF</tt> when the scanning is terminated by reaching the end of the input stream.
&nbsp; Otherwise, the number of input arguments for which values were successfully scanned and stored is returned.&nbsp; When
 a file input error occurs, the <tt> errno</tt> global variable may be set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cscanf">cscanf</a>, <a href="#fscanf">fscanf</a>, <a href="#scanf">scanf</a>, <a href="#sscanf">sscanf</a>, <a href="#va_arg">va_arg</a>,
 <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>, <a href="#vfscanf">vfscanf</a>, <a href="#vscanf">vscanf</a>,
 <a href="#vsscanf">vsscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><br><tt>void cfind( char *format, ... )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vcscanf( format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; cfind( &quot;%s %s %d %d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day, &amp;year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cprintf( &quot;\n%s, %s %d, %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="vfprintf"> vfprintf, vfwprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int vfprintf( FILE *fp,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int vfwprintf( FILE *fp,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#vfprintf_s">vfprintf_s</a> function which is a safer alternative to<tt>
 vfprintf</tt>.&nbsp; This newer<tt> vfprintf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 vfprintf</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vfprintf</tt> function writes output to the file pointed to by<b> fp</b> under control of the argument<b> format</b>.
&nbsp; The<b> format</b> string is described under the description of the <tt> printf</tt> function.&nbsp; The<tt> vfprintf</tt>
 function is equivalent to the <tt> fprintf</tt> function, with the variable argument list replaced with<b> arg</b>, which
 has been initialized by the <tt> va_start</tt> macro.
<br>The<tt> vfwprintf</tt> function is identical to<tt> vfprintf</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vfprintf</tt> function returns the number of characters written, or a negative value if an output error occurred.
&nbsp; The<tt> vfwprintf</tt> function returns the number of wide characters written, or a negative value if an output error
 occurred.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#va_arg">va_arg</a>, <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>,
 <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vprintf">vprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><br><tt>FILE *LogFile;</tt>
<br><br><tt>/* a general error routine */</tt>
<br><br><tt>void errmsg( char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fprintf( stderr, &quot;Error: &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vfprintf( stderr, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( LogFile != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf( LogFile, &quot;Error: &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vfprintf( LogFile, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; LogFile = fopen( &quot;error.log&quot;, &quot;w&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>vfprintf is ANSI
<br>vfwprintf is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> vfprintf - All, Netware</tt>
<br><tt>vfwprintf - All</tt>
</dl>
<h2 id="vfprintf_s"> vfprintf_s, vfwprintf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int vfprintf_s( FILE * restrict stream,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, va_list arg );</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int vfwprintf_s( FILE * restrict stream,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, va_list prg );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 vfprintf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> stream</b> nor<b> format</b> shall be a null pointer.&nbsp; The<tt> %n</tt> specifier (modified or not by flags,
 field width, or precision) shall not appear in the string pointed to by<b> format</b>.&nbsp; Any argument to<tt> vfprintf_s</tt>
 corresponding to a<tt> %s</tt> specifier shall not be a null pointer.
<br><br>If there is a runtime-constraint violation, the<tt> vfprintf_s</tt> function does not attempt to produce further output,
 and it is unspecified to what extent<tt> vfprintf_s</tt> produced output before discovering the runtime-constraint violation.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vfprintf_s</tt> function is equivalent to the <tt> vprintf</tt> function except for the explicit runtime-constraints
 listed above.
<br>The<tt> vfwprintf_s</tt> function is identical to<tt> vfprintf_s</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vfprintf_s</tt> function returns the number of characters written, or a negative value if an output error or runtime-constraint
 violation occurred.
<br>The<tt> vfwprintf_s</tt> function returns the number of wide characters written, or a negative value if an output error
 or runtime-constraint violation occurred.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>,
 <a href="#vprintf">vprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><br><tt>FILE *LogFile;</tt>
<br><br><tt>/* a general error routine */</tt>
<br><br><tt>void errmsg( char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; fprintf_s( stderr, &quot;Error: &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vfprintf_s( stderr, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( LogFile != NULL ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fprintf_s( LogFile, &quot;Error: &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vfprintf_s( LogFile, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Error: Failed 100 times</tt>
</dl>
<dl>
<dt>Classification:
<dd>vfprintf_s is TR 24731
<br>vfwprintf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> vfprintf_s - All, Netware</tt>
<br><tt>vfwprintf_s - All</tt>
</dl>
<h2 id="vfscanf"> vfscanf, vfwscanf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>int vfscanf( FILE *fp,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
<br><tt>int vfwscanf( FILE *fp,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#vfscanf_s">vfscanf_s</a> function which is a safer alternative to<tt>
 vfscanf</tt>.&nbsp; This newer<tt> vfscanf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 vfscanf</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vfscanf</tt> function scans input from the file designated by<b> fp</b> under control of the argument<b> format</b>.
&nbsp; The<b> format</b> string is described under the description of the <tt> scanf</tt> function.
<br>The<tt> vfscanf</tt> function is equivalent to the <tt> fscanf</tt> function, with a variable argument list replaced with<b>
 arg</b>, which has been initialized using the <tt> va_start</tt> macro.
<br><br>The<tt> vfwscanf</tt> function is identical to<tt> vfscanf</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vfscanf</tt> function returns <tt> EOF</tt> if an input failure occurred before any conversion.&nbsp; Otherwise, the
 number of input arguments for which values were successfully scanned and stored is returned.&nbsp; When a file input error
 occurs, the <tt> errno</tt> global variable may be set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cscanf">cscanf</a>, <a href="#fscanf">fscanf</a>, <a href="#scanf">scanf</a>, <a href="#sscanf">sscanf</a>, <a href="#va_arg">va_arg</a>,
 <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>, <a href="#vcscanf">vcscanf</a>, <a href="#vscanf">vscanf</a>,
 <a href="#vsscanf">vsscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><br><tt>void ffind( FILE *fp, char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vfscanf( fp, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; ffind( stdin,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%s %s %d %d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day, &amp;year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n%s, %s %d, %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>vfscanf is ISO C99
<br>vfwscanf is ISO C99
</dl>
<dl>
<dt>Systems:
<dd><tt> vfscanf - All, Netware</tt>
<br><tt>vfwscanf - All</tt>
</dl>
<h2 id="vfscanf_s"> vfscanf_s, vfwscanf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int vfscanf_s( FILE * restrict stream,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, va_list arg );</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int vfwscanf_s( FILE * restrict stream,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, va_list arg );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 vfscanf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> stream</b> nor<b> format</b> shall be a null pointer.&nbsp; Any argument indirected through in order to store
 converted input shall not be a null pointer.
<br><br>If there is a runtime-constraint violation, the<tt> vfscanf_s</tt> function does not attempt to perform further input,
 and it is unspecified to what extent<tt> vfscanf_s</tt> performed input before discovering the runtime-constraint violation.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vfscanf_s</tt> function is equivalent to <tt> fscanf_s</tt>, with the variable argument list replaced by<b> arg</b>,
 which shall have been initialized by the <tt> va_start</tt> macro (and possibly subsequent <tt> va_arg</tt> calls).&nbsp;
 The<tt> vfscanf_s</tt> function does not invoke the <tt> va_end</tt> macro.
<br>The<tt> vfwscanf_s</tt> function is identical to<tt> vfscanf_s</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vfscanf_s</tt> function returns <tt> EOF</tt> if an input failure occurred before any conversion or if there was a
 runtime-constraint violation.&nbsp; Otherwise, the<tt> vfscanf_s</tt> function returns the number of input items successfully
 assigned, which can be fewer than provided for, or even zero.
<br>When a file input error occurs, the <tt> errno</tt> global variable may be set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cscanf">cscanf</a>, <a href="#fscanf">fscanf</a>, <a href="#scanf">scanf</a>, <a href="#sscanf">sscanf</a>, <a href="#va_arg">va_arg</a>,
 <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>, <a href="#vcscanf">vcscanf</a>, <a href="#vfscanf">vfscanf</a>,
 <a href="#vscanf">vscanf</a>, <a href="#vsscanf">vsscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><br><tt>void ffind( FILE *fp, char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vfscanf_s( fp, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; ffind( stdin,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%s %s %d %d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, sizeof( weekday ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; month, sizeof( month ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;day, &amp;year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf_s( &quot;\n%s, %s %d, %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>vfscanf_s is TR 24731
<br>vfwscanf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> vfscanf_s - All, Netware</tt>
<br><tt>vfwscanf_s - All</tt>
</dl>
<h2 id="vprintf"> vprintf, vwprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int vprintf( const char *format, va_list arg );</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int vwprintf( const wchar_t *format, va_list arg );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#vprintf_s">vprintf_s</a> function which is a safer alternative to<tt>
 vprintf</tt>.&nbsp; This newer<tt> vprintf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 vprintf</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vprintf</tt> function writes output to the file <tt> stdout</tt> under control of the argument<b> format</b>.&nbsp;
 The<b> format</b> string is described under the description of the <tt> printf</tt> function.&nbsp; The<tt> vprintf</tt>
 function is equivalent to the <tt> printf</tt> function, with the variable argument list replaced with<b> arg</b>, which
 has been initialized by the <tt> va_start</tt> macro.
<br>The<tt> vwprintf</tt> function is identical to<tt> vprintf</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vprintf</tt> function returns the number of characters written, or a negative value if an output error occurred.&nbsp;
 The<tt> vwprintf</tt> function returns the number of wide characters written, or a negative value if an output error occurred.
&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#va_arg">va_arg</a>, <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>,
 <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>The following shows the use of<tt> vprintf</tt> in a general error message routine.
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><br><tt>void errmsg( char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Error: &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vprintf( format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Error: Failed 100 times</tt>
</dl>
<dl>
<dt>Classification:
<dd>vprintf is ANSI
<br>vwprintf is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> vprintf - All, Netware</tt>
<br><tt>vwprintf - All</tt>
</dl>
<h2 id="vprintf_s"> vprintf_s, vwprintf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int vprintf_s( const char * restrict format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int vwprintf_s( const wchar_t * restrict format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list prg );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 vprintf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>The<b> format</b> argument shall not be a null pointer.&nbsp; The<tt> %n</tt> specifier (modified or not by flags, field
 width, or precision) shall not appear in the string pointed to by<b> format</b>.&nbsp; Any argument to<tt> vprintf_s</tt>
 corresponding to a<tt> %s</tt> specifier shall not be a null pointer.
<br><br>If there is a runtime-constraint violation, the<tt> vprintf_s</tt> function does not attempt to produce further output,
 and it is unspecified to what extent<tt> vprintf_s</tt> produced output before discovering the runtime-constraint violation.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vprintf_s</tt> function is equivalent to the <tt> vprintf</tt> function except for the explicit runtime-constraints
 listed above.
<br>The<tt> vwprintf_s</tt> function is identical to<tt> vprintf_s</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vprintf_s</tt> function returns the number of characters written, or a negative value if an output error or runtime-constraint
 violation occurred.
<br>The<tt> vwprintf_s</tt> function returns the number of wide characters written, or a negative value if an output error
 or runtime-constraint violation occurred.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>,
 <a href="#vprintf">vprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><br><tt>void errmsg( char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf_s( &quot;Error: &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vprintf_s( format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Error: Failed 100 times</tt>
</dl>
<dl>
<dt>Classification:
<dd>vprintf_s is TR 24731
<br>vwprintf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> vprintf_s - All, Netware</tt>
<br><tt>vwprintf_s - All</tt>
</dl>
<h2 id="vscanf"> vscanf, vwscanf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int vscanf( const char *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int vwscanf( const wchar_t *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#vscanf_s">vscanf_s</a> function which is a safer alternative to<tt> vscanf</tt>.
&nbsp; This newer<tt> vscanf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> vscanf</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vscanf</tt> function scans input from the file designated by<b> stdin</b> under control of the argument<b> format</b>.
&nbsp; The<b> format</b> string is described under the description of the <tt> scanf</tt> function.
<br>The<tt> vscanf</tt> function is equivalent to the <tt> scanf</tt> function, with a variable argument list replaced with<b>
 arg</b>, which has been initialized using the <tt> va_start</tt> macro.
<br><br>The<tt> vwscanf</tt> function is identical to<tt> vscanf</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vscanf</tt> function returns <tt> EOF</tt> if an input failure occurred before any conversion.&nbsp; values were successfully
 scanned and stored is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cscanf">cscanf</a>, <a href="#fscanf">fscanf</a>, <a href="#scanf">scanf</a>, <a href="#sscanf">sscanf</a>, <a href="#va_arg">va_arg</a>,
 <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>, <a href="#vcscanf">vcscanf</a>, <a href="#vfscanf">vfscanf</a>,
 <a href="#vsscanf">vsscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><br><tt>void find( char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vscanf( format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; find( &quot;%s %s %d %d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day, &amp;year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n%s, %s %d, %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>vscanf is ISO C99
<br>vwscanf is ISO C99
</dl>
<dl>
<dt>Systems:
<dd><tt> vscanf - All, Netware</tt>
<br><tt>vwscanf - All</tt>
</dl>
<h2 id="vscanf_s"> vscanf_s, vwscanf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int vscanf_s( const char * restrict format, va_list arg );</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int vwscanf_s( const wchar_t * restrict format, va_list arg );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 vscanf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>The argument<b> format</b> shall not be a null pointer.&nbsp; Any argument indirected through in order to store converted
 input shall not be a null pointer.
<br><br>If there is a runtime-constraint violation, the<tt> vscanf_s</tt> function does not attempt to perform further input,
 and it is unspecified to what extent<tt> vscanf_s</tt> performed input before discovering the runtime-constraint violation.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vscanf_s</tt> function is equivalent to <tt> scanf_s</tt>, with the variable argument list replaced by<b> arg</b>,
 which shall have been initialized by the <tt> va_start</tt> macro (and possibly subsequent <tt> va_arg</tt> calls).&nbsp;
 The<tt> vscanf_s</tt> function does not invoke the <tt> va_end</tt> macro.
<br>The<tt> vwscanf_s</tt> function is identical to<tt> vscanf_s</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vscanf_s</tt> function returns <tt> EOF</tt> if an input failure occurred before any conversion or if there was a
 runtime-constraint violation.&nbsp; Otherwise, the<tt> vscanf_s</tt> function returns the number of input items successfully
 assigned, which can be fewer than provided for, or even zero.
<br>When a file input error occurs, the <tt> errno</tt> global variable may be set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cscanf">cscanf</a>, <a href="#fscanf">fscanf</a>, <a href="#scanf">scanf</a>, <a href="#sscanf">sscanf</a>, <a href="#va_arg">va_arg</a>,
 <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>, <a href="#vcscanf">vcscanf</a>, <a href="#vfscanf">vfscanf</a>,
 <a href="#vscanf">vscanf</a>, <a href="#vsscanf">vsscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><br><tt>void find( char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vscanf_s( format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; find( &quot;%s %s %d %d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, sizeof( weekday ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; month, sizeof( month ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;day, &amp;year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf_s( &quot;\n%s, %s %d, %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>vscanf_s is TR 24731
<br>vwscanf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> vscanf_s - All, Netware</tt>
<br><tt>vwscanf_s - All</tt>
</dl>
<h2 id="_vsnprintf"> _vsnprintf, _vsnwprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int _vsnprintf( char *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int _vsnwprintf( wchar_t *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _vsnprintf</tt> function formats data under control of the<b> format</b> control string and stores the result in<b>
 buf</b>.&nbsp; The maximum number of characters to store is specified by<b> count</b>.&nbsp; A null character is placed at
 the end of the generated character string if fewer than<b> count</b> characters were stored.&nbsp; The<b> format</b> string
 is described under the description of the <tt> printf</tt> function.&nbsp; The<tt> _vsnprintf</tt> function is equivalent
 to the <tt> _snprintf</tt> function, with the variable argument list replaced with<b> arg</b>, which has been initialized
 by the <tt> va_start</tt> macro.
<br>The<tt> _vsnwprintf</tt> function is identical to<tt> _vsnprintf</tt> except that the argument<b> buf</b> specifies an
 array of wide characters into which the generated output is to be written, rather than converted to multibyte characters
 and written to a stream.&nbsp; The maximum number of wide characters to write is specified by<b> count</b>.&nbsp; A null
 wide character is placed at the end of the generated wide character string if fewer than<b> count</b> wide characters were
 stored.&nbsp; The<tt> _vsnwprintf</tt> function accepts a wide-character string argument for<b> format</b>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _vsnprintf</tt> function returns the number of characters written into the array, not counting the terminating null
 character, or a negative value if more than<b> count</b> characters were requested to be generated.&nbsp; An error can occur
 while converting a value for output.&nbsp; The<tt> _vsnwprintf</tt> function returns the number of wide characters written
 into the array, not counting the terminating null wide character, or a negative value if more than<b> count</b> wide characters
 were requested to be generated.&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of
 error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#va_arg">va_arg</a>, <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>,
 <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vprintf">vprintf</a>,
 <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>The following shows the use of<tt> _vsnprintf</tt> in a general error message routine.
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char msgbuf&#91;80&#93;;</tt>
<br><br><tt>char *fmtmsg( char *format, ... )</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( msgbuf, &quot;Error: &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _vsnprintf( &amp;msgbuf&#91;7&#93;, 80-7, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( msgbuf );</tt>
<br><tt>&nbsp; }</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *msg;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; msg = fmtmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, msg );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> _vsnprintf - All, Netware</tt>
<br><tt>_vsnwprintf - All</tt>
</dl>
<h2 id="vsnprintf"> vsnprintf, vsnwprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int vsnprintf( char *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int vsnwprintf( wchar_t *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#vsnprintf_s">vsnprintf_s</a> function which is a safer alternative to<tt>
 vsnprintf</tt>.&nbsp; This newer<tt> vsnprintf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 vsnprintf</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vsnprintf</tt> function formats data under control of the<b> format</b> control string and stores the result in<b>
 buf</b>.&nbsp; The maximum number of characters to store, including a terminating null character, is specified by<b> count</b>.
&nbsp; The<b> format</b> string is described under the description of the <tt> printf</tt> function.&nbsp; The<tt> vsnprintf</tt>
 function is equivalent to the <tt> _snprintf</tt> function, with the variable argument list replaced with<b> arg</b>, which
 has been initialized by the <tt> va_start</tt> macro.
<br>The<tt> vsnwprintf</tt> function is identical to<tt> vsnprintf</tt> except that the argument<b> buf</b> specifies an array
 of wide characters into which the generated output is to be written, rather than converted to multibyte characters and written
 to a stream.&nbsp; The maximum number of wide characters to write, including a terminating null wide character, is specified
 by<b> count</b>.&nbsp; The<tt> vsnwprintf</tt> function accepts a wide-character string argument for<b> format</b>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vsnprintf</tt> function returns the number of characters that would have been written had<b> count</b> been sufficiently
 large, not counting the terminating null character, or a negative value if an encoding error occurred.&nbsp; Thus, the null-terminated
 output has been completely written if and only if the returned value is nonnegative and less than<b> count</b>.&nbsp; The<tt>
 vsnwprintf</tt> function returns the number of wide characters that would have been written had<b> count</b> been sufficiently
 large, not counting the terminating null wide character, or a negative value if an encoding error occurred.&nbsp; Thus, the
 null-terminated output has been completely written if and only if the returned value is nonnegative and less than<b> count</b>.
&nbsp; When an error has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#va_arg">va_arg</a>, <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>,
 <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vprintf">vprintf</a>,
 <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>The following shows the use of<tt> vsnprintf</tt> in a general error message routine.
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char *fmtmsg( char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *msgbuf;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; len;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; len = vsnprintf( NULL, 0, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; len = len + 1 + 7;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; msgbuf = malloc( len );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( msgbuf, &quot;Error: &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vsnprintf( &amp;msgbuf&#91;7&#93;, len, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( msgbuf );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *msg;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; msg = fmtmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, msg );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; free( msg );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>vsnprintf is ANSI
<br>vsnwprintf is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> vsnprintf - All, Netware</tt>
<br><tt>vsnwprintf - All</tt>
</dl>
<h2 id="vsnprintf_s"> vsnprintf_s, vsnwprintf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int vsnprintf_s( char * restrict s, rsize_t n</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, va_list arg );</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int vsnwprintf_s( char * restrict s, rsize_t n,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, va_list arg );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 vsnprintf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> s</b> nor<b> format</b> shall be a null pointer.&nbsp; The<b> n</b> argument shall neither equal zero nor be
 greater than<tt> RSIZE_MAX.</tt>&nbsp; The number of characters (including the trailing null) required for the result to
 be written to the array pointed to by<b> s</b> shall not be greater than<b> n</b>.&nbsp; The<tt> %n</tt> specifier (modified
 or not by flags, field width, or precision) shall not appear in the string pointed to by<b> format</b>.&nbsp; Any argument
 to<tt> vsnprintf_s</tt> corresponding to a<tt> %s</tt> specifier shall not be a null pointer.&nbsp; No encoding error shall
 occur.
<br><br>If there is a runtime-constraint violation, then if<b> s</b> is not a null pointer and<b> n</b> is greater than zero
 and less than<tt> RSIZE_MAX,</tt> then the<tt> vsnprintf_s</tt> function sets<b> s&#91;0&#93;</b> to the null character.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vsnprintf_s</tt> function is equivalent to the <tt> vsnprintf</tt> function except for the explicit runtime-constraints
 listed above.
<br>The<tt> vsnprintf_s</tt> function, unlike <tt> vsprintf_s</tt>, will truncate the result to fit within the array pointed
 to by<b> s</b>.
<br><br>The<tt> vsnwprintf_s</tt> function is identical to<tt> vsnprintf_s</tt> except that it accepts a wide-character string
 argument for<b> format</b> and produces wide character output.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vsnprintf_s</tt> function returns the number of characters that would have been written had<b> n</b> been sufficiently
 large, not counting the terminating null character, or a negative value if a runtime-constraint violation occurred.&nbsp;
 Thus, the null-terminated output has been completely written if and only if the returned value is nonnegative and less than<b>
 n</b>.
<br>The<tt> vsnprintf_s</tt> function returns the number of wide characters that would have been written had<b> n</b> been
 sufficiently large, not counting the terminating wide null character, or a negative value if a runtime-constraint violation
 occurred.&nbsp; Thus, the null-terminated output has been completely written if and only if the returned value is nonnegative
 and less than<b> n</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>,
 <a href="#vprintf">vprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>The following shows the use of<tt> vsnprintf_s</tt> in a general error message routine.
<br><br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char *fmtmsg( char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; *msgbuf;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; len;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; len = vsnprintf( NULL, 0, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; len = len + 1 + 7;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; msgbuf = malloc( len );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( msgbuf, &quot;Error: &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vsnprintf_s( &amp;msgbuf&#91;7&#93;, len, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( msgbuf );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *msg;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; msg = fmtmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf_s( &quot;%s\n&quot;, msg );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; free( msg );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>vsnprintf_s is TR 24731
<br>vsnwprintf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> vsnprintf_s - All, Netware</tt>
<br><tt>vsnwprintf_s - All</tt>
</dl>
<h2 id="vsprintf"> vsprintf, vswprintf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int vsprintf( char *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int vswprintf( wchar_t *buf,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t count,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#vsprintf_s">vsprintf_s</a> function which is a safer alternative to<tt>
 vsprintf</tt>.&nbsp; This newer<tt> vsprintf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 vsprintf</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vsprintf</tt> function formats data under control of the<b> format</b> control string and writes the result to<b>
 buf</b>.&nbsp; The<b> format</b> string is described under the description of the <tt> printf</tt> function.&nbsp; The<tt>
 vsprintf</tt> function is equivalent to the <tt> sprintf</tt> function, with the variable argument list replaced with<b>
 arg</b>, which has been initialized by the <tt> va_start</tt> macro.
<br>The<tt> vswprintf</tt> function is identical to<tt> vsprintf</tt> except that the argument<b> buf</b> specifies an array
 of wide characters into which the generated output is to be written, rather than converted to multibyte characters and written
 to a stream.&nbsp; The maximum number of wide characters to write, including a terminating null wide character, is specified
 by<b> count</b>.&nbsp; The<tt> vswprintf</tt> function accepts a wide-character string argument for<b> format</b>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vsprintf</tt> function returns the number of characters written, or a negative value if an output error occurred.
&nbsp; The<tt> vswprintf</tt> function returns the number of wide characters written into the array, not counting the terminating
 null wide character, or a negative value if<b> count</b> or more wide characters were requested to be generated.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#va_arg">va_arg</a>, <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>,
 <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>, <a href="#vprintf">vprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>The following shows the use of<tt> vsprintf</tt> in a general error message routine.
<br><br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char msgbuf&#91;80&#93;;</tt>
<br><br><tt>char *fmtmsg( char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy( msgbuf, &quot;Error: &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vsprintf( &amp;msgbuf&#91;7&#93;, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( msgbuf );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *msg;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; msg = fmtmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, msg );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>vsprintf is ANSI
<br>vswprintf is ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> vsprintf - All, Netware</tt>
<br><tt>vswprintf - All</tt>
</dl>
<h2 id="vsprintf_s"> vsprintf_s, vswprintf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int vsprintf_s( char * restrict s, rsize_t n</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format, va_list arg );</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int vswprintf_s( char * restrict s, rsize_t n,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict format, va_list arg );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 vsprintf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> s</b> nor<b> format</b> shall be a null pointer.&nbsp; The<b> n</b> argument shall neither equal zero nor be
 greater than<tt> RSIZE_MAX.</tt>&nbsp; The number of characters (including the trailing null) required for the result to
 be written to the array pointed to by<b> s</b> shall not be greater than<b> n</b>.&nbsp; The<tt> %n</tt> specifier (modified
 or not by flags, field width, or precision) shall not appear in the string pointed to by<b> format</b>.&nbsp; Any argument
 to<tt> vsprintf_s</tt> corresponding to a<tt> %s</tt> specifier shall not be a null pointer.&nbsp; No encoding error shall
 occur.
<br><br>If there is a runtime-constraint violation, then if<b> s</b> is not a null pointer and<b> n</b> is greater than zero
 and less than<tt> RSIZE_MAX,</tt> then the<tt> vsprintf_s</tt> function sets<b> s&#91;0&#93;</b> to the null character.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vsprintf_s</tt> function is equivalent to the <tt> vsprintf</tt> function except for the explicit runtime-constraints
 listed above.
<br>The<tt> vsprintf_s</tt> function, unlike <tt> vsnprintf_s</tt>, treats a result too big for the array pointed to by<b>
 s</b> as a runtime-constraint violation.
<br><br>The<tt> vswprintf_s</tt> function is identical to<tt> vsprintf_s</tt> except that it accepts a wide-character string
 argument for<b> format</b> and produces wide character output.
</dl>
<dl>
<dt>Returns:
<dd>If no runtime-constraint violation occurred, the<tt> vsprintf_s</tt> function returns the number of characters written in
 the array, not counting the terminating null character.&nbsp; If an encoding error occurred,<tt> vsprintf_s</tt> returns
 a negative value.&nbsp; If any other runtime-constraint violation occurred,<tt> vsprintf_s</tt> returns zero.
<br>If no runtime-constraint violation occurred, the<tt> vswprintf_s</tt> function returns the number of wide characters written
 in the array, not counting the terminating null wide character.&nbsp; If an encoding error occurred or if<b> n</b> or more
 wide characters are requested to be written,<tt> vswprintf_s</tt> returns a negative value.&nbsp; If any other runtime-constraint
 violation occurred,<tt> vswprintf_s</tt> returns zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_bprintf">_bprintf</a>, <a href="#cprintf">cprintf</a>, <a href="#fprintf">fprintf</a>, <a href="#printf">printf</a>,
 <a href="#sprintf">sprintf</a>, <a href="#_vbprintf">_vbprintf</a>, <a href="#vcprintf">vcprintf</a>, <a href="#vfprintf">vfprintf</a>,
 <a href="#vprintf">vprintf</a>, <a href="#vsprintf">vsprintf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br>The following shows the use of<tt> vsprintf_s</tt> in a general error message routine.
<br><br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;string.h&gt;</tt>
<br><br><tt>char msgbuf&#91;80&#93;;</tt>
<br><br><tt>char *fmtmsg( char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; strcpy_s( msgbuf, sizeof( buffer ), &quot;Error: &quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vsprintf_s( &amp;msgbuf&#91;7&#93;, sizeof( msgbuf ) - 7,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( msgbuf );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *msg;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; msg = fmtmsg( &quot;%s %d %s&quot;, &quot;Failed&quot;, 100, &quot;times&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, msg );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>vsprintf_s is TR 24731
<br>vswprintf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> vsprintf_s - All, Netware</tt>
<br><tt>vswprintf_s - All</tt>
</dl>
<h2 id="vsscanf"> vsscanf, vswscanf </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>int vsscanf( const char *in_string,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
<br><tt>int vswscanf( const wchar_t *in_string,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t *format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#vsscanf_s">vsscanf_s</a> function which is a safer alternative to<tt>
 vsscanf</tt>.&nbsp; This newer<tt> vsscanf_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 vsscanf</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vsscanf</tt> function scans input from the string designated by<b> in_string</b> under control of the argument<b>
 format</b>.&nbsp; The<b> format</b> string is described under the description of the <tt> scanf</tt> function.
<br>The<tt> vsscanf</tt> function is equivalent to the <tt> sscanf</tt> function, with a variable argument list replaced with<b>
 arg</b>, which has been initialized using the <tt> va_start</tt> macro.
<br><br>The<tt> vswscanf</tt> function is identical to<tt> vsscanf</tt> except that it accepts a wide-character string argument
 for<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vsscanf</tt> function returns <tt> EOF</tt> if the end of the input string was reached before any conversion.&nbsp;
 Otherwise, the number of input arguments for which values were successfully scanned and stored is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cscanf">cscanf</a>, <a href="#fscanf">fscanf</a>, <a href="#scanf">scanf</a>, <a href="#sscanf">sscanf</a>, <a href="#va_arg">va_arg</a>,
 <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>, <a href="#vcscanf">vcscanf</a>, <a href="#vfscanf">vfscanf</a>,
 <a href="#vscanf">vscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><br><tt>void sfind( char *string, char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vsscanf( string, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; sfind( &quot;Saturday April 18 1987&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%s %s %d %d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, &amp;day, &amp;year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;\n%s, %s %d, %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>vsscanf is ISO C99
<br>vswscanf is ISO C99
</dl>
<dl>
<dt>Systems:
<dd><tt> vsscanf - All, Netware</tt>
<br><tt>vswscanf - All</tt>
</dl>
<h2 id="vsscanf_s"> vsscanf_s, vswscanf_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>int vsscanf_s( const char * restrict s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const char * restrict format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int vswscanf_s( const wchar_t * restrict s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t * restrict
 format,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; va_list arg );</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 vsscanf_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> s</b> not<b> format</b> shall be a null pointer.&nbsp; Any argument indirected through in order to store converted
 input shall not be a null pointer.
<br><br>If there is a runtime-constraint violation, the<tt> vsscanf_s</tt> function does not attempt to perform further input,
 and it is unspecified to what extent<tt> vsscanf_s</tt> performed input before discovering the runtime-constraint violation.
</dl>
<dl>
<dt>Description:
<dd>The<tt> vsscanf_s</tt> function is equivalent to <tt> sscanf_s</tt>, with the variable argument list replaced by<b> arg</b>,
 which shall have been initialized by the <tt> va_start</tt> macro (and possibly subsequent <tt> va_arg</tt> calls).&nbsp;
 The<tt> vsscanf_s</tt> function does not invoke the <tt> va_end</tt> macro.
<br>The<tt> vswscanf_s</tt> function is identical to<tt> vsscanf_s</tt> except that it accepts wide-character string arguments
 for<b> s</b> and<b> format</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> vsscanf_s</tt> function returns <tt> EOF</tt> if an input failure occurred before any conversion or if there was a
 runtime-constraint violation.&nbsp; Otherwise, the<tt> vsscanf_s</tt> function returns the number of input items successfully
 assigned, which can be fewer than provided for, or even zero.
<br>When a file input error occurs, the <tt> errno</tt> global variable may be set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#cscanf">cscanf</a>, <a href="#fscanf">fscanf</a>, <a href="#scanf">scanf</a>, <a href="#sscanf">sscanf</a>, <a href="#va_arg">va_arg</a>,
 <a href="#va_end">va_end</a>, <a href="#va_start">va_start</a>, <a href="#vcscanf">vcscanf</a>, <a href="#vfscanf">vfscanf</a>,
 <a href="#vscanf">vscanf</a>, <a href="#vsscanf">vsscanf</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdarg.h&gt;</tt>
<br><br><tt>void sfind( char *string, char *format, ... )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_list arglist;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; va_start( arglist, format );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; vsscanf_s( string, format, arglist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; va_end( arglist );</tt>
<br><tt>}</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int day, year;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char weekday&#91;10&#93;, month&#91;10&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; sfind( &quot;Friday August 0013 2004&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;%s %s %d %d&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, sizeof( weekday ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; month, sizeof( month ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;day, &amp;year );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf_s( &quot;\n%s, %s %d, %d\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; weekday, month, day, year );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Friday, August 13, 2004</tt>
</dl>
<dl>
<dt>Classification:
<dd>vsscanf_s is TR 24731
<br>vswscanf_s is TR 24731
</dl>
<dl>
<dt>Systems:
<dd><tt> vsscanf_s - All, Netware</tt>
<br><tt>vswscanf_s - All</tt>
</dl>
<h2 id="wait"> wait </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;process.h&gt;</tt>
<br><tt>int wait( int *status );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> wait</tt> function suspends the calling process until any of the caller's immediate child processes terminate.
<br>Under Win32, there is no parent-child relationship amongst processes so the<tt> wait</tt> function cannot and does not
 wait for child processes to terminate.&nbsp; To wait for any process, you must specify its process id.&nbsp; For this reason,
 the <tt> cwait</tt> function should be used (one of its arguments is a process id).
<br><br>If<b> status</b> is not<tt> NULL,</tt> it points to a word that will be filled in with the termination status word
 and return code of the terminated child process.
<br><br>If the child process terminated normally, then the low order byte of the status word will be set to 0, and the high
 order byte will contain the low order byte of the return code that the child process passed to the <tt> DOSEXIT</tt> function.
&nbsp; The <tt> DOSEXIT</tt> function is called whenever <tt> main</tt> returns, or <tt> exit</tt> or <tt> _exit</tt> are
 explicity called.
<br><br>If the child process did not terminate normally, then the high order byte of the status word will be set to 0, and
 the low order byte will contain one of the following values:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>1
<dd>Hard-error abort
<dt><br>2
<dd>Trap operation
<dt><br>3
<dd>SIGTERM signal not intercepted
</dl>
<dl>
<dt>Note:
<dd>This implementation of the status value follows the OS/2 model and differs from the Microsoft implementation.&nbsp; Under
 Microsoft, the return code is returned in the low order byte and it is not possible to determine whether a return code of
 1, 2, or 3 imply that the process terminated normally.&nbsp; For portability to Microsoft compilers, you should ensure that
 the application that is waited on does not return one of these values.&nbsp; The following shows how to handle the status
 value in a portable manner.
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; cwait( &amp;status, process_id, WAIT_CHILD );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; #if defined(__WATCOMC__)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; switch( status &amp; 0xff ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 0:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal termination exit code = %d\n&quot;, status &gt;&gt;
 8 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 1:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Hard-error abort\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 2:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Trap operation\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 3:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;SIGTERM signal not intercepted\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; default:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Bogus return status\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; #else if defined(_MSC_VER)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; switch( status &amp; 0xff ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 1:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Possible Hard-error abort\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 2:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Possible Trap operation\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; case 3:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Possible SIGTERM signal not intercepted\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; default:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Normal termination exit code = %d\n&quot;, status );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; #endif</tt>
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> wait</tt> function returns the child's process id if the child process terminated normally.&nbsp; Otherwise,<tt> wait</tt>
 returns -1 and sets <tt> errno</tt> to one of the following values:
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>ECHILD
<dd>No child processes exist for the calling process.
<dt><br>EINTR
<dd>The child process terminated abnormally.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#cwait">cwait</a>, <a href="#exit">exit</a>, <a href="#_exit">_exit</a>, <a href="#spawn___">spawn...</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>#include &lt;process.h&gt;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp; process_id, status;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; process_id = spawnl( P_NOWAIT, &quot;child.exe&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;child&quot;, &quot;parm&quot;,
 NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; wait( &amp;status );</tt>
<br><tt>&nbsp; }</tt>
</dl>
<dl>
<dt>Classification:
<dd>WATCOM
</dl>
<dl>
<dt>Systems:
<dd>Win32, QNX, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="wcrtomb"> wcrtomb, _fwcrtomb </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int wcrtomb( char *s, wchar_t wc, mbstate_t *ps );</tt>
<br><tt>int _fwcrtomb( char __far *s, wchar_t wc, mbstate_t __far *ps );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#wcrtomb_s">wcrtomb_s</a> function which is a safer alternative to<tt>
 wcrtomb</tt>.&nbsp; This newer<tt> wcrtomb_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 wcrtomb</tt> function.
</dl>
<dl>
<dt>Description:
<dd>If<b> s</b> is a null pointer, the<tt> wcrtomb</tt> function determines the number of bytes necessary to enter the initial
 shift state (zero if encodings are not state-dependent or if the initial conversion state is described).&nbsp; The resulting
 state described will be the initial conversion state.
<br>If<b> s</b> is not a null pointer, the<tt> wcrtomb</tt> function determines the number of bytes needed to represent the
 multibyte character that corresponds to the wide character given by<b> wc</b> (including any shift sequences), and stores
 the resulting bytes in the array whose first element is pointed to by<b> s</b>.&nbsp; At most <tt> MB_CUR_MAX</tt> bytes
 will be stored.&nbsp; If<b> wc</b> is a null wide character, the resulting state described will be the initial conversion
 state.
<br><br>The<tt> _fwcrtomb</tt> function is a data model independent form of the<tt> wcrtomb</tt> function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The restartable multibyte/wide character conversion functions differ from the corresponding internal-state multibyte
 character functions ( <tt> mblen</tt>, <tt> mbtowc</tt>, and <tt> wctomb</tt>) in that they have an extra argument,<b> ps</b>,
 of type pointer to <tt> mbstate_t</tt> that points to an object that can completely describe the current conversion state
 of the associated multibyte character sequence.&nbsp; If<b> ps</b> is a null pointer, each function uses its own internal
 <tt> mbstate_t</tt> object instead.&nbsp; You are guaranteed that no other function in the library calls these functions
 with a null pointer for<b> ps</b>, thereby ensuring the stability of the state.
<br><br>Also unlike their corresponding functions, the return value does not represent whether the encoding is state-dependent.
<br><br>If the encoding is state-dependent, on entry each function takes the described conversion state (either internal or
 pointed to by<b> ps</b>) as current.&nbsp; The conversion state described by the pointed-to object is altered as needed to
 track the shift state of the associated multibyte character sequence.&nbsp; For encodings without state dependency, the pointer
 to the <tt> mbstate_t</tt> argument is ignored.
</dl>
<dl>
<dt>Returns:
<dd>If<b> s</b> is a null pointer, the<tt> wcrtomb</tt> function returns the number of bytes necessary to enter the initial shift
 state.&nbsp; The value returned will not be greater than that of the <tt> MB_CUR_MAX</tt> macro.
<br>If<b> s</b> is not a null pointer, the<tt> wcrtomb</tt> function returns the number of bytes stored in the array object
 (including any shift sequences) when<b> wc</b> is a valid wide character; otherwise (when<b> wc</b> is not a valid wide character),
 an encoding error occurs, the value of the macro <tt> EILSEQ</tt> will be stored in <tt> errno</tt> and -1 will be returned,
 but the conversion state will be unchanged.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>,
 <a href="#mbrlen">mbrlen</a>, <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>,
 <a href="#mbstowcs">mbstowcs</a>, <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>,
 <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;errno.h&gt;</tt>
<br><br><tt>const wchar_t wc&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0020,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x002e,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0031,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0041,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x3000,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff21,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x3048,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x30a3,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff61,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff66,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff9f,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x720d,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0000</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( wc ) / sizeof( wchar_t )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s&#91;2&#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; i = wcrtomb( NULL, 0, NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Number of bytes to enter &quot;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;initial shift state = %d\n&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; j = 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = wcrtomb( s, wc&#91;i&#93;, NULL );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character &quot;, j );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( errno == EILSEQ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; - illegal wide character\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( j == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( j == 1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = s&#91;0&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( j == 2 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = s&#91;0&#93;&lt;&lt;8 | s&#91;1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;(%#6.4x-&gt;%#6.4x)\n&quot;, wc&#91;i&#93;, k
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Number of bytes to enter initial shift state = 0</tt>
<br><tt>1 bytes in character (0x0020-&gt;0x0020)</tt>
<br><tt>1 bytes in character (0x002e-&gt;0x002e)</tt>
<br><tt>1 bytes in character (0x0031-&gt;0x0031)</tt>
<br><tt>1 bytes in character (0x0041-&gt;0x0041)</tt>
<br><tt>2 bytes in character (0x3000-&gt;0x8140)</tt>
<br><tt>2 bytes in character (0xff21-&gt;0x8260)</tt>
<br><tt>2 bytes in character (0x3048-&gt;0x82a6)</tt>
<br><tt>2 bytes in character (0x30a3-&gt;0x8342)</tt>
<br><tt>1 bytes in character (0xff61-&gt;0x00a1)</tt>
<br><tt>1 bytes in character (0xff66-&gt;0x00a6)</tt>
<br><tt>1 bytes in character (0xff9f-&gt;0x00df)</tt>
<br><tt>2 bytes in character (0x720d-&gt;0xe0a1)</tt>
<br><tt>1 bytes in character (&nbsp; 0000-&gt;0x0069)</tt>
</dl>
<dl>
<dt>Classification:
<dd>wcrtomb is ANSI
<br>_fwcrtomb is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> wcrtomb - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fwcrtomb - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="wcrtomb_s"> wcrtomb_s, _fwcrtomb_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>errno_t wcrtomb_s( size_t * restrict retval,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char
 * restrict s, rsize_t smax,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t
 wc, mbstate_t * restrict ps);</tt>
<br><br><tt>errno_t _wcrtomb_s( size_t __far * restrict retval,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char
 __far * restrict s, rsize_t smax,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t
 wc, mbstate_t __far * restrict ps);</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 wcrtomb_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> retval</b> nor<b> ps</b> shall be a null pointer.&nbsp; If<b> s</b> is not a null pointer, then<b> smax</b>
 shall not equal zero and shall not be greater than <tt> RSIZE_MAX</tt>.&nbsp; If<b> s</b> is not a null pointer, then<b>
 smax</b> shall be not be less than the number of bytes to be stored in the array pointed to by<b> s</b>.&nbsp; If<b> s</b>
 is a null pointer, then<b> smax</b> shall equal zero.
<br><br>If there is a runtime-constraint violation, then<tt> wcrtomb_s</tt> does the following.&nbsp; If<b> s</b> is not a
 null pointer and<b> smax</b> is greater than zero and not greater than <tt> RSIZE_MAX</tt>, then<tt> wcrtomb_s</tt> sets<b>
 s&#91;0&#93;</b> to the null character.&nbsp; If<b> retval</b> is not a null pointer, then <tt> wcrtomb_s</tt> sets<b> *retval</b>
 to (size_t)(-1).
</dl>
<dl>
<dt>Description:
<dd>If<b> s</b> is a null pointer, the<tt> wcrtomb_s</tt> function is equivalent to the call
<br>wcrtomb_s(&amp;retval, buf, sizeof buf, L'\0', ps)
<br>where<b> retval</b> and<b> buf</b> are internal variables of the appropriate types, and the size of<b> buf</b> is greater
 than MB_CUR_MAX.
<br>If<b> s</b> is not a null pointer, the<tt> wcrtomb_s</tt> function determines the number of bytes needed to represent
 the multibyte character that corresponds to the wide character given by<b> wc</b> (including any shift sequences), and stores
 the multibyte character representation in the array whose first element is pointed to by<b> s</b>.&nbsp; At most <tt> MB_CUR_MAX</tt>
 bytes are stored.&nbsp; If<b> wc</b> is a null wide character, a null byte is stored, preceded by any shift sequence needed
 to restore the initial shift state; the resulting state described is the initial conversion state.
<br><br>If<b> wc</b> does not correspond to a valid multibyte character, an encoding error occurs:&nbsp; the<tt> wcrtomb_s</tt>
 function stores the value (size_t)(-1) into<b> *retval</b> and the conversion state is unspecified.&nbsp; Otherwise, the<tt>
 wcrtomb_s</tt> function stores into<b> *retval</b> the number of bytes (including any shift sequences) stored in the array
 pointed to by<b> s</b>.
<br><br>The<tt> _fwcrtomb_s</tt> function is a data model independent form of the wcrtomb_s function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> wcrtomb_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>,
 <a href="#mbrlen">mbrlen</a>, <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>,
 <a href="#mbstowcs">mbstowcs</a>, <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>,
 <a href="#wcrtomb">wcrtomb</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__&nbsp; 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;errno.h&gt;</tt>
<br><br><tt>const wchar_t wc&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0020,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x002e,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0031,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0041,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x3000,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff21,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x3048,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x30a3,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff61,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff66,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff9f,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x720d,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0000</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( wc ) / sizeof( wchar_t )</tt>
<br><br><tt>int main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j, k;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s&#91;2&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errno_t&nbsp;&nbsp;&nbsp;&nbsp; rc;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mbstate_t&nbsp;&nbsp; state;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; j = 1;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = wcrtomb_s( &amp;retval, s, 2, wc&#91;i&#93;, &amp;state );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rc != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot; - illegal wide character\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%d bytes in character &quot;, retval );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( retval == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if ( retval == 1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = s&#91;0&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else if( retval == 2 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k = s&#91;0&#93;&lt;&lt;8 | s&#91;1&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;(%#6.4x-&gt;%#6.4x)\n&quot;, wc&#91;i&#93;, k
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>1 bytes in character (0x0020-&gt;0x0020)</tt>
<br><tt>1 bytes in character (0x002e-&gt;0x002e)</tt>
<br><tt>1 bytes in character (0x0031-&gt;0x0031)</tt>
<br><tt>1 bytes in character (0x0041-&gt;0x0041)</tt>
<br><tt>2 bytes in character (0x3000-&gt;0x8140)</tt>
<br><tt>2 bytes in character (0xff21-&gt;0x8260)</tt>
<br><tt>2 bytes in character (0x3048-&gt;0x82a6)</tt>
<br><tt>2 bytes in character (0x30a3-&gt;0x8342)</tt>
<br><tt>1 bytes in character (0xff61-&gt;0x00a1)</tt>
<br><tt>1 bytes in character (0xff66-&gt;0x00a6)</tt>
<br><tt>1 bytes in character (0xff9f-&gt;0x00df)</tt>
<br><tt>2 bytes in character (0x720d-&gt;0xe0a1)</tt>
<br><tt>1 bytes in character (&nbsp; 0000-&gt;0x0069)</tt>
</dl>
<dl>
<dt>Classification:
<dd>wcrtomb_s is TR24731
<br>_fwcrtomb_s is WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> wcrtomb_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fwcrtomb_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="wcsrtombs"> wcsrtombs, _fwcsrtombs </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>size_t wcsrtombs( char *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t **src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n, mbstate_t *ps );</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>size_t _fwcsrtombs( char __far *dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const wchar_t __far * __far *src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t n, mbstate_t __far *ps );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#wcsrtombs_s">wcsrtombs_s</a> function which is a safer alternative to<tt>
 wcsrtombs</tt>.&nbsp; This newer<tt> wcsrtombs_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 wcsrtombs</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> wcsrtombs</tt> function converts a sequence of wide characters from the array indirectly pointed to by<b> src</b>
 into a sequence of corresponding multibyte characters that begins in the shift state described by<b> ps</b>, which, if<b>
 dst</b> is not a null pointer, are then stored into the array pointed to by<b> dst</b>.&nbsp; Conversion continues up to
 and including a terminating null wide character, but the terminating null character (byte) will not be stored.&nbsp; Conversion
 will stop earlier in two cases:&nbsp; when a code is reached that does not correspond to a valid multibyte character, or
 (if<b> dst</b> is not a null pointer) when the next multibyte character would exceed the limit of<b> len</b> total bytes
 to be stored into the array pointed to by<b> dst</b>.&nbsp; Each conversion takes place as if by a call to the <tt> wcrtomb</tt>
 function.
<br>If<b> dst</b> is not a null pointer, the pointer object pointed to by<b> src</b> will be assigned either a null pointer
 (if conversion stopped due to reaching a terminating null wide character) or the address just past the last wide character
 converted.&nbsp; If conversion stopped due to reaching a terminating null wide character and if<b> dst</b> is not a null
 pointer, the resulting state described will be the initial conversion state.
<br><br>The<tt> _fwcsrtombs</tt> function is a data model independent form of the<tt> wcsrtombs</tt> function that accepts
 far pointer arguments.&nbsp; It is most useful in mixed memory model applications.
<br><br>The restartable multibyte/wide string conversion functions differ from the corresponding internal-state multibyte
 string functions ( <tt> mbstowcs</tt> and <tt> wcstombs</tt>) in that they have an extra argument,<b> ps</b>, of type pointer
 to <tt> mbstate_t</tt> that points to an object that can completely describe the current conversion state of the associated
 multibyte character sequence.&nbsp; If<b> ps</b> is a null pointer, each function uses its own internal <tt> mbstate_t</tt>
 object instead.&nbsp; You are guaranteed that no other function in the library calls these functions with a null pointer
 for<b> ps</b>, thereby ensuring the stability of the state.
<br><br>Also unlike their corresponding functions, the conversion source argument,<b> src</b>, has a pointer-to-pointer type.
&nbsp; When the function is storing conversion results (that is, when<b> dst</b> is not a null pointer), the pointer object
 pointed to by this argument will be updated to reflect the amount of the source processed by that invocation.
<br><br>If the encoding is state-dependent, on entry each function takes the described conversion state (either internal or
 pointed to by<b> ps</b>) as current and then, if the destination pointer,<b> dst</b>, is not a null pointer, the conversion
 state described by the pointed-to object is altered as needed to track the shift state of the associated multibyte character
 sequence.&nbsp; For encodings without state dependency, the pointer to the <tt> mbstate_t</tt> argument is ignored.
</dl>
<dl>
<dt>Returns:
<dd>If the first code is not a valid wide character, an encoding error occurs:&nbsp; The<tt> wcsrtombs</tt> function stores the
 value of the macro <tt> EILSEQ</tt> in <tt> errno</tt> and returns<tt> (size_t)-1,</tt> but the conversion state will be
 unchanged.&nbsp; Otherwise, it returns the number of bytes in the resulting multibyte characters sequence, which is the same
 as the number of array elements modified when<b> dst</b> is not a null pointer.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>,
 <a href="#mbrlen">mbrlen</a>, <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>,
 <a href="#mbstowcs">mbstowcs</a>, <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>,
 <a href="#wcrtomb">wcrtomb</a>, <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;errno.h&gt;</tt>
<br><br><tt>const wchar_t wc&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0020,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x002e,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0031,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0041,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x3000,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff21,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x3048,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x30a3,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff61,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff66,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff9f,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x720d,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0000</tt>
<br><tt>};</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elements;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const wchar_t&nbsp;&nbsp; *src;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mb&#91;50&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mbstate_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstate;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; src = wc;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; elements = wcsrtombs( mb, &amp;src, 50, &amp;pstate );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( errno == EILSEQ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error in wide character string\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; elements; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;0x%2.2x\n&quot;, mb&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>0x20</tt>
<br><tt>0x2e</tt>
<br><tt>0x31</tt>
<br><tt>0x41</tt>
<br><tt>0x81</tt>
<br><tt>0x40</tt>
<br><tt>0x82</tt>
<br><tt>0x60</tt>
<br><tt>0x82</tt>
<br><tt>0xa6</tt>
<br><tt>0x83</tt>
<br><tt>0x42</tt>
<br><tt>0xa1</tt>
<br><tt>0xa6</tt>
<br><tt>0xdf</tt>
<br><tt>0xe0</tt>
<br><tt>0xa1</tt>
</dl>
<dl>
<dt>Classification:
<dd>wcsrtombs is ANSI
<br>_fwcsrtombs is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> wcsrtombs - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fwcsrtombs - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="wcsrtombs_s"> wcsrtombs_s, _fwcsrtombs_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>errno_t wcsrtombs_s( size_t * restrict retval,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; char * restrict dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; rsize_t dstmax,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; const wchar_t ** restrict src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; rsize_t len,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; mbstate_t * restrict ps);</tt>
<br><tt>errno_t _fwcsrtombs_s( size_t __far * restrict retval,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; char __far * restrict dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; rsize_t dstmax,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; const wchar_t __far * __far * restrict src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; rsize_t len,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; mbstate_t __far * restrict ps);</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 wcsrtombs_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>None of<b> retval</b>,<b> src</b>,<b> *src</b>, or<b> ps</b> shall be null pointers.&nbsp; If<b> dst</b> is not a null
 pointer, then neither<b> len</b> nor<b> dstmax</b> shall be greater than <tt> RSIZE_MAX</tt>.&nbsp; If<b> dst</b> is a null
 pointer, then<b> dstmax</b> shall equal zero.&nbsp; If<b> dst</b> is not a null pointer,then<b> dstmax</b> shall not equal
 zero.&nbsp; If<b> dst</b> is not a null pointer and<b> len</b> is not less than<b> dstmax</b>, then the conversion shall
 have been stopped (see below) because a terminating null wide character was reached or because an encoding error occurred.
<br><br>If there is a runtime-constraint violation, then<tt> wcsrtombs_s</tt> does the following.&nbsp; If<b> retval</b> is
 not a null pointer,then<tt> wcsrtombs_s</tt> sets<b> *retval</b> to (size_t)(-1).&nbsp; If<b> dst</b> is not a null pointer
 and<b> dstmax</b> is greater than zero and less than <tt> RSIZE_MAX</tt>, then<tt> wcsrtombs_s</tt> sets<b> dst&#91;0&#93;</b>
 to the null character.
</dl>
<dl>
<dt>Description:
<dd>The<tt> wcsrtombs_s</tt> function converts a sequence of wide characters from the array indirectly pointed to by<b> src</b>
 into a sequence of corresponding multibyte characters that begins in the conversion state described by the object pointed
 to by<b> ps</b>.&nbsp; If<b> dst</b> is not a null pointer, the converted characters are then stored into the array pointed
 to by<b> dst</b>.&nbsp; Conversion continues up to and including a terminating null wide character, which is also stored.
<br>Conversion stops earlier in two cases:
<ul>
<li>when a wide character is reached that does not correspond to a valid multibyte character;
<li>(if<b> dst</b> is not a null pointer) when the next multibyte character would exceed the limit of n total bytes to be
 stored into the array pointed to by<b> dst</b>.&nbsp; If the wide character being converted is the null wide character, then
 n is the lesser of<b> len</b> or<b> dstmax</b>.&nbsp; Otherwise, n is the lesser of<b> len</b> or<b> dstmax-1</b>.
</ul>
<br>If the conversion stops without converting a null wide character and<b> dst</b> is not a null pointer, then a null character
 is stored into the array pointed to by<b> dst</b> immediately following any multibyte characters already stored.&nbsp; Each
 conversion takes place as if by a call to the <tt> wcrtomb</tt> function.
<br><br>If<b> dst</b> is not a null pointer, the pointer object pointed to by<b> src</b> is assigned either a null pointer
 (if conversion stopped due to reaching a terminating null wide character) or the address just past the last wide character
 converted (if any).&nbsp; If conversion stopped due to reaching a terminating null wide character, the resulting state described
 is the initial conversion state.
<br><br>Regardless of whether<b> dst</b> is or is not a null pointer, if the input conversion encounters a wide character
 that does not correspond to a valid multibyte character, an encoding error occurs:&nbsp; the<tt> wcsrtombs_s</tt> function
 stores the value (size_t)(-1) into<b> *retval</b> and the conversion state is unspecified.&nbsp; Otherwise, the<tt> wcsrtombs_s</tt>
 function stores into<b> *retval</b> the number of bytes in the resulting multibyte character sequence, not including the
 terminating null character (if any).
<br><br>All elements following the terminating null character (if any) written by<tt> wcsrtombs_s</tt> in the array of<b>
 dstmax</b> elements pointed to by<b> dst</b> take unspecified values when<tt> wcsrtombs_s</tt> returns.
<br><br>If copying takes place between objects that overlap, the objects take on unspecified values.
<br><br>The<tt> _fwcsrtombs_s</tt> function is a data model independent form of the wcsrtombs_s function that accepts far
 pointer arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> wcsrtombs_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>,
 <a href="#mbrlen">mbrlen</a>, <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>,
 <a href="#mbstowcs">mbstowcs</a>, <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>,
 <a href="#wcrtomb">wcrtomb</a>, <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcstombs">wcstombs</a>,
 <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctob">wctob</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><tt>#include &lt;errno.h&gt;</tt>
<br><br><tt>const wchar_t wc&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0020,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x002e,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0031,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0041,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x3000,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff21,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x3048,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x30a3,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff61,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff66,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff9f,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x720d,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0000</tt>
<br><tt>};</tt>
<br><br><tt>int main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retval;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; const wchar_t&nbsp;&nbsp; *src;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mb&#91;50&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mbstate_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pstate;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errno_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; src = wc;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; rc = wcsrtombs_s( &amp;retval, mb, 50, &amp;src, sizeof(wc), &amp;pstate );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( rc != 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error in wide character string\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; retval; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;0x%2.2x\n&quot;, mb&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( rc );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>0x20</tt>
<br><tt>0x2e</tt>
<br><tt>0x31</tt>
<br><tt>0x41</tt>
<br><tt>0x81</tt>
<br><tt>0x40</tt>
<br><tt>0x82</tt>
<br><tt>0x60</tt>
<br><tt>0x82</tt>
<br><tt>0xa6</tt>
<br><tt>0x83</tt>
<br><tt>0x42</tt>
<br><tt>0xa1</tt>
<br><tt>0xa6</tt>
<br><tt>0xdf</tt>
<br><tt>0xe0</tt>
<br><tt>0xa1</tt>
</dl>
<dl>
<dt>Classification:
<dd>wcsrtombs_s is TR 24731
<br>_fwcsrtombs_s is WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> wcsrtombs_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
<br><tt>_fwcsrtombs_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="wcstombs"> wcstombs, _fwcstombs </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>size_t wcstombs( char *s, const wchar_t *pwcs, size_t n );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>size_t _fwcstombs( char __far *s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
 wchar_t __far *pwcs,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t
 n );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#wcstombs_s">wcstombs_s</a> function which is a safer alternative to<tt>
 wcstombs</tt>.&nbsp; This newer<tt> wcstombs_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt>
 wcstombs</tt> function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> wcstombs</tt> function converts a sequence of wide character codes from the array pointed to by<b> pwcs</b> into a
 sequence of multibyte characters and stores them in the array pointed to by<b> s</b>.&nbsp; The<tt> wcstombs</tt> function
 stops if a multibyte character would exceed the limit of<b> n</b> total bytes, or if the null character is stored.&nbsp;
 At most<b> n</b> bytes of the array pointed to by<b> s</b> will be modified.
<br>The<tt> _fwcstombs</tt> function is a data model independent form of the<tt> wcstombs</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>If an invalid multibyte character is encountered, the<tt> wcstombs</tt> function returns<tt> (size_t)-1.</tt>&nbsp; Otherwise,
 the<tt> wcstombs</tt> function returns the number of array elements modified, not including the terminating zero code if
 present.
</dl>
<dl>
<dt>See Also:
<dd><a href="#wcstombs_s">wcstombs_s</a>, <a href="#mblen">mblen</a>, <a href="#mbtowc">mbtowc</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>wchar_t wbuffer&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0073,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0074,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0072,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0069,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x006e,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0067,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0000</tt>
<br><tt>&nbsp; };</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; mbsbuffer&#91;50&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i, len;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; len = wcstombs( mbsbuffer, wbuffer, 50 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( len != -1 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; len; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;/%4.4x&quot;, wbuffer&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mbsbuffer&#91;len&#93; = '\0';</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, mbsbuffer, len );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>/0073/0074/0072/0069/006e/0067</tt>
<br><tt>string(6)</tt>
</dl>
<dl>
<dt>Classification:
<dd>wcstombs is ANSI
<br>_fwcstombs is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> wcstombs - All, Netware</tt>
<br><tt>_fwcstombs - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="wcstombs_s"> wcstombs_s, _fwcstombs_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>errno_t wcstombs_s( size_t * restrict retval,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 char * restrict dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 rsize_t dstmax,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 const wchar_t * restrict src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 rsize_t len);</tt>
<br><br><tt>errno_t _fwcstombs_s( size_t __far * restrict retval,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; char __far * restrict dst,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; rsize_t dstmax,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; const wchar_t __far * restrict src,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; rsize_t len);</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 wcstombs_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Neither<b> retval</b> nor<b> src</b> shall be a null pointer.&nbsp; If<b> dst</b> is not a null pointer, then neither<b>
 len</b> nor<b> dstmax</b> shall be greater than <tt> RSIZE_MAX</tt>.&nbsp; If<b> dst</b> is a null pointer, then<b> dstmax</b>
 shall equal zero.&nbsp; If<b> dst</b> is not a null pointer,then<b> dstmax</b> shall not equal zero.&nbsp; If<b> dst</b>
 is not a null pointer and<b> len</b> is not less than<b> dstmax</b>, then the conversion shall have been stopped (see below)
 because a terminating null wide character was reached or because an encoding error occurred.
<br><br>If there is a runtime-constraint violation, then<tt> wcstombs_s</tt> does the following.&nbsp; If<b> retval</b> is
 not a null pointer,then<tt> wcstombs_s</tt> sets<b> *retval</b> to (size_t)(-1).&nbsp; If<b> dst</b> is not a null pointer
 and<b> dstmax</b> is greater than zero and less than <tt> RSIZE_MAX</tt>, then<tt> wcstombs_s</tt> sets<b> dst&#91;0&#93;</b>
 to the null character.
</dl>
<dl>
<dt>Description:
<dd>The<tt> wcstombs_s</tt> function converts a sequence of wide characters from the array pointed to by<b> src</b> into a sequence
 of corresponding multibyte characters that begins in the initial shift state.&nbsp; If<b> dst</b> is not a null pointer,the
 converted characters are then stored into the array pointed to by<b> dst</b>.&nbsp; Conversion continues up to and including
 a terminating null wide character, which is also stored.
<br>Conversion stops earlier in two cases:
<br><br>when a wide character is reached that does not correspond to a valid multibyte character;
<br>(if<b> dst</b> is not a null pointer) when the next multibyte character would exceed the limit of<b> n</b> total bytes
 to be stored into the array pointed to by<b> dst</b>.&nbsp; If the wide character being converted is the null wide character,
 then<b> n</b> is the lesser of<b> len</b> or<b> dstmax</b>.&nbsp; Otherwise,<b> n</b> is the lesser of<b> len</b> or<b> dstmax-1</b>.
<br>If the conversion stops without converting a null wide character and<b> dst</b> is not a null pointer, then a null character
 is stored into the array pointed to by<b> dst</b> immediately following any multibyte characters already stored.&nbsp; Each
 conversion takes place as if by a call to the wcrtomb function.
<br><br>Regardless of whether<b> dst</b> is or is not a null pointer, if the input conversion encounters a wide character
 that does not correspond to a valid multibyte character, an encoding error occurs:&nbsp; the<tt> wcstombs_s</tt> function
 stores the value (size_t)(-1) into<b> *retval</b>.&nbsp; Otherwise, the<tt> wcstombs_s</tt> function stores into<b> *retval</b>
 the number of bytes in the resulting multibyte character sequence, not including the terminating null character (if any).
<br><br>All elements following the terminating null character (if any) written by<tt> wcstombs_s</tt> in the array of<b> dstmax</b>
 elements pointed to by<b> dst</b> take unspecified values when<tt> wcstombs_s</tt> returns.
<br><br>If copying takes place between objects that overlap, the objects take on unspecified values.
<br><br>The<tt> _fwcstombs_s</tt> function is a data model independent form of the wcstombs_s function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> wcstombs_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#wcstombs">wcstombs</a>, <a href="#mblen">mblen</a>, <a href="#mbtowc">mbtowc</a>, <a href="#mbstowcs">mbstowcs</a>,
 <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>wchar_t wbuffer&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0073,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0074,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0072,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0069,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x006e,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0067,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0073,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0074,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0072,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0069,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x006e,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0067,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0000</tt>
<br><tt>&nbsp; };</tt>
<br><br><tt>int main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp; mbsbuffer&#91;50&#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; size_t&nbsp; retval;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errno_t rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = wcstombs_s( &amp;retval, mbsbuffer, 50, wbuffer, sizeof( wbuffer ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( rc == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; retval; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;/%4.4x&quot;, wbuffer&#91;i&#93;
 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mbsbuffer&#91;retval&#93; = '\0';</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, mbsbuffer, retval );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( rc );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>/0073/0074/0072/0069/006e/0067</tt>
<br><tt>string(6)</tt>
</dl>
<dl>
<dt>Classification:
<dd>wcstombs_s is TR 24731
<br>_fwcstombs_s is WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> wcstombs_s - All, Netware</tt>
<br><tt>_fwcstombs_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="wctob"> wctob </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>int wctob( wint_t wc );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> wctob</tt> function determines whether<b> wc</b> corresponds to a member of the extended character set whose multibyte
 character representation is as a single byte when in the initial shift state.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> wctob</tt> function returns<tt> EOF</tt> if<b> wc</b> does not correspond to a multibyte character with length one;
 otherwise, it returns the single byte representation.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_mbccmp">_mbccmp</a>, <a href="#_mbccpy">_mbccpy</a>, <a href="#_mbcicmp">_mbcicmp</a>, <a href="#_mbcjistojms">_mbcjistojms</a>,
 <a href="#_mbcjmstojis">_mbcjmstojis</a>, <a href="#_mbclen">_mbclen</a>, <a href="#_mbctohira">_mbctohira</a>, <a href="#_mbctokata">_mbctokata</a>,
 <a href="#_mbctolower">_mbctolower</a>, <a href="#_mbctombb">_mbctombb</a>, <a href="#_mbctoupper">_mbctoupper</a>, <a href="#mblen">mblen</a>,
 <a href="#mbrlen">mbrlen</a>, <a href="#mbrtowc">mbrtowc</a>, <a href="#mbsrtowcs">mbsrtowcs</a>, <a href="#mbsrtowcs_s">mbsrtowcs_s</a>,
 <a href="#mbstowcs">mbstowcs</a>, <a href="#mbstowcs_s">mbstowcs_s</a>, <a href="#mbtowc">mbtowc</a>, <a href="#btowc">btowc</a>,
 <a href="#wcrtomb">wcrtomb</a>, <a href="#wcrtomb_s">wcrtomb_s</a>, <a href="#wcsrtombs">wcsrtombs</a>, <a href="#wcsrtombs_s">wcsrtombs_s</a>,
 <a href="#wcstombs">wcstombs</a>, <a href="#wcstombs_s">wcstombs_s</a>, <a href="#wctomb">wctomb</a>, <a href="#wctomb_s">wctomb_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><tt>#include &lt;mbctype.h&gt;</tt>
<br><br><tt>const wint_t wc&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0020,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x002e,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0031,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0041,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x3000,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte space */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff21,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte A */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x3048,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Hiragana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x30a3,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Katakana */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff61,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana punctuation */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff66,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0xff9f,&nbsp;&nbsp;&nbsp;&nbsp; /* single-byte Katakana alphabetic */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x720d,&nbsp;&nbsp;&nbsp;&nbsp; /* double-byte Kanji */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; 0x0000</tt>
<br><tt>};</tt>
<br><br><tt>#define SIZE sizeof( wc ) / sizeof( wchar_t )</tt>
<br><br><tt>void main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, j;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setmbcp( 932 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; SIZE; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j = wctob( wc&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( j == EOF ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x EOF\n&quot;, wc&#91;i&#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%#6.4x-&gt;%#6.4x\n&quot;, wc&#91;i&#93;, j );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>0x0020-&gt;0x0020</tt>
<br><tt>0x002e-&gt;0x002e</tt>
<br><tt>0x0031-&gt;0x0031</tt>
<br><tt>0x0041-&gt;0x0041</tt>
<br><tt>0x3000 EOF</tt>
<br><tt>0xff21 EOF</tt>
<br><tt>0x3048 EOF</tt>
<br><tt>0x30a3 EOF</tt>
<br><tt>0xff61-&gt;0x00a1</tt>
<br><tt>0xff66-&gt;0x00a6</tt>
<br><tt>0xff9f-&gt;0x00df</tt>
<br><tt>0x720d EOF</tt>
<br><tt>&nbsp; 0000-&gt;0x0000</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32
</dl>
<h2 id="wctomb"> wctomb, _fwctomb </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>int wctomb( char *s, wchar_t wc );</tt>
<br><tt>#include &lt;mbstring.h&gt;</tt>
<br><tt>int _fwctomb( char __far *s, wchar_t wc );</tt>
</dl>
<dl>
<dt>Safer C:
<dd>The Safer C Library extension provides the <a href="#wctomb_s">wctomb_s</a> function which is a safer alternative to<tt> wctomb</tt>.
&nbsp; This newer<tt> wctomb_s</tt> function is recommended to be used instead of the traditional &quot;unsafe&quot;<tt> wctomb</tt>
 function.
</dl>
<dl>
<dt>Description:
<dd>The<tt> wctomb</tt> function determines the number of bytes required to represent the multibyte character corresponding to
 the wide character contained in<b> wc</b>.&nbsp; If<b> s</b> is not a NULL pointer, the multibyte character representation
 is stored in the array pointed to by<b> s</b>.&nbsp; At most <tt> MB_CUR_MAX</tt> characters will be stored.
<br>The<tt> _fwctomb</tt> function is a data model independent form of the<tt> wctomb</tt> function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>If<b> s</b> is a NULL pointer, the<tt> wctomb</tt> function returns zero if multibyte character encodings are not state dependent,
 and non-zero otherwise.&nbsp; If<b> s</b> is not a NULL pointer, the<tt> wctomb</tt> function returns:
<dl>
<dt>Value&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>-1
<dd>if the value of<b> wc</b> does not correspond to a valid multibyte character
<dt><br>len
<dd>the number of bytes that comprise the multibyte character corresponding to the value of<b> wc</b>.
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#wctomb_s">wctomb_s</a>, <a href="#mblen">mblen</a>, <a href="#mbstowcs">mbstowcs</a>, <a href="#mbstowcs_s">mbstowcs_s</a>,
 <a href="#mbtowc">mbtowc</a>, <a href="#wcstombs">wcstombs</a>, <a href="#wcstombs_s">wcstombs_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>wchar_t wchar = { 0x0073 };</tt>
<br><tt>char&nbsp;&nbsp;&nbsp; mbbuffer&#91;2&#93;;</tt>
<br><br><tt>void main()</tt>
<br><tt>&nbsp; {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int len;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Character encodings are %sstate dependent\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( wctomb( NULL, 0 ) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ? &quot;&quot; : &quot;not &quot; );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; len = wctomb( mbbuffer, wchar );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; mbbuffer&#91;len&#93; = '\0';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, mbbuffer, len );</tt>
<br><tt>&nbsp; }</tt>
<br><br>produces the following:
<br><br><tt>Character encodings are not state dependent</tt>
<br><tt>s(1)</tt>
</dl>
<dl>
<dt>Classification:
<dd>wctomb is ANSI
<br>_fwctomb is not ANSI
</dl>
<dl>
<dt>Systems:
<dd><tt> wctomb - All, Netware</tt>
<br><tt>_fwctomb - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="wctomb_s"> wctomb_s, _fwctomb_s </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><tt>errno_t wctomb_s( int * restrict status,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char * restrict
 s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t smax,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t wc);</tt>
<br><tt>errno_t _fwctomb_s( int __far * restrict status,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char __far
 * restrict s,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rsize_t smax,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wchar_t wc);</tt>
</dl>
<dl>
<dt>Constraints:
<dd>If any of the following runtime-constraints is violated, the currently active runtime-constraint handler will be invoked and<tt>
 wctomb_s</tt> will return a non-zero value to indicate an error, or the runtime-constraint handler aborts the program.
<br>Let<b> n</b> denote the number of bytes needed to represent the multibyte character corresponding to the wide character
 given by<b> wc</b> (including any shift sequences).
<br><br>If<b> s</b> is not a null pointer, then<b> smax</b> shall not be less than<b> n</b>, and<b> smax</b> shall not be
 greater than <tt> RSIZE_MAX</tt>.&nbsp; If<b> s</b> is a null pointer, then<b> smax</b> shall equal zero.
<br><br>If there is a runtime-constraint violation,<tt> wctomb_s</tt> does not modify the int pointed to by<b> status</b>,
 and if<b> s</b> is not a null pointer, no more than<b> smax</b> elements in the array pointed to by<b> s</b> will be accessed.
</dl>
<dl>
<dt>Description:
<dd>The<tt> wctomb_s</tt> function determines<b> n</b> and stores the multibyte character representation of<b> wc</b> in the array
 whose first element is pointed to by<b> s</b> (if<b> s</b> is not a null pointer).&nbsp; The number of characters stored
 never exceeds <tt> MB_CUR_MAX</tt> or<b> smax</b>.&nbsp; If<b> wc</b> is a null wide character, a null byte is stored, preceded
 by any shift sequence needed to restore the initial shift state, and the function is left in the initial conversion state.
<br>The implementation shall behave as if no library function calls the<tt> wctomb_s</tt> function.
<br><br>If<b> s</b> is a null pointer,the<tt> wctomb_s</tt> function stores into the int pointed to by<b> status</b> a nonzero
 or zero value, if multibyte character encodings, respectively, do or do not have state-dependent encodings.
<br><br>If<b> s</b> is not a null pointer,the<tt> wctomb_s</tt> function stores into the int pointed to by<b> status</b> either<b>
 n</b> or<b> -1</b> if<b> wc</b>, respectively, does or does not correspond to a valid multibyte character.
<br><br>In no case will the int pointed to by<b> status</b> be set to a value greater than the <tt> MB_CUR_MAX</tt> macro.
<br><br>The<tt> _fwctomb_s</tt> function is a data model independent form of the wctomb_s function that accepts far pointer
 arguments.&nbsp; It is most useful in mixed memory model applications.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> wctomb_s</tt> function returns zero if there was no runtime-constraint violation.&nbsp; Otherwise, a non-zero value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#wctomb">wctomb</a>, <a href="#mblen">mblen</a>, <a href="#mbstowcs">mbstowcs</a>, <a href="#mbstowcs_s">mbstowcs_s</a>,
 <a href="#mbtowc">mbtowc</a>, <a href="#wcstombs">wcstombs</a>, <a href="#wcstombs_s">wcstombs_s</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#define __STDC_WANT_LIB_EXT1__ 1</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>wchar_t wchar = { 0x0073 };</tt>
<br><tt>char&nbsp;&nbsp;&nbsp; mbbuffer&#91;3&#93;;</tt>
<br><br><tt>int main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; len;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; status;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; errno_t rc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = wctomb_s( &amp;status, NULL, 0, wchar );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; printf( &quot;Character encodings are %sstate dependent\n&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( status ) ? &quot;&quot; : &quot;not &quot; );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; rc = wctomb_s( &amp;len, mbbuffer, 2, wchar );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( rc != 0) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Character encoding error\n&quot;);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mbbuffer&#91;len&#93; = '\0';</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%d)\n&quot;, mbbuffer, len );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( rc );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>Character encodings are not state dependent</tt>
<br><tt>s(1)</tt>
</dl>
<dl>
<dt>Classification:
<dd>wctomb_s is TR 24731
<br>_fwctomb_s is WATCOM
</dl>
<dl>
<dt>Systems:
<dd><tt> wctomb_s - All, Netware</tt>
<br><tt>_fwctomb_s - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h2 id="wctrans"> wctrans </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>wctrans_t wctrans( const char *property );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> wctrans</tt> function constructs a value with type <tt> wctrans_t</tt> that describes a mapping between wide characters
 identified by the string argument<b> property</b>.&nbsp; The constructed value is affected by the <tt> LC_CTYPE</tt> category
 of the current locale; the constructed value becomes indeterminate if the category's setting is changed.
<br>The two strings listed below are valid in all locales as<b> property</b> arguments to the<tt> wctrans</tt> function.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>tolower
<dd>uppercase characters are mapped to lowercase
<dt><br>toupper
<dd>lowercase characters are mapped to uppercase
</dl>
</dl>
<dl>
<dt>Returns:
<dd>If<b> property</b> identifies a valid class of wide characters according to the <tt> LC_CTYPE</tt> category of the current
 locale, the<tt> wctrans</tt> function returns a non-zero value that is valid as the second argument to the <tt> towctrans</tt>
 function; otherwise, it returns zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>,
 <a href="#isprint">isprint</a>, <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>,
 <a href="#iswctype">iswctype</a>, <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>,
 <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><br><tt>char *translations&#91;2&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;tolower&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;toupper&quot;</tt>
<br><tt>};</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wint_t&nbsp; wc = 'A';</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wint_t&nbsp; twc;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 2; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; twc = towctrans( wc, wctrans( translations&#91;i&#93; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s(%lc): %lc\n&quot;, translations&#91;i&#93;, wc, twc );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>tolower(A): a</tt>
<br><tt>toupper(A): A</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All, Netware
</dl>
<h2 id="wctype"> wctype </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wctype.h&gt;</tt>
<br><tt>wctype_t wctype( const char *property );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> wctype</tt> function constructs a value with type <tt> wctype_t</tt> that describes a class of wide characters identified
 by the string argument,<b> property</b>.&nbsp; The constructed value is affected by the <tt> LC_CTYPE</tt> category of the
 current locale; the constructed value becomes indeterminate if the category's setting is changed.
<br>The twelve strings listed below are valid in all locales as<b> property</b> arguments to the<tt> wctype</tt> function.
<dl>
<dt>Constant&nbsp;&nbsp;&nbsp;&nbsp; Meaning
<dt>alnum
<dd>any wide character for which one of <tt> iswalpha</tt> or <tt> iswdigit</tt> is true
<dt><br>alpha
<dd>any wide character for which <tt> iswupper</tt> or <tt> iswlower</tt> is true, that is, for any wide character that is one
 of an implementation-defined set for which none of <tt> iswcntrl</tt>, <tt> iswdigit</tt>, <tt> iswpunct</tt>, or <tt> iswspace</tt>
 is true
<dt><br>blank
<dd>any wide character corresponding to a standard blank character (space or horizontal tab) or is one of an implementation-defined
 set of wide characters for which <tt> iswblank</tt> is true
<dt><br>cntrl
<dd>any control wide character
<dt><br>digit
<dd>any wide character corresponding to a decimal-digit character
<dt><br>graph
<dd>any printable wide character except a space wide character
<dt><br>lower
<dd>any wide character corresponding to a lowercase letter, or one of an implementation-defined set of wide characters for which
 none of <tt> iswcntrl</tt>, <tt> iswdigit</tt>, <tt> iswpunct</tt>, or <tt> iswspace</tt> is true
<dt><br>print
<dd>any printable wide character including a space wide character
<dt><br>punct
<dd>any printable wide character that is not a space wide character or a wide character for which <tt> iswalnum</tt> is true
<dt><br>space
<dd>any wide character corresponding to a standard white-space character or is one of an implementation-defined set of wide characters
 for which <tt> iswalnum</tt> is false
<dt><br>upper
<dd>any wide character corresponding to a uppercase letter, or if c is one of an implementation-defined set of wide characters
 for which none of <tt> iswcntrl</tt>, <tt> iswdigit</tt>, <tt> iswpunct</tt>, or <tt> iswspace</tt> is true
<dt><br>xdigit
<dd>any wide character corresponding to a hexadecimal digit character
</dl>
</dl>
<dl>
<dt>Returns:
<dd>If<b> property</b> identifies a valid class of wide characters according to the <tt> LC_CTYPE</tt> category of the current
 locale, the<tt> wctype</tt> function returns a non-zero value that is valid as the second argument to the <tt> iswctype</tt>
 function; otherwise, it returns zero.
</dl>
<dl>
<dt>See Also:
<dd><a href="#isalnum">isalnum</a>, <a href="#isalpha">isalpha</a>, <a href="#isblank">isblank</a>, <a href="#iscntrl">iscntrl</a>,
 <a href="#isdigit">isdigit</a>, <a href="#isgraph">isgraph</a>, <a href="#isleadbyte">isleadbyte</a>, <a href="#islower">islower</a>,
 <a href="#isprint">isprint</a>, <a href="#ispunct">ispunct</a>, <a href="#isspace">isspace</a>, <a href="#isupper">isupper</a>,
 <a href="#iswctype">iswctype</a>, <a href="#isxdigit">isxdigit</a>, <a href="#tolower">tolower</a>, <a href="#toupper">toupper</a>,
 <a href="#towctrans">towctrans</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;wchar.h&gt;</tt>
<br><br><tt>char *types&#91;&#93; = {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;alnum&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;blank&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;alpha&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;cntrl&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;digit&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;graph&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;lower&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;print&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;punct&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;space&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;upper&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; &quot;xdigit&quot;</tt>
<br><tt>};</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; wint_t&nbsp; wc = 'A';</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( i = 0; i &lt; 12; i++ )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( iswctype( wc, wctype( types&#91;i&#93; ) ) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;%s\n&quot;, types&#91;i&#93; );</tt>
<br><tt>}</tt>
<br><br>produces the following:
<br><br><tt>alnum</tt>
<br><tt>alpha</tt>
<br><tt>graph</tt>
<br><tt>print</tt>
<br><tt>upper</tt>
<br><tt>xdigit</tt>
</dl>
<dl>
<dt>Classification:
<dd>ANSI
</dl>
<dl>
<dt>Systems:
<dd>All
</dl>
<h2 id="_wrapon"> _wrapon </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>short _FAR _wrapon( short wrap );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _wrapon</tt> function is used to control the display of text when the text output reaches the right side of the text
 window.&nbsp; This is text displayed with the <tt> _outtext</tt> and <tt> _outmem</tt> functions.&nbsp; The<b> wrap</b> argument
 can take one of the following values:
<dl>
<dt>_GWRAPON
<dd>causes lines to wrap at the window border
<dt><br>_GWRAPOFF
<dd>causes lines to be truncated at the window border
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _wrapon</tt> function returns the previous setting for wrapping.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_settextwindow">_settextwindow</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;conio.h&gt;</tt>
<br><tt>#include &lt;graph.h&gt;</tt>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><br><tt>main()</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int i;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char buf&#91; 80 &#93;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _TEXTC80 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _settextwindow( 5, 20, 20, 30 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _wrapon( _GWRAPOFF );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 1; i &lt;= 3; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _settextposition( 2 * i, 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Very very long line %d&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _wrapon( _GWRAPON );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( i = 4; i &lt;= 6; ++i ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _settextposition( 2 * i, 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sprintf( buf, &quot;Very very long line %d&quot;, i );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _outtext( buf );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; getch();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; _setvideomode( _DEFAULTMODE );</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>_wrapon is PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="write"> write, _write </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>int write( int handle, void *buffer, unsigned len );</tt>
<br><tt>int _write( int handle, void *buffer, unsigned len );</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> write</tt> function writes data at the operating system level.&nbsp; The number of bytes transmitted is given by<b>
 len</b> and the data to be transmitted is located at the address specified by<b> buffer</b>.
<br>The<tt> _write</tt> function is identical to<tt> write</tt>.&nbsp; Use<tt> _write</tt> for ANSI/ISO naming conventions.
<br><br>The<b> handle</b> value is returned by the <tt> open</tt> function.&nbsp; The access mode must have included either
 <tt> O_WRONLY</tt> or <tt> O_RDWR</tt> when the <tt> open</tt> function was invoked.
<br><br>The data is written to the file at the end when the file was opened with <tt> O_APPEND</tt> included as part of the
 access mode; otherwise, it is written at the current file position for the file in question.&nbsp; This file position can
 be determined with the <tt> tell</tt> function and can be set with the <tt> lseek</tt> function.
<br><br>When <tt> O_BINARY</tt> is included in the access mode, the data is transmitted unchanged.&nbsp; When <tt> O_TEXT</tt>
 is included in the access mode, the data is transmitted with extra carriage return characters inserted before each linefeed
 character encountered in the original data.
<br><br>A file can be truncated under DOS and OS/2 2.0 by specifying 0 as the<b> len</b> argument.<b>&nbsp; Note,</b> however,
 that this doesn't work under OS/2 2.1, Windows NT/2000, and other operating systems.&nbsp; To truncate a file in a portable
 manner, use the <tt> chsize</tt> function.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> write</tt> function returns the number of bytes (does not include any extra carriage-return characters transmitted)
 of data transmitted to the file.&nbsp; When there is no error, this is the number given by the<b> len</b> argument.&nbsp;
 In the case of an error, such as there being no space available to contain the file data, the return value will be less than
 the number of bytes transmitted.&nbsp; A value of -1 may be returned in the case of some output errors.&nbsp; When an error
 has occurred, <tt> errno</tt> contains a value indicating the type of error that has been detected.
</dl>
<dl>
<dt>See Also:
<dd><a href="#chsize">chsize</a>, <a href="#close">close</a>, <a href="#creat">creat</a>, <a href="#dup">dup</a>, <a href="#dup2">dup2</a>,
 <a href="#eof">eof</a>, <a href="#exec___">exec...</a>, <a href="#fdopen">fdopen</a>, <a href="#filelength">filelength</a>,
 <a href="#fileno">fileno</a>, <a href="#fstat">fstat</a>, <a href="#_grow_handles">_grow_handles</a>, <a href="#isatty">isatty</a>,
 <a href="#lseek">lseek</a>, <a href="#open">open</a>, <a href="#read">read</a>, <a href="#setmode">setmode</a>, <a href="#sopen">sopen</a>,
 <a href="#stat">stat</a>, <a href="#tell">tell</a>, <a href="#umask">umask</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>#include &lt;stdio.h&gt;</tt>
<br><tt>#include &lt;io.h&gt;</tt>
<br><tt>#include &lt;fcntl.h&gt;</tt>
<br><br><tt>char buffer&#91;&#93;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = { &quot;A text record to be written&quot; };</tt>
<br><br><tt>void main( void )</tt>
<br><tt>{</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int handle;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int size_written;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; /* open a file for output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; /* replace existing file if it exists */</tt>
<br><tt>&nbsp;&nbsp;&nbsp; handle = open( &quot;file&quot;,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; O_WRONLY | O_CREAT | O_TRUNC
 | O_TEXT,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; S_IRUSR | S_IWUSR | S_IRGRP
 | S_IWGRP );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( handle != -1 ) {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* write the text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_written = write( handle, buffer,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof( buffer ) );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* test for error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( size_written != sizeof( buffer ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( &quot;Error writing file\n&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* close the file&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; */</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; close( handle );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<dl>
<dt>Classification:
<dd>write is POSIX 1003.1
<br>_write is not POSIX
<br>_write conforms to ANSI/ISO naming conventions
</dl>
<dl>
<dt>Systems:
<dd><tt> write - All, Netware</tt>
<br><tt>_write - DOS, Windows, Win386, Win32, OS/2 1.x(all), OS/2-32</tt>
</dl>
<h1 id="ReMentrant_Functions"> Re-entrant Functions </h1>
<br>The following functions in the C library are re-entrant:
<br><br><tt>abs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; atoi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; atol&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bsearch&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; bsearch_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; div&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; fabs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmbsrtowcs_s&nbsp; _fmbstowcs_s&nbsp;&nbsp; _fmemccpy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemcmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemcpy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemicmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemmove&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fmemset
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrcat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 _fstrcmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrcpy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrcspn&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _fstricmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrlen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrlwr&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _fstrncat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrncmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrncpy&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _fstrnicmp&nbsp;&nbsp;&nbsp;&nbsp; _fstrnset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrpbrk&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 _fstrrchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrrev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; _fstrspn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrstr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _fstrupr&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; _fwcrtombs_s&nbsp;&nbsp; _fwcsrtombs_s&nbsp; _fwcstombs_s&nbsp;&nbsp; _fwctomb_s&nbsp;&nbsp;&nbsp;&nbsp;
 isalnum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isalpha&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isascii&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; isblank&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iscntrl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 isdigit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isgraph&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; islower&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; isprint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ispunct&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 isspace&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isupper&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; isxdigit&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; itoa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ldiv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lfind&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longjmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _lrotl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _lrotr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lsearch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ltoa
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _makepath&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mblen&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mbsrtowcs_s&nbsp;&nbsp;&nbsp; mbstowcs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mbstowcs_s
&nbsp;&nbsp;&nbsp;&nbsp; mbtowc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memccpy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; memchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memcpy_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memicmp&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; memmove&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memmove_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memset&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movedata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qsort&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; qsort_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _rotl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _rotr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; segread&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 setjmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _splitpath&nbsp;&nbsp;&nbsp;&nbsp; strcat&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; strcat_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 strcmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcoll&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcpy_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strcspn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; strerror_s&nbsp;&nbsp;&nbsp;&nbsp; strerrorlen_s&nbsp; stricmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strlen&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strlwr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncat&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; strncat_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strncpy_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strnicmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; strnlen_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strnset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strpbrk&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; strrchr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strrev&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; strset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strspn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strstr
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strtok_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strupr&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; swab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tolower&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; toupper&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ultoa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; utoa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcrtombs_s&nbsp;&nbsp;&nbsp;&nbsp; wcscat_s&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcscpy_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcserror_s&nbsp;&nbsp;&nbsp;&nbsp; wcserrorlen_s
&nbsp; wcsncat_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcsncat_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcsncpy_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 wcsnlen_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcsrtombs_s&nbsp;&nbsp;&nbsp; wcstok_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcstombs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wcstombs_s&nbsp;&nbsp;&nbsp;&nbsp; wctomb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>wctomb_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wmemcpy_s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wmemmove_s&nbsp;&nbsp;&nbsp;
 </tt>
<h1 id="ImplementationMDefined_Behavior_of_the_C_Library"> Implementation-Defined Behavior of the C Library </h1>
<br><br>This appendix describes the behavior of the 16-bit and 32-bit Watcom C libraries when the ANSI/ISO C Language standard
 describes the behavior as<b> implementation-defined.</b>&nbsp; The term describing each behavior is taken directly from the
 ANSI/ISO C Language standard.&nbsp; The numbers in parentheses at the end of each term refers to the section of the standard
 that discusses the behavior.
<h2 id="NULL_Macro"> NULL Macro </h2>
<br><b>The null pointer constant to which the macro </b><tt> NULL</tt><b> expands (7.1.6).</b>
<br><br>The macro <tt> NULL</tt> expands to 0 in small data models and to 0L in large data models.
<h2 id="Diagnostic_Printed_by_the_assert_Function"> Diagnostic Printed by the assert Function </h2>
<br><b>The diagnostic printed by and the termination behavior of the </b><tt> assert</tt><b> function (7.2).</b>
<br><br>The <tt> assert</tt> function prints a diagnostic message to <tt> stderr</tt> and calls the <tt> abort</tt> routine
 if the expression is false.&nbsp; The diagnostic message has the following form:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Assertion failed: &#91;expression&#93;, file &#91;name&#93;, line &#91;number&#93;</tt>
<h2 id="Character_Testing"> Character Testing </h2>
<br><b>The sets of characters tested for by the </b><tt> isalnum</tt><b>, </b><tt> isalpha</tt><b>, </b><tt> iscntrl</tt><b>,
 </b><tt> islower</tt><b>, </b><tt> isprint</tt><b>, and </b><tt> isupper</tt><b> functions (7.3.1).</b>
<dl>
<dt>Function&nbsp;&nbsp;&nbsp;&nbsp; Characters Tested For
<dt>isalnum
<dd>Characters 0-9, A-Z, a-z
<dt><br>isalpha
<dd>Characters A-Z, a-z
<dt><br>iscntrl
<dd>ASCII 0x00-0x1f, 0x7f
<dt><br>islower
<dd>Characters a-z
<dt><br>isprint
<dd>ASCII 0x20-0x7e
<dt><br>isupper
<dd>Characters A-Z
</dl>
<h2 id="Domain_Errors"> Domain Errors </h2>
<br><b>The values returned by the mathematics functions on domain errors (7.5.1).</b>
<br><br>When a domain error occurs, the listed values are returned by the following functions:
<dl>
<dt>Function&nbsp;&nbsp;&nbsp;&nbsp; Value returned
<dt>acos
<dd>0.0
<dt><br>acosh
<dd>- HUGE_VAL
<dt><br>asin
<dd>0.0
<dt><br>atan2
<dd>0.0
<dt><br>atanh
<dd>- HUGE_VAL
<dt><br>log
<dd>- HUGE_VAL
<dt><br>log10
<dd>- HUGE_VAL
<dt><br>log2
<dd>- HUGE_VAL
<dt><br>pow(neg,frac)
<dd>0.0
<dt><br>pow(0.0,0.0)
<dd>1.0
<dt><br>pow(0.0,neg)
<dd>- HUGE_VAL
<dt><br>sqrt
<dd>0.0
<dt><br>y0
<dd>- HUGE_VAL
<dt><br>y1
<dd>- HUGE_VAL
<dt><br>yn
<dd>- HUGE_VAL
</dl>
<h2 id="Underflow_of_FloatingMPoint_Values"> Underflow of Floating-Point Values </h2>
<br><b>Whether the mathematics functions set the integer expression </b><tt> errno</tt><b> to the value of the macro </b><tt>
 ERANGE</tt><b> on underflow range errors (7.5.1).</b>
<br><br>The integer expression <tt> errno</tt> is not set to <tt> ERANGE</tt> on underflow range errors in the mathematics
 functions.
<h2 id="The_fmod_Function"> The fmod Function </h2>
<br><b>Whether a domain error occurs or zero is returned when the </b><tt> fmod</tt><b> function has a second argument of
 zero (7.5.6.4).</b>
<br><br>Zero is returned when the second argument to <tt> fmod</tt> is zero.
<h2 id="The_signal_Function"> The signal Function </h2>
<br><b>The set of signals for the </b><tt> signal</tt><b> function (7.7.1.1).</b>
<br><br>See the description of the <tt> signal</tt> function presented earlier in this book.
<br><br><b>The semantics for each signal recognized by the </b><tt> signal</tt><b> function (7.7.1.1).</b>
<br><br>See the description of the <tt> signal</tt> function presented earlier in this book.
<br><br><b>The default handling and the handling at program startup for each signal recognized by the </b><tt> signal</tt><b>
 function (7.7.1.1).</b>
<br><br>See the description of the <tt> signal</tt> function presented earlier in this book.
<h2 id="Default_Signals"> Default Signals </h2>
<br><b>If the equivalent of </b><tt> signal</tt><b>( sig, SIG_DFL ) is not executed prior to the call of a signal handler,
 the blocking of the signal that is performed (7.7.1.1).</b>
<br><br>The equivalent of
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; signal( sig, SIG_DFL );</tt>
<br><br>is executed prior to the call of a signal handler.
<h2 id="The_SIGILL_Signal"> The SIGILL Signal </h2>
<br><b>Whether the default handling is reset if the </b><tt> SIGILL</tt><b> signal is received by a handler specified to the
 </b><tt> signal</tt><b> function (7.7.1.1).</b>
<br><br>The equivalent of
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; signal( SIGILL, SIG_DFL );</tt>
<br><br>is executed prior to the call of the signal handler.
<h2 id="Terminating_Newline_Characters"> Terminating Newline Characters </h2>
<br><b>Whether the last line of a text stream requires a terminating new-line character (7.9.2).</b>
<br><br>The last line of a text stream does not require a terminating new-line character.
<h2 id="Space_Characters"> Space Characters </h2>
<br><b>Whether space characters that are written out to a text stream immediately before a new-line character appear when
 read in (7.9.2).</b>
<br><br>All characters written out to a text stream will appear when read in.
<h2 id="Null_Characters"> Null Characters </h2>
<br><b>The number of null characters that may be appended to data written to a binary stream (7.9.2).</b>
<br><br>No null characters are appended to data written to a binary stream.
<h2 id="File_Position_in_Append_Mode"> File Position in Append Mode </h2>
<br><b>Whether the file position indicator of an append mode stream is initially positioned at the beginning or end of the
 file (7.9.3).</b>
<br><br>When a file is open in append mode, the file position indicator initially points to the end of the file.
<h2 id="Truncation_of_Text_Files"> Truncation of Text Files </h2>
<br><b>Whether a write on a text stream causes the associated file to be truncated beyond that point (7.9.3).</b>
<br><br>Writing to a text stream does not truncate the file beyond that point.
<h2 id="File_Buffering"> File Buffering </h2>
<br><b>The characteristics of file buffering (7.9.3).</b>
<br><br>Disk files accessed through the standard I/O functions are fully buffered.&nbsp; The default buffer size is 512 bytes
 for 16-bit systems, and 4096 bytes for 32-bit systems.
<h2 id="ZeroMLength_Files"> Zero-Length Files </h2>
<br><b>Whether a zero-length file actually exists (7.9.3).</b>
<br><br>A file with length zero can exist.
<h2 id="File_Names"> File Names </h2>
<br><b>The rules of composing valid file names (7.9.3).</b>
<br><br>A valid file specification consists of an optional drive letter (which is always followed by a colon), a series of
 optional directory names separated by backslashes, and a file name.
<br><br><b>FAT File System:</b>&nbsp; Directory names and file names can contain up to eight characters followed optionally
 by a period and a three letter extension.&nbsp; The complete path (including drive, directories and file name) cannot exceed
 143 characters.&nbsp; Case is ignored (lowercase letters are converted to uppercase letters).
<br><br><b>HPFS File System:</b>&nbsp; Directory names and file names can contain up to 254 characters in the OS/2 High Performance
 File System (HPFS).&nbsp; However, the complete path (including drive, directories and file name) cannot exceed 259 characters.
&nbsp; The period is a valid file name character and can appear in a file name or directory name as many times as required;
 HPFS file names do not require file extensions as in the FAT file system.&nbsp; The HPFS preserves case in file names only
 in directory listings but ignores case in file searches and other system operations (i.e, a directory cannot have more than
 one file whose names differ only in case).
<h2 id="File_Access_Limits"> File Access Limits </h2>
<br><b>Whether the same file can be open multiple times (7.9.3).</b>
<br><br>It is possible to open a file multiple times.
<h2 id="Deleting_Open_Files"> Deleting Open Files </h2>
<br><b>The effect of the </b><tt> remove</tt><b> function on an open file (7.9.4.1).</b>
<br><br>The <tt> remove</tt> function deletes a file, even if the file is open.
<h2 id="Renaming_with_a_Name_that_Exists"> Renaming with a Name that Exists </h2>
<br><b>The effect if a file with the new name exists prior to a call to the </b><tt> rename</tt><b> function (7.9.4.2).</b>
<br><br>The <tt> rename</tt> function will fail if you attempt to rename a file using a name that exists.
<h2 id="Printing_Pointer_Values"> Printing Pointer Values </h2>
<br><b>The output for</b><tt> %p</tt><b> conversion in the </b><tt> fprintf</tt><b> function (7.9.6.1).</b>
<br><br>Two types of pointers are supported:&nbsp; near pointers (%hp), and far pointers (%lp).&nbsp; The output for %p depends
 on the memory model being used.
<br><br>In 16-bit mode, the <tt> fprintf</tt> function produces hexadecimal values of the form XXXX for 16-bit near pointers,
 and XXXX:XXXX (segment and offset separated by a colon) for 32-bit far pointers.
<br><br>In 32-bit mode, the <tt> fprintf</tt> function produces hexadecimal values of the form XXXXXXXX for 32-bit near pointers,
 and XXXX:XXXXXXXX (segment and offset separated by a colon) for 48-bit far pointers.
<h2 id="Reading_Pointer_Values"> Reading Pointer Values </h2>
<br><b>The input for</b><tt> %p</tt><b> conversion in the </b><tt> fscanf</tt><b> function (7.9.6.2).</b>
<br><br>The <tt> fscanf</tt> function converts hexadecimal values into the correct address when the %p format specifier is
 used.
<h2 id="Reading_Ranges"> Reading Ranges </h2>
<br><b>The interpretation of a</b><tt> -</tt><b> character that is neither the first nor the last character in the scanlist
 for</b><tt> %&#91;</tt><b> conversion in the </b><tt> fscanf</tt><b> function (7.9.6.2).</b>
<br><br>The &quot;-&quot; character indicates a character range.&nbsp; The character prior to the &quot;-&quot; is the first
 character in the range.&nbsp; The character following the &quot;-&quot; is the last character in the range.
<h2 id="File_Position_Errors"> File Position Errors </h2>
<br><b>The value to which the macro </b><tt> errno</tt><b> is set by the </b><tt> fgetpos</tt><b> or </b><tt> ftell</tt><b>
 function on failure (7.9.9.1, 7.9.9.4).</b>
<br><br>When the function <tt> fgetpos</tt> or <tt> ftell</tt> fails, they set <tt> errno</tt> to <tt> EBADF</tt> if the file
 number is bad.&nbsp; The constants are defined in the<tt> &lt;errno.h&gt;</tt> header file.
<h2 id="Messages_Generated_by_the_perror_Function"> Messages Generated by the perror Function </h2>
<br><b>The messages generated by the </b><tt> perror</tt><b> function (7.9.10.4).</b>
<br><br>The <tt> perror</tt> function generates the following messages.
<dl>
<dt><b><i>Error</i></b>
<dd><b><i>Message</i></b>
<dt><br>0
<dd>&quot;Error 0&quot;
<dt><br>1
<dd>&quot;No such file or directory&quot;
<dt><br>2
<dd>&quot;Argument list too big&quot;
<dt><br>3
<dd>&quot;Exec format error&quot;
<dt><br>4
<dd>&quot;Bad file number&quot;
<dt><br>5
<dd>&quot;Not enough memory&quot;
<dt><br>6
<dd>&quot;Permission denied&quot;
<dt><br>7
<dd>&quot;File exists&quot;
<dt><br>8
<dd>&quot;Cross-device link&quot;
<dt><br>9
<dd>&quot;Invalid argument&quot;
<dt><br>10
<dd>&quot;File table overflow&quot;
<dt><br>11
<dd>&quot;Too many open files&quot;
<dt><br>12
<dd>&quot;No space left on device&quot;
<dt><br>13
<dd>&quot;Argument too large&quot;
<dt><br>14
<dd>&quot;Result too large&quot;
<dt><br>15
<dd>&quot;Resource deadlock would occur&quot;
</dl>
<h2 id="Allocating_Zero_Memory"> Allocating Zero Memory </h2>
<br><b>The behavior of the </b><tt> calloc</tt><b>, </b><tt> malloc</tt><b>, or </b><tt> realloc</tt><b> function if the size
 requested is zero (7.10.3).</b>
<br><br>The value returned will be <tt> NULL</tt>.&nbsp; No actual memory is allocated.
<h2 id="The_abort_Function"> The abort Function </h2>
<br><b>The behavior of the </b><tt> abort</tt><b> function with regard to open and temporary files (7.10.4.1).</b>
<br><br>The <tt> abort</tt> function does not close any files that are open or temporary, nor does it flush any output buffers.
<h2 id="The_atexit_Function"> The atexit Function </h2>
<br><b>The status returned by the </b><tt> exit</tt><b> function if the value of the argument is other than zero, </b><tt>
 EXIT_SUCCESS</tt><b>, or </b><tt> EXIT_FAILURE</tt><b> (7.10.4.3).</b>
<br><br>The <tt> exit</tt> function returns the value of its argument to the operating system regardless of its value.
<h2 id="Environment_Names"> Environment Names </h2>
<br><b>The set of environment names and the method for altering the environment list used by the </b><tt> getenv</tt><b> function
 (7.10.4.4).</b>
<br><br>The set of environment names is unlimited.&nbsp; Environment variables can be set from the DOS command line using
 the SET command.&nbsp; A program can modify its environment variables with the <tt> putenv</tt> function.&nbsp; Such modifications
 last only until the program terminates.
<h2 id="The_system_Function"> The system Function </h2>
<br><b>The contents and mode of execution of the string by the </b><tt> system</tt><b> function (7.10.4.5).</b>
<br><br>The <tt> system</tt> function executes an internal DOS, Windows, or OS/2 command, or an EXE, COM, BAT or CMD file
 from within a C program rather than from the command line.&nbsp; The <tt> system</tt> function examines the <tt> COMSPEC</tt>
 environment variable to find the command interpreter and passes the argument string to the command interpreter.
<h2 id="The_strerror_Function"> The strerror Function </h2>
<br><b>The contents of the error message strings returned by the </b><tt> strerror</tt><b> function (7.11.6.2).</b>
<br><br>The <tt> strerror</tt> function generates the following messages.
<dl>
<dt><b><i>Error</i></b>
<dd><b><i>Message</i></b>
<dt><br>0
<dd>&quot;Error 0&quot;
<dt><br>1
<dd>&quot;No such file or directory&quot;
<dt><br>2
<dd>&quot;Argument list too big&quot;
<dt><br>3
<dd>&quot;Exec format error&quot;
<dt><br>4
<dd>&quot;Bad file number&quot;
<dt><br>5
<dd>&quot;Not enough memory&quot;
<dt><br>6
<dd>&quot;Permission denied&quot;
<dt><br>7
<dd>&quot;File exists&quot;
<dt><br>8
<dd>&quot;Cross-device link&quot;
<dt><br>9
<dd>&quot;Invalid argument&quot;
<dt><br>10
<dd>&quot;File table overflow&quot;
<dt><br>11
<dd>&quot;Too many open files&quot;
<dt><br>12
<dd>&quot;No space left on device&quot;
<dt><br>13
<dd>&quot;Argument too large&quot;
<dt><br>14
<dd>&quot;Result too large&quot;
<dt><br>15
<dd>&quot;Resource deadlock would occur&quot;
</dl>
<h2 id="The_Time_Zone"> The Time Zone </h2>
<br><b>The local time zone and Daylight Saving Time (7.12.1).</b>
<br><br>The default time zone is &quot;Eastern Standard Time&quot; (EST), and the corresponding daylight saving time zone
 is &quot;Eastern Daylight Saving Time&quot; (EDT).
<h2 id="The_clock_Function"> The clock Function </h2>
<br><b>The era for the </b><tt> clock</tt><b> function (7.12.2.1).</b>
<br><br>The <tt> clock</tt> function's era begins with a value of 0 when the program starts to execute.
</body>
