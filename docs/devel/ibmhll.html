<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">
<HTML><HEAD>
<TITLE>High Level Languages Debug Table Documentation</TITLE>
<!-- Begin Header Records  ========================================== -->
<!-- HLLDBG SCRIPT H converted by B2H R2.1a (230) (CMS-OS2) by BOXALL -->
<!-- at TOROLAB6 on 8 Jul 1996 at 16:26:41                            -->
<META HTTP-EQUIV="updated"  CONTENT="1996-07-08">
<META HTTP-EQUIV="review"  CONTENT="1997-07-08">
<META HTTP-EQUIV="expires"  CONTENT="1998-07-08">
</HEAD><BODY>
<!-- End Header Records  ============================================ -->
<A NAME=Top_Of_Page>&#32;</A>
<H1>High Level Languages Debug Table Documentation</H1>
<P>Alan Boxall<BR>
<P>Alan Boxall<BR>
Date of Issue&#58; December 15,1995
<P><ADDRESS>
3T/438/1150/TOR<BR>
SWS Division Toronto Laboratory<BR>
IBM Canada Ltd.<BR>
</ADDRESS>
<HR><P><H2><A NAME=ToC>Table of Contents</A></H2><P>
<P><B><A NAME=ToC_1 HREF="#Header_1" >Document Control Information</A></B><BR>
<P><B><A NAME=ToC_5 HREF="#HDRFIGLIST_START" >Figures</A></B><BR>
<P><B><A NAME=ToC_6 HREF="#HDRDBINTRO" >Introduction</A></B><BR>
<P><B><A NAME=ToC_7 HREF="#HDRDBGEN" >32-bit Object Module Format General Requirements</A></B><BR>
<MENU><MENU>
<LI><A NAME=ToC_8 HREF="#Header_8" >PUBDEF, COMDEF, EXTDEF Records</A>
<LI><A NAME=ToC_9 HREF="#Header_9" >COMENT Record</A>
<LI><A NAME=ToC_10 HREF="#Header_10" >LNAMES Record</A>
<LI><A NAME=ToC_11 HREF="#Header_11" >SEGDEF Record</A>
<LI><A NAME=ToC_12 HREF="#Header_12" >Order of Debug Info Records</A>
</MENU></MENU>
<P><B><A NAME=ToC_13 HREF="#HDRDBSYMBL" >Symbol Scope Table</A></B><BR>
<MENU><MENU>
<LI><A NAME=ToC_14 HREF="#Header_14" >Symbol Scope Table Sub-Record Definitions</A>
</MENU></MENU>
<P><B><A NAME=ToC_45 HREF="#HDRDBTYPE" >Type Table</A></B><BR>
<MENU><MENU>
<LI><A NAME=ToC_46 HREF="#HDRTTEINDX" >Type Index Formats</A>
<LI><A NAME=ToC_47 HREF="#HDRTTENAME" >Name Length Formats</A>
<LI><A NAME=ToC_48 HREF="#HDRTTEPRIM" >Primitive Types Values</A>
<LI><A NAME=ToC_49 HREF="#HDRTTECPLX" >Complex Types Values</A>
<LI><A NAME=ToC_50 HREF="#HDRTTEFLDI" >Field ID Values</A>
<LI><A NAME=ToC_51 HREF="#HDRTTEDEFN" >Type Table Entry Definitions</A>
</MENU></MENU>
<P><B><A NAME=ToC_82 HREF="#HDRDBLINUM" >Line Number Table</A></B><BR>
<MENU><MENU>
<LI><A NAME=ToC_83 HREF="#HDRDBLPATH" >Path Table</A>
<LI><A NAME=ToC_84 HREF="#HDRDBLFILE" >File Names Table</A>
</MENU></MENU>
<P><B><A NAME=ToC_85 HREF="#HDRDBLXSEC" >Appendix A. LX Format Debug Section Description</A></B><BR>
<MENU>
<LI><A NAME=ToC_86 HREF="#Header_86" >Overview</A>
<LI><A NAME=ToC_87 HREF="#Header_87" >Subsection Descriptions</A>
</MENU><HR><P>
<P><STRONG>Synopsis&#58;</STRONG><P>
<P><B>Abstract</B>
<P>This document describes the format of the debug information
generated by the compiler and used by the debugger to allow source
level debugging.
<P>
<P>
<H1><A NAME="Header_1" HREF="#ToC_1">Document Control Information</A></H1>
<TABLE BORDER><TR><TH ALIGN=LEFT>Notice</TH><TR><TD>
<P>The official version of this document is kept in the file HLLDBG
LIST3820 on the DOC LEXTRAN disk.
To obtain a copy of this official version, contact the owner.
<P>
Other formats available are&#58;
<UL>
<P><LI>HLLDBG PS - postscript
<P><LI>HLLDBG HTML - HTML version 3 format
</UL>
<P>Users of this document are personally responsible for
using the official version and for verifying that any
copies of the document, in whole or in part, are of the official
version. If this document is not a copy of the official version, it is
obsolete.
</TD></TR></TABLE>
<P>
<H4><A NAME="Header_2">Current Authors/Updaters List</A></H4>
<UL>
<P><LI>Alan Boxall
</UL>
<P>
<H4><A NAME="Header_3">Approver List</A></H4>
<DL>
<P><DT>Date Approved
<DD>Name, Position/Area
<P><DT>06/01/96
<DD>Alan Boxall, Debug Architect/D438
</DL>
<P>
<H4><A NAME="Header_4">Revision History/Summary of Changes</A></H4>
<DL>
<P><DT>Date
<DD>Description
<P><DT>12/15/95<DD>Initial draft version written by John Mehl (Lexington)
<P><DT>06/20/96<DD>Remove old revision flags/conditionals used by Lexington
<P><DT>07/08/96<DD>Increased size of "Number of Segments" in
the LX Debug format.
</DL>
<P>
<H1><A NAME="HDRFIGLIST_START" HREF="#ToC_5">Figures</A></H1>
<OL>
<LI><A HREF="#TBLDEBRECS" >Debugger Required OMF-32 Record Types</A></LI>
<LI><A HREF="#FIGDBFSYMR" >Symbol Scope Table Record Format</A></LI>
<LI><A HREF="#FIGDBFSYME" >Symbol Scope Table Sub-Record -- General Format</A></LI>
<LI><A HREF="#FIGDBFSXMC" >Symbol Scope Table Sub-Record -- Typical Organization for C</A></LI>
<LI><A HREF="#FIGDBFSBEG" >Symbol Scope Table Sub-Record -- Begin</A></LI>
<LI><A HREF="#FIGDBFSPRC" >Symbol Scope Table Sub-Record -- Procedure, Entry, Member Function</A></LI>
<LI><A HREF="#FIGDBFSEND" >Symbol Scope Table Sub-Record -- End</A></LI>
<LI><A HREF="#FIGDBFSDEF" >Symbol Scope Table Sub-Record -- Auto</A></LI>
<LI><A HREF="#FIGDBFSSTA" >Symbol Scope Table Sub-Record -- Static</A></LI>
<LI><A HREF="#FIGDBFTLS" >Symbol Scope Table Sub-Record -- TLS</A></LI>
<LI><A HREF="#FIGDBFSCOD" >Symbol Scope Table Sub-Record -- CodeLabel</A></LI>
<LI><A HREF="#FIGDBFSREG" >Symbol Scope Table Sub-Record -- Reg</A></LI>
<LI><A HREF="#FIGREGREL" >Symbol Scope Table Sub-Record -- RegRelative</A></LI>
<LI><A HREF="#FIGDBFSCON" >Symbol Scope Table Sub-Record -- Constant</A></LI>
<LI><A HREF="#FIGDBCHSEG" >Symbol Scope Table Sub-Record -- ChangSeg</A></LI>
<LI><A HREF="#FIGDBFSTDF" >Symbol Scope Table Sub-Record -- Typedef</A></LI>
<LI><A HREF="#FIGDBFSPUB" >Symbol Scope Table Sub-Record -- Public</A></LI>
<LI><A HREF="#FIGDBFSMEM" >Symbol Scope Table Sub-Record -- Member</A></LI>
<LI><A HREF="#FIGDBFSBAS" >Symbol Scope Table Sub-Record -- Based</A></LI>
<LI><A HREF="#FIGDBFSBSM" >Symbol Scope Table Sub-Record -- Based with Member</A></LI>
<LI><A HREF="#FIGDBFARYS" >Symbol Scope Table Sub-Record -- Array Symbol Record</A></LI>
<LI><A HREF="#FIGDBFSTAG" >Symbol Scope Table Sub-Record -- Tag</A></LI>
<LI><A HREF="#FIGDBFSMAP" >Symbol Scope Table Sub-Record -- Map</A></LI>
<LI><A HREF="#FIGDBFSTAB" >Symbol Scope Table Sub-Record -- Table</A></LI>
<LI><A HREF="#FIGDBFSCUI" >Symbol Scope Table Sub-Record -- CuInfo</A></LI>
<LI><A HREF="#FIGCLASSSR" >Symbol Scope Table Sub-Record -- Tag2</A></LI>
<LI><A HREF="#FIGCPPSR" >Symbol Scope Table Sub-Record -- AutoScoped</A></LI>
<LI><A HREF="#FIGSTATSR" >Symbol Scope Table Sub-Record -- StaticScoped</A></LI>
<LI><A HREF="#FIGDBFTYPR" >Type Table Record Format</A></LI>
<LI><A HREF="#FIGDBFTYSR" >Type Table Entry Sub-Record -- General Format</A></LI>
<LI><A HREF="#FIGDBFTYSP" >Type Table Entry Sub-Record -- Specific Data Format</A></LI>
<LI><A HREF="#Table_32" >Type Table Entry Sub-Record - Area</A></LI>
<LI><A HREF="#Table_33" >Type Table Entry Sub-Record - Array</A></LI>
<LI><A HREF="#Table_34" >Type Table Entry Sub-Record - Base Class</A></LI>
<LI><A HREF="#Table_35" >Type Table Entry Sub-Record - Bit string</A></LI>
<LI><A HREF="#Table_36" >Type Table Entry Sub-Record - Character String</A></LI>
<LI><A HREF="#Table_37" >Type Table Entry Sub-Record - Class</A></LI>
<LI><A HREF="#Table_38" >Type Table Entry Sub-Record - Class Definition</A></LI>
<LI><A HREF="#Table_39" >Type Table Entry Sub-Record - Class Member</A></LI>
<LI><A HREF="#Table_40" >Type Table Entry Sub-Record - Code label</A></LI>
<LI><A HREF="#Table_41" >Type Table Entry Sub-Record - Entry</A></LI>
<LI><A HREF="#Table_42" >Type Table Entry Sub-Record - Enum</A></LI>
<LI><A HREF="#Table_43" >Type Table Entry Sub-Record - File</A></LI>
<LI><A HREF="#Table_44" >Type Table Entry Sub-Record - Format label</A></LI>
<LI><A HREF="#Table_45" >Type Table Entry Sub-Record - Friend</A></LI>
<LI><A HREF="#Table_46" >Type Table Entry Sub-Record - Function</A></LI>
<LI><A HREF="#Table_47" >Type Table Entry Sub-Record - Graphic</A></LI>
<LI><A HREF="#Table_48" >Type Table Entry Sub-Record - Logical</A></LI>
<LI><A HREF="#Table_49" >Type Table Entry Sub-Record - Macro</A></LI>
<LI><A HREF="#Table_50" >Type Table Entry Sub-Record - Member Function</A></LI>
<LI><A HREF="#Table_51" >Type Table Entry Sub-Record - Member Pointer</A></LI>
<LI><A HREF="#Table_52" >Type Table Entry Sub-Record - Picture</A></LI>
<LI><A HREF="#Table_53" >Type Table Entry Sub-Record - Pointer</A></LI>
<LI><A HREF="#Table_54" >Type Table Entry Sub-Record - Procedure</A></LI>
<LI><A HREF="#Table_55" >Type Table Entry Sub-Record - Reference</A></LI>
<LI><A HREF="#Table_56" >Type Table Entry Sub-Record - Scalars</A></LI>
<LI><A HREF="#Table_57" >Type Table Entry Sub-Record - Set of</A></LI>
<LI><A HREF="#Table_58" >Type Table Entry Sub-Record - Stack</A></LI>
<LI><A HREF="#Table_59" >Type Table Entry Sub-Record - Structure/Union/Record</A></LI>
<LI><A HREF="#Table_60" >Type Table Entry Sub-Record - Subrange</A></LI>
<LI><A HREF="#Table_61" >Type Table Entry Sub-Record - User Defined Type</A></LI>
<LI><A HREF="#FIGDBFLINT" >Line Number Table -- Overview</A></LI>
<LI><A HREF="#FIGDBFLHDR" >Line Number Table Record -- Header</A></LI>
<LI><A HREF="#FIGDBFFLNE" >Line Number Table First Entry</A></LI>
<LI><A HREF="#FIGDBFLENT" >Line Number Entries</A></LI>
<LI><A HREF="#FIGDBFPATH" >Path Table Entry</A></LI>
<LI><A HREF="#FIGDBFFILE" >File Names Table</A></LI>
</OL>
<HR>
<H1><A NAME="HDRDBINTRO" HREF="#ToC_6">Introduction</A></H1>
<P>
The HLL Debug Tables described in this this document are
generated by the following compilers&#58;
<UL>
<P><LI>IBM C Set/2
<P><LI>IBM C Set++
<P><LI>VisualAge C++
<P><LI>COBOL VisualAge
<P><LI>VRPG compilers
</UL>
<P>
The following debuggers from IBM make use of the HLL Debug Tables.
<UL>
<P><LI>IPMD, PMD, PM Debugger or Presentation Manager Debugger
refer to the CSET debugger or the IBM VisualAge Debugger.
</UL>
<P>
The tables are designed to support multiple languages.
however, only the compilers listed above are
currently supported by the IBM VisualAge Debugger.
References to other languages, including PL/X<A HREF="#FNFNPLX">(1)</A>,
are general in nature and imply no specific product plans.
<P>
Additional copies of this document, if required, should be requested
from the author, whose address is on the title page.
<P>
IBM reserves the right to change the HLL Debug Tables
as required to support the IBM languages Tools products.
<P>
The HLL Debug Tables are organized into three segments&#58;
<OL COMPACT>
<LI>Symbol information
<LI>Type information
<LI>Line Number information
</OL>
When these optional HLL Debug Tables are generated, the IBM VisualAge Debugger also
expects specific information to be present in other 32-bit Object Module Format records.
<P>
The record formats described in the remainder of this document are read
from the EXE and DLL executable files generated by the Linker.
The Linker program copies the records from the
compiler generated object files
without modification, except for FIXUPPs, and saves the "HLL Style"
information in the Debug section directory (see <A HREF="#HDRDBLXSEC">Appendix A. "LX Format Debug Section Description"</A>).
The PM Debugger reads the information, as required during a debug
session, after the executables have been loaded.
<P>
The remainder of this document first discusses the information IBM VisualAge Debugger
expects in the standard 32-bit Object Module Format records, then the format of the
debugger specific records.
<HR>
<H1><A NAME="HDRDBGEN" HREF="#ToC_7">32-bit Object Module Format General Requirements</A></H1>
<P>
The 32-bit Object Module Format (OMF-32) defines the records contained in the OBJ file,
the primary output of the HLL compilers and primary source of debug
information (after Linker processing) for PMD.
<P>
The OBJ file contains all
of the information required by PMD to allow a user
to debug a HLL program at the source code and/or listing level.
The OMF-32 record types required by the debugger listed in
<A HREF="#TBLDEBRECS">Figure 1.</A>.
<BR>
<P><B><A NAME="TBLDEBRECS">Figure 1. Debugger Required OMF-32 Record Types</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=15%>Record
<BR>
Type
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=15%>Record
<BR>
Name
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=71%>&#32;
<BR>
Information
</TH></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>91
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>PUBDEF
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=71%>type information.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>8C
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>EXTDEF
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=71%>type information.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>B0
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>COMDEF
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=71%>type information.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>88
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>COMENT
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=71%>debug style information.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>96
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>LNAMES
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=71%>debug segment names.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>99
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>SEGDEF
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=71%>debug segment definitions.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>A0, A1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>LEDATA
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=71%>$$SYMBOLS and $$TYPES segments.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>9D
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>FIXUPP
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=71%>must be present for symbols and types LEDATA records.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>95
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=15%>LINNUM
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=71%>line number / offset table.
</TD></TR></TABLE>
<P>The $$SYMBOLS, $$TYPES, and LINNUM records are defined in
<A HREF="#HDRDBSYMBL">"Symbol Scope Table"</A>, <A HREF="#HDRDBTYPE">"Type Table"</A>, and
<A HREF="#HDRDBLINUM">"Line Number Table"</A>, respectively.
PMD dependencies on the other record
types are described in the sections that follow.
<P>
<H3><A NAME="Header_8" HREF="#ToC_8">PUBDEF, COMDEF, EXTDEF Records</A></H3>
<P>
Standard PUBDEF and EXTDEF records for public variables are expected.
The TypInd (Type Index) field is assumed null for all records.  It is
not used by PM Debugger.
<P>
The PUBDEF and EXTDEF records contain all the external symbols defined
or referenced in the user program.  EXTDEF
records are for unresolved references.
<P>
Standard COMDEF records are allowed for communal variables.
The TypInd field is the same as that for PUBDEF/EXTDEF records.
<P>
The names in the PUBDEF/EXTDEF/COMDEF records may be mangled names
if a C++ program has been compiled; therefore, must be "interpreted"
using a compiler supplied demangler routine.  If the "full" mangled
name exceeds the space available in a record, only the class and
function name can be derived from the mangled name.  Argument
information may be incomplete.
<P>
<H3><A NAME="Header_9" HREF="#ToC_9">COMENT Record</A></H3>
<P>
A COMENT record with Comment Class x'A1' (Symbolic Debug Information)
must be present in the OBJ with the following commentary byte string&#58;
<UL>
<P><LI><B>4,'H','L'</B> for HLL Style Debug Tables
<P>where the first byte is the binary version number; the second and
third bytes are the ASCII codes for the characters 'H' and 'L'.
1 was the orginal version. Version 2 is an interim
version number, used only for early alloc_text pragma support.  Starting
with version 3, the version number in this record will match the version
number in the document title.
</UL>
<P>
A COMENT record with Comment Class x'A2' (Link Pass) must be present
with subclass value of 1, as documented in the OMF-32 definition.
<P><B>Note: </B>This record is optional, but improves linkage editor performance.
<P>
<H3><A NAME="Header_10" HREF="#ToC_10">LNAMES Record</A></H3>
<P>
A standard LNAMES record must be in the OBJ.  It should include LNAMES
for&#58;
<DL COMPACT>
<DT>$$SYMBOLS
<DD>The segment name of the symbols segment.
<DT>DEBSYM
<DD>The class name of the symbols segment.
<DT>$$TYPES
<DD>The segment name of the types segment.
<DT>DEBTYP
<DD>The class name of the types segment.
</DL>
<P>
<H3><A NAME="Header_11" HREF="#ToC_11">SEGDEF Record</A></H3>
<P>
Standard SEGDEF records must be present for both the symbols segment and
the types segment.
<UL>
<P><LI>Class names "DEBSYM" and "DEBTYP"
<P><LI>Segment names "$$SYMBOL" and "$$TYPES"
</UL>
<P>
<H3><A NAME="Header_12" HREF="#ToC_12">Order of Debug Info Records</A></H3>
<P>
The record order is chosen so that linkage editor
passes through an object module are minimized.
The following order must be maintained for proper passing of the debug
information to the executable module.
<P><P>
<OL>
<P><I>Identifier record(s)</I>
<P><LI>THEADR
<P><I>Link Pass one records</I>
<P><LI>COMENT identifying debug format
<P><LI>LNAMES providing ordered name list
<P><LI>SEGDEF providing ordered list of program segments
<P><LI>GRPDEF providing ordered list of logical segments
<P><LI>PUBDEF locating and naming public symbols
<P><LI>COMDEF, LCOMDEF, COMFIX, EXTDEF, and LEXTDEF records, ordered.
This group of records is ordered jointly (may be referenced
by external index in FIXUPP).
<P><I>Link pass separator</I>
<P><LI>COMENT (Comment Class x'A2')
indicating that only text, fixups, line number, and
the modend record follow (optional).
Indicates end of "link phase 1"
records.
<P><I>Link pass two records</I>
<P><LI>LEDATA record(s) for $$SYMBOLS segment and corresponding FIXUPP
record(s).
<P><LI>LINNUM providing line number and program offset association.
<P><LI>LEDATA record(s) for $$TYPES segment and corresponding FIXUPP
record(s).
<P><I>Terminator</I>
<P><LI>MODEND indicating end of module, optional start address.
</OL>
<HR>
<H1><A NAME="HDRDBSYMBL" HREF="#ToC_13">Symbol Scope Table</A></H1>
<P>
The Symbol Scope Table contains the symbolic information required by the
debugger to display and alter a program's "local" variables.
The Symbol Scope Table (SST)
contains the local (automatic or stack) variables and non-public static
variables for a program, including the scoping information for those
variables.  Public variables are contained in the PUBDEF, COMDEF, or
EXTDEF records.  They are assumed to have a "program-wide" scope.
<P>
The $$SYMBOLS (DEBSYM) records are built by each HLL compiler to
communicate the Symbol Scope Table to PM Debugger via the Linker.
These records are stored in the OBJ file by the
compilers when the compilers' debug option is specified by the user.
The Linker
copies the records to the Debug section of the EXE file for
reference by PMD while the program is being debugged by the user.
The $$SYMBOLS records are stored in the OBJ as LEDATA records, whose
format is described in the OMF-32<A HREF="#FNFNOMF">(2)</A> Definition, with
a segment index
pointing to the SEGDEF record for $$SYMBOLS (SegName = '$$SYMBOLS';
ClassName = 'DEBSYM').
<P>
Each LEDATA record can contain no more than 1024 bytes, including a
checksum byte.  It is recommended
that records be ended at "logical" boundaries between sub-records.
The Linker will copy the records to the .EXE file
in the order stored in the OBJ file.
PMD will read the records in the order stored in the .EXE file,
concatenating each record to the previous to make a contiguous table
in storage.  The "Symbol Scope Table records" in the .EXE file are
<I>not</I> loaded with the program when the program is started
by OS/2.
<P><B>Note: </B>All "offsets" must have a companion FIXUPP record immediately
following the containing LEDATA record.
See the OMF-32 Definition for
details.  Typically, sub-record types <B>Proc</B> and
<B>Static</B> contain segment offsets.
<P><B><A NAME="FIGDBFSYMR">Figure 2. Symbol Scope Table Record Format</A></B><BR>
<P><BR>
<PRE>
         +---------------------------------------+
         |  LEDATA Header                        |
         |                                       |
         +---------------------------------------+
         |                                       |
         |  Symbol Table Sub-Records             |
         |                                       |
         |                                       |
         |                                       |
         |                                       |
         |                                       |
         |                                       |
         +---------+-----------------------------+
         | Check   |
         |    Sum  |
         +---------+
</PRE><BR>
<P>
<P>The Symbol Scope Table is a collection of sub-records organized to provide
a representation of the program in the OBJ file containing this
Symbol Scope Table, as
shown in <A HREF="#FIGDBFSYMR">Figure 2.</A>.
See the OMF-32 Definition for a description of the LEDATA Header.
The order of the individual sub-records is important.  PMD determines
the scope of automatic and non-public static variables based on the order
of the sub-records.
See <A HREF="#FIGDBFSXMC">Figure 4.</A> for a "typical" Symbol Scope Table organization.
A Compile Unit Information record must be the first sub-record.  A Change
Default Segment sub-record must precede the first Procedure sub-record.
<P>
The Symbol Scope Table is designed to support complete debugging of nested
blocks.  The Symbol Scope Table Sub-Records are designed
to support the scoping rules of C and PL/I.
<P><B>Note: </B>It is assumed here that other HLL compiler scoping rules are
similar and can be represented within the structure described here.
<P>
The format of the Symbol Scope Table Sub-Record
is shown in <A HREF="#FIGDBFSYME">Figure 3.</A>.
The "Type" field identifies the type of sub-record.  Each sub-record
has a unique format as described in <A HREF="#FIGDBFSBEG">Figure 5.</A> through
<A HREF="#FIGSTATSR">Figure 28.</A>.
Each sub-record is length-prefixed with an encoded-length of one or
two bytes, with the length (Len) field containing
the number of bytes in the sub-record (excluding the length field
byte(s)).
PMD interprets the encoded-length as follows&#58;
<P>
<PRE>
 
   FirstByte = *(LenFldPtr++);
 
   if (FirstByte & 0x80)
     {
       SecondByte = *LenFldPtr;
       Length  = ((FirstByte & 0x7F) << 8) + SecondByte;
     }
   else
     {
       Length  = FirstByte;
     }
 
</PRE>
<P><B><A NAME="FIGDBFSYME">Figure 3. Symbol Scope Table Sub-Record -- General Format</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+-------------------------------------------------+
    | Len|Type| Sub-Record Specific Data                        |
    |    |    |                                                 |
    +----+----+-------------------------------------------------+
     0    1    2
       or 2    3
 
</PRE><BR>
<P>
<P>
The supported sub-record types (hex values) are&#58;
<DL COMPACT>
<DT>Begin
<DD>00 - Begin block ({ in C; Begin or first executable statement in
a PL/X-86 procedure)
<DT>Proc
<DD>01 - Procedure (function in C; Proc in PL/X-86)
<DT>End
<DD>02 - End block or End procedure
<DT>Auto
<DD>04 - Automatic (Scoped) variable (local in C; AUTOMATIC in PL/X-86)
<DT>Static
<DD>05 - Static variable (static in C; STATIC non-external in PL/X-86)
<DT>TLS
<DD>06 - Thread Local Storage variable
<BR>
<DT>CodeLabel
<DD>0B - Code Label
<DT>With
<DD>0C - With Start Symbol
<BR>
not used by PM Debugger.
<DT>Reg
<DD>0D - Register variable (register in C; ???? in PL/X-86)
<BR>
<DT>Constant
<DD>0E - Constant Symbol (CONSTANT in PL/X-86)
<DT>Entry
<DD>0F - Secondary Entry (ENTRY in PL/X-86)
<DT>Skip
<DD>10 - Skip Record (for future incremental Link capability)
<BR>
Not used by PM Debugger.
<DT>ChangSeg
<DD>11 - Change Default Segment
(for C alloc_text pragma).
<DT>Typedef
<DD>12 - User Defined Type (typedef in C)
<DT>Public
<DD>13 - Public reference to "major" structure, Table or Multiply Occuring Data Structure
<DT>Member
<DD>14 - member of "major" or "minor" structure
<DT>Based
<DD>15 - Based variables
<DT>Tag
<DD>16 - Tags used in structure, union, record, enum, etc.
<DT>Table
<DD>17 - Table or Multiply Occuring Data Structure (for RPG)
<DT>Map
<DD>18 - Map external variable (for C)
<DT>Tag2
<DD>19 - Extended Tag (long names)
<DT>MemFunc
<DD>1A - Member Function (for C++)
<DT>AutoScoped
<DD>1B - Scoped Automatic Variable (for C++)
<BR>
not used by PM Debugger.
<DT>StaticScoped
<DD>1C - Scoped Static Variable (for C++)
<BR>
not used by PM Debugger.
<DT>Proc2
<DD>1D - Extended Proc (long names)
<DT>Static2
<DD>1E - Extended Static (long names)
<DT>RegRelative
<DD>20 - Register Relative for use by conversion routines
<DT>BasedMember
<DD>21 - Based with Offset variable
<DT>ArraySym
<DD>22 - Array Symbol Record
<DT>CuInfo
<DD>40 - Compile Unit Information (compiler ID, compiler options, etc.)
<DT>CuFuncNum
<DD>41 - Reserved for use by compiler for Function Name List
</DL>
<P><B><A NAME="FIGDBFSXMC">Figure 4. Symbol Scope Table Sub-Record -- Typical Organization for C</A></B><BR>
<TABLE BORDER><TR><TD><BR>
<PRE>
 
 
          -- C example --                 -- Symbol Scope Subrecords --
                                             CuInfo  (Compile Unit Information)
                                             ChangSeg (Change Default Segment)
  1
  2         int A;                           Static (A)
  3         main (void)                      Proc (main)
  4
  5         {                                Begin (Block0)
  6           int A,X;                       Auto (A)
  7         }                                Auto (X)
  8                                          End (Block0)
  9                                          End (Proc_main)
  10
  11        static int X;                    Static (X)
  12
  13        P1 (int B, int X)                Proc (P1)
  14                                         Auto (B)
  15                                         Auto (X)
  16        {                                Begin (Block0)
  17          static int D;                  Static (D)
  18            {                            Begin (Block1)
  19              int B;                     Auto (B)
  20            }                            End (Block1)
  21        }                                End (Block0)
  22                                         End (Proc_P1)
  23
  24        static int E;                    Static (E)
  25
  26        P2 (void)                        Proc (P2)
  27
  28        {                                Begin (Block0)
  29                                         Auto (A)
  30          int A;                         End (Block0)
  31        }                                End (proc_P2)
                                             CuInfo  (Compile Unit Information)
  Note&#58;
       Along with main, P1 and p2, A in line 2 will also be shown as Public
       symbol in PUBDEF.
 
</PRE><BR>
</TD></TR></TABLE>
<P><P>
<P>
<H3><A NAME="Header_14" HREF="#ToC_14">Symbol Scope Table Sub-Record Definitions</A></H3>
<P>
<H5><A NAME="Header_15">Begin Block</A></H5>
<P><B><A NAME="FIGDBFSBEG">Figure 5. Symbol Scope Table Sub-Record -- Begin</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+-------------------+-------------------+
    | Len|Type| segment offset    | Length of block   |
    |    |    |                   |                   |
    +----+----+-------------------+-------------------+
     0    1    2                   6                   A
       or 2    3                   7                   B
 
 
 
            .-+----+------------------------+
              |Len |  Name of Block         |
              |Name|                        |
            .-+----+------------------------+
               A    B
            or B    C
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>The length of the block is measured in bytes
<P><LI>Name of Block (and its length) is optional
</UL>
</DL>
<P>
<H5><A NAME="Header_16">Procedure</A></H5>
<P>
<H5><A NAME="Header_17">Secondary Entry</A></H5>
<P>
<H5><A NAME="Header_18">Member Function</A></H5>
<P>
<H5><A NAME="Header_19">Extended Procedure</A></H5>
<P><B><A NAME="FIGDBFSPRC">Figure 6. Symbol Scope Table Sub-Record -- Procedure, Entry, Member Function</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+-------------------+---------+-------------------+-
    | Len|Type| segment offset    | Type    | Length of Proc    |
    |    |    |                   |   Index |                   |
    +----+----+-------------------+---------+-------------------+-
     0    1    2                   6         8                   C
       or 2    3                   7         9                   D
 
 
       .-+---------+-------------------+---------+----+-
         |Length of| Length of prologue| Class   |Near|
         | Prologue| plus Body         |   Type  |/Far|
       .-+---------+-------------------+---------+----+-
          C         E                   12        14   15
          D         F                   13        15   16
 
 
       .-+----+------------------------+
         |Len |  Name of Procedure     |
         |Name|                        |
       .-+----+------------------------+
          15   16
          16   17 or 18
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<BR>
<P><LI>All "Length" fields in this sub-record are measured in bytes.
<BR>
<P><LI>The same sub-record format is used for Procedure, Secondary Entry,
and Proc2 sub-record types.  For Member Function sub-records,
the Class Type field is also required.
<P><LI>Segment offset, initially zero, is resolved by the Linker
using a FIXUPP record that must follow the record containing this
sub-record.
<P><LI>Length of Prologue is the offset to the first executable instruction
associated with the first user source statement.
<P><LI>Length of Prologue plus Body is the offset to the first executable
instruction following the last user source statment (epilogue code).
<P><LI>The Near/Far field indicates the type of return made by the Procedure
or Entry.  It has the following values
<DL COMPACT>
<DT>0 -
<DD>16-bit near (offset-16)
<DT>4 -
<DD>16-bit far  (segment-32)
<DT>8 -
<DD>32-bit near (offset-32)
<DT>C -
<DD>32-bit far  (segment-48)
<BR>
<B>Note&#58;</B> Only used for Ring 3 Call Gate accessible code.
<BR>
<B>Note&#58;</B> Not used by PM Debugger.
</DL>
<P><LI>The Symbol Name length prefix is encoded, the same as the symbol
sub-record length encoding described in <A HREF="#HDRDBSYMBL">"Symbol Scope Table"</A>,
only for Member Function and Extended Procedure sub-records.
<P><LI>The Member Function sub-record and Extended Procedure sub-record
Name fields may be mangled; therefore, they must be
"interpreted" using a compiler supplied demangler routine.
</UL>
</DL>
<P>
<H5><A NAME="Header_20">End of Procedure or Block</A></H5>
<P><B><A NAME="FIGDBFSEND">Figure 7. Symbol Scope Table Sub-Record -- End</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+
    | Len|Type|
    |    |    |
    +----+----+
     0    1    2
       or 2    3
 
</PRE><BR>
<P>
<P>
<H5><A NAME="Header_21">Automatic Variable</A></H5>
<P><B><A NAME="FIGDBFSDEF">Figure 8. Symbol Scope Table Sub-Record -- Auto</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+-------------------+---------+----+-------------------+
    | Len|Type| Offset Into Stack | Type    |Len | Symbol Name       |
    |    |    |   Frame           |  Index  |Name|                   |
    +----+----+-------------------+---------+----+-------------------+
     0    1    2                   6         8    9
       or 2    3                   7         9    A
 
</PRE><BR>
<P>
<P>
<H5><A NAME="Header_22">Static Variable</A></H5>
<P>
<H5><A NAME="Header_23">Static2</A></H5>
<P><B><A NAME="FIGDBFSSTA">Figure 9. Symbol Scope Table Sub-Record -- Static</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+-------------------+---------+---------+----+-------------------+
    | Len|Type| Segment offset    | Segment | Type    |Len | Symbol Name       |
    |    |    |                   |  Address|  Index  |Name|                   |
    +----+----+-------------------+---------+---------+----+-------------------+
     0    1    2                   6         8         A    B
       or 2    3                   7         9         B    C or D
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>Segment offset, initially zero, is resolved by the Linker
using a FIXUPP record that must follow the record containing this
sub-record.
<BR>
<P><LI>Segment Address is an index into the SEGDEF records.
<P><LI>The Symbol Name length prefix is encoded, the same as the symbol
sub-record length encoding described in <A HREF="#HDRDBSYMBL">"Symbol Scope Table"</A>,
only for Extended Static (Static2) sub-records.
<P><LI>The Static2 Symbol Name may be mangled; therefore, it must be
"interpreted" using a compiler supplied demangler routine.
</UL>
</DL>
<P>
<H5><A NAME="Header_24">Thread Local Storage Variable</A></H5>
<P><B><A NAME="FIGDBFTLS">Figure 10. Symbol Scope Table Sub-Record -- TLS</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+-------------------+---------+---------+----+-------------------+
    | Len|Type| Offset into thread| reserved| Type    |Len | Symbol Name       |
    |    |    |  local storage    |         |  Index  |Name|                   |
    +----+----+-------------------+---------+---------+----+-------------------+
     0    1    2                   6         8         A    B
       or 2    3                   7         9         B    C or D
 
</PRE><BR>
<P>
<P>
<H5><A NAME="Header_25">Code Label</A></H5>
<P><B><A NAME="FIGDBFSCOD">Figure 11. Symbol Scope Table Sub-Record -- CodeLabel</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+-------------------+----+----+-------------------+
    | Len|Type| Segment offset    |Near|Len | Symbol Name       |
    |    |    |                   |/Far|Name|                   |
    +----+----+-------------------+----+----+-------------------+
     0    1    2                   6    7    8
       or 2    3                   7    8    9
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>The Near/Far field has the following values
<DL COMPACT>
<DT>0
<DD>- 16-bit near (offset-16)
<DT>4
<DD>- 16-bit far  (segment-32)
<DT>8
<DD>- 32-bit near (offset-32)
<DT>C
<DD>- 32-bit far  (segment-48)
</DL>
</UL>
</DL>
<P>
<H5><A NAME="Header_26">Register Variable</A></H5>
<P><B><A NAME="FIGDBFSREG">Figure 12. Symbol Scope Table Sub-Record -- Reg</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+---------+----+----+-------------------+
    | Len|Type| Type    | Reg|Len | Symbol Name       |
    |    |    |  Index  | No.|Name|                   |
    +----+----+---------+----+----+-------------------+
     0    1    2         4    5    6
       or 2    3         5    6    7
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>The Reg No. values (in hex) are&#58;
<DL COMPACT>
<P>8-bit registers
<DT>00
<DD>AL
<DT>01
<DD>CL
<DT>02
<DD>DL
<DT>03
<DD>BL
<DT>04
<DD>AH
<DT>05
<DD>CH
<DT>06
<DD>DH
<DT>07
<DD>BH
<P>16-bit registers
<DT>08
<DD>AX
<DT>09
<DD>CX
<DT>0A
<DD>DX
<DT>0B
<DD>BX
<DT>0C
<DD>SP
<DT>0D
<DD>BP
<DT>0E
<DD>SI
<DT>0F
<DD>DI
<P>32-bit registers
<DT>10
<DD>EAX
<DT>11
<DD>ECX
<DT>12
<DD>EDX
<DT>13
<DD>EBX
<DT>14
<DD>ESP
<DT>15
<DD>EBP
<DT>16
<DD>ESI
<DT>17
<DD>EDI
<P>Segment registers
<DT>18
<DD>ES
<DT>19
<DD>CS
<DT>1A
<DD>SS
<DT>1B
<DD>DS
<DT>1C
<DD>FS
<DT>1D
<DD>GS
<P>Special cases
<DT>20
<DD>'DX&#58;AX'
<DT>21
<DD>'ES&#58;BX'
<DT>22
<DD>IP
<DT>23
<DD>FLAGS
<DT>24
<DD>EFLAGS
<P>Register extensions for 8087/287/387
<DT>80
<DD>ST(0)
<DT>81
<DD>ST(1)
<DT>82
<DD>ST(2)
<DT>83
<DD>ST(3)
<DT>84
<DD>ST(4)
<DT>85
<DD>ST(5)
<DT>86
<DD>ST(6)
<DT>87
<DD>ST(7)
</DL>
</UL>
</DL>
<P>
<H5><A NAME="Header_27">Register Relative</A></H5>
<P><B><A NAME="FIGREGREL">Figure 13. Symbol Scope Table Sub-Record -- RegRelative</A></B><BR>
<P><BR>
<PRE>
         +----+----+--------+------------+--------+-.
         |Len |Type|Register|Offset from | Type   |  ...
         |    |    | Number |  Register  |  Index |
         +----+----+--------+------------+--------+-.
          0    1    2        4           8         A
       or      2    3        5           9         B
 
       .-+----+------------------------+
         |Len |  Name of Symbol        |
         |Name|                        |
       .-+----+------------------------+
          A    B
       or B    C
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>Intended only for conversion from other formats to PM Debugger
format.
</UL>
<P><DT>Register Number
<P><DD>of register used as "base register" for variable
<P><DT>Offset from Register
<P><DD>content to storage location of variable
</DL>
<P>
<H5><A NAME="Header_28">Constant Symbol</A></H5>
<P><B><A NAME="FIGDBFSCON">Figure 14. Symbol Scope Table Sub-Record -- Constant</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+---------+------+------------+----+-------------------+
    | Len|Type| Type    |Len   | Value      |Len | Symbol Name       |
    |    |    |  Index  |Value |            |Name|                   |
    +----+----+---------+------+------------+----+-------------------+
     0    1    2         4      5            5    6 + Len Value
       or 2    3         5      6            6    7 + Len Value
                                             +
                                          Len Value
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>The Value field may be variable, depending on the Constant Type
represented in the Type Index
(currently, is character string representing the value of the
constant).
</UL>
</DL>
<P>
<H5><A NAME="Header_29">With Start Symbol</A></H5>
<P>To be supplied in a future draft, if required.
<P>
<H5><A NAME="Header_30">Skip Record</A></H5>
<P>To be supplied in a future release, if required.
<P>
<H5><A NAME="Header_31">Change Default Segment</A></H5>
<P><B><A NAME="FIGDBCHSEG">Figure 15. Symbol Scope Table Sub-Record -- ChangSeg</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+---------+---------+
    | Len|Type| Segment | Reserved|
    |    |    |  Number |         |
    +----+----+---------+---------+
     0    1    2         4
       or 2    3         5
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>A Change Default Segment sub-record is required for each
#pragma alloc_text statement in the source file being
compiled.  Each Change Default Segment sub-record must precede the
Procedure sub-record corresponding to the function names in the
alloc_text statement. A Change Default Segment sub-record must precede the
first Procedure sub-record in the Symbol Scope Table.
<P><LI>A "Selector" type FIXUPP record should be generated for each Change
Default Segment sub-record, with a "target value" equal to the segment
number assigned by the compiler for the function whose Procedure
sub-record follows.
The FIXUPP record is required to allow the Linker to convert the
logical segment numbers to physical segment numbers when building the
executable.
<P><LI>The segment number is initialized to zero (0) by the compiler.
</UL>
</DL>
<P>
<H5><A NAME="Header_32">User Defined Symbol</A></H5>
<P><B><A NAME="FIGDBFSTDF">Figure 16. Symbol Scope Table Sub-Record -- Typedef</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+---------+----+-------------------+
    | Len|Type| Type    |Len | Symbol Name       |
    |    |    |  Index  |Name|                   |
    +----+----+---------+----+-------------------+
     0    1    2         4    5
       or 2    3         5    6
 
</PRE><BR>
<P>
<P>
<H5><A NAME="Header_33">Public</A></H5>
<P><B><A NAME="FIGDBFSPUB">Figure 17. Symbol Scope Table Sub-Record -- Public</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+-------------------+---------+---------+----+-------------------+
    | Len|Type| Segment offset    | Segment | Type    |Len | Symbol Name       |
    |    |    |                   |  Address|  Index  |Name|                   |
    +----+----+-------------------+---------+---------+----+-------------------+
     0    1    2                   6         8         A    B
       or 2    3                   7         9         B    C
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>The Public sub-record is a duplicate of the PUBDEF record
generated for a public (external) "major" Structure, RPG Table, or RPG
Multiply Occuring Data Structure.
<P>This sub-record is required for languages that support direct symbolic
references to "minor" (nested) structures and/or "elements" (members) of
a structure.  In addition, RPG will use this sub-record for the above
constructs.
The sub-record is used as a "target" for Member or Table sub-records.
PMD uses the Public sub-record as a substitute PUBDEF record to
obtain location and type information.
<P><LI>Segment offset, initially zero, is resolved by the Linker
using a FIXUPP record that must follow the record containing this
sub-record.
<P><LI>Segment Address is an index into the SEGDEF records.
</UL>
</DL>
<P>
<H5><A NAME="Header_34">Member</A></H5>
<P><B><A NAME="FIGDBFSMEM">Figure 18. Symbol Scope Table Sub-Record -- Member</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+-------------------+----+-----------------+
    | Len|Type| Offset to         |Len | Symbol Name     |
    |    |    |    Subrecord      |Name|                 |
    +----+----+-------------------+----+-----------------+
     0    1    2                   6    7
       or 2    3                   7    8
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>A member sub-record is required for each
"minor" (nested) structure and/or "element" (member) of
a structure the user can reference symbolically.
<P><LI>The offset in this sub-record identifies the Member or
Public/Static/Automatic sub-record for the immediate parent
of this minor structure or element, respectively.
<P><B>Note: </B>A Member sub-record will be the "target" of another Member sub-record
if "minor" structures containing elements exist within a "major" structure."
Only one Public/Static/Automatic sub-record will exist for each "major"
structure"
</UL>
</DL>
<P>
<H5><A NAME="Header_35">Based</A></H5>
<P><B><A NAME="FIGDBFSBAS">Figure 19. Symbol Scope Table Sub-Record -- Based</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+-------------------+---------+----+-----------+
    | Len|Type| Offset to         |Type     |Len |  Name     |
    |    |    |    Subrecord      | Index   |Name|           |
    +----+----+-------------------+---------+----+-----------+
     0    1    2                   6          8    9
       or 2    3                   7          9    A
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>Offset in this sub-record identifies the sub-record upon which this
variable is based. The type index identifies this variable's type.
</UL>
</DL>
<P>
<H5><A NAME="Header_36">BasedMember</A></H5>
<P><B><A NAME="FIGDBFSBSM">Figure 20. Symbol Scope Table Sub-Record -- Based with Member</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+-------------------+---------+-------------------+----+-----------“
    | Len|Type| Offset to         |Type     | Offset from       |Len |  Name     |
    |    |    |    Subrecord      | Index   |    Base           |Name|           |
    +----+----+-------------------+---------+-------------------+----+-----------•
     0    1    2                   6         8                   C    D
       or 2    3                   7         9                   D    E
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>Offset to Subrecord identifies the sub-record upon which this
variable is based. The type index identifies this variable's type.
Offset from Base identifies the element in the based structure.
</UL>
</DL>
<P>
<H5><A NAME="Header_37">ArraySymbol</A></H5>
<P><B><A NAME="FIGDBFARYS">Figure 21. Symbol Scope Table Sub-Record -- Array Symbol Record</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+---------+-------------------+
    | Len|Type|Type     | Offset to symbol  |
    |    |    | Index   |    of ODO object  |
    +----+----+---------+-------------------+
     0    1    2         4                   8
       or 2    3         5                   9
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>Type Index is reference to array type record
<P><LI>Offset to symbol of the ODO object
<P><LI>There will be one array symbol for each variable length
array which would contain the type index to array type
record.  The symbol record would also contain a reference
to the symbol record which indicated the bounds of the
array.  In the case of a multi-dimensional array, there
would be one array symbol for each dimension of the array.
</UL>
</DL>
<P>
<H5><A NAME="Header_38">Tag</A></H5>
<P><B><A NAME="FIGDBFSTAG">Figure 22. Symbol Scope Table Sub-Record -- Tag</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+---------+----+-----------+
    | Len|Type| Type    |Len |  Name     |
    |    |    |  Index  |Name|           |
    +----+----+---------+----+-----------+
     0    1    2         4    5
       or 2    3         5    6
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>This subrecord provides the scope information for tags.
(e.g. structure)
</UL>
</DL>
<P>
<H5><A NAME="Header_39">Map</A></H5>
<P><B><A NAME="FIGDBFSMAP">Figure 23. Symbol Scope Table Sub-Record -- Map</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+--------+--------+-------+-----------+
    | Len|Type| Len (1)|Name    |Len (2)|External   |
    |    |    | Name   |        |Name   |Known Name |
    +----+----+--------+--------+-------+-----------+
     0    1    2        3        3 +      4 +
       or 2    3        4        4 +      5 +
                                 Len(1)   Len(1)
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>Map supports mapped external names for C.
</UL>
</DL>
<P>
<H5><A NAME="Header_40">Table</A></H5>
<P><B><A NAME="FIGDBFSTAB">Figure 24. Symbol Scope Table Sub-Record -- Table</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+-------------+---------+---------+-------------+----+--------------+
    | Len|Type| Segment     | Segment | Type    |Index Offset |Len | Symbol Name  |
    |    |    | offset      |  Address|  Index  |to subrecord |Name|              |
    +----+----+-------------+---------+---------+-------------+----+--------------+
     0    1    2             6         8         A             E     F
       or 2    3             7         9         B             F    10
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>The Table sub-record identifies the Public/Static sub-records for the
name and location of a table and the Index to a table.  It is
used for the RPG Table and Multiply Occuring Data Structure
constructs.
<P><B>Note: </B>These two constructs are similiar to arrays except the index to the
table is maintained internally in storage; therefore, must be
referenced by a separate Public/Static sub-record.
<P><LI>Index Offset in this sub-record identifies the sub-record containing
the location and symbolic name of the index to the Table.
</UL>
</DL>
<P>
<H5><A NAME="Header_41">Compilable Unit Information</A></H5>
<P><B><A NAME="FIGDBFSCUI">Figure 25. Symbol Scope Table Sub-Record -- CuInfo</A></B><BR>
<P><BR>
<PRE>
 
    +----+----+----+----+-------------------+---------------------------------------+-
    | Len|Type|Comp|Len | Compiler Options  | Compiler Data                         |
    |    |    | ID |Opts|                   |                                       |
    +----+----+----+----+-------------------+---------------------------------------+-
     0    1    2    3    4                   8                                       10
       or 2    3    4    5                   9                                       11
 
 
    +---------------------------------------+
    | Timestamp                             |
    |                                       |
    +---------------------------------------+
     10                                      18
  or 11                                      19
 
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>The Compile Unit Information sub-reord contains compiler specific
information required by PMD to correctly process the user program.
<DL>
<P><DT>Compiler ID
<DD>is an encoded identification of the compiler generating this OBJ.
The values for this data item are&#58;
<DL COMPACT>
<DT>01
<DD>C
<DT>02
<DD>C++
<DT>03
<DD>PL/X-86
<DT>04
<DD>PL/I
<DT>05
<DD>RPG
<DT>06
<DD>COBOL
<DT>07
<DD>ALP (Assembler for Intel)
</DL>
<P><DT>Compiler Options
<DD>is a string of bits representing the compiler options in
effect for the compilation generating this OBJ.
<P><B>Note: </B>Not used by PMD
<P><DT>Timestamp
<DD>in DosGetDateTime format (8 bytes)
<P><DT>Compiler Date
<DD>Length-prefixed string containing "build date" of compiler emitting
debug information.  Used only for "visual" verification of compiler
level.
</DL>
<P><LI>The Compile Unit Information sub-record must be the first sub-record in
the Symbol Scope Table.
</UL>
</DL>
<P>
<H5><A NAME="Header_42">Extended Tag (long names)</A></H5>
<P><B><A NAME="FIGCLASSSR">Figure 26. Symbol Scope Table Sub-Record -- Tag2</A></B><BR>
<P><BR>
<PRE>
         +----+----+----------+----+---------------+
         |Len |Type| Type     |Len | Name          |
         |    |    | Index    |Name|               |
         +----+----+----------+----+---------------+
          0    1    2          4    5
            or 2    3          5    6 or 7
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>Same as Tag record, only support long names generally used for C++.
<P><LI>The Name length prefix is encoded, the same as the symbol
sub-record length encoding described in <A HREF="#HDRDBSYMBL">"Symbol Scope Table"</A>.
<P><LI>The Name may be mangled; therefore, it must be
"interpreted" using a compiler supplied demangler routine.
</UL>
</DL>
<P>
<H5><A NAME="Header_43">Scoped Automatic Variable</A></H5>
<P><B><A NAME="FIGCPPSR">Figure 27. Symbol Scope Table Sub-Record -- AutoScoped</A></B><BR>
<P><BR>
<PRE>
         +----+----+-------------+-----------+-----------+-.
         |Len |Type|Offset into  |Source File|Source File|  ...
         |    |    |Stack Frame  |  Index    |Line No.   |
         +----+----+-------------+-----------+-----------+-.
          0    1    2             6           8           C
       or      2    3             7           9           D
 
       .-+---------+----+------------------------+
         | Type    |Len |  Name of Symbol        |
         |  Index  |Name|                        |
       .-+---------+----+------------------------+
          D         F    10
       or E        10    11
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>Intended only for C++, not used by PM Debugger.
</UL>
<P><DT>Source File Index
<P><DD>of source file containing Source File Line Number
<P><DT>Source File Line No.
<P><DD>in source file where symbol scope becomes valid
</DL>
<P>
<H5><A NAME="Header_44">Scoped Static Variable</A></H5>
<P><B><A NAME="FIGSTATSR">Figure 28. Symbol Scope Table Sub-Record -- StaticScoped</A></B><BR>
<P><BR>
<PRE>
         +----+----+-------+---------+----------+-----------+-.
         |Len |Type|Segment|Segment  |Source    |Source File|  ...
         |    |    |Offset |Address  |File Index| Line No.  |
         +----+----+-------+---------+----------+-----------+-.
          0    1    2       6         8          A           E
       or      2    3       7         9          B           F
 
       .-+---------+----+------------------------+
         | Type    |Len |  Name of Symbol        |
         |  Index  |Name|                        |
       .-+---------+----+------------------------+
          E         10   11
      or  F         11   12
</PRE><BR>
<P>
<DL>
<P><DT>Notes&#58;
<P><DD>
<UL>
<P><LI>Intended only for C++, not used by PM Debugger.
</UL>
<P><DT>Source File Index
<P><DD>of source file containing Source File Line Number
<P><DT>Source File Line No.
<P><DD>in source file where symbol scope becomes valid
</DL>
<HR>
<H1><A NAME="HDRDBTYPE" HREF="#ToC_45">Type Table</A></H1>
<P>
The Type Table contains all the invariant information required to
describe complex ("non-primitive") variables.
A Type Table Entry (or sub-record) is built for
every unique complex variable type in the user program (Type Table
Entries may be reused for more than one variable if the variables'
attributes are exactly alike).
The entries may be generated as the symbol information is added to the
various OMF records (see <A HREF="#HDRDBSYMBL">"Symbol Scope Table"</A>).
No specific order is assumed by PMD.
The data is always located using the type index contained in
the PUBDEF, EXTDEF, COMDEF, $$SYMBOLS or $$TYPES records, as defined in
<A HREF="#HDRTTEINDX">"Type Index Formats"</A>.
<P>
The $$TYPES (DEBTYP) records are used by each HLL compiler to
communicate the Type Table information to PM Debugger,
via the Linker.
These records are stored in the OBJ file by the
compilers when the compilers' debug option is specified by the user.
The Linker
copies the records to the Debug section of the EXE file for
reference by PMD while the program is being debugged by the user.
The $$TYPES records are stored in the OBJ as LEDATA records, whose
format is described in the OMF-32 Definition, with a segment index
pointing to the SEGDEF record for $$TYPES (SegName = '$$TYPES';
ClassName = 'DEBTYP').
<P>
Each LEDATA record can contain no more than 1024 bytes, including a
checksum byte.  It is recommended
that records be ended at "logical" boundaries within the definition
of the data below.  The Linker
will copy the records to the .EXE file
in the order stored in the OBJ file.
PMD will read the records in the order stored in the .EXE file,
concatenating each record to the previous to make a contiguous table
in storage.  The "type table records" in the .EXE file are
<I>not</I> loaded with the program when the program is started
by OS/2.
<P><B>Note: </B>All "offsets" must have a companion FIXUPP record immediately
following the containing LEDATA record.  See the OMF-32 Definition for
details.
<P><B><A NAME="FIGDBFTYPR">Figure 29. Type Table Record Format</A></B><BR>
<P><BR>
<PRE>
         +---------------------------------------+
         |  LEDATA Header                        |
         |                                       |
         +---------------------------------------+
         |  Type Table Entries (or Sub-Records)  |
         |                                       |
         |                                       |
         |                                       |
         |                                       |
         |                                       |
         |                                       |
         +---------+-----------------------------+
         | Check   |
         |    Sum  |
         +---------+
</PRE><BR>
<P>
<P>
An overview of a Type Table Record is shown in
<A HREF="#FIGDBFTYPR">Figure 29.</A>.
See the OMF-32 Definition for a description of the LEDATA Header.
Each Type Table Entry consists of one or more sub-records, as shown
in <A HREF="#FIGDBFTYSR">Figure 30.</A>.
The length of the sub-record is a two byte value containing only the
number of data bytes. This number does not include the
two bytes for the length field.
<P><B>Note: </B>The first byte in the subrecord, set to be 01 for linkable in
Version 1, has been removed.
<P>
The Sub-Record Specific Data consists
of fixed format information followed by varying length
individual data items
identified by a one byte Field IDentifier (FID) preceding the data.
The data may also be a type index to
another sub-record for a Type Table Entry.
<P><B><A NAME="FIGDBFTYSR">Figure 30. Type Table Entry Sub-Record -- General Format</A></B><BR>
<P><BR>
<PRE>
 
    +-----------+----+----+-----------------------------+
    | Length of |Type|Type| Sub-Record Specific Data    |
    | Sub-Record|    |Qual|                             |
    +-----------+----+----+-----------------------------+
     0           2    3    4
 
</PRE><BR>
<P>
<P>
<A HREF="#FIGDBFTYSP">Figure 31.</A> illustrates the
the Sub-Record Specific Data, including the Type and Type Qualifier
fields, in the same format the Type data is defined in
<A HREF="#HDRTTEDEFN">"Type Table Entry Definitions"</A>.
<P><B><A NAME="FIGDBFTYSP">Figure 31. Type Table Entry Sub-Record -- Specific Data Format</A></B><BR>
<P><BR>
<PRE>
 
      1    1    varying   1    varying                  1    varying             bytes
    +----+----+----//---+----+-------------------+-//-+----+-------------------+
    |Type|Type|Fixed Fmt| FID| Data identified   |    | FID| Data identified   |
    |    |Qual|  Data   |    |  by FID           |    |    |  by FID           |
    +----+----+----//---+----+-------------------+-//-+----+-------------------+
 
                         <--------------------- Repeated --------------------->
</PRE><BR>
<P>
The unique type table entries for each variable type are defined
in <A HREF="#HDRTTEDEFN">"Type Table Entry Definitions"</A>.
The values for the Type are defined in <A HREF="#HDRTTEPRIM">"Primitive Types Values"</A>
and <A HREF="#HDRTTECPLX">"Complex Types Values"</A>.
<P><P>
<P>
<H3><A NAME="HDRTTEINDX" HREF="#ToC_46">Type Index Formats</A></H3>
<P>
The Type Index (TypInd) field has two formats.
<OL>
<P><LI>The type index may be stored as either one or two bytes values in the following
records&#58;
<UL COMPACT>
<LI>PUBDEF, LPUBDEF
<LI>COMDEF, LCOMDEF
<LI>EXTDEF, LEXTDEF
</UL>
<P>
PMD interprets the Type Index in these records as follows&#58;
<P>
<PRE>
 
   FirstByte = *(TypeFldPtr++);
 
   if (FirstByte & 0x80)
     {
       SecondByte = *TypeFldPtr;
       TypeIndex  = ((FirstByte & 0x7F) << 8) + SecondByte;
     }
   else
     {
       TypeIndex  = FirstByte;
     }
 
</PRE>
<P><B>Note: </B>The only known case where a one byte Type Index can be stored is
for a TypInd=0 in EXTDEF.
<P><LI>It must be stored as a normal "byte reversed"
two byte value ('short int' in C; 'FIXED(16)' in PL/X-86) in the
following records&#58;
<UL COMPACT>
<LI>$$SYMBOLS sub-records
<LI>$$TYPES sub-records
</UL>
</OL>
<P>
<H3><A NAME="HDRTTENAME" HREF="#ToC_47">Name Length Formats</A></H3>
<P>
Names in type sub-records have two types of length-prefixes.  Names
preceded by a FID_String byte continue to have single-byte length
prefixes.  Names not preceded by a FID_String, noted with "ENC" in
the "Field Length" column, contain an encoded-length prefix of one or
two bytes, with the length field containing
the number of bytes in the Name (excluding the length field byte(s)).
PMD interprets the encoded-length as follows&#58;
<P>
<PRE>
 
   FirstByte = *(LenFldPtr++);
 
   if (FirstByte & 0x80)
     {
       SecondByte = *LenFldPtr;
       Length  = ((FirstByte & 0x7F) << 8) + SecondByte;
     }
   else
     {
       Length  = FirstByte;
     }
 
</PRE>
<P>
<H3><A NAME="HDRTTEPRIM" HREF="#ToC_48">Primitive Types Values</A></H3>
<P>
A symbolic variable is considered "primitive" if the variable can be
fully described by a single value (i.e., extended information contained
in a Type Table Entry is not required).
The Type Index for a primitive variable must have a value less than 255,
decimal.
<P>The Primitive Type values are defined below.
Note&#58; Near is defined as offset_32. Far is defined as segment_48.
They are stored in the Type Index field as defined in
<A HREF="#HDRTTEINDX">"Type Index Formats"</A>.
<PRE>
 
                DEC       HEX          DESCRIPTION
               =====     =====       ===============
 
                128        80          8 bit signed
                129        81          16 bit signed
                130        82          32 bit signed
                132        84          8 bit unsigned
                133        85          16 bit unsigned
                134        86          32 bit unsigned
                136        88          32 bit real
                137        89          64 bit real
                138        8A          80 bit real
                140        8C          64 bit complex
                141        8D
          128 bit complex
                142        8E          160 bit complex
                144        90          8 bit boolean
                145        91          16 bit boolean
                146        92          32 bit boolean
                148        94          8 bit character
                149        95          16 bit characters
                150        96          32 bit characters
                151        97          void
                152        98          15 bit unsigned
                153        99          24 bit unsigned
                154        9A          31 bit unsigned
                155        9B          64 bit signed (long_long)
                156        9C          64 bit unsigned
                160        A0          near pointer to 8 bit signed
                161        A1          near pointer to 16 bit signed
                162        A2          near pointer to 32 bit signed
                164        A4          near pointer to 8 bit unsigned
                165        A5          near pointer to 16 bit unsigned
                166        A6          near pointer to 32 bit unsigned
                168        A8          near pointer to 32 bit real
                169        A9          near pointer to 64 bit real
                170        AA          near pointer to 80 bit real
                172        AC          near pointer to 64 bit complex
                173        AD          near pointer to 128 bit complex
                174        AE          near pointer to 160 bit complex
                176        B0          near pointer to 8 bit boolean
                177        B1          near pointer to 16 bit boolean
                178        B2          near pointer to 32 bit boolean
                180        B4          near pointer to 8 bit character
                181        B5          near pointer to 16 bit character
                182        B6          near pointer to 32 bit character
                183        B7          near pointer to void
                184        B8          near pointer to 15 bit unsigned
                185        B9          near pointer to 24 bit unsigned
                186        BA          near pointer to 31 bit unsigned
                187        BB          near pointer to 64 bit signed
                188        BC          near pointer to 64 bit unsigned
</PRE>
<PRE>
 
                DEC       HEX          DESCRIPTION
               =====     =====       ===============
 
                192        C0          far pointer to 8 bit signed
                193        C1          far pointer to 16 bit signed
                194        C2          far pointer to 32 bit signed
                196        C4          far pointer to 8 bit unsigned
                197        C5          far pointer to 16 bit unsigned
                198        C6          far pointer to 32 bit unsigned
                200        C8          far pointer to 32 bit real
                201        C9          far pointer to 64 bit real
                202        CA          far pointer to 80 bit real
                204        CC          far pointer to 64 bit complex
                205        CD          far pointer to 128 bit complex
                206        CE          far pointer to 160 bit complex
                208        D0          far pointer to 8 bit boolean
                209        D1          far pointer to 16 bit boolean
                210        D2          far pointer to 32 bit boolean
                212        D4          far pointer to 8 bit character
                213        D5          far pointer to 16 bit character
                214        D6          far pointer to 32 bit character
                215        D7          far pointer to void
                216        D8          far pointer to 15 bit unsigned
                217        D9          far pointer to 24 bit unsigned
                218        DA          far pointer to 31 bit unsigned
                219        DB          far pointer to 64 bit signed
                220        DC          far pointer to 64 bit unsigned
 
</PRE>
<P>
<H3><A NAME="HDRTTECPLX" HREF="#ToC_49">Complex Types Values</A></H3>
<P>
If a symbolic variable is not one of the "primitive" types defined in
<A HREF="#HDRTTEPRIM">"Primitive Types Values"</A>, it is considered a "non-primitive" or complex
variable.  The Type Index for a complex variable must have a value
greater than 511, decimal, (starting at 512 and up),
that is a dynamically (as OMF records
and $$TYPES sub-records are built)
generated index into the $$TYPES records to a Type Table Entry.
<P>The complex variable type values are defined, in hex notation, below.
The type qualifier values are defined in each sub-record in
<A HREF="#HDRTTEDEFN">"Type Table Entry Definitions"</A>.
<DL COMPACT>
<DT>0x40
<DD>Class
<DT>0x41
<DD>Base Class
<DT>0x42
<DD>Friend
<DT>0x43
<DD>Class Definition
<DT>0x44
<DD>not used
<DT>0x45
<DD>Member Function
<DT>0x46
<DD>Class Member
<DT>0x47
<DD>not used
<DT>0x48
<DD>Reference
<DT>0x49
<DD>Member Pointer
<DT>0x51
<DD>Scalars
<DT>0x52
<DD>Set
<DT>0x53
<DD>Entry
<DT>0x54
<DD>Function
<DT>0x55
<DD>Area
<DT>0x56
<DD>Logical
<DT>0x57
<DD>Stack
<DT>0x59
<DD>Macro
<DT>0x5C
<DD>Bit String
<DT>0x5D
<DD>User defined type
<DT>0x60
<DD>Character String
<DT>0x61
<DD>Picture
<DT>0x62
<DD>Graphic
<DT>0x65
<DD>Format Label
<DT>0x67
<DD>File
<DT>0x6F
<DD>Subrange
<DT>0x72
<DD>Code Label
<DT>0x75
<DD>Procedure
<DT>0x78
<DD>Array
<DT>0x79
<DD>Structure/Union/Record
<DT>0x7A
<DD>Pointer
<DT>0x7B
<DD>Enum
<P>Special sub-record types
<DT>0x7F
<DD>List
</DL>
<P>
<H3><A NAME="HDRTTEFLDI" HREF="#ToC_50">Field ID Values</A></H3>
<P>The Field ID values are used in the Type Table Sub-Records to
identify the contents and number of byte(s) that follow immediately. (With
the exception of FID_nil and FID_void, see note below)
<P>The Field ID values are defined, in hex notation, as follows&#58;
<P><B>Note: </B>The names correspond to the Type Table Entry definitions in
<A HREF="#HDRTTEDEFN">"Type Table Entry Definitions"</A>.
<DL COMPACT>
<DT>FID_nil
<DD>
<DL COMPACT>
<DT>0x80
<DD>(this identifies the contents to be nil, no further data expected)
<DD>
</DL>
<DT>FID_void
<DD>
<DL COMPACT>
<DT>0x81
<DD>(this identifies the contents to be of type void, no further data expected)
<DD>
</DL>
<DT>FID_string
<DD>
<DL COMPACT>
<DT>0x82
<DD>(the contents is a length prefixed character string, the first byte(s) is the length)
<DD>
</DL>
<DT>FID_index
<DD>
<DL COMPACT>
<DT>0x83
<DD>(the contents is type index, it may be a primitive or complex type)
<DD>
</DL>
<DT>FID_span
<DD>
<DL COMPACT>
<DT>
<DD>(the length and nature of the contents depends on the values listed below)
<DD>
</DL>
<BR>
<DL COMPACT>
<DT>0x85
<DD>16-bit unsigned
<DT>0x86
<DD>32-bit unsigned
<DT>0x88
<DD>8-bit signed
<DT>0x89
<DD>16-bit signed
<DT>0x8A
<DD>32-bit signed
<DT>0x8B
<DD>8-bit unsigned
</DL>
<DT>FID_precision
<DD>
<DL COMPACT>
<DT>0x8C
<DD>deleted
</DL>
</DL>
<P><P>
<P>
<H3><A NAME="HDRTTEDEFN" HREF="#ToC_51">Type Table Entry Definitions</A></H3>
<P>
<H5><A NAME="Header_52">Area</A></H5>
<BR>
<P><B><A NAME="Table_32">Figure 32. Type Table Entry Sub-Record - Area</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x55)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Area (fixed)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x00
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Size of area
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Size in bytes, field length depends on the preceding FID_span value
</TD></TR><TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Area - adjustable
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x02
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Descriptor is provided by PL/I.
</TD></TR><TR>
</TABLE>
<P><P>
<P>
<H5><A NAME="Header_53">Array</A></H5>
<DL COMPACT>
The ordering of the FID_index is required as defined in the sub-record.
The array's type qualifier byte has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            row major
                            1            column major
 
                1           0            unpacked array
                            1            packed array
 
                2           0            no descriptor required
                            1            descriptor provided
 
                3           0            fixed length array
                            1            variable length array
 
               4-7                       reserved
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_33">Figure 33. Type Table Entry Sub-Record - Array</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x78)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Array
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Size of array
</TD><TD ALIGN=LEFT VALIGN=TOP>4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Size in bytes
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Bounds
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>This index identifies a sub-record containing the high and low bounds
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type index
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Type Index of the elements in the array
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_string
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>N/A
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Length-prefixed Name of array. The first 1 byte determines the length of the name.
</TD></TR></TABLE>
<DL COMPACT>
A few words on multi-dimensional array and array of complex type&#58;
We have a 2 by 4 by 6 array of type char. The index for the dimensions are
4 to 5, 7 to 10, and 4 to 9 respectively. Then the compiler will need
to generate six sub-records (two for each dimension and treat each
dimension as an array itself). The first one will be for the outer most
dimension. It has a length of 384 bits (48 bytes), a type index identifies a
sub-record (subrange or enum) for its high/low bounds, a type index identifying
the next (second) sub-record, and a name string for that array if available.
In the second sub-record, it will have a length of 192 bits (24 bytes), a type
index identifies a sub-record (subrange or enum) for its high/low bounds, and a
type index identifying the last (third) record. The third record will have a
length of 48 bits (6 bytes), a type index identifies a sub-record (subrange or
enum) for it's high/low bounds, and a type index of primitive type char.
The name of the array will appear in the outer most sub-record. The length
field in the name string will be 0 in subsequent sub-records as the name for
the second and third sub-records are not required.
So to derive the dimension, all we need to do is to divide the length by the
type if the type is a primitive type. For complex type, then we need to divide
the length of the current sub-record by the length of the subsequent
sub-record (the current record's type index identifies the subsequent
sub-record). This may sound very complex in the beginning.
However, this design gives us the flexibility of reusing previous defined
types. This multi-language design will support array of complex construct (i.e.
structure/union ) as well as primitive type.
See subrange and enum sub-records for details in coding the dimension of the
array.
</DL>
<P><P>
<P>
<H5><A NAME="Header_54">Base Class</A></H5>
<DL COMPACT>
The Base Class' type qualifier byte has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            not a virtual class
                            1            is_virtual
 
               1-7                       reserved
 
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_34">Figure 34. Type Table Entry Sub-Record - Base Class</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x41)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=2%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=96%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Base Class
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Protection
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>0=Private, 1=Protected, 2=Public
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Field type
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Type index of class record
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Refer to "Field ID Values"
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Offset
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>The field's offset in bytes from the
start of class(field length determined by preceding FID_span)
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_55">Bit String</A></H5>
<DL COMPACT>
The bit string's type qualifier byte has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            non-varying
                            1            varying
 
                1           0            unsigned
                            1            signed
 
                2           0            byte alignment
                            1            word alignment
 
                3           0            display as string of 0 and 1
                            1            display as a value
 
                4           0            no descriptor required
                            1            descriptor provided
 
               5-7                       reserved
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_35">Figure 35. Type Table Entry Sub-Record - Bit string</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x5C)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Bit String - fixed
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Offset
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Starting position (from bit 0) of the string in a byte or word depends on bit 2 in type qualifier
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Size of the bit string
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Size in bits, field length determined by preceding FID_span
</TD></TR><TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Bit String - varying
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Offset
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Starting position (from bit 0) of the string in a byte or word depends on bit 2 in type qualifier
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Max allowable size of the bit string
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Size in bits, field length determined by preceding FID_span
</TD></TR><TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Bit String - adjustable
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Descriptor provided by PL/I.
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_56">Character String</A></H5>
<BR>
<P><B><A NAME="Table_36">Figure 36. Type Table Entry Sub-Record - Character String</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x60)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Character string (fixed)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x00
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Size of string
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Size in bytes, field length depends on the preceding FID_span value
</TD></TR><TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Character string - varying (length prefixed)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x01
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Max. length
</TD><TD ALIGN=LEFT VALIGN=TOP>1,2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Max. allowable length in bytes, field length depends on the preceding FID_span value
</TD></TR><TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Character string - adjustable
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x02
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Descriptor provided by PL/I.
</TD></TR><TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Character string - (null terminated)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x03
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Max. length
</TD><TD ALIGN=LEFT VALIGN=TOP>1,2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Max. allowable length in bytes, field length depends on the preceding FID_span value
</TD></TR><TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Character string - DBCS
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x04
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Max. length
</TD><TD ALIGN=LEFT VALIGN=TOP>1,2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Max. allowable length in bytes, field length depends on the preceding FID_span value
</TD></TR><TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Character string - DBCS edited
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x05
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>To be completed in the next draft
</TD></TR><TR>
</TABLE>
<P><P>
<P>
<H5><A NAME="Header_57">Class</A></H5>
<DL COMPACT>
The Class' type qualifier byte has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            not a structure
                            1            is_struct
                1           0            not a DTS class
                            1            is_DTS_class
                2           0            not a placeholder for linker
                            1            is_place_holder
                                         (not used by PM Debugger)
               3-7                       reserved
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_37">Figure 37. Type Table Entry Sub-Record - Class</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x40)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=2%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=96%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Class
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Size of Class
</TD><TD ALIGN=LEFT VALIGN=TOP>4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Size in bytes
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Class Item count
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Number of items in class
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Index to class item list
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>This index identifies a sub-record
containing a list of class items
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>ENC
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Length prefixed name of class tag.
This name may be mangled; therefore, it must be "interpreted" using a
compiler supplied demangler routine.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>The following three data items are present
only if <B>is_DTS_class</B>=1.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>SOMClassMajor
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>SOM Class Major version
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>SOMClassMinor
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>SOM Class Minor version
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>SOMClassName
</TD><TD ALIGN=LEFT VALIGN=TOP>ENC
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Length prefixed name of SOM class Name.
This name may be mangled; therefore, it must be "interpreted" using a
compiler supplied demangler routine.?
</TD></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>List (0x7F)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x01
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Repeat begins (for number of class items)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Class Item Type
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Type index (5 different complex types&#58;
Class Definition, Base Class, Friend, Member Function, Class Member)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Repeat ends
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_58">Class Definition</A></H5>
<BR>
<P><B><A NAME="Table_38">Figure 38. Type Table Entry Sub-Record - Class Definition</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x43)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=2%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=96%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Class Definition
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x00
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>
<BR></TD></TR><TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Protection
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>0=Private, 1=Protected, 2=Public
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Field type
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Type number of the typedef record
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Defining class type
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Type of defining class
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_59">Class Member</A></H5>
<DL COMPACT>
The Class Member's type qualifier byte has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            non-static
                            1            is_static
 
                1           0            not virtual table ptr
                            1            is_vtbl_ptr
 
                2           0            not virtual base ptr
                            1            is_vbase_ptr
 
                3           0            non_const
                            1            Const
 
                4           0            non_volatile
                            1            volatile
 
                5           0            not self_ptr
                            1            is_self_ptr
 
               6-7                       reserved
 
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_39">Figure 39. Type Table Entry Sub-Record - Class Member</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x46)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=2%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=96%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Class Member
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Protection
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>0=Private, 1=Protected, 2=Public
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Field type
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Type index (it may be primitive or complex)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Refer to "Field ID Values"
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Offset
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>The field's offset in bytes from the
start of class(field length determined by preceding FID_span)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>ENC
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>If is_static is set, the first Nlen               /Name
will be the name of the static symbol in the Symbol Scope Table.
This name may be mangled; therefore, it must be "interpreted" using a
compiler supplied demangler routine.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>ENC
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>The name of the member.
This name may be mangled; therefore, it must be "interpreted" using a
compiler supplied demangler routine.
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_60">Code label</A></H5>
<DL COMPACT>
The label's type qualifier byte, showing the model of the label, has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            16
                            1            32
 
                1           0            near
                            1            far
 
               2-7                       reserved
 
 
               Note&#58;
                     16 near = offset-16
                     16 far  = segment-32
                     32 near = offset-32
                     32 far  = segment-48
 
 
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_40">Figure 40. Type Table Entry Sub-Record - Code label</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x72)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Code label
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>No data expected.
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_61">Entry</A></H5>
<DL COMPACT>
The entry sub-record and its corresponding list sub-record are shown together
for completeness. Each sub-record is to be encoded individually as a type table
entry.
The ordering of the FID_index is required as defined in the sub-record.
The entry's type qualifier byte, showing the calling convention of the
entry, has the following bit map&#58;
</DL>
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            args pushed left to right
                            1            args pushed right to left
 
                1           0            called program (callee) pops args
                            1            caller pops args
 
                2           0            16
                            1            32
 
                3           0            near
                            1            far
 
                4           0            fixed number of parameters
                            1            variable number of parameters
 
                5           0            OS/2 calling convention
                            1            private calling convention
 
               6-7                       reserved
 
 
               Note&#58;
                     16 near = offset-16
                     16 far  = segment-32
                     32 near = offset-32
                     32 far  = segment-48
 
 
</PRE>
<DL COMPACT>
The flag for each parameter in the list sub-record has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            passed by address
                            1            passed by value
 
                1           0            no descriptor required
                            1            descriptor provided
 
               2-7                       reserved
 
 
 
 
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_41">Figure 41. Type Table Entry Sub-Record - Entry</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x53)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Entry
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Parameter count
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Number of parameters
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Max. parameter count
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Max. number of parameters allowable
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Index
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Type index of the value returned by the entry
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Index to types list
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>This index identifies a sub-record containing a list of type indexes for the parameters.
</TD></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>List (0x7F)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x04
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Repeat begins (for number of parameters in an entry)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Flag
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>See bit map above
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type index
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Parameter's type index (it may be primitive or complex)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Repeat ends
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_62">Enum</A></H5>
<DL COMPACT>
The enum sub-record and its corresponding list sub-record are shown together
for completeness. The sub-record is to be encoded individually as a type table
entry.
The ordering of the FID_index and FID_span in this sub-record is important and required as
defined in the table.
</DL>
<BR>
<P><B><A NAME="Table_42">Figure 42. Type Table Entry Sub-Record - Enum</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x7B)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Enum
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x00
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type index
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Element's data type
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type index
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>This index identifies a list sub-record of name and index for each element.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Starting (minimum) index
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Beginning index, field length determined by preceding FID_span
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Ending (maximum) index
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field length determined by preceding FID_span
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_string
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>N/A
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Length-prefixed name of the enum tag, first 1 byte determines the length
</TD></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>List (0x7F)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x03
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Repeat begins (for number of items in enum)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_string
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>N/A
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Length-prefixed Name of element, first 1 byte determines the length
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Element's index
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Index, field length determined by preceding FID_span
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Repeat ends
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_63">File</A></H5>
<BR>
<P><B><A NAME="Table_43">Figure 43. Type Table Entry Sub-Record - File</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x67)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>File
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x00
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>No data expected.
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_64">Format label</A></H5>
<DL COMPACT>
The label's type qualifier byte, showing the model of the label, has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            16
                            1            32
 
                1           0            near
                            1            far
 
               2-7                       reserved
 
 
               Note&#58;
                     16 near = offset-16
                     16 far  = segment-32
                     32 near = offset-32
                     32 far  = segment-48
 
 
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_44">Figure 44. Type Table Entry Sub-Record - Format label</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x65)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Format label
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>No data expected.
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_65">Friend</A></H5>
<DL COMPACT>
The Base Class' type qualifier byte has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            friend_function
                            1            friend_class
 
               1-7                       reserved
 
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_45">Figure 45. Type Table Entry Sub-Record - Friend</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x42)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=2%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=96%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Friend
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Field type
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Type index of class record if it is a friend
class, and it is a type index of a function record if it is
a friend function.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>ENC
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Length-prefixed Name of Friend Function.
This name may be mangled; therefore, it must be "interpreted" using a
compiler supplied demangler routine.
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_66">Function</A></H5>
<DL COMPACT>
The function sub-record and its corresponding list sub-record are shown together
for completeness. Each sub-record is to be encoded individually as a type table
entry.
The ordering of the FID_index is required as defined in the sub-record.
The function's type qualifier byte, showing the calling convention of the
function, has the following bit map&#58;
</DL>
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            args pushed left to right
                            1            args pushed right to left
 
                1           0            called program (callee) pops args
                            1            caller pops args
 
                2           0            16
                            1            32
 
                3           0            near
                            1            far
 
                4           0            fixed number of parameters
                            1            variable number of parameters
 
                5           0            OS/2 calling convention
                            1            private calling convention
 
               6-7                       reserved
 
 
               Note&#58;
                     16 near = offset-16
                     16 far  = segment-32
                     32 near = offset-32
                     32 far  = segment-48
 
 
</PRE>
<DL COMPACT>
The flag for each parameter in the list sub-record has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            passed by address
                            1            passed by value
 
                1           0            no descriptor required
                            1            descriptor provided
 
               2-7                       reserved
 
 
 
 
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_46">Figure 46. Type Table Entry Sub-Record - Function</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x54)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Function
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Parameter count
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Number of parameters
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Max. parameter count
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Max. number of parameters allowable
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Index
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Type index of the value returned by the function
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Index to types list
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>This index identifies a sub-record containing a list of type indexes for the parameters.
</TD></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>List (0x7F)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x04
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>List not used by PM Debugger
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Repeat begins (for number of parameters in a function)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Flag
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>See bit map above
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type index
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Parameter's type index (it may be primitive or complex)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Repeat ends
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_67">Graphic</A></H5>
<BR>
<P><B><A NAME="Table_47">Figure 47. Type Table Entry Sub-Record - Graphic</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x62)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Graphic string (fixed)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x00
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Size of string
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Size in bytes, field length depends on the preceding FID_span value
</TD></TR><TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Graphic string - varying (length prefixed)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x01
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Max. length of string
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Max allowable length in bytes, field length depends on the preceding FID_span value
</TD></TR><TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Graphic string - adjustable
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x02
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Descriptor provided by PL/I.
</TD></TR><TR>
</TABLE>
<P><P>
<P>
<H5><A NAME="Header_68">Logical</A></H5>
<BR>
<P><B><A NAME="Table_48">Figure 48. Type Table Entry Sub-Record - Logical</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x56)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)

</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Logical (Fortran 4)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x01
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>No data expected.
</TD></TR><TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Logical (Fortran 1)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x02
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>No data expected.
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_69">Macro</A></H5>
<BR>
<P><B><A NAME="Table_49">Figure 49. Type Table Entry Sub-Record - Macro</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x59)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Macro
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x00
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Length of macro definition
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Length in bytes, field length depends on the preceding FID_span value
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Definition
</TD><TD ALIGN=LEFT VALIGN=TOP>N/A
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>String of macro definition
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_70">Member Function</A></H5>
<DL COMPACT>
The Member Function's type qualifier byte has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            non-static
                            1            static
 
                1           0            non-inline
                            1            inline
 
                2           0            non-const
                            1            const
 
                3           0            non-volatile
                            1            volatile
 
                4           0            non-virtual
                            1            virtual
 
               5-7                       reserved
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_50">Figure 50. Type Table Entry Sub-Record - Member Function</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x45)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=2%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=96%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Member Function
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Protection
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>0=Private, 1=Protected, 2=Public
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Function Type
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>0 = regular member fcn,
1 = constructor, 2 = destructor
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Type Index
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Type Index of function sub-record
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Refer to "Field Id Values"
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>VirtNo
</TD><TD ALIGN=LEFT VALIGN=TOP>4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>For virtual fcns, the index into the virtual
table.  This field and the defining FID_span field are present only if
the virtual type qualifier bit is set.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>ENC
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Name of the function.
This name may be mangled; therefore, it must be "interpreted" using a
compiler supplied demangler routine.
If this name is mangled, it is an "abbreviated" mangled name, meaning
the class information has been excluded from the name.
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_71">Member Pointer</A></H5>
<DL COMPACT>
The Member Pointer's type qualifier byte has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            no vbases
                            1            has vbases
 
                1           0            no mult-inh
                            1            has mult-inh
 
                2           0            non-const
                            1            const
 
                3           0            non-volatile
                            1            volatile
 
               4-7                       reserved
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_51">Figure 51. Type Table Entry Sub-Record - Member Pointer</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x49)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=2%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=96%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Member Pointer
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Child type
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Type of the member that may be pointed at
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Class type
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Type of the class that may be pointed at
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Representation type
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Actual type being used to represent this
pointer to member type.
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_72">Picture</A></H5>
<BR>
<P><B><A NAME="Table_52">Figure 52. Type Table Entry Sub-Record - Picture</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x61)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Picture
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x00
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Length of picture string
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Size in bytes, field length depends on the preceding FID_span value
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Picture string
</TD><TD ALIGN=LEFT VALIGN=TOP>N/A
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Compiler supplied string describing variable.
Used for number of COBOL-specific data types.  Requires COBOL supplied
expression evaluation routines to correctly interpret.
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_73">Pointer</A></H5>
<DL COMPACT>
The pointer's type qualifier byte, showing the size of the pointer, has the
the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
 
                0           0            16
                            1            32
 
                1           0            near
                            1            far
 
               2-7                       reserved
 
 
 
               Note&#58;
                     16 near = offset-16
                     16 far  = segment-32
                     32 near = offset-32
                     32 far  = segment-48
 
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_53">Figure 53. Type Table Entry Sub-Record - Pointer</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x7A)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Pointer
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Type Index - the type of data the pointer points to
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_string
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>N/A
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Optional name of pointer. The first 1 byte determines the length of the name.
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_74">Procedure</A></H5>
<DL COMPACT>
The procedure sub-record and its corresponding list sub-record are shown together
for completeness. Each sub-record is to be encoded individually as a type table
entry.
The ordering of the FID_index is required as defined in the sub-record.
The procedure's type qualifier byte, showing the calling convention of the
procedure, has the following bit map&#58;
</DL>
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            args pushed left to right
                            1            args pushed right to left
 
                1           0            called program (callee) pops args
                            1            caller pops args
 
                2           0            16
                            1            32
 
                3           0            near
                            1            far
 
                4           0            fixed number of parameters
                            1            variable number of parameters
 
                5           0            OS/2 calling convention
                            1            private calling convention
 
               6-7                       reserved
 
 
               Note&#58;
                     16 near = offset-16
                     16 far  = segment-32
                     32 near = offset-32
                     32 far  = segment-48
 
 
</PRE>
<DL COMPACT>
The flag for each parameter in the list sub-record has the following bit map&#58;
</DL>
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            passed by address
                            1            passed by value
 
                1           0            no descriptor required
                            1            descriptor provided
 
               2-7                       reserved
 
 
 
 
</PRE>
<BR>
<P><B><A NAME="Table_54">Figure 54. Type Table Entry Sub-Record - Procedure</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x75)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Procedure
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Parameter count
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Number of parameters
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Max. parameter count
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Max. number of parameters allowable
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Index
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Type index of the value returned by the procedure
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Index to types list
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>This index identifies a sub-record containing a list of type indexes for the parameters.
</TD></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>List (0x7F)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x04
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Repeat begins (for number of parameters in a procedure)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Flag
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>See bit map above
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type index
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Parameter's type index (it may be primitive or complex)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Repeat ends
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_75">Reference</A></H5>
<BR>
<P><B><A NAME="Table_55">Figure 55. Type Table Entry Sub-Record - Reference</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x48)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=2%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=96%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Reference
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x00
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=2%>Field type
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=96%>Type number of the reference type
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_76">Scalars</A></H5>
<DL COMPACT>
The scalar's type qualifier byte has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            unpacked (zoned)
                            1            packed
 
                1           0            real
                            1            complex
 
                2           0            fixed
                            1            float
 
                3           0            binary
                            1            decimal
 
 
               4-7                       reserved
 
 
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_56">Figure 56. Type Table Entry Sub-Record - Scalars</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x51)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Scalars
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Index
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>A primitive type
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Precision
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Number of significant digits for packed decimal and floating point. Or number of significant bytes for zoned decimal.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Scale factor
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>128 + scale factor
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_77">Set</A></H5>
<DL COMPACT>
</DL>
<BR>
<P><B><A NAME="Table_57">Figure 57. Type Table Entry Sub-Record - Set of</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x52)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Set
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x00
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type index
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Base type
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>N/A
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Length-prefixed name of set's tag. First 1 byte determines the length of the name.
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_78">Stack</A></H5>
<DL COMPACT>
The stack's type qualifier byte, showing the model of the stack, has the following bit map&#58;
</DL>
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
                0           0            16
                            1            32
 
                1           0            near
                            1            far
 
               2-7                       reserved
 
 
               Note&#58;
                     16 near = offset-16
                     16 far  = segment-32
                     32 near = offset-32
                     32 far  = segment-48
 
 
</PRE>
<BR>
<P><B><A NAME="Table_58">Figure 58. Type Table Entry Sub-Record - Stack</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x57)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Stack
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Size of stack
</TD><TD ALIGN=LEFT VALIGN=TOP>4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Size in bytes
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>N/A
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Length prefixed name of the stack (first 1 byte determines the length)
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_79">Structure/Union/Record</A></H5>
<DL COMPACT>
The structure sub-record and its corresponding list sub-record are shown together
for completeness. Each sub-record is to be encoded individually as a type table
entry.
The ordering for the type index to type list and name list is important and
required as defined below.
The type list and the name list in the LIST sub-records must be
synchronized. (i.e. the type for the nth name in the name list is
the nth item in the type list.)
The structure's type qualifier byte has the following bit map&#58;
<PRE>
               Bit        Value         Data Description
               ===        =====         ========================
               0-1                       reserved
                2           0            not a placeholder for linker
                            1            is_place_holder
                                         (not used by PM Debugger)
 
               3-7                       reserved
 
 
</PRE>
</DL>
<BR>
<P><B><A NAME="Table_59">Figure 59. Type Table Entry Sub-Record - Structure/Union/Record</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x79)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Structure, Union
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>See bit map above
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Size of structure
</TD><TD ALIGN=LEFT VALIGN=TOP>4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>size in bytes
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>field count
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Number of fields in structure
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Index to types list
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>This index identifies a sub-record containing a list of field types. See type list below.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Index to names list
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>This index identifies a sub-record containing a list of field names and offset. See name list below.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_string
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>N/A
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Length-prefixed Name of Structure Tag. First 1 byte determines the length of the name.
</TD></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>List (0x7F)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x01
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Repeat begins (for number of items in structure)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field type
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Type index (it may be primitive or complex)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Repeat ends
</TD></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>List (0x7F)
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x02
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Repeat begins (for number of items in structure)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_string
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>N/A
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Length-prefixed Name of the field, first 1 byte determines the length.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Offset
</TD><TD ALIGN=LEFT VALIGN=TOP>1, 2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>The field's offset in bytes from the start of structure (field length determined by preceding FID_span)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Repeat ends
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_80">Subrange</A></H5>
<DL COMPACT>
The ordering of the FID_span's in this sub-record is important and required as
defined in the table.
</DL>
<BR>
<P><B><A NAME="Table_60">Figure 60. Type Table Entry Sub-Record - Subrange</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x6F)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Subrange
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x00
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Element's type
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Type index
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Starting value
</TD><TD ALIGN=LEFT VALIGN=TOP>1 ,2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>The starting value, or low bound in an array (field length determined by preceding FID_span)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_span
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Ending value
</TD><TD ALIGN=LEFT VALIGN=TOP>1 ,2 or 4
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>The ending value, or high bound in an array (field length determined by preceding FID_span)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>N/A
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Length-prefixed Name, first 1 byte determines the length.
</TD></TR></TABLE>
<P><P>
<P>
<H5><A NAME="Header_81">User Defined Type</A></H5>
<BR>
<P><B><A NAME="Table_61">Figure 61. Type Table Entry Sub-Record - User Defined Type</A></B><BR>
<TABLE BORDER>
<TR>
<TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type (0x5D)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type Qual.
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=1%>Field Name
</TH><TH ALIGN=LEFT VALIGN=TOP>Field Length (bytes)
</TH><TH ALIGN=LEFT VALIGN=TOP WIDTH=97%>Field Data Description
</TH></TR><TR>
<TR>
<TR>
<TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>User defined type
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>0x00
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>
<BR></TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_index
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Type index
</TD><TD ALIGN=LEFT VALIGN=TOP>2
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>This index identifies a type previously defined (it may be primitive or complex)
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>FID_string
</TD><TD ALIGN=LEFT VALIGN=TOP>1
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>Refer to
<A HREF="#HDRTTEFLDI">"Field ID Values"</A>.
</TD></TR><TR>
<TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>
<BR></TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=1%>Name
</TD><TD ALIGN=LEFT VALIGN=TOP>N/A
</TD><TD ALIGN=LEFT VALIGN=TOP WIDTH=97%>The name assigned to that type, first 1 byte determines the length
</TD></TR><TR>
</TABLE>
<HR>
<H1><A NAME="HDRDBLINUM" HREF="#ToC_82">Line Number Table</A></H1>
<P>
The Line Number Table provides the information necessary to associate an
offset into a program segment with either a specific line in the source
file or listing file.  If both source and listing information is
provided, the debugger will synchronize multiple views of the program.
<P>
The Line Number Table is actually a collection of individual tables
containing unique information required by the debugger to correctly
map the executable output of the compiler to the source code for an
application.
Each table begins in a new OMF-32 LINNUM record and
may span multiple LINNUM records, if the information exceeds the
maximum record size defined in the 32-bit Object Module Format (1024).  The
tables within the Line Number Table are organized as illustrated in
<A HREF="#FIGDBFLINT">Figure 62.</A>&#58;
<OL>
<P><LI>
The File Names Table is always the first LINNUM record in the obj file.
The File Names Table contains the names of all source files required to
compile the program and optionally the listing file name.
The Base Segment index in the OMF-32 header is zero for this record,
indicating to the Linker there is no logical-to-physical segment
association or conversion required
<P><LI>
A Path Table may be present in the LINNUM records following the File
Names Table if "path" information is provided by the compiler
describing the general flow of control through the program.
The Path Table starts in a new LINNUM record, unique from the File Names
Table.
The Base Segment index in the OMF-32 header is zero for this record,
indicating to the Linker there is no logical-to-physical segment
association or conversion required
<P><LI>
The Line Number Entries for each Logical Segment follow the File Names
Table and the Path Table, if provided.
A separate set of Line Number
entries, beginning in a new LINNUM record, is required for each
Logical Segment in the compiled program.  A Logical Segment is
equivalent to the SEGDEF index in the obj file.  The compiler saves
the segment number in the LINNUM Header Base Segment index field.
<P>
The LINNUM records must appear in ascending order
of segment index.  If the Line Number Entries for a logical segment
exceed the maximum size of a LINNUM record, the "continuation" LINNUM
records must immediately follow the first LINNUM record and contain the
same Base Segment index value.  The "continuation" LINNUM records do not
contain a "First Entry."
<P>
If a logical segment does not contain any executable code, no LINNUM
record should be generated for that segment.
<P>
The Line Number Entries for each logical segment must be sorted in
ascending order by offset.  More than one entry with different offsets
may exist for the same source line number; however, multiple entries
with different source line numbers for the same offset may NOT exist.
</OL>
<P><P>
<P>
The Line Number Table is organized as follows&#58;
<P><B><A NAME="FIGDBFLINT">Figure 62. Line Number Table -- Overview</A></B><BR>
<P><BR>
<PRE>
         +---------------------------------------+
         |  Header                               |
         +---------------------------------------+
         |  First Entry (special)                |
         +---------------------------------------+
         |                                       |
         |  File Names Table                     |
        ///   (may span mult. LINNUM records)   ///
         |                                       |
         +---------------------------------------+
         |  Header                               |
         +---------------------------------------+
         |  First Entry (special)                |
         +---------------------------------------+
         |                                       |
         |  Path Table                           |
        ///   (may span mult. LINNUM records)   ///
         |                                       |
         +---------------------------------------+
         |  Header                               |
         +---------------------------------------+
         |  First Entry (special)                |
         +---------------------------------------+
         |                                       |
         |  Line Number Entries                  |
        ///   (may span mult. LINNUM records)   ///
         |                                       |
         |                                       |
         +---------------------------------------+
         |                   .                   |
        ///                  .                  ///
         |                   .                   |
         +---------------------------------------+
         |  Header                               |
         +---------------------------------------+
         |  First Entry (special)                |
         +---------------------------------------+
         |                                       |
         |  Line Number Entries                  |
        ///   (may span mult. LINNUM records)   ///
         |                                       |
         |                                       |
         +---------------------------------------+
</PRE><BR>
<P>
<P>
The LINNUM Header format is&#58;
<P><B><A NAME="FIGDBFLHDR">Figure 63. Line Number Table Record -- Header</A></B><BR>
<P><BR>
<PRE>
            1      2         1      1 or 2     (bytes)
         +----+---------+---------+---------+
         |    |Rec      |Base     |Base     |
         | 95 |  Length |   Group |  Segment|
         |    |         |         |         |
         |    |         |         |         |
         +----+---------+---------+---------+
</PRE><BR>
<P>
<DL>
<P><DT>Record Type
<DD>is '95'x, indicating the record is for 32-bit flat addressing model
programs.
<P><DT>Base Group
<DD>The Base Group is an index specifying a previously defined
GRPDEF record.  The group index is ignored and assumed zero.
<P><DT>Base Segment
<DD>The Base Segment is an index specifying a previously defined
SEGDEF record.  The segment
index values must correspond to FIXUPP records for the
Symbol Scope Table (see <A HREF="#HDRDBSYMBL">"Symbol Scope Table"</A>), except for
the File Names and Path Tables LINNUM records whose segment indices
will set to zero.
The segment index is length-encoded with a 0x80 indicating the value
is contained in the following 15 bits; otherwise, the index is 1 byte.
</DL>
<P>
The First Entry format is&#58;
<P><B><A NAME="FIGDBFFLNE">Figure 64. Line Number Table First Entry</A></B><BR>
<P><BR>
<PRE>
 
         +-------------------+---------+---------+
       0 | Line Number = 0   | Entry   | Reserved|
         |                   |   Type  |         |
         +-------------------+---------+---------+
       4 | Count of Table    | Segment Number    |
         |   Entries         |                   |
         +-------------------+-------------------+
       8 | File Names Table Size or              |
         | Address of Logical Segment            |
         +---------------------------------------+
       C
</PRE><BR>
<P>
<DL>
<P><DT>First Entry
<DD>in the each LINNUM record that begins a File Names Table, Path Table
or group of Line Number Entries for a
logical segment of code, identifing the type of information
in the remainder of the LINNUM record.
<DL COMPACT>
<DT>Line Number = 0
<DD>to indicate this is a special entry.
<DT>Entry Type
<DD>controls the format of the Line Number entry.
<DL COMPACT>
<DT>0x00
<DD>Source File Information and offset only.
<DT>0x01
<DD>Listing File Information and offset only.
<BR>
<B>Note&#58;</B> Not used by PM Debugger.
<DT>0x02
<DD>Source and Listing File Information and offset.
<BR>
<B>Note&#58;</B> Not used by PM Debugger.
<DT>0x03
<DD>File Names Table follows first entry
<BR>
<DT>0x04
<DD>Path Table follows first entry
<BR>
<B>Note&#58;</B> Not used by PM Debugger.
</DL>
<DT>Count of Table Entries
<DD>for this entry type, not including the First (special) Entry.
Used for Path Table, plus
Source, Listing, and Source/Listing type Line Number information.
<DT>Segment Number for Line Number Table
<DD>initialized to zero by compiler, set by Linker to physical segment
number containing logical segment in LINNUM header
via compiler generated fixup record.
<DT>File Names Table Size
<DD>in bytes, including the three counts preceding the file
name entries.
This 4-byte value extends the First Entry size to
12 bytes only when Entry Type is "0x03."
<DT>Address of Logical Segment
<DD>for this Line Number Table, initialized to zero by compiler,
set to correct address by linker via compiler generated fixup record.
This 4-byte value extends the First Entry size to
12 bytes when Entry Type is "0x00" or "0x01" or "0x02"
</DL>
</DL>
<P><P>
<P>
Each Line Number Entry has one of the following formats&#58;
<P><B><A NAME="FIGDBFLENT">Figure 65. Line Number Entries</A></B><BR>
<P><BR>
<PRE>
    <B>Entry Type = 0x00 - Source Line Numbers</B>
 
         +---------------------------------------+
       0 | Source File       | Source File       |
         |     Line Number   |    Index          |
         +---------------------------------------+
       4 | Offset into Segment                   |
         |                                       |
         +---------------------------------------+
       8
 
    <B>Entry Type = 0x01 - Listing Statement Numbers</B>
 
         +---------------------------------------+
       0 | Listing File Line Number              |
         |                                       |
         +---------------------------------------+
       4 | Listing File Statement Number         |
         |                                       |
         +---------------------------------------+
       8 | Offset into Segment                   |
         |                                       |
         +---------------------------------------+
       C
 
    <B>Entry Type = 0x02 - Source and Listing File Information</B>
 
         +---------------------------------------+
       0 | Source File       | Source File       |
         |     Line Number   |    Index          |
         +---------------------------------------+
       4 | Listing File Line Number              |
         |                                       |
         +---------------------------------------+
       8 | Listing File Statement Number         |
         |                                       |
         +---------------------------------------+
       C | Offset into Segment                   |
         |                                       |
         +---------------------------------------+
      10
</PRE><BR>
<P>
<P>
The data items in the different format Line Number Entries are&#58;
<DL>
<P><DT>Source File Line Number
<DD>is the line number in the source file identified by the Source
File Index
<P><DT>Listing File Line Number
<DD>is the line number in the listing file, whose name is the last name
in the File Names Table (see <A HREF="#HDRDBLFILE">"File Names Table"</A>).
<P><DT>Listing Statement Number
<DD>is the statement number assigned by the compiler to the source
program.
<P><DT>Source File Index
<DD>is a two byte index into the File Names Table, identifying the
source file in which the program offset resides.
The index of the first file is one (1).
<P><DT>Offset
<DD>is a 4 byte quantity which gives the translated code or data&#39;s
start byte in the program segment defined by the SEGDEF index.
</DL>
<P><P>
<P>
<H3><A NAME="HDRDBLPATH" HREF="#ToC_83">Path Table</A></H3>
<P>
The Path Table immediately follows the File Names Table, starting in a
separate LINNUM record.
Path Information can not reside in an OBJ without Source or Listing
information.
<P><B>Note: </B>Not used by PM Debugger.
<P><B><A NAME="FIGDBFPATH">Figure 66. Path Table Entry</A></B><BR>
<P><BR>
<PRE>
    <B>Entry Type = Path Table</B>
 
         +---------------------------------------+
       0 | Offset into Segment                   |
         |                                       |
         +-------------------+-------------------+
       4 | Path Code         | Source File       |
         |                   |    Index          |
         +-------------------+-------------------+
       8
</PRE><BR>
<P>
<DL>
<P><DT>Offset
<DD>is a 4 byte quantity which gives the translated code or data&#39;s
start byte in the program segment defined by the SEGDEF index.
<P><B>Note: </B>Path Table entries must be sorted by offset.
<P><DT>Path Code
<DD>is a two byte quantity identifying significant control flow points
in the compiled program.
<P><B>Note: </B>The path code is two bytes long only to force word boundaries for
each entry, to improve code efficiency.
<P><DT>Source File Index
<DD>is a two byte index into the File Names Table, identifying the
source file in which the program offset resides.
The index of the first file is one (1).
</DL>
<P><P>
<P>
<H3><A NAME="HDRDBLFILE" HREF="#ToC_84">File Names Table</A></H3>
<P>
The File Names Table is the first LINNUM record in an obj file.
<P>
The File Names Table contains the names of the primary source file, the source
files, INCLUDEd by the primary source file and, if listing file line numbers or
statement numbers are supplied (see <A HREF="#HDRDBLINUM">"Line Number Table"</A>), the name
of the listing file.
<P><B><A NAME="FIGDBFFILE">Figure 67. File Names Table</A></B><BR>
<P><BR>
<PRE>
    +-------------------+-------------------+-------------------+-.
    | First Displayable | Number Displayable| Number of Source  |
    |  Char in List Line| Chars in List Line| and Listing Files |
    +-------------------+-------------------+-------------------+-.
     0                   4                   8                   C
 
 
       .-+----+------------------------+-//-+----+-------------------+-.
         |Len | Name of File           |....|Len | Name of File      |
         |Name|                        |    |Name|                   |
       .-+----+------------------------+-//-+----+-------------------+-.
          C    D
 
 
       .-+----+------------------------+
         |Len | Listing File Name      |
         |Name|                        |
       .-+----+------------------------+
 
</PRE><BR>
<P>
<DL>
<P><DT>First Displayable Character in Listing Line
<DD>
<P><B>Note: </B>Not used by PM Debugger.
<P><DT>Number of Displayable Characters in Listing Line
<DD>
<P><B>Note: </B>Not used by PM Debugger.
<P><DT>Number of Source and Listing Files
<DD>is count of the number of file name entries in the table.
<P><DT>File Names
<DD>for each Source file and/or the listing file.
The listing file name will always will the last name in the table.
<P><B>Notes: </B><OL>
<P><LI>The length-prefixed file names are indexed by the Source
File Index in the Line Number records (see <A HREF="#HDRDBLINUM">"Line Number Table"</A>).
<P><LI>The order of search for file names is&#58;
<OL COMPACT>
<LI>The path information (drive and directory) in the file name
<LI>The directory containing the EXE file.
<LI>The path specified in the PMDPATH environment variable.
<LI>The current path in effect when PMD is started.
</OL>
</OL>
</DL>
<HR>
<H1><A NAME="HDRDBLXSEC" HREF="#ToC_85">Appendix A. LX Format Debug Section Description</A></H1>
<HR>
<H2><A NAME="Header_86" HREF="#ToC_86">Overview</A></H2>
<P>
The Debug Section of the OS/2 Warp LX executable file contains symbolic
debug information, which is NOT loaded by the OS/2 Loader.  The Debug
Section begins and ends with the NB04 signature (ASCII char string).
The Debug Section is generated whenever the /DEbug (or /COdeview)
option is specified to the Linker.
<P><B>Note: </B>NB00 format debug information may also be generated if OBJs are
linked containing ONLY non-HLL style debug information.
The directory header contains only a 2-byte count of number of
directory entries.
Differently formatted and/or additional subsections
will exist for NB00 signatures, consistent with existing 16-bit
Microsoft-compatible debug information; however, all offset/length
fields will be four bytes long, instead of two bytes.
<P>Legend for the following information
<PRE>
   DB - byte   - char
   DW - word   - unsigned short
   DD - double - unsigned long
</PRE>
<P>
The Directory information (the block of information at the end of the
Debug section
pointed to by the offset
pointer following the leading NB04 signature, or the Offset/Length
fields in the EXE/DLL header) has the following format&#58;
<P><B><I>Include structure name = NB04_DEBUG_DIRINFO </I></B>
<PRE>
   00 DW number of bytes in DNT directory structure
        (currently 8 - 0x0008)
   02 DW number of bytes in the DNT entry
        (currently 12 - 0x000c)
   04 DD number of directory entries
</PRE>
   followed by the array of DNT structures (entries) containing&#58;
<P><B><I>Include structure name = NB04_DEBUG_DIR </I></B>
<PRE>
   00 DW sst subsection type
   02 DW Module index number (1-based)
   04 DD Offset of start of debug subsection
   08 DD size of section in bytes
</PRE>
<HR>
<H2><A NAME="Header_87" HREF="#ToC_87">Subsection Descriptions</A></H2>
<P>
The sstModules section (type 0x101) of an EXE/DLL file with an
NB04 signature has the following format&#58;
<P><B><I>Include structure name = NB04_DEBUG_MOD_32 </I></B>
<PRE>
   00 DW Code Segment Base
   02 DD Code Segment offset
   06 DD Code Segment length
   0A DW Overlay number
   0C DW Index into sstLibraries subsection, or 0 if non-library module
 
         The next 2 bytes indicate the number of Segments to follow
         (Total number of segments)
         0 or 1 indicate a single segment for the module n where n>1
         indicates n-1 additional segment structs exist (see below)
   0E DB Low order byte of number of segments
   0F DB High order byte of number of segments
   10 DW Debug Style ('HL" for HLL debug tables, 'CV' or 00 for
         CodeView)
   12 DW Version Number of format (containing two-character codes of
         the form ('00 01' or '00 03' for HL; '00 00' or '00 01' may be
         present for CV?)
   14 DB Length prefixed name of module (1 byte length)
</PRE>
   after the name, the following three fields will be repeated for any
   additional segments that may exist for the module.  The NOPackcode
   Linker option should be used if multiple code segments exist for a
   module (using the PACKCode option (default if NOPackcode isn't
   specified) may combine separate segments created by the compiler;
   therefore, preventing the debugger from being able to locate the
   original logical segments).
   Addition segment structs have the following format&#58;
<P><B><I>Include structure name = DEBUG_SEGINFO_32 </I></B>
<PRE>
   00 DW Code Segment number
   02 DD Code Segment offset
   06 DD Code Segment length
   0A    Repeat above three data areas per Number of Segments above
</PRE>
<P>The sstPublics subsection (type 0x102) has the following format for
NB04 Debug sections&#58;
<P><B><I>Include structure name = PUBLIC_32 </I></B>
<PRE>
   00 DD Offset
   04 DW Segment
   06 DW Type Index
   08 DB Length prefixed name of symbol (1 byte length)
</PRE>
<P>
The sstType subsection (type 0x103) contains the HLL Debug Format
Type records, as emitted by the compiler in the OBJ file.
If a sstType subsection does not exist for a module, the type records
have been "packed" into a single sstType section for the Linker
created module "$$HL04" (see also the new ILINK DBGP(ACK) option).
<P><B>Note: </B>If object files containing older versions of debug information
are also linked, modules may have also been created with names "$$HL01"
and/or "$$HL03"
<P>
The sstSymbols subsection (type 0x104) contains the HLL Debug Format
Symbol Scope Table records, as emitted by the compiler in the OBJ file.
<P>
The sstLibraries subsection (type 0x106) contains an array of length-
prefixed names (one-byte length) of all the library files used during
the link step.  The order of this list defines the library index number
in the sstModules subsection.  The use of this list allows removal of
redundant library names in the Modules subsection.  The first entry
should be empty (i.e., zero-length string) since library indices are
1-based.
<P>
The sstHLLSrc subsection (type 0x10B) contains the HLL Debug Format
Line Number Tables, as emitted by the compiler in the OBJ file.
<TABLE BORDER><TR><TH ALIGN=LEFT>End of Document</TH><TR><TD>
</TD></TR></TABLE>
<HR><B> Footnotes:</B>
<P><A NAME="Footnote_1" >(1)</A>
IBM Internal Use Only systems language
<P><A NAME="Footnote_2" >(2)</A>
32-bit Object Module Format defined in OS/2 2.0 documentation
<A NAME=Bot_Of_Page>&#32;</A>
</BODY></HTML>