<head>
<title> Open Watcom 1.9 C++ Class Library Reference </title>
</head>
<body>
<h1 id="Index_of_Topics"> Index of Topics </h1>
<dl>
<dt>- A -
<dd><a href="#String__alloc_mult_sizeLR">alloc_mult_size() &#91;String&#93;</a>
<br><a href="#strstreambuf__alloc_size_incrementLR">alloc_size_increment() &#91;strstreambuf&#93;</a>
<br><a href="#streambuf__allocateLR">allocate() &#91;streambuf&#93;</a>
<br><a href="#WCIsvSListXTypeY__appendLR__WCIsvDListXTypeY__appendLR">append() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListIterXTypeY__appendLR__WCIsvDListIterXTypeY__appendLR">append() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrOrderedVectorXTypeY__appendLR">append() &#91;WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__appendLR__WCPtrDListXTypeY__appendLR">append() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListIterXTypeY__appendLR__WCPtrDListIterXTypeY__appendLR">append() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValOrderedVectorXTypeY__appendLR">append() &#91;WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__appendLR__WCValDListXTypeY__appendLR">append() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListIterXTypeY__appendLR__WCValDListIterXTypeY__appendLR">append() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93;</a>
<br><a href="#filebuf__attachLR">attach() &#91;filebuf&#93;</a>
<br><a href="#fstreambase__attachLR">attach() &#91;fstreambase&#93;</a>
<dt><br>- B -
<dd><a href="#ios__badLR">bad() &#91;ios&#93;</a>
<br><a href="#streambuf__baseLR">base() &#91;streambuf&#93;</a>
<br><a href="#ios__bitallocLR">bitalloc() &#91;ios&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__bitHashLR">bitHash() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__bitHashLR__WCPtrHashSetXTypeY__bitHashLR">bitHash() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__bitHashLR">bitHash() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__bitHashLR__WCValHashSetXTypeY__bitHashLR">bitHash() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#streambuf__blenLR">blen() &#91;streambuf&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__bucketsLR">buckets() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__bucketsLR__WCPtrHashSetXTypeY__bucketsLR">buckets() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__bucketsLR">buckets() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__bucketsLR__WCValHashSetXTypeY__bucketsLR">buckets() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93;</a>
<dt><br>- C -
<dd><a href="#cerr">cerr</a>
<br><a href="#cin">cin</a>
<br><a href="#ios__clearLR">clear() &#91;ios&#93;</a>
<br><a href="#WCIsvSListXTypeY__clearLR__WCIsvDListXTypeY__clearLR">clear() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__clearLR">clear() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__clearLR__WCPtrHashSetXTypeY__clearLR">clear() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__clearLR__WCPtrSkipListSetXTypeY__clearLR">clear() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__clearLR">clear() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__clearLR__WCPtrDListXTypeY__clearLR">clear() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY__clearLR__WCPtrOrderedVectorXTypeY__clearLR">clear() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrVectorXTypeY__clearLR">clear() &#91;WCPtrVector&lt;Type&gt;&#93;</a>
<br><a href="#WCQueueXType_FTypeY__clearLR">clear() &#91;WCQueue&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCStackXType_FTypeY__clearLR">clear() &#91;WCStack&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__clearLR">clear() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__clearLR__WCValHashSetXTypeY__clearLR">clear() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__clearLR__WCValSkipListSetXTypeY__clearLR">clear() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY__clearLR">clear() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__clearLR__WCValDListXTypeY__clearLR">clear() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY__clearLR__WCValOrderedVectorXTypeY__clearLR">clear() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValVectorXTypeY__clearLR">clear() &#91;WCValVector&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListXTypeY_WCIsvDListXTypeY__clearAndDestroyLR">clearAndDestroy() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__clearAndDestroyLR">clearAndDestroy() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY_WCPtrHashSetXTypeY__clearAndDestroyLR">clearAndDestroy() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY_WCPtrSkipListSetXTypeY__clearAndDestroyLR">clearAndDestroy() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__clearAndDestroyLR">clearAndDestroy() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY_WCPtrDListXTypeY__clearAndDestroyLR">clearAndDestroy() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__clearAndDestroyLR">clearAndDestroy() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrVectorXTypeY__clearAndDestroyLR">clearAndDestroy() &#91;WCPtrVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListXTypeY_WCValDListXTypeY__clearAndDestroyLR">clearAndDestroy() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#clog">clog</a>
<br><a href="#filebuf__closeLR">close() &#91;filebuf&#93;</a>
<br><a href="#fstreambase__closeLR">close() &#91;fstreambase&#93;</a>
<br><a href="#Common_Types">Common Types</a>
<br><a href="#Complex_absLR">Complex abs() &#91;Complex&#93;</a>
<br><a href="#Complex_acosLR">Complex acos() &#91;Complex&#93;</a>
<br><a href="#Complex_acoshLR">Complex acosh() &#91;Complex&#93;</a>
<br><a href="#Complex_argLR">Complex arg() &#91;Complex&#93;</a>
<br><a href="#Complex_asinLR">Complex asin() &#91;Complex&#93;</a>
<br><a href="#Complex_asinhLR">Complex asinh() &#91;Complex&#93;</a>
<br><a href="#Complex_atanLR">Complex atan() &#91;Complex&#93;</a>
<br><a href="#Complex_atanhLR">Complex atanh() &#91;Complex&#93;</a>
<br><a href="#Complex_Class">Complex Class</a>
<br><a href="#Complex_Class_Description">Complex Class Description</a>
<br><a href="#Complex_conjLR">Complex conj() &#91;Complex&#93;</a>
<br><a href="#Complex_cosLR">Complex cos() &#91;Complex&#93;</a>
<br><a href="#Complex_coshLR">Complex cosh() &#91;Complex&#93;</a>
<br><a href="#Complex_expLR">Complex exp() &#91;Complex&#93;</a>
<br><a href="#Complex_imagLR">Complex imag() &#91;Complex&#93;</a>
<br><a href="#Complex_logLR">Complex log() &#91;Complex&#93;</a>
<br><a href="#Complex_log10LR">Complex log10() &#91;Complex&#93;</a>
<br><a href="#Complex_normLR">Complex norm() &#91;Complex&#93;</a>
<br><a href="#Complex_operator__ELR">Complex operator !=() &#91;Complex&#93;</a>
<br><a href="#Complex_operator_TLR">Complex operator *() &#91;Complex&#93;</a>
<br><a href="#Complex_operator_PLR">Complex operator +() &#91;Complex&#93;</a>
<br><a href="#Complex_operator_MLR">Complex operator -() &#91;Complex&#93;</a>
<br><a href="#Complex_operator_DLR">Complex operator /() &#91;Complex&#93;</a>
<br><a href="#Complex_operator_XXLR">Complex operator &lt;&lt;() &#91;Complex&#93;</a>
<br><a href="#Complex_operator_EELR">Complex operator ==() &#91;Complex&#93;</a>
<br><a href="#Complex_operator_YYLR">Complex operator &gt;&gt;() &#91;Complex&#93;</a>
<br><a href="#Complex_polarLR">Complex polar() &#91;Complex&#93;</a>
<br><a href="#Complex_powLR">Complex pow() &#91;Complex&#93;</a>
<br><a href="#Complex_realLR">Complex real() &#91;Complex&#93;</a>
<br><a href="#Complex_sinLR">Complex sin() &#91;Complex&#93;</a>
<br><a href="#Complex_sinhLR">Complex sinh() &#91;Complex&#93;</a>
<br><a href="#Complex_sqrtLR">Complex sqrt() &#91;Complex&#93;</a>
<br><a href="#Complex_tanLR">Complex tan() &#91;Complex&#93;</a>
<br><a href="#Complex_tanhLR">Complex tanh() &#91;Complex&#93;</a>
<br><a href="#Complex__ComplexLR">Complex() &#91;Complex&#93;</a>
<br><a href="#Container_Allocators_and_Deallocators">Container Allocators and Deallocators</a>
<br><a href="#Container_Exception_Classes">Container Exception Classes</a>
<br><a href="#WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__containerLR">container() &#91;WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__containerLR">container() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__containerLR">container() &#91;WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictIterXKey_ValueY__containerLR">container() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashSetIterXTypeY_WCPtrHashTableIterXTypeY__containerLR">container() &#91;WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__containerLR">container() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__containerLR">container() &#91;WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictIterXKey_ValueY__containerLR">container() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashSetIterXTypeY_WCValHashTableIterXTypeY__containerLR">container() &#91;WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListIterXTypeY_WCValDListIterXTypeY__containerLR">container() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListXTypeY__containsLR__WCIsvDListXTypeY__containsLR">contains() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__containsLR">contains() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__containsLR__WCPtrHashSetXTypeY__containsLR">contains() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__containsLR__WCPtrSkipListSetXTypeY__containsLR">contains() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__containsLR">contains() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__containsLR__WCPtrDListXTypeY__containsLR">contains() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__containsLR">contains() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__containsLR">contains() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__containsLR__WCValHashSetXTypeY__containsLR">contains() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__containsLR__WCValSkipListSetXTypeY__containsLR">contains() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY__containsLR">contains() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__containsLR__WCValDListXTypeY__containsLR">contains() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__containsLR">contains() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#cout">cout</a>
<br><a href="#WCIsvConstSListIterXTypeY__currentLR__WCIsvConstDListIterXTypeY__currentLR">current() &#91;WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListIterXTypeY__currentLR__WCIsvDListIterXTypeY__currentLR">current() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrConstSListIterXTypeY__currentLR__WCPtrConstDListIterXTypeY__currentLR">current() &#91;WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashSetIterXTypeY__currentLR__WCPtrHashTableIterXTypeY__currentLR">current() &#91;WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListIterXTypeY__currentLR__WCPtrDListIterXTypeY__currentLR">current() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValConstSListIterXTypeY__currentLR__WCValConstDListIterXTypeY__currentLR">current() &#91;WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashSetIterXTypeY__currentLR__WCValHashTableIterXTypeY__currentLR">current() &#91;WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListIterXTypeY__currentLR__WCValDListIterXTypeY__currentLR">current() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93;</a>
<dt><br>- D -
<dd><a href="#streambuf__dbpLR">dbp() &#91;streambuf&#93;</a>
<br><a href="#streambuf__do_sgetnLR">do_sgetn() &#91;streambuf&#93;</a>
<br><a href="#streambuf__do_sputnLR">do_sputn() &#91;streambuf&#93;</a>
<br><a href="#streambuf__doallocateLR">doallocate() &#91;streambuf&#93;</a>
<br><a href="#strstreambuf__doallocateLR">doallocate() &#91;strstreambuf&#93;</a>
<dt><br>- E -
<dd><a href="#istream__eatwhiteLR">eatwhite() &#91;istream&#93;</a>
<br><a href="#streambuf__ebackLR">eback() &#91;streambuf&#93;</a>
<br><a href="#streambuf__ebufLR">ebuf() &#91;streambuf&#93;</a>
<br><a href="#streambuf__egptrLR">egptr() &#91;streambuf&#93;</a>
<br><a href="#WCIsvSListXTypeY__entriesLR__WCIsvDListXTypeY__entriesLR">entries() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__entriesLR">entries() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__entriesLR__WCPtrHashSetXTypeY__entriesLR">entries() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__entriesLR__WCPtrSkipListSetXTypeY__entriesLR">entries() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__entriesLR">entries() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__entriesLR__WCPtrDListXTypeY__entriesLR">entries() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY__entriesLR__WCPtrOrderedVectorXTypeY__entriesLR">entries() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCQueueXType_FTypeY__entriesLR">entries() &#91;WCQueue&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCStackXType_FTypeY__entriesLR">entries() &#91;WCStack&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__entriesLR">entries() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__entriesLR__WCValHashSetXTypeY__entriesLR">entries() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__entriesLR__WCValSkipListSetXTypeY__entriesLR">entries() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY__entriesLR">entries() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__entriesLR__WCValDListXTypeY__entriesLR">entries() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY__entriesLR__WCValOrderedVectorXTypeY__entriesLR">entries() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#ios__eofLR">eof() &#91;ios&#93;</a>
<br><a href="#streambuf__epptrLR">epptr() &#91;streambuf&#93;</a>
<br><a href="#ios__exceptionsLR">exceptions() &#91;ios&#93;</a>
<br><a href="#WCExcept__exceptionsLR">exceptions() &#91;WCExcept&#93;</a>
<br><a href="#WCIterExcept__exceptionsLR">exceptions() &#91;WCIterExcept&#93;</a>
<dt><br>- F -
<dd><a href="#ios__failLR">fail() &#91;ios&#93;</a>
<br><a href="#filebuf__fdLR">fd() &#91;filebuf&#93;</a>
<br><a href="#fstreambase__fdLR">fd() &#91;fstreambase&#93;</a>
<br><a href="#filebuf_Class_Description">filebuf Class Description</a>
<br><a href="#filebuf__filebufLR">filebuf() &#91;filebuf&#93;</a>
<br><a href="#ios__fillLR">fill() &#91;ios&#93;</a>
<br><a href="#WCIsvSListXTypeY__findLR__WCIsvDListXTypeY__findLR">find() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__findLR">find() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__findLR__WCPtrHashSetXTypeY__findLR">find() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__findLR__WCPtrSkipListSetXTypeY__findLR">find() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__findLR">find() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__findLR__WCPtrDListXTypeY__findLR">find() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY__findLR__WCPtrOrderedVectorXTypeY__findLR">find() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__findLR">find() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__findLR__WCValHashSetXTypeY__findLR">find() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__findLR__WCValSkipListSetXTypeY__findLR">find() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY__findLR">find() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__findLR__WCValDListXTypeY__findLR">find() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY__findLR__WCValOrderedVectorXTypeY__findLR">find() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__findKeyAndValueLR">findKeyAndValue() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__findKeyAndValueLR">findKeyAndValue() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__findKeyAndValueLR">findKeyAndValue() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY__findKeyAndValueLR">findKeyAndValue() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCIsvSListXTypeY__findLastLR__WCIsvDListXTypeY__findLastLR">findLast() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__findLastLR__WCPtrDListXTypeY__findLastLR">findLast() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__findLastLR__WCValDListXTypeY__findLastLR">findLast() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY__firstLR__WCPtrOrderedVectorXTypeY__firstLR">first() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCQueueXType_FTypeY__firstLR">first() &#91;WCQueue&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY__firstLR__WCValOrderedVectorXTypeY__firstLR">first() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#ios__flagsLR">flags() &#91;ios&#93;</a>
<br><a href="#ostream__flushLR">flush() &#91;ostream&#93;</a>
<br><a href="#ios__fmtflags">fmtflags &#91;ios&#93;</a>
<br><a href="#WCIsvSListXTypeY__forAllLR__WCIsvDListXTypeY__forAllLR">forAll() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__forAllLR">forAll() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__forAllLR__WCPtrHashSetXTypeY__forAllLR">forAll() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__forAllLR__WCPtrSkipListSetXTypeY__forAllLR">forAll() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__forAllLR">forAll() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__forAllLR__WCPtrDListXTypeY__forAllLR">forAll() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__forAllLR">forAll() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__forAllLR__WCValHashSetXTypeY__forAllLR">forAll() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__forAllLR__WCValSkipListSetXTypeY__forAllLR">forAll() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY__forAllLR">forAll() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__forAllLR__WCValDListXTypeY__forAllLR">forAll() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#Formatted_Input__Extractors">Formatted Input:&nbsp; Extractors</a>
<br><a href="#Formatted_Output__Inserters">Formatted Output:&nbsp; Inserters</a>
<br><a href="#strstreambuf__freezeLR">freeze() &#91;strstreambuf&#93;</a>
<br><a href="#fstream_Class_Description">fstream Class Description</a>
<br><a href="#fstream__fstreamLR">fstream() &#91;fstream&#93;</a>
<br><a href="#fstreambase_Class_Description">fstreambase Class Description</a>
<br><a href="#fstreambase__fstreambaseLR">fstreambase() &#91;fstreambase&#93;</a>
<dt><br>- G -
<dd><a href="#streambuf__gbumpLR">gbump() &#91;streambuf&#93;</a>
<br><a href="#istream__gcountLR">gcount() &#91;istream&#93;</a>
<br><a href="#istream__getLR">get() &#91;istream&#93;</a>
<br><a href="#WCIsvSListXTypeY__getLR__WCIsvDListXTypeY__getLR">get() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__getLR__WCPtrDListXTypeY__getLR">get() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCQueueXType_FTypeY__getLR">get() &#91;WCQueue&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__getLR__WCValDListXTypeY__getLR">get() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#String__get_atLR">get_at() &#91;String&#93;</a>
<br><a href="#istream__getlineLR">getline() &#91;istream&#93;</a>
<br><a href="#ios__goodLR">good() &#91;ios&#93;</a>
<br><a href="#streambuf__gptrLR">gptr() &#91;streambuf&#93;</a>
<dt><br>- H -
<dd><a href="#Hash_Containers">Hash Containers</a>
<br><a href="#Hash_Iterators">Hash Iterators</a>
<br><a href="#Header_Files">Header Files</a>
<dt><br>- I -
<dd><a href="#ifstream_Class_Description">ifstream Class Description</a>
<br><a href="#ifstream__ifstreamLR">ifstream() &#91;ifstream&#93;</a>
<br><a href="#istream__ignoreLR">ignore() &#91;istream&#93;</a>
<br><a href="#Complex__imagLR">imag() &#91;Complex&#93;</a>
<br><a href="#streambuf__in_availLR">in_avail() &#91;streambuf&#93;</a>
<br><a href="#String__indexLR">index() &#91;String&#93;</a>
<br><a href="#WCIsvSListXTypeY__indexLR__WCIsvDListXTypeY__indexLR">index() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__indexLR__WCPtrDListXTypeY__indexLR">index() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY__indexLR__WCPtrOrderedVectorXTypeY__indexLR">index() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__indexLR__WCValDListXTypeY__indexLR">index() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY__indexLR__WCValOrderedVectorXTypeY__indexLR">index() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#ios__initLR">init() &#91;ios&#93;</a>
<br><a href="#InputDOutput_Classes">Input/Output Classes</a>
<br><a href="#WCIsvDListIterXTypeY__insertLR">insert() &#91;WCIsvDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListXTypeY__insertLR__WCIsvDListXTypeY__insertLR">insert() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrDListIterXTypeY__insertLR">insert() &#91;WCPtrDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__insertLR">insert() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__insertLR__WCPtrHashSetXTypeY__insertLR">insert() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__insertLR__WCPtrSkipListSetXTypeY__insertLR">insert() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__insertLR">insert() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__insertLR__WCPtrDListXTypeY__insertLR">insert() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY__insertLR__WCPtrOrderedVectorXTypeY__insertLR">insert() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCQueueXType_FTypeY__insertLR">insert() &#91;WCQueue&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCValDListIterXTypeY__insertLR">insert() &#91;WCValDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__insertLR">insert() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__insertLR__WCValHashSetXTypeY__insertLR">insert() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__insertLR__WCValSkipListSetXTypeY__insertLR">insert() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY__insertLR">insert() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__insertLR__WCValDListXTypeY__insertLR">insert() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY__insertLR__WCValOrderedVectorXTypeY__insertLR">insert() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrOrderedVectorXTypeY__insertAtLR">insertAt() &#91;WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValOrderedVectorXTypeY__insertAtLR">insertAt() &#91;WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#ios_Class_Description">ios Class Description</a>
<br><a href="#ios__iosLR">ios() &#91;ios&#93;</a>
<br><a href="#ios__iostate">iostate &#91;ios&#93;</a>
<br><a href="#iostream_Class_Description">iostream Class Description</a>
<br><a href="#iostream__iostreamLR">iostream() &#91;iostream&#93;</a>
<br><a href="#istream__ipfxLR">ipfx() &#91;istream&#93;</a>
<br><a href="#filebuf__is_openLR">is_open() &#91;filebuf&#93;</a>
<br><a href="#fstreambase__is_openLR">is_open() &#91;fstreambase&#93;</a>
<br><a href="#WCIsvSListXTypeY__isEmptyLR__WCIsvDListXTypeY__isEmptyLR">isEmpty() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__isEmptyLR">isEmpty() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__isEmptyLR__WCPtrHashSetXTypeY__isEmptyLR">isEmpty() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__isEmptyLR__WCPtrSkipListSetXTypeY__isEmptyLR">isEmpty() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__isEmptyLR">isEmpty() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__isEmptyLR__WCPtrDListXTypeY__isEmptyLR">isEmpty() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__isEmptyLR">isEmpty() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCQueueXType_FTypeY__isEmptyLR">isEmpty() &#91;WCQueue&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCStackXType_FTypeY__isEmptyLR">isEmpty() &#91;WCStack&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__isEmptyLR">isEmpty() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__isEmptyLR__WCValHashSetXTypeY__isEmptyLR">isEmpty() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__isEmptyLR__WCValSkipListSetXTypeY__isEmptyLR">isEmpty() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY__isEmptyLR">isEmpty() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__isEmptyLR__WCValDListXTypeY__isEmptyLR">isEmpty() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__isEmptyLR">isEmpty() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#istream__isfxLR">isfx() &#91;istream&#93;</a>
<br><a href="#istream_Class_Description">istream Class Description</a>
<br><a href="#istream_Input">istream Input</a>
<br><a href="#istream__istreamLR">istream() &#91;istream&#93;</a>
<br><a href="#istrstream_Class_Description">istrstream Class Description</a>
<br><a href="#istrstream__istrstreamLR">istrstream() &#91;istrstream&#93;</a>
<br><a href="#ios__iwordLR">iword() &#91;ios&#93;</a>
<dt><br>- K -
<dd><a href="#WCPtrHashDictIterXKey_ValueY__keyLR">key() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashDictIterXKey_ValueY__keyLR">key() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93;</a>
<dt><br>- L -
<dd><a href="#WCPtrSortedVectorXTypeY__lastLR__WCPtrOrderedVectorXTypeY__lastLR">last() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCQueueXType_FTypeY__lastLR">last() &#91;WCQueue&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY__lastLR__WCValOrderedVectorXTypeY__lastLR">last() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#String__lengthLR">length() &#91;String&#93;</a>
<br><a href="#WCPtrVectorXTypeY__lengthLR">length() &#91;WCPtrVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValVectorXTypeY__lengthLR">length() &#91;WCValVector&lt;Type&gt;&#93;</a>
<br><a href="#Library_Functions_and_Types">Library Functions and Types</a>
<br><a href="#List_Containers">List Containers</a>
<br><a href="#List_Iterators">List Iterators</a>
<br><a href="#String__lowerLR">lower() &#91;String&#93;</a>
<dt><br>- M -
<dd><a href="#manipulator_decLR">manipulator dec() &#91;manipulator&#93;</a>
<br><a href="#manipulator_endlLR">manipulator endl() &#91;manipulator&#93;</a>
<br><a href="#manipulator_endsLR">manipulator ends() &#91;manipulator&#93;</a>
<br><a href="#manipulator_flushLR">manipulator flush() &#91;manipulator&#93;</a>
<br><a href="#manipulator_hexLR">manipulator hex() &#91;manipulator&#93;</a>
<br><a href="#manipulator_octLR">manipulator oct() &#91;manipulator&#93;</a>
<br><a href="#manipulator_resetiosflagsLR">manipulator resetiosflags() &#91;manipulator&#93;</a>
<br><a href="#manipulator_setbaseLR">manipulator setbase() &#91;manipulator&#93;</a>
<br><a href="#manipulator_setfillLR">manipulator setfill() &#91;manipulator&#93;</a>
<br><a href="#manipulator_setiosflagsLR">manipulator setiosflags() &#91;manipulator&#93;</a>
<br><a href="#manipulator_setprecisionLR">manipulator setprecision() &#91;manipulator&#93;</a>
<br><a href="#manipulator_setwLR">manipulator setw() &#91;manipulator&#93;</a>
<br><a href="#manipulator_setwidthLR">manipulator setwidth() &#91;manipulator&#93;</a>
<br><a href="#manipulator_wsLR">manipulator ws() &#91;manipulator&#93;</a>
<br><a href="#Manipulators">Manipulators &#91;manipulator&#93;</a>
<br><a href="#String__matchLR">match() &#91;String&#93;</a>
<dt><br>- O -
<dd><a href="#WCPtrHashTableXTypeY__occurencesOfLR">occurencesOf() &#91;WCPtrHashTable&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__occurencesOfLR">occurencesOf() &#91;WCValHashTable&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__occurrencesOfLR">occurrencesOf() &#91;WCPtrSkipList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__occurrencesOfLR">occurrencesOf() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__occurrencesOfLR">occurrencesOf() &#91;WCValSkipList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__occurrencesOfLR">occurrencesOf() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#ofstream_Class_Description">ofstream Class Description</a>
<br><a href="#ofstream__ofstreamLR">ofstream() &#91;ofstream&#93;</a>
<br><a href="#filebuf__openLR">open() &#91;filebuf&#93;</a>
<br><a href="#fstream__openLR">open() &#91;fstream&#93;</a>
<br><a href="#fstreambase__openLR">open() &#91;fstreambase&#93;</a>
<br><a href="#ifstream__openLR">open() &#91;ifstream&#93;</a>
<br><a href="#ofstream__openLR">open() &#91;ofstream&#93;</a>
<br><a href="#ios__openmode">openmode &#91;ios&#93;</a>
<br><a href="#filebuf__openprot">openprot &#91;filebuf&#93;</a>
<br><a href="#ios__operator__LR">operator !() &#91;ios&#93;</a>
<br><a href="#String__operator__LR">operator !() &#91;String&#93;</a>
<br><a href="#String__operator_LRLR">operator ()() &#91;String&#93;</a>
<br><a href="#WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__operator_LRLR">operator ()() &#91;WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__operator_LRLR">operator ()() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__operator_LRLR">operator ()() &#91;WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictIterXKey_ValueY__operator_LRLR">operator ()() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashSetIterXTypeY_WCPtrHashTableIterXTypeY__operator_LRLR">operator ()() &#91;WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__operator_LRLR">operator ()() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__operator_LRLR">operator ()() &#91;WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictIterXKey_ValueY__operator_LRLR">operator ()() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashSetIterXTypeY_WCValHashTableIterXTypeY__operator_LRLR">operator ()() &#91;WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListIterXTypeY_WCValDListIterXTypeY__operator_LRLR">operator ()() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93;</a>
<br><a href="#Complex__operator_TELR">operator *=() &#91;Complex&#93;</a>
<br><a href="#Complex__operator_PLR">operator +() &#91;Complex&#93;</a>
<br><a href="#WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__operator_PPLR">operator ++() &#91;WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__operator_PPLR">operator ++() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__operator_PPLR">operator ++() &#91;WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictIterXKey_ValueY__operator_PPLR">operator ++() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashSetIterXTypeY_WCPtrHashTableIterXTypeY__operator_PPLR">operator ++() &#91;WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__operator_PPLR">operator ++() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__operator_PPLR">operator ++() &#91;WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictIterXKey_ValueY__operator_PPLR">operator ++() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashSetIterXTypeY_WCValHashTableIterXTypeY__operator_PPLR">operator ++() &#91;WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListIterXTypeY_WCValDListIterXTypeY__operator_PPLR">operator ++() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93;</a>
<br><a href="#Complex__operator_PELR">operator +=() &#91;Complex&#93;</a>
<br><a href="#String__operator_PELR">operator +=() &#91;String&#93;</a>
<br><a href="#WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__operator_PELR">operator +=() &#91;WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__operator_PELR">operator +=() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__operator_PELR">operator +=() &#91;WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__operator_PELR">operator +=() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__operator_PELR">operator +=() &#91;WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListIterXTypeY_WCValDListIterXTypeY__operator_PELR">operator +=() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93;</a>
<br><a href="#Complex__operator_MLR">operator -() &#91;Complex&#93;</a>
<br><a href="#WCIsvConstDListIterXTypeY__operator_MMLR">operator --() &#91;WCIsvConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvDListIterXTypeY__operator_MMLR">operator --() &#91;WCIsvDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrConstDListIterXTypeY__operator_MMLR">operator --() &#91;WCPtrConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrDListIterXTypeY__operator_MMLR">operator --() &#91;WCPtrDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValConstDListIterXTypeY__operator_MMLR">operator --() &#91;WCValConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValDListIterXTypeY__operator_MMLR">operator --() &#91;WCValDListIter&lt;Type&gt;&#93;</a>
<br><a href="#Complex__operator_MELR">operator -=() &#91;Complex&#93;</a>
<br><a href="#WCIsvConstDListIterXTypeY__operator_MELR">operator -=() &#91;WCIsvConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvDListIterXTypeY__operator_MELR">operator -=() &#91;WCIsvDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrConstDListIterXTypeY__operator_MELR">operator -=() &#91;WCPtrConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrDListIterXTypeY__operator_MELR">operator -=() &#91;WCPtrDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValConstDListIterXTypeY__operator_MELR">operator -=() &#91;WCValConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValDListIterXTypeY__operator_MELR">operator -=() &#91;WCValDListIter&lt;Type&gt;&#93;</a>
<br><a href="#Complex__operator_DELR">operator /=() &#91;Complex&#93;</a>
<br><a href="#ostream__operator_XXLR">operator &lt;&lt;() &#91;ostream&#93;</a>
<br><a href="#Complex__operator_ELR">operator =() &#91;Complex&#93;</a>
<br><a href="#iostream__operator_ELR">operator =() &#91;iostream&#93;</a>
<br><a href="#istream__operator_ELR">operator =() &#91;istream&#93;</a>
<br><a href="#ostream__operator_ELR">operator =() &#91;ostream&#93;</a>
<br><a href="#String__operator_ELR">operator =() &#91;String&#93;</a>
<br><a href="#WCIsvSListXTypeY__operator_ELR__WCIsvDListXTypeY__operator_ELR">operator =() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__operator_ELR">operator =() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__operator_ELR__WCPtrHashSetXTypeY__operator_ELR">operator =() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__operator_ELR__WCPtrSkipListSetXTypeY__operator_ELR">operator =() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__operator_ELR">operator =() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__operator_ELR__WCPtrDListXTypeY__operator_ELR">operator =() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__operator_ELR">operator =() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrVectorXTypeY__operator_ELR">operator =() &#91;WCPtrVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__operator_ELR">operator =() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__operator_ELR__WCValHashSetXTypeY__operator_ELR">operator =() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__operator_ELR__WCValSkipListSetXTypeY__operator_ELR">operator =() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY__operator_ELR">operator =() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__operator_ELR__WCValDListXTypeY__operator_ELR">operator =() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__operator_ELR">operator =() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValVectorXTypeY__operator_ELR">operator =() &#91;WCValVector&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListXTypeY__operator_EELR__WCIsvDListXTypeY__operator_EELR">operator ==() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__operator_EELR">operator ==() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__operator_EELR__WCPtrHashSetXTypeY__operator_EELR">operator ==() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__operator_EELR__WCPtrSkipListSetXTypeY__operator_EELR">operator ==() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__operator_EELR">operator ==() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__operator_EELR__WCPtrDListXTypeY__operator_EELR">operator ==() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__operator_EELR">operator ==() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrVectorXTypeY__operator_EELR">operator ==() &#91;WCPtrVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__operator_EELR">operator ==() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__operator_EELR__WCValHashSetXTypeY__operator_EELR">operator ==() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__operator_EELR__WCValSkipListSetXTypeY__operator_EELR">operator ==() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY__operator_EELR">operator ==() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__operator_EELR__WCValDListXTypeY__operator_EELR">operator ==() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__operator_EELR">operator ==() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValVectorXTypeY__operator_EELR">operator ==() &#91;WCValVector&lt;Type&gt;&#93;</a>
<br><a href="#istream__operator_YYLR">operator &gt;&gt;() &#91;istream&#93;</a>
<br><a href="#String__operator_UVLR">operator &#91;&#93;() &#91;String&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__operator_UVLR">operator &#91;&#93;() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__operator_UVLR">operator &#91;&#93;() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__operator_UVLR">operator &#91;&#93;() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrVectorXTypeY__operator_UVLR">operator &#91;&#93;() &#91;WCPtrVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__operator_UVLR">operator &#91;&#93;() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY__operator_UVLR">operator &#91;&#93;() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__operator_UVLR">operator &#91;&#93;() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValVectorXTypeY__operator_UVLR">operator &#91;&#93;() &#91;WCValVector&lt;Type&gt;&#93;</a>
<br><a href="#String__operator_char_const_TLR">operator char const *() &#91;String&#93;</a>
<br><a href="#String__operator_charLR">operator char() &#91;String&#93;</a>
<br><a href="#ios__operator_void_TLR">operator void *() &#91;ios&#93;</a>
<br><a href="#ostream__opfxLR">opfx() &#91;ostream&#93;</a>
<br><a href="#ostream__osfxLR">osfx() &#91;ostream&#93;</a>
<br><a href="#ostream_Class_Description">ostream Class Description</a>
<br><a href="#ostream_Output">ostream Output</a>
<br><a href="#ostream__ostreamLR">ostream() &#91;ostream&#93;</a>
<br><a href="#ostrstream_Class_Description">ostrstream Class Description</a>
<br><a href="#ostrstream__ostrstreamLR">ostrstream() &#91;ostrstream&#93;</a>
<br><a href="#streambuf__out_waitingLR">out_waiting() &#91;streambuf&#93;</a>
<br><a href="#filebuf__overflowLR">overflow() &#91;filebuf&#93;</a>
<br><a href="#stdiobuf__overflowLR">overflow() &#91;stdiobuf&#93;</a>
<br><a href="#streambuf__overflowLR">overflow() &#91;streambuf&#93;</a>
<br><a href="#strstreambuf__overflowLR">overflow() &#91;strstreambuf&#93;</a>
<dt><br>- P -
<dd><a href="#filebuf__pbackfailLR">pbackfail() &#91;filebuf&#93;</a>
<br><a href="#streambuf__pbackfailLR">pbackfail() &#91;streambuf&#93;</a>
<br><a href="#streambuf__pbaseLR">pbase() &#91;streambuf&#93;</a>
<br><a href="#streambuf__pbumpLR">pbump() &#91;streambuf&#93;</a>
<br><a href="#ostrstream__pcountLR">pcount() &#91;ostrstream&#93;</a>
<br><a href="#istream__peekLR">peek() &#91;istream&#93;</a>
<br><a href="#WCStackXType_FTypeY__popLR">pop() &#91;WCStack&lt;Type,FType&gt;&#93;</a>
<br><a href="#streambuf__pptrLR">pptr() &#91;streambuf&#93;</a>
<br><a href="#ios__precisionLR">precision() &#91;ios&#93;</a>
<br><a href="#Predefined_Objects">Predefined Objects</a>
<br><a href="#WCPtrOrderedVectorXTypeY__prependLR">prepend() &#91;WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValOrderedVectorXTypeY__prependLR">prepend() &#91;WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCStackXType_FTypeY__pushLR">push() &#91;WCStack&lt;Type,FType&gt;&#93;</a>
<br><a href="#ostream__putLR">put() &#91;ostream&#93;</a>
<br><a href="#String__put_atLR">put_at() &#91;String&#93;</a>
<br><a href="#istream__putbackLR">putback() &#91;istream&#93;</a>
<br><a href="#ios__pwordLR">pword() &#91;ios&#93;</a>
<dt><br>- Q -
<dd><a href="#Queue_Container">Queue Container</a>
<dt><br>- R -
<dd><a href="#fstreambase__rdbufLR">rdbuf() &#91;fstreambase&#93;</a>
<br><a href="#ios__rdbufLR">rdbuf() &#91;ios&#93;</a>
<br><a href="#strstreambase__rdbufLR">rdbuf() &#91;strstreambase&#93;</a>
<br><a href="#ios__rdstateLR">rdstate() &#91;ios&#93;</a>
<br><a href="#istream__readLR">read() &#91;istream&#93;</a>
<br><a href="#Complex__realLR">real() &#91;Complex&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__removeLR">remove() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__removeLR__WCPtrHashSetXTypeY__removeLR">remove() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__removeLR__WCPtrSkipListSetXTypeY__removeLR">remove() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__removeLR">remove() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY__removeLR__WCPtrOrderedVectorXTypeY__removeLR">remove() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__removeLR">remove() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__removeLR__WCValHashSetXTypeY__removeLR">remove() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__removeLR__WCValSkipListSetXTypeY__removeLR">remove() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY__removeLR">remove() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY__removeLR__WCValOrderedVectorXTypeY__removeLR">remove() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__removeAllLR">removeAll() &#91;WCPtrHashTable&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__removeAllLR">removeAll() &#91;WCPtrSkipList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeAllLR">removeAll() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__removeAllLR">removeAll() &#91;WCValHashTable&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__removeAllLR">removeAll() &#91;WCValSkipList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeAllLR">removeAll() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeAtLR">removeAt() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeAtLR">removeAt() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeFirstLR">removeFirst() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeFirstLR">removeFirst() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeLastLR">removeLast() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeLastLR">removeLast() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvConstSListIterXTypeY__resetLR__WCIsvConstDListIterXTypeY__resetLR">reset() &#91;WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListIterXTypeY__resetLR__WCIsvDListIterXTypeY__resetLR">reset() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrConstSListIterXTypeY__resetLR__WCPtrConstDListIterXTypeY__resetLR">reset() &#91;WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictIterXKey_ValueY__resetLR">reset() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashSetIterXTypeY__resetLR__WCPtrHashTableIterXTypeY__resetLR">reset() &#91;WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListIterXTypeY__resetLR__WCPtrDListIterXTypeY__resetLR">reset() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValConstSListIterXTypeY__resetLR__WCValConstDListIterXTypeY__resetLR">reset() &#91;WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictIterXKey_ValueY__resetLR">reset() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashSetIterXTypeY__resetLR__WCValHashTableIterXTypeY__resetLR">reset() &#91;WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListIterXTypeY__resetLR__WCValDListIterXTypeY__resetLR">reset() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__resizeLR">resize() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__resizeLR__WCPtrHashSetXTypeY__resizeLR">resize() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY__resizeLR__WCPtrOrderedVectorXTypeY__resizeLR">resize() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrVectorXTypeY__resizeLR">resize() &#91;WCPtrVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__resizeLR">resize() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__resizeLR__WCValHashSetXTypeY__resizeLR">resize() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY__resizeLR__WCValOrderedVectorXTypeY__resizeLR">resize() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValVectorXTypeY__resizeLR">resize() &#91;WCValVector&lt;Type&gt;&#93;</a>
<dt><br>- S -
<dd><a href="#streambuf__sbumpcLR">sbumpc() &#91;streambuf&#93;</a>
<br><a href="#ios__seekdir">seekdir &#91;ios&#93;</a>
<br><a href="#istream__seekgLR">seekg() &#91;istream&#93;</a>
<br><a href="#filebuf__seekoffLR">seekoff() &#91;filebuf&#93;</a>
<br><a href="#streambuf__seekoffLR">seekoff() &#91;streambuf&#93;</a>
<br><a href="#strstreambuf__seekoffLR">seekoff() &#91;strstreambuf&#93;</a>
<br><a href="#ostream__seekpLR">seekp() &#91;ostream&#93;</a>
<br><a href="#streambuf__seekposLR">seekpos() &#91;streambuf&#93;</a>
<br><a href="#streambuf__setbLR">setb() &#91;streambuf&#93;</a>
<br><a href="#filebuf__setbufLR">setbuf() &#91;filebuf&#93;</a>
<br><a href="#fstreambase__setbufLR">setbuf() &#91;fstreambase&#93;</a>
<br><a href="#streambuf__setbufLR">setbuf() &#91;streambuf&#93;</a>
<br><a href="#strstreambuf__setbufLR">setbuf() &#91;strstreambuf&#93;</a>
<br><a href="#ios__setfLR">setf() &#91;ios&#93;</a>
<br><a href="#streambuf__setgLR">setg() &#91;streambuf&#93;</a>
<br><a href="#streambuf__setpLR">setp() &#91;streambuf&#93;</a>
<br><a href="#ios__setstateLR">setstate() &#91;ios&#93;</a>
<br><a href="#streambuf__sgetcLR">sgetc() &#91;streambuf&#93;</a>
<br><a href="#streambuf__sgetcharLR">sgetchar() &#91;streambuf&#93;</a>
<br><a href="#streambuf__sgetnLR">sgetn() &#91;streambuf&#93;</a>
<br><a href="#Skip_List_Containers">Skip List Containers</a>
<br><a href="#streambuf__snextcLR">snextc() &#91;streambuf&#93;</a>
<br><a href="#streambuf__speekcLR">speekc() &#91;streambuf&#93;</a>
<br><a href="#streambuf__sputbackcLR">sputbackc() &#91;streambuf&#93;</a>
<br><a href="#streambuf__sputcLR">sputc() &#91;streambuf&#93;</a>
<br><a href="#streambuf__sputnLR">sputn() &#91;streambuf&#93;</a>
<br><a href="#Stack_Container">Stack Container</a>
<br><a href="#stdiobuf_Class_Description">stdiobuf Class Description</a>
<br><a href="#stdiobuf__stdiobufLR">stdiobuf() &#91;stdiobuf&#93;</a>
<br><a href="#streambuf__stosscLR">stossc() &#91;streambuf&#93;</a>
<br><a href="#ostrstream__strLR">str() &#91;ostrstream&#93;</a>
<br><a href="#strstream__strLR">str() &#91;strstream&#93;</a>
<br><a href="#strstreambuf__strLR">str() &#91;strstreambuf&#93;</a>
<br><a href="#streambuf_Class_Description">streambuf Class Description</a>
<br><a href="#streambuf__streambufLR">streambuf() &#91;streambuf&#93;</a>
<br><a href="#String_Class">String Class</a>
<br><a href="#String_Class_Description">String Class Description</a>
<br><a href="#String_operator__ELR">String operator !=() &#91;String&#93;</a>
<br><a href="#String_operator_PLR">String operator +() &#91;String&#93;</a>
<br><a href="#String_operator_XLR">String operator &lt;() &#91;String&#93;</a>
<br><a href="#String_operator_XXLR">String operator &lt;&lt;() &#91;String&#93;</a>
<br><a href="#String_operator_XELR">String operator &lt;=() &#91;String&#93;</a>
<br><a href="#String_operator_EELR">String operator ==() &#91;String&#93;</a>
<br><a href="#String_operator_YLR">String operator &gt;() &#91;String&#93;</a>
<br><a href="#String_operator_YELR">String operator &gt;=() &#91;String&#93;</a>
<br><a href="#String_operator_YYLR">String operator &gt;&gt;() &#91;String&#93;</a>
<br><a href="#String_validLR">String valid() &#91;String&#93;</a>
<br><a href="#String__StringLR">String() &#91;String&#93;</a>
<br><a href="#strstream_Class_Description">strstream Class Description</a>
<br><a href="#strstream__strstreamLR">strstream() &#91;strstream&#93;</a>
<br><a href="#strstreambase_Class_Description">strstreambase Class Description</a>
<br><a href="#strstreambase__strstreambaseLR">strstreambase() &#91;strstreambase&#93;</a>
<br><a href="#strstreambuf_Class_Description">strstreambuf Class Description</a>
<br><a href="#strstreambuf__strstreambufLR">strstreambuf() &#91;strstreambuf&#93;</a>
<br><a href="#filebuf__syncLR">sync() &#91;filebuf&#93;</a>
<br><a href="#istream__syncLR">sync() &#91;istream&#93;</a>
<br><a href="#stdiobuf__syncLR">sync() &#91;stdiobuf&#93;</a>
<br><a href="#streambuf__syncLR">sync() &#91;streambuf&#93;</a>
<br><a href="#strstreambuf__syncLR">sync() &#91;strstreambuf&#93;</a>
<br><a href="#ios__sync_with_stdioLR">sync_with_stdio() &#91;ios&#93;</a>
<dt><br>- T -
<dd><a href="#istream__tellgLR">tellg() &#91;istream&#93;</a>
<br><a href="#ostream__tellpLR">tellp() &#91;ostream&#93;</a>
<br><a href="#ios__tieLR">tie() &#91;ios&#93;</a>
<br><a href="#WCStackXType_FTypeY__topLR">top() &#91;WCStack&lt;Type,FType&gt;&#93;</a>
<dt><br>- U -
<dd><a href="#streambuf__unbufferedLR">unbuffered() &#91;streambuf&#93;</a>
<br><a href="#filebuf__underflowLR">underflow() &#91;filebuf&#93;</a>
<br><a href="#stdiobuf__underflowLR">underflow() &#91;stdiobuf&#93;</a>
<br><a href="#streambuf__underflowLR">underflow() &#91;streambuf&#93;</a>
<br><a href="#strstreambuf__underflowLR">underflow() &#91;strstreambuf&#93;</a>
<br><a href="#Unformatted_Input">Unformatted Input</a>
<br><a href="#Unformatted_Output">Unformatted Output</a>
<br><a href="#ios__unsetfLR">unsetf() &#91;ios&#93;</a>
<br><a href="#String__upperLR">upper() &#91;String&#93;</a>
<dt><br>- V -
<dd><a href="#String__validLR">valid() &#91;String&#93;</a>
<br><a href="#WCPtrHashDictIterXKey_ValueY__valueLR">value() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashDictIterXKey_ValueY__valueLR">value() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#Vector_Containers">Vector Containers</a>
<dt><br>- W -
<dd><a href="#WCExcept__wc_state">wc_state &#91;WCExcept&#93;</a>
<br><a href="#WCDLink_Class_Description">WCDLink Class Description</a>
<br><a href="#WCDLink__WCDLinkLR">WCDLink() &#91;WCDLink&#93;</a>
<br><a href="#WCExcept_Class_Description">WCExcept Class Description</a>
<br><a href="#WCExcept__WCExceptLR">WCExcept() &#91;WCExcept&#93;</a>
<br><a href="#WCIsvConstDListIterXTypeY__WCIsvConstDListIterLR">WCIsvConstDListIter() &#91;WCIsvConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvConstSListIterXTypeY__WCIsvConstSListIterLR">WCIsvConstSListIter() &#91;WCIsvConstSListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvConstSListIterXTypeY__WCIsvConstDListIterXTypeY_Class_Description">WCIsvConstSListIter&lt;Type&gt;, WCIsvConstDListIter&lt;Type&gt; Class Description</a>
<br><a href="#WCIsvDListXTypeY__WCIsvDListLR">WCIsvDList() &#91;WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvDListIterXTypeY__WCIsvDListIterLR">WCIsvDListIter() &#91;WCIsvDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListXTypeY__WCIsvSListLR">WCIsvSList() &#91;WCIsvSList&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListXTypeY__WCIsvDListXTypeY_Class_Description">WCIsvSList&lt;Type&gt;, WCIsvDList&lt;Type&gt; Class Description</a>
<br><a href="#WCIsvSListIterXTypeY__WCIsvSListIterLR">WCIsvSListIter() &#91;WCIsvSListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListIterXTypeY__WCIsvDListIterXTypeY_Class_Description">WCIsvSListIter&lt;Type&gt;, WCIsvDListIter&lt;Type&gt; Class Description</a>
<br><a href="#WCIterExcept__wciter_state">wciter_state &#91;WCIterExcept&#93;</a>
<br><a href="#WCIterExcept_Class_Description">WCIterExcept Class Description</a>
<br><a href="#WCIterExcept__WCIterExceptLR">WCIterExcept() &#91;WCIterExcept&#93;</a>
<br><a href="#WCPtrConstDListIterXTypeY__WCPtrConstDListIterLR">WCPtrConstDListIter() &#91;WCPtrConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrConstSListIterXTypeY__WCPtrConstSListIterLR">WCPtrConstSListIter() &#91;WCPtrConstSListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrConstSListIterXTypeY__WCPtrConstDListIterXTypeY_Class_Description">WCPtrConstSListIter&lt;Type&gt;, WCPtrConstDListIter&lt;Type&gt; Class Description</a>
<br><a href="#WCPtrDListXTypeY__WCPtrDListLR">WCPtrDList() &#91;WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrDListIterXTypeY__WCPtrDListIterLR">WCPtrDListIter() &#91;WCPtrDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY__WCPtrHashDictLR">WCPtrHashDict() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY_Class_Description">WCPtrHashDict&lt;Key,Value&gt; Class Description</a>
<br><a href="#WCPtrHashDictIterXKey_ValueY__WCPtrHashDictIterLR">WCPtrHashDictIter() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashDictIterXKey_ValueY_Class_Description">WCPtrHashDictIter&lt;Key,Value&gt; Class Description</a>
<br><a href="#WCPtrHashSetXTypeY__WCPtrHashSetLR">WCPtrHashSet() &#91;WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashSetIterXTypeY__WCPtrHashSetIterLR">WCPtrHashSetIter() &#91;WCPtrHashSetIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashSetIterXTypeY__WCPtrHashTableIterXTypeY_Class_Description">WCPtrHashSetIter&lt;Type&gt;, WCPtrHashTableIter&lt;Type&gt; Class Description</a>
<br><a href="#WCPtrHashTableXTypeY__WCPtrHashTableLR">WCPtrHashTable() &#91;WCPtrHashTable&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY__WCPtrHashSetXTypeY_Class_Description">WCPtrHashTable&lt;Type&gt;, WCPtrHashSet&lt;Type&gt; Class Description</a>
<br><a href="#WCPtrHashTableIterXTypeY__WCPtrHashTableIterLR">WCPtrHashTableIter() &#91;WCPtrHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrOrderedVectorXTypeY__WCPtrOrderedVectorLR">WCPtrOrderedVector() &#91;WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__WCPtrSkipListLR">WCPtrSkipList() &#91;WCPtrSkipList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY__WCPtrSkipListSetXTypeY_Class_Description">WCPtrSkipList&lt;Type&gt;, WCPtrSkipListSet&lt;Type&gt; Class Description</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY__WCPtrSkipListDictLR">WCPtrSkipListDict() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY_Class_Description">WCPtrSkipListDict&lt;Key,Value&gt; Class Description</a>
<br><a href="#WCPtrSkipListSetXTypeY__WCPtrSkipListSetLR">WCPtrSkipListSet() &#91;WCPtrSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__WCPtrSListLR">WCPtrSList() &#91;WCPtrSList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY__WCPtrDListXTypeY_Class_Description">WCPtrSList&lt;Type&gt;, WCPtrDList&lt;Type&gt; Class Description</a>
<br><a href="#WCPtrSListIterXTypeY__WCPtrSListIterLR">WCPtrSListIter() &#91;WCPtrSListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListIterXTypeY__WCPtrDListIterXTypeY_Class_Description">WCPtrSListIter&lt;Type&gt;, WCPtrDListIter&lt;Type&gt; Class Description</a>
<br><a href="#WCPtrSortedVectorXTypeY__WCPtrSortedVectorLR">WCPtrSortedVector() &#91;WCPtrSortedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY__WCPtrOrderedVectorXTypeY_Class_Description">WCPtrSortedVector&lt;Type&gt;, WCPtrOrderedVector&lt;Type&gt; Class Description</a>
<br><a href="#WCPtrVectorXTypeY__WCPtrVectorLR">WCPtrVector() &#91;WCPtrVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrVectorXTypeY_Class_Description">WCPtrVector&lt;Type&gt; Class Description</a>
<br><a href="#WCQueueXType_FTypeY__WCQueueLR">WCQueue() &#91;WCQueue&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCQueueXType_FTypeY_Class_Description">WCQueue&lt;Type,FType&gt; Class Description</a>
<br><a href="#WCSLink_Class_Description">WCSLink Class Description</a>
<br><a href="#WCSLink__WCSLinkLR">WCSLink() &#91;WCSLink&#93;</a>
<br><a href="#WCStackXType_FTypeY__WCStackLR">WCStack() &#91;WCStack&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCStackXType_FTypeY_Class_Description">WCStack&lt;Type,FType&gt; Class Description</a>
<br><a href="#WCValConstDListIterXTypeY__WCValConstDListIterLR">WCValConstDListIter() &#91;WCValConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValConstSListIterXTypeY__WCValConstSListIterLR">WCValConstSListIter() &#91;WCValConstSListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValConstSListIterXTypeY__WCValConstDListIterXTypeY_Class_Description">WCValConstSListIter&lt;Type&gt;, WCValConstDListIter&lt;Type&gt; Class Description</a>
<br><a href="#WCValDListXTypeY__WCValDListLR">WCValDList() &#91;WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValDListIterXTypeY__WCValDListIterLR">WCValDListIter() &#91;WCValDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY__WCValHashDictLR">WCValHashDict() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY_Class_Description">WCValHashDict&lt;Key,Value&gt; Class Description</a>
<br><a href="#WCValHashDictIterXKey_ValueY__WCValHashDictIterLR">WCValHashDictIter() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashDictIterXKey_ValueY_Class_Description">WCValHashDictIter&lt;Key,Value&gt; Class Description</a>
<br><a href="#WCValHashSetXTypeY__WCValHashSetLR">WCValHashSet() &#91;WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashSetIterXTypeY__WCValHashSetIterLR">WCValHashSetIter() &#91;WCValHashSetIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashSetIterXTypeY__WCValHashTableIterXTypeY_Class_Description">WCValHashSetIter&lt;Type&gt;, WCValHashTableIter&lt;Type&gt; Class Description</a>
<br><a href="#WCValHashTableXTypeY__WCValHashTableLR">WCValHashTable() &#91;WCValHashTable&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY__WCValHashSetXTypeY_Class_Description">WCValHashTable&lt;Type&gt;, WCValHashSet&lt;Type&gt; Class Description</a>
<br><a href="#WCValHashTableIterXTypeY__WCValHashTableIterLR">WCValHashTableIter() &#91;WCValHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValOrderedVectorXTypeY__WCValOrderedVectorLR">WCValOrderedVector() &#91;WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__WCValSkipListLR">WCValSkipList() &#91;WCValSkipList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY__WCValSkipListSetXTypeY_Class_Description">WCValSkipList&lt;Type&gt;, WCValSkipListSet&lt;Type&gt; Class Description</a>
<br><a href="#WCValSkipListDictXKey_ValueY__WCValSkipListDictLR">WCValSkipListDict() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY_Class_Description">WCValSkipListDict&lt;Key,Value&gt; Class Description</a>
<br><a href="#WCValSkipListSetXTypeY__WCValSkipListSetLR">WCValSkipListSet() &#91;WCValSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__WCValSListLR">WCValSList() &#91;WCValSList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListXTypeY__WCValDListXTypeY_Class_Description">WCValSList&lt;Type&gt;, WCValDList&lt;Type&gt; Class Description</a>
<br><a href="#WCValSListIterXTypeY__WCValSListIterLR">WCValSListIter() &#91;WCValSListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListIterXTypeY__WCValDListIterXTypeY_Class_Description">WCValSListIter&lt;Type&gt;, WCValDListIter&lt;Type&gt; Class Description</a>
<br><a href="#WCValSortedVectorXTypeY__WCValSortedVectorLR">WCValSortedVector() &#91;WCValSortedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY__WCValOrderedVectorXTypeY_Class_Description">WCValSortedVector&lt;Type&gt;, WCValOrderedVector&lt;Type&gt; Class Description</a>
<br><a href="#WCValVectorXTypeY__WCValVectorLR">WCValVector() &#91;WCValVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValVectorXTypeY_Class_Description">WCValVector&lt;Type&gt; Class Description</a>
<br><a href="#ios__widthLR">width() &#91;ios&#93;</a>
<br><a href="#ostream__writeLR">write() &#91;ostream&#93;</a>
<dt><br>- X -
<dd><a href="#ios__xallocLR">xalloc() &#91;ios&#93;</a>
<dt><br>-&nbsp; -
<dd><a href="#Complex____ComplexLR">Complex() &#91;Complex&#93;</a>
<br><a href="#filebuf____filebufLR">filebuf() &#91;filebuf&#93;</a>
<br><a href="#fstream____fstreamLR">fstream() &#91;fstream&#93;</a>
<br><a href="#fstreambase____fstreambaseLR">fstreambase() &#91;fstreambase&#93;</a>
<br><a href="#ifstream____ifstreamLR">ifstream() &#91;ifstream&#93;</a>
<br><a href="#ios____iosLR">ios() &#91;ios&#93;</a>
<br><a href="#iostream____iostreamLR">iostream() &#91;iostream&#93;</a>
<br><a href="#istream____istreamLR">istream() &#91;istream&#93;</a>
<br><a href="#istrstream____istrstreamLR">istrstream() &#91;istrstream&#93;</a>
<br><a href="#ofstream____ofstreamLR">ofstream() &#91;ofstream&#93;</a>
<br><a href="#ostream____ostreamLR">ostream() &#91;ostream&#93;</a>
<br><a href="#ostrstream____ostrstreamLR">ostrstream() &#91;ostrstream&#93;</a>
<br><a href="#stdiobuf____stdiobufLR">stdiobuf() &#91;stdiobuf&#93;</a>
<br><a href="#streambuf____streambufLR">streambuf() &#91;streambuf&#93;</a>
<br><a href="#String____StringLR">String() &#91;String&#93;</a>
<br><a href="#strstream____strstreamLR">strstream() &#91;strstream&#93;</a>
<br><a href="#strstreambase____strstreambaseLR">strstreambase() &#91;strstreambase&#93;</a>
<br><a href="#strstreambuf____strstreambufLR">strstreambuf() &#91;strstreambuf&#93;</a>
<br><a href="#WCDLink____WCDLinkLR">WCDLink() &#91;WCDLink&#93;</a>
<br><a href="#WCExcept____WCExceptLR">WCExcept() &#91;WCExcept&#93;</a>
<br><a href="#WCIsvConstDListIterXTypeY____WCIsvConstDListIterLR">WCIsvConstDListIter() &#91;WCIsvConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvConstSListIterXTypeY____WCIsvConstSListIterLR">WCIsvConstSListIter() &#91;WCIsvConstSListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvDListXTypeY____WCIsvDListLR">WCIsvDList() &#91;WCIsvDList&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvDListIterXTypeY____WCIsvDListIterLR">WCIsvDListIter() &#91;WCIsvDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListXTypeY____WCIsvSListLR">WCIsvSList() &#91;WCIsvSList&lt;Type&gt;&#93;</a>
<br><a href="#WCIsvSListIterXTypeY____WCIsvSListIterLR">WCIsvSListIter() &#91;WCIsvSListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCIterExcept____WCIterExceptLR">WCIterExcept() &#91;WCIterExcept&#93;</a>
<br><a href="#WCPtrConstDListIterXTypeY____WCPtrConstDListIterLR">WCPtrConstDListIter() &#91;WCPtrConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrConstSListIterXTypeY____WCPtrConstSListIterLR">WCPtrConstSListIter() &#91;WCPtrConstSListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrDListXTypeY____WCPtrDListLR">WCPtrDList() &#91;WCPtrDList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrDListIterXTypeY____WCPtrDListIterLR">WCPtrDListIter() &#91;WCPtrDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashDictXKey_ValueY____WCPtrHashDictLR">WCPtrHashDict() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashDictIterXKey_ValueY____WCPtrHashDictIterLR">WCPtrHashDictIter() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrHashSetXTypeY____WCPtrHashSetLR">WCPtrHashSet() &#91;WCPtrHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashSetIterXTypeY____WCPtrHashSetIterLR">WCPtrHashSetIter() &#91;WCPtrHashSetIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashTableXTypeY____WCPtrHashTableLR">WCPtrHashTable() &#91;WCPtrHashTable&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrHashTableIterXTypeY____WCPtrHashTableIterLR">WCPtrHashTableIter() &#91;WCPtrHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrOrderedVectorXTypeY____WCPtrOrderedVectorLR">WCPtrOrderedVector() &#91;WCPtrOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListXTypeY____WCPtrSkipListLR">WCPtrSkipList() &#91;WCPtrSkipList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSkipListDictXKey_ValueY____WCPtrSkipListDictLR">WCPtrSkipListDict() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCPtrSkipListSetXTypeY____WCPtrSkipListSetLR">WCPtrSkipListSet() &#91;WCPtrSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListXTypeY____WCPtrSListLR">WCPtrSList() &#91;WCPtrSList&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSListIterXTypeY____WCPtrSListIterLR">WCPtrSListIter() &#91;WCPtrSListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrSortedVectorXTypeY____WCPtrSortedVectorLR">WCPtrSortedVector() &#91;WCPtrSortedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCPtrVectorXTypeY____WCPtrVectorLR">WCPtrVector() &#91;WCPtrVector&lt;Type&gt;&#93;</a>
<br><a href="#WCQueueXType_FTypeY____WCQueueLR">WCQueue() &#91;WCQueue&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCSLink____WCSLinkLR">WCSLink() &#91;WCSLink&#93;</a>
<br><a href="#WCStackXType_FTypeY____WCStackLR">WCStack() &#91;WCStack&lt;Type,FType&gt;&#93;</a>
<br><a href="#WCValConstDListIterXTypeY____WCValConstDListIterLR">WCValConstDListIter() &#91;WCValConstDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValConstSListIterXTypeY____WCValConstSListIterLR">WCValConstSListIter() &#91;WCValConstSListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValDListXTypeY____WCValDListLR">WCValDList() &#91;WCValDList&lt;Type&gt;&#93;</a>
<br><a href="#WCValDListIterXTypeY____WCValDListIterLR">WCValDListIter() &#91;WCValDListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashDictXKey_ValueY____WCValHashDictLR">WCValHashDict() &#91;WCValHashDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashDictIterXKey_ValueY____WCValHashDictIterLR">WCValHashDictIter() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValHashSetXTypeY____WCValHashSetLR">WCValHashSet() &#91;WCValHashSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashSetIterXTypeY____WCValHashSetIterLR">WCValHashSetIter() &#91;WCValHashSetIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashTableXTypeY____WCValHashTableLR">WCValHashTable() &#91;WCValHashTable&lt;Type&gt;&#93;</a>
<br><a href="#WCValHashTableIterXTypeY____WCValHashTableIterLR">WCValHashTableIter() &#91;WCValHashTableIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValOrderedVectorXTypeY____WCValOrderedVectorLR">WCValOrderedVector() &#91;WCValOrderedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListXTypeY____WCValSkipListLR">WCValSkipList() &#91;WCValSkipList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSkipListDictXKey_ValueY____WCValSkipListDictLR">WCValSkipListDict() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93;</a>
<br><a href="#WCValSkipListSetXTypeY____WCValSkipListSetLR">WCValSkipListSet() &#91;WCValSkipListSet&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListXTypeY____WCValSListLR">WCValSList() &#91;WCValSList&lt;Type&gt;&#93;</a>
<br><a href="#WCValSListIterXTypeY____WCValSListIterLR">WCValSListIter() &#91;WCValSListIter&lt;Type&gt;&#93;</a>
<br><a href="#WCValSortedVectorXTypeY____WCValSortedVectorLR">WCValSortedVector() &#91;WCValSortedVector&lt;Type&gt;&#93;</a>
<br><a href="#WCValVectorXTypeY____WCValVectorLR">WCValVector() &#91;WCValVector&lt;Type&gt;&#93;</a>
</dl>
<h1 id="Header_Files"> Header Files </h1>
<br>The following header files are supplied with the Open Watcom C++ library.&nbsp; When a class or function from the library
 is used in a source file the related header file should be included in that source file.&nbsp; The header files can be included
 multiple times and in any order with no ill effect.
<br><br>The facilities of the C standard library can be used in C++ programs by including the appropriate &quot;cname&quot;
 header.&nbsp; In that case all of the C standard library functions are in namespace<tt> std.</tt>&nbsp; For example, to use
 function<tt> std::printf</tt> one should include the header cstdio.&nbsp; Note that the cname headers declare in the global
 namespace any non-standard names they contain as extensions.&nbsp; It is also possible to include in a C++ program the same
 headers used by C programs.&nbsp; In that case, the standard functions are in both the global namespace as well as in namespace<tt>
 std.</tt>
<br><br>Some of C++ standard library headers described below come in a form with a .h extension and in a form without an extension.
&nbsp; The extensionless headers declare their library classes and functions in namespace<tt> std.</tt>&nbsp; The headers
 with a .h extension declare their library classes and functions in both the global namespace and in namespace<tt> std.</tt>
&nbsp; Such headers are provided as a convenience and for compatibility with legacy code.&nbsp; Programs that intend to conform
 to Standard C++ should use the extensionless headers to access the facilities of the C++ standard library.
<br><br>Certain headers defined by Standard C++ have names that are longer than the 8.3 limit imposed by the FAT16 filesystem.
&nbsp; Such headers are provided with names that are truncated to eight characters so they can be used with the DOS host.
&nbsp; However, one can still refer to them in #include directives using their full names as defined by the standard.&nbsp;
 If the Open Watcom C++ compiler is unable to open a header with the long name, it will truncate the name and try again.
<br><br>The Open Watcom C++ library contains some components that were developed before C++ was standardized.&nbsp; These
 legacy components continue to be supported and are described in this documentation.
<br><br>The header files are all located in the<tt> \WATCOM\H</tt> directory.
<dl>
<dt>algorithm (algorith)
<dd>This header file defines the standard algorithm templates.
<dt><br>complex
<dd>This header file defines the<tt> std::complex</tt> class template and related function templates.&nbsp; This template can
 be instantiated for the three different floating point types.&nbsp; It can be used to represent complex numbers and to perform
 complex arithmetic.
<dt><br>complex.h
<dd>This header file defines the legacy<tt> Complex</tt> class.&nbsp; This class is used to represent complex numbers and to perform
 complex arithmetic.&nbsp; The class defined in this header is not the Standard C++<tt> std::complex</tt> class template.
<dt><br>exception/exception.h (exceptio/exceptio.h)
<dd>This header file defines components to be used with the exception handling mechanism.&nbsp; It defines the base class of the
 standard exception hierarchy.
<dt><br>functional (function)
<dd>This header file defines the standard functional templates.&nbsp; This includes the functors and binders described by Standard
 C++.
<dt><br>fstream/fstream.h
<dd>This header file defines the<tt> filebuf</tt>,<tt> fstreambase</tt>,<tt> ifstream</tt>,<tt> ofstream</tt>, and<tt> fstream</tt>
 classes.&nbsp; These classes are used to perform C++ file input and output operations.&nbsp; The various class members are
 declared and inline member functions for the classes are defined.
<dt><br>generic.h
<dd>This header file is part of the macro support required to implement generic containers prior to the introduction of templates
 in the C++ language.&nbsp; It is retained for backwards compatibility.
<dt><br>iomanip/iomanip.h
<dd>This header file defines the parameterized manipulators.
<dt><br>ios/ios.h
<dd>This header file defines the class<tt> ios</tt> that is used as a base of the other iostream classes.
<dt><br>iosfwd/iosfwd.h
<dd>This header file provides forward declarations of the iostream classes.&nbsp; It should be used in cases where the full class
 definitions are not needed but where one still wants to declare pointers or references to iostream related objects.&nbsp;
 Typically this occurs in a header for another class that wants to provide overloaded inserter or extractor operators.&nbsp;
 By including<tt> iosfwd</tt> instead of<tt> iostream</tt> (for example), compilation speed can be improved because less material
 must be processed by the compiler.
<br>Note that including<tt> iosfwd</tt> is the only appropriate way to forward declare the iostream classes.&nbsp; Manually
 writing forward declarations is not recommended.
<dt><br>iostream/iostream.h
<dd>This header file (indirectly) defines the<tt> ios</tt>,<tt> istream</tt>,<tt> ostream</tt>, and<tt> iostream</tt> classes.
&nbsp; These classes form the basis of the C++ formatted input and output support.&nbsp; The various class members are declared
 and inline member functions for the classes are defined.&nbsp; The<tt> cin</tt>,<tt> cout</tt>,<tt> cerr</tt>, and<tt> clog</tt>
 predefined objects are declared along with the non-parameterized manipulators.
<dt><br>istream/istream.h
<dd>This header file defines class<tt> istream</tt> and class<tt> iostream.</tt>&nbsp; It also defines their associated parameterless
 manipulators.
<dt><br>iterator
<dd>This header file defines several templates to facilitate the handling of iterators.&nbsp; In particular, it defines the<tt>
 std::iterator_traits</tt> template as well as several other supporting iterator related templates.
<dt><br>limits
<dd>This header file defines the<tt> std::numeric_limits</tt> template and provides specializations of that template for each
 of the built-in types.
<br>Note that this header is not directly related to the header limits.h from the C standard library (or to the C++ form of
 that header, climits).
<dt><br>list
<dd>This header file defines the<tt> std::list</tt> class template.&nbsp; It provides a way to make a sequence of objects with
 efficient insert and erase operations.
<dt><br>map
<dd>This header file defines the<tt> std::map</tt> and<tt> std::multimap</tt> class templates.&nbsp; They provide ways to associate
 keys to values.
<dt><br>memory
<dd>This header file defines the default allocator template,<tt> std::allocator,</tt> as well as several function templates for
 manipulating raw (uninitialized) memory regions.&nbsp; In addition this header defines the<tt> std::auto_ptr</tt> template.
<br>Note that the header<tt> memory.h</tt> is part of the Open Watcom C library and is unrelated to<tt> memory.</tt>
<dt><br>new/new.h
<dd>This header file provides declarations to be used with the intrinsic<tt> operator new</tt> and<tt> operator delete</tt> memory
 management functions.
<dt><br>numeric
<dd>This header file defines several standard algorithm templates pertaining to numerical computation.
<dt><br>ostream/ostream.h
<dd>This header file defines class<tt> ostream.</tt>&nbsp; It also defines its associated parameterless manipulators.
<dt><br>set
<dd>This header file defines the<tt> std::set</tt> and<tt> std::multiset</tt> class templates.&nbsp; They provide ways to make
 ordered collections of objects with efficient insert, erase, and find operations.
<dt><br>stdiobuf.h
<dd>This header file defines the<tt> stdiobuf</tt> class which provides the support for the C++ input and output operations to
 standard input, standard output, and standard error streams.
<dt><br>streambuf/streambuf.h (streambu/streambu.h)
<dd>This header file defines the<tt> streambuf</tt> class which provides the support for buffering of input and output operations.
&nbsp; This header file is automatically included by the<tt> iostream.h</tt> header file.
<dt><br>string
<dd>This header file defines the<tt> std::basic_string</tt> class template.&nbsp; It also contains the type definitions for<tt>
 std::string</tt> and<tt> std::wstring.</tt>&nbsp; In addition, this header contains specializations of the<tt> std::char_traits</tt>
 template for both characters and wide characters.
<dt><br>string.hpp
<dd>This header file defines the legacy<tt> String</tt> class.&nbsp; The<tt> String</tt> class is used to manipulate character
 strings.&nbsp; Note that the<tt> hpp</tt> extension is used to avoid colliding with the Standard C<tt> string.h</tt> header
 file.&nbsp; The class defined in this header is not the Standard C++<tt> std::string</tt> class.
<dt><br>strstream.h (strstrea.h)
<dd>This header files defines the<tt> strstreambuf</tt>,<tt> strstreambase</tt>,<tt> istrstream</tt>,<tt> ostrstream</tt>, and<tt>
 strstream</tt> classes.&nbsp; These classes are used to perform C++ in-memory formatting.&nbsp; The various class members
 are declared and inline member functions for the classes are defined.
<dt><br>vector
<dd>This header contains the<tt> std::vector</tt> class template.
<dt><br>wcdefs.h
<dd>This header file contains definitions used by the Open Watcom legacy container libraries.&nbsp; If a container class needs
 any of these definitions, the file is automatically included.
<br>Note that all headers having names that start with &quot;wc&quot; are related to the legacy container libraries.
<dt><br>wclbase.h
<dd>This header file defines the base classes which are used by the list containers.
<dt><br>wclcom.h
<dd>This header file defines the classes which are common to the list containers.
<dt><br>wclibase.h
<dd>This header file defines the base classes which are used by the list iterators.
<dt><br>wclist.h
<dd>This header file defines the<tt> list</tt> container classes.&nbsp; The available list container classes are single and double
 linked versions of intrusive, value and pointer lists.
<dt><br>wclistit.h
<dd>This header file defines the<tt> iterator</tt> classes that correspond to the list containers.
<dt><br>wcqueue.h
<dd>This header file defines the<tt> queue</tt> class.&nbsp; Entries in a queue class are accessed first in, first out.
<dt><br>wcstack.h
<dd>This header file defines the<tt> stack</tt> class.&nbsp; Entries in a stack class are accessed last in, first out.
</dl>
<h1 id="Common_Types"> Common Types </h1>
<br>The set of classes that make up the C++ class library use several common typedefs and macros.&nbsp; They are declared
 in<tt> &lt;iostream.h&gt;</tt> and<tt> &lt;fstream.h&gt;</tt>.
<br><br><tt>typedef long streampos;</tt>
<br><tt>typedef long streamoff;</tt>
<br><tt>typedef int filedesc;</tt>
<br><tt>#define __NOT_EOF 0</tt>
<br><tt>#define EOF -1</tt>
<br><br>The<tt> streampos</tt> type represents an absolute position within the file.&nbsp; For Open Watcom C++, the file position
 can be represented by an integral type.&nbsp; For some file systems, or at a lower level within the file system, the stream
 position might be represented by an aggregate (structure) containing information such as cylinder, track, sector and offset.
<br>The<tt> streamoff</tt> type represents a relative position within the file.&nbsp; The offset can always be represented
 as a signed integer quantity since it is a number of characters before or after an absolute position within the file.
<br><br>The<tt> filedesc</tt> type represents the type of a C library file handle.&nbsp; It is used in places where the I/O
 stream library takes a C library file handle as an argument.
<br><br>The<tt> __NOT_EOF</tt> macro is defined for cases where a function needs to return something other than<tt> EOF</tt>
 to indicate success.
<br><br>The<tt> EOF</tt> macro is defined to be identical to the value provided by the<tt> &lt;stdio.h&gt;</tt> header file.
<h1 id="Predefined_Objects"> Predefined Objects </h1>
<br>Most programs interact in some manner with the keyboard and screen.&nbsp; The C programming language provides three values,<tt>
 stdin</tt>,<tt> stdout</tt> and<tt> stderr</tt>, that are used for communicating with these &quot;standard&quot; devices,
 which are opened before the user program starts execution at<tt> main()</tt>.&nbsp; These three values are<tt> FILE</tt>
 pointers and can be used in virtually any file operation supported by the C library.
<br><br>In a similar manner, C++ provides seven objects for communicating with the same &quot;standard&quot; devices.&nbsp;
 C++ provides the three C<tt> FILE</tt> pointers<tt> stdin</tt>,<tt> stdout</tt> and<tt> stderr</tt>, but they cannot be used
 with the extractors and inserters provided as part of the C++ library.&nbsp; C++ provides four new objects, called<tt> cin</tt>,<tt>
 cout</tt>,<tt> cerr</tt> and<tt> clog</tt>, which correspond to<tt> stdin</tt>,<tt> stdout</tt>,<tt> stderr</tt> and buffered<tt>
 stderr</tt>.
<h2 id="cin"> cin </h2>
<br><tt>cin</tt> is an<tt> istream</tt> object which is connected to &quot;standard input&quot; (usually the keyboard) prior
 to program execution.&nbsp; Values extracted using the<tt> istream operator &gt;&gt;</tt> class extractor operators are read
 from standard input and interpreted according to the type of the object being extracted.
<br><br>Extractions from standard input via<tt> cin</tt> skip whitespace characters by default because the<tt> ios::skipws</tt>
 bit is on.&nbsp; The default behavior can be changed with the<tt> ios::setf</tt> public member function or with the<tt> setiosflags</tt>
 manipulator.
<h2 id="cout"> cout </h2>
<br><tt>cout</tt> is an<tt> ostream</tt> object which is connected to &quot;standard output&quot; (usually the screen) prior
 to program execution.&nbsp; Values inserted using the<tt> ostream operator &lt;&lt;</tt> class inserter operators are converted
 to characters and written to standard output according to the type of the object being inserted.
<br><br>Insertions to standard output via<tt> cout</tt> are buffered by default because the<tt> ios::unitbuf</tt> bit is not
 on.&nbsp; The default behavior can be changed with the<tt> ios::setf</tt> public member function or with the<tt> setiosflags</tt>
 manipulator.
<h2 id="cerr"> cerr </h2>
<br><tt>cerr</tt> is an<tt> ostream</tt> object which is connected to &quot;standard error&quot; (the screen) prior to program
 execution.&nbsp; Values inserted using the<tt> ostream operator &lt;&lt;</tt> class inserter operators are converted to characters
 and written to standard error according to the type of the object being inserted.
<br><br>Insertions to standard error via<tt> cerr</tt> are not buffered by default because the<tt> ios::unitbuf</tt> bit is
 on.&nbsp; The default behavior can be changed with the<tt> ios::setf</tt> public member function or with the<tt> setiosflags</tt>
 manipulator.
<h2 id="clog"> clog </h2>
<br><tt>clog</tt> is an<tt> ostream</tt> object which is connected to &quot;standard error&quot; (the screen) prior to program
 execution.&nbsp; Values inserted using the<tt> ostream operator &lt;&lt;</tt> class inserter operators are converted to characters
 and written to standard error according to the type of the object being inserted.
<br><br>Insertions to standard error via<tt> clog</tt> are buffered by default because the<tt> ios::unitbuf</tt> bit is not
 on.&nbsp; The default behavior can be changed with the<tt> ios::setf</tt> public member function or with the<tt> setiosflags</tt>
 manipulator.
<h1 id="istream_Input"> istream Input </h1>
<br>This chapter describes formatted and unformatted input.
<h2 id="Formatted_Input__Extractors"> Formatted Input:&nbsp; Extractors </h2>
<br>The<tt> operator &gt;&gt;</tt> function is used to read formatted values from a stream.&nbsp; It is called an<b> extractor</b>.
&nbsp; Characters are read and interpreted according to the type of object being extracted.
<br><br>All<tt> operator &gt;&gt;</tt> functions perform the same basic sequence of operations.&nbsp; First, the input prefix
 function<tt> ipfx</tt> is called with a parameter of zero, causing leading whitespace characters to be discarded if<tt> ios::skipws</tt>
 is set in<tt> ios::fmtflags</tt>.&nbsp; If the input prefix function fails and returns zero, the<tt> operator &gt;&gt;</tt>
 function also fails and returns immediately.&nbsp; If the input prefix function succeeds, characters are read from the stream
 and interpreted in terms of the type of object being extracted and<tt> ios::fmtflags</tt>.&nbsp; Finally, the input suffix
 function<tt> isfx</tt> is called.
<br><br>The<tt> operator &gt;&gt;</tt> functions return a reference to the specified stream so that multiple extractions can
 be done in one statement.
<br><br>Errors are indicated via<tt> ios::iostate</tt>.<tt>&nbsp; ios::failbit</tt> is set if the characters read from the
 stream could not be interpreted for the required type.<tt>&nbsp; ios::badbit</tt> is set if the extraction of characters
 from the stream failed in such a way as to make subsequent extractions impossible.<tt>&nbsp; ios::eofbit</tt> is set if the
 stream was located at the end when the extraction was attempted.
<h2 id="Unformatted_Input"> Unformatted Input </h2>
<br>The unformatted input functions are used to read characters from the stream without interpretation.
<br><br>Like the extractors, the unformatted input functions follow a pattern.&nbsp; First, they call<tt> ipfx</tt>, the input
 prefix function, with a parameter of one, causing no leading whitespace characters to be discarded.&nbsp; If the input prefix
 function fails and returns zero, the unformatted input function also fails and returns immediately.&nbsp; If the input prefix
 function succeeds, characters are read from the stream without interpretation.&nbsp; Finally,<tt> isfx</tt>, the input suffix
 function, is called.
<br><br>Errors are indicated via the iostate bits.<tt>&nbsp; ios::failbit</tt> is set if the extraction of characters from
 the stream failed.<tt>&nbsp; ios::eofbit</tt> is set if the stream was located at the end of input when the operation was
 attempted.
<h1 id="ostream_Output"> ostream Output </h1>
<br>This chapter describes formatted and unformatted output.
<h2 id="Formatted_Output__Inserters"> Formatted Output:&nbsp; Inserters </h2>
<br>The<tt> operator &lt;&lt;</tt> function is used to write formatted values to a stream.&nbsp; It is called an<b> inserter</b>.
&nbsp; Values are formatted and written according to the type of object being inserted and<tt> ios::fmtflags</tt>.
<br><br>All<tt> operator &lt;&lt;</tt> functions perform the same basic sequence of operations.&nbsp; First, the output prefix
 function<tt> opfx</tt> is called.&nbsp; If it fails and returns zero, the<tt> operator &lt;&lt;</tt> function also fails
 and returns immediately.&nbsp; If the output prefix function succeeds, the object is formatted according to its type and<tt>
 ios::fmtflags</tt>.&nbsp; The formatted sequence of characters is then written to the specified stream.&nbsp; Finally, the
 output suffix function<tt> osfx</tt> is called.
<br><br>The<tt> operator &lt;&lt;</tt> functions return a reference to the specified stream so that multiple insertions can
 be done in one statement.
<br><br>For details on the interpretation of<tt> ios::fmtflags</tt>, see the<tt> ios::fmtflags</tt> section of the Library
 Functions and Types Chapter.
<br><br>Errors are indicated via<tt> ios::iostate</tt>.<tt>&nbsp; ios::failbit</tt> is set if the<tt> operator &lt;&lt;</tt>
 function fails while writing the characters to the stream.
<h2 id="Unformatted_Output"> Unformatted Output </h2>
<br>The unformatted output functions are used to write characters to the stream without conversion.
<br><br>Like the inserters, the unformatted output functions follow a pattern.&nbsp; First, they call the output prefix function<tt>
 opfx</tt> and fail if it fails.&nbsp; Then the characters are written without conversion.&nbsp; Finally, the output suffix
 function<tt> osfx</tt> is called.
<br><br>Errors are indicated via<tt> ios::iostate</tt>.<tt>&nbsp; ios::failbit</tt> is set if the function fails while writing
 the characters to the stream.
<h1 id="Library_Functions_and_Types"> Library Functions and Types </h1>
<br>Each of the classes and functions in the Class Library is described in this chapter.&nbsp; Each description consists of
 a number of subsections:
<dl>
<dt>Declared:
<dd>This optional subsection specifies which header file contains the declaration for a class.&nbsp; It is only found in sections
 describing class declarations.
<dt><br>Derived From:
<dd>This optional subsection shows the inheritance for a class.&nbsp; It is only found in sections describing class declarations.
<dt><br>Derived By:
<dd>This optional subsection shows which classes inherit from this class.&nbsp; It is only found in sections describing class
 declarations.
<dt><br>Synopsis:
<dd>This subsection gives the name of the header file that contains the declaration of the function.&nbsp; This header file must
 be included in order to reference the function.
<br>For class member functions, the protection associated with the function is indicated via the presence of one of the<tt>
 private</tt>,<tt> protected</tt>, or<tt> public</tt> keywords.
<br><br>The full function prototype is specified.&nbsp; Virtual class member functions are indicated via the presence of the<tt>
 virtual</tt> keyword in the function prototype.
<dt><br>Semantics:
<dd>This subsection is a description of the function.
<dt><br>Derived Implementation Protocol:
<dd>This optional subsection is present for virtual member functions.&nbsp; It describes how derived implementations of the virtual
 member function should behave.
<dt><br>Default Implementation:
<dd>This optional subsection is present for virtual member functions.&nbsp; It describes how the default implementation provided
 with the base class definition behaves.
<dt><br>Results:
<dd>This optional subsection describes the function's return value, if any, and the impact of a member function on its object's
 state.
<dt><br>See Also:
<dd>This optional subsection provides a list of related functions or classes.
</dl>
<h1 id="Complex_Class"> Complex Class </h1>
<br>This class is used for the storage and manipulation of complex numbers, which are often represented by<b> real</b> and<b>
 imaginary</b> components (Cartesian coordinates), or by<b> magnitude</b> and<b> angle</b> (polar coordinates).&nbsp; Each
 object stores exactly one complex number.&nbsp; An object may be used in expressions in the same manner as floating-point
 values.
<br><br>The class documented here is the Open Watcom legacy complex class.&nbsp; It is not the<tt> std::complex</tt> class
 template specified by Standard C++.
<h2 id="Complex_Class_Description"> Complex Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> complex.h</tt>
<br>The<tt> Complex</tt> class is used for the storage and manipulation of complex numbers, which are often represented by<b>
 real</b> and<b> imaginary</b> components (Cartesian coordinates), or by<b> magnitude</b> and<b> angle</b> (polar coordinates).
&nbsp; Each<tt> Complex</tt> object stores exactly one complex number.&nbsp; A<tt> Complex</tt> object may be used in expressions
 in the same manner as floating-point values.
<br><br><b>Public Member Functions</b>
<br><br>The following constructors and destructors are declared:
<br><br><tt>Complex();</tt>
<br><tt> Complex( Complex const &amp; );</tt>
<br><tt> Complex( double, double = 0.0 );</tt>
<br><tt> ~Complex();</tt>
<br><br>The following arithmetic member functions are declared:
<br><br><tt>Complex &amp;operator =( Complex const &amp; );</tt>
<br><tt> Complex &amp;operator =( double );</tt>
<br><tt> Complex &amp;operator +=( Complex const &amp; );</tt>
<br><tt> Complex &amp;operator +=( double );</tt>
<br><tt> Complex &amp;operator -=( Complex const &amp; );</tt>
<br><tt> Complex &amp;operator -=( double );</tt>
<br><tt> Complex &amp;operator *=( Complex const &amp; );</tt>
<br><tt> Complex &amp;operator *=( double );</tt>
<br><tt> Complex &amp;operator /=( Complex const &amp; );</tt>
<br><tt> Complex &amp;operator /=( double );</tt>
<br><tt> Complex operator +() const;</tt>
<br><tt> Complex operator -() const;</tt>
<br><tt> double imag() const;</tt>
<br><tt> double real() const;</tt>
<br><br><b>Friend Functions</b>
<br><br>The following I/O Stream inserter and extractor friend functions are declared:
<br><br><tt>friend istream &amp;operator &gt;&gt;( istream &amp;, Complex &amp; );</tt>
<br><tt>friend ostream &amp;operator &lt;&lt;( ostream &amp;, Complex const &amp; );</tt>
<br><br><b>Related Operators</b>
<br><br>The following operators are declared:
<br><br><tt>Complex operator&nbsp; +( Complex const &amp;, Complex const &amp; );</tt>
<br><tt>Complex operator&nbsp; +( Complex const &amp;, double );</tt>
<br><tt>Complex operator&nbsp; +( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp; );</tt>
<br><tt>Complex operator&nbsp; -( Complex const &amp;, Complex const &amp; );</tt>
<br><tt>Complex operator&nbsp; -( Complex const &amp;, double );</tt>
<br><tt>Complex operator&nbsp; -( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp; );</tt>
<br><tt>Complex operator&nbsp; *( Complex const &amp;, Complex const &amp; );</tt>
<br><tt>Complex operator&nbsp; *( Complex const &amp;, double );</tt>
<br><tt>Complex operator&nbsp; *( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp; );</tt>
<br><tt>Complex operator&nbsp; /( Complex const &amp;, Complex const &amp; );</tt>
<br><tt>Complex operator&nbsp; /( Complex const &amp;, double );</tt>
<br><tt>Complex operator&nbsp; /( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp; );</tt>
<br><tt>int&nbsp;&nbsp;&nbsp;&nbsp; operator ==( Complex const &amp;, Complex const &amp; );</tt>
<br><tt>int&nbsp;&nbsp;&nbsp;&nbsp; operator ==( Complex const &amp;, double );</tt>
<br><tt>int&nbsp;&nbsp;&nbsp;&nbsp; operator ==( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp;
 );</tt>
<br><tt>int&nbsp;&nbsp;&nbsp;&nbsp; operator !=( Complex const &amp;, Complex const &amp; );</tt>
<br><tt>int&nbsp;&nbsp;&nbsp;&nbsp; operator !=( Complex const &amp;, double );</tt>
<br><tt>int&nbsp;&nbsp;&nbsp;&nbsp; operator !=( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp;
 );</tt>
<br><br><b>Related Functions</b>
<br><br>The following related functions are declared:
<br><br><tt>double&nbsp; abs&nbsp; ( Complex const &amp; );</tt>
<br><tt>Complex acos ( Complex const &amp; );</tt>
<br><tt>Complex acosh( Complex const &amp; );</tt>
<br><tt>double&nbsp; arg&nbsp; ( Complex const &amp; );</tt>
<br><tt>Complex asin ( Complex const &amp; );</tt>
<br><tt>Complex asinh( Complex const &amp; );</tt>
<br><tt>Complex atan ( Complex const &amp; );</tt>
<br><tt>Complex atanh( Complex const &amp; );</tt>
<br><tt>Complex conj ( Complex const &amp; );</tt>
<br><tt>Complex cos&nbsp; ( Complex const &amp; );</tt>
<br><tt>Complex cosh ( Complex const &amp; );</tt>
<br><tt>Complex exp&nbsp; ( Complex const &amp; );</tt>
<br><tt>double&nbsp; imag ( Complex const &amp; );</tt>
<br><tt>Complex log&nbsp; ( Complex const &amp; );</tt>
<br><tt>Complex log10( Complex const &amp; );</tt>
<br><tt>double&nbsp; norm ( Complex const &amp; );</tt>
<br><tt>Complex polar( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , double = 0 );</tt>
<br><tt>Complex pow&nbsp; ( Complex const &amp;, Complex const &amp; );</tt>
<br><tt>Complex pow&nbsp; ( Complex const &amp;, double );</tt>
<br><tt>Complex pow&nbsp; ( double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , Complex const &amp; );</tt>
<br><tt>Complex pow&nbsp; ( Complex const &amp;, int );</tt>
<br><tt>double&nbsp; real ( Complex const &amp; );</tt>
<br><tt>Complex sin&nbsp; ( Complex const &amp; );</tt>
<br><tt>Complex sinh ( Complex const &amp; );</tt>
<br><tt>Complex sqrt ( Complex const &amp; );</tt>
<br><tt>Complex tan&nbsp; ( Complex const &amp; );</tt>
<br><tt>Complex tanh ( Complex const &amp; );</tt>
</dl>
<h2 id="Complex_absLR"> Complex abs() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>double abs( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> abs</tt> function computes the magnitude of<b> num</b>, which is equivalent to the length (magnitude) of the vector
 when the<b> num</b> is represented in polar coordinates.
<dt><br>Results:
<dd>The<tt> abs</tt> function returns the magnitude of<b> num</b>.
<dt><br>See Also:
<dd><tt> arg</tt>,<tt> norm</tt>,<tt> polar</tt>
</dl>
<h2 id="Complex_acosLR"> Complex acos() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex acos( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> acos</tt> function computes the arccosine of<b> num</b>.
<dt><br>Results:
<dd>The<tt> acos</tt> function returns the arccosine of<b> num</b>.
<dt><br>See Also:
<dd><tt> asin</tt>,<tt> atan</tt>,<tt> cos</tt>
</dl>
<h2 id="Complex_acoshLR"> Complex acosh() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex acosh( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> acosh</tt> function computes the inverse hyperbolic cosine of<b> num</b>.
<dt><br>Results:
<dd>The<tt> acosh</tt> function returns the inverse hyperbolic cosine of<b> num</b>.
<dt><br>See Also:
<dd><tt> asinh</tt>,<tt> atanh</tt>,<tt> cosh</tt>
</dl>
<h2 id="Complex_argLR"> Complex arg() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>double arg( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> arg</tt> function computes the angle of the vector when the<b> num</b> is represented in polar coordinates.&nbsp;
 The angle has the same sign as the real component of the<b> num</b>.&nbsp; It is positive in the 1st and 2nd quadrants, and
 negative in the 3rd and 4th quadrants.
<dt><br>Results:
<dd>The<tt> arg</tt> function returns the angle of the vector when the<b> num</b> is represented in polar coordinates.
<dt><br>See Also:
<dd><tt> abs</tt>,<tt> norm</tt>,<tt> polar</tt>
</dl>
<h2 id="Complex_asinLR"> Complex asin() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex asin( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> asin</tt> function computes the arcsine of<b> num</b>.
<dt><br>Results:
<dd>The<tt> asin</tt> function returns the arcsine of<b> num</b>.
<dt><br>See Also:
<dd><tt> acos</tt>,<tt> atan</tt>,<tt> sin</tt>
</dl>
<h2 id="Complex_asinhLR"> Complex asinh() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex asinh( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> asinh</tt> function computes the inverse hyperbolic sine of<b> num</b>.
<dt><br>Results:
<dd>The<tt> asinh</tt> function returns the inverse hyperbolic sine of<b> num</b>.
<dt><br>See Also:
<dd><tt> acosh</tt>,<tt> atanh</tt>,<tt> sinh</tt>
</dl>
<h2 id="Complex_atanLR"> Complex atan() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex atan( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> atan</tt> function computes the arctangent of<b> num</b>.
<dt><br>Results:
<dd>The<tt> atan</tt> function returns the arctangent of<b> num</b>.
<dt><br>See Also:
<dd><tt> acos</tt>,<tt> asin</tt>,<tt> tan</tt>
</dl>
<h2 id="Complex_atanhLR"> Complex atanh() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex atanh( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> atanh</tt> function computes the inverse hyperbolic tangent of<b> num</b>.
<dt><br>Results:
<dd>The<tt> atanh</tt> function returns the inverse hyperbolic tangent of<b> num</b>.
<dt><br>See Also:
<dd><tt> acosh</tt>,<tt> asinh</tt>,<tt> tanh</tt>
</dl>
<h2 id="Complex__ComplexLR"> Complex() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Complex::Complex();</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> Complex</tt> constructor creates a default<tt> Complex</tt> object with value zero for both the
 real and imaginary components.
<dt><br>Results:
<dd>This form of the public<tt> Complex</tt> constructor produces a default<tt> Complex</tt> object.
<dt><br>See Also:
<dd><tt> ~Complex</tt>,<tt> real</tt>,<tt> imag</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Complex::Complex( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> Complex</tt> constructor creates a<tt> Complex</tt> object with the same value as<b> num</b>.
<dt><br>Results:
<dd>This form of the public<tt> Complex</tt> constructor produces a<tt> Complex</tt> object.
<dt><br>See Also:
<dd><tt> ~Complex</tt>,<tt> real</tt>,<tt> imag</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Complex::Complex( double real, double imag = 0.0 );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> Complex</tt> constructor creates a<tt> Complex</tt> object with the real component set to<b> real</b>
 and the imaginary component set to<b> imag</b>.&nbsp; If no imaginary component is specified,<b> imag</b> takes the default
 value of zero.
<dt><br>Results:
<dd>This form of the public<tt> Complex</tt> constructor produces a<tt> Complex</tt> object.
<dt><br>See Also:
<dd><tt> ~Complex</tt>,<tt> real</tt>,<tt> imag</tt>
</dl>
<h2 id="Complex____ComplexLR"> ~Complex() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Complex::~Complex();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~Complex</tt> destructor destroys the<tt> Complex</tt> object.&nbsp; The call to the public<tt> ~Complex</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> Complex</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> Complex</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> Complex</tt>
</dl>
<h2 id="Complex_conjLR"> Complex conj() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex conj( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> conj</tt> function computes the conjugate of<b> num</b>.&nbsp; The conjugate consists of the unchanged real component,
 and the negative of the imaginary component.
<dt><br>Results:
<dd>The<tt> conj</tt> function returns the conjugate of<b> num</b>.
</dl>
<h2 id="Complex_cosLR"> Complex cos() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex cos( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> cos</tt> function computes the cosine of<b> num</b>.
<dt><br>Results:
<dd>The<tt> cos</tt> function returns the cosine of<b> num</b>.
<dt><br>See Also:
<dd><tt> acos</tt>,<tt> sin</tt>,<tt> tan</tt>
</dl>
<h2 id="Complex_coshLR"> Complex cosh() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex cosh( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> cosh</tt> function computes the hyperbolic cosine of<b> num</b>.
<dt><br>Results:
<dd>The<tt> cosh</tt> function returns the hyperbolic cosine of<b> num</b>.
<dt><br>See Also:
<dd><tt> acosh</tt>,<tt> sinh</tt>,<tt> tanh</tt>
</dl>
<h2 id="Complex_expLR"> Complex exp() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex exp( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> exp</tt> function computes the value of<b> e</b> raised to the power<b> num</b>.
<dt><br>Results:
<dd>The<tt> exp</tt> function returns the value of<b> e</b> raised to the power<b> num</b>.
<dt><br>See Also:
<dd><tt> log</tt>,<tt> log10</tt>,<tt> pow</tt>,<tt> sqrt</tt>
</dl>
<h2 id="Complex__imagLR"> imag() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>double Complex::imag();</tt>
<dt><br>Semantics:
<dd>The<tt> imag</tt> public member function extracts the imaginary component of the<tt> Complex</tt> object.
<dt><br>Results:
<dd>The<tt> imag</tt> public member function returns the imaginary component of the<tt> Complex</tt> object.
<dt><br>See Also:
<dd><tt> imag</tt>,<tt> real</tt>
<br><tt>Complex::real</tt>
</dl>
<h2 id="Complex_imagLR"> Complex imag() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>double imag( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> imag</tt> function extracts the imaginary component of<b> num</b>.
<dt><br>Results:
<dd>The<tt> imag</tt> function returns the imaginary component of<b> num</b>.
<dt><br>See Also:
<dd><tt> real</tt>
<br><tt>Complex::imag</tt>,<tt> real</tt>
</dl>
<h2 id="Complex_logLR"> Complex log() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex log( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> log</tt> function computes the natural, or base<b> e</b>, logarithm of<b> num</b>.
<dt><br>Results:
<dd>The<tt> log</tt> function returns the natural, or base<b> e</b>, logarithm of<b> num</b>.
<dt><br>See Also:
<dd><tt> exp</tt>,<tt> log10</tt>,<tt> pow</tt>,<tt> sqrt</tt>
</dl>
<h2 id="Complex_log10LR"> Complex log10() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex log10( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> log10</tt> function computes the base 10 logarithm of<b> num</b>.
<dt><br>Results:
<dd>The<tt> log10</tt> function returns the base 10 logarithm of<b> num</b>.
<dt><br>See Also:
<dd><tt> exp</tt>,<tt> log</tt>,<tt> pow</tt>,<tt> sqrt</tt>
</dl>
<h2 id="Complex_normLR"> Complex norm() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>double norm( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> norm</tt> function computes the square of the magnitude of<b> num</b>, which is equivalent to the square of the length
 (magnitude) of the vector when<b> num</b> is represented in polar coordinates.
<dt><br>Results:
<dd>The<tt> norm</tt> function returns the square of the magnitude of<b> num</b>.
<dt><br>See Also:
<dd><tt> arg</tt>,<tt> polar</tt>
</dl>
<h2 id="Complex_operator__ELR"> Complex operator !=() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>int operator !=( Complex const &amp;num1, Complex const &amp;num2 );</tt>
<br><tt>int operator !=( Complex const &amp;num1, double num2 );</tt>
<br><tt>int operator !=( double num1, Complex const &amp;num2 );</tt>
<dt><br>Semantics:
<dd>The<tt> operator !=</tt> function compares<b> num1</b> and<b> num2</b> for inequality.&nbsp; At least one of the parameters
 must be a<tt> Complex</tt> object for this function to be called.
<br>Two<tt> Complex</tt> objects are not equal if either of their corresponding real or imaginary components are not equal.
<br><br>If the<tt> operator !=</tt> function is used with a<tt> Complex</tt> object and an object of any other built-in numeric
 type, the non-<tt> Complex</tt> object is converted to a<tt> double</tt> and the second or third form of the<tt> operator
 !=</tt> function is used.
<dt><br>Results:
<dd>The<tt> operator !=</tt> function returns a non-zero value if<b> num1</b> is not equal to<b> num2</b>, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> operator ==</tt>
</dl>
<h2 id="Complex_operator_TLR"> Complex operator *() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex operator *( Complex const &amp;num1, Complex const &amp;num2 );</tt>
<br><tt>Complex operator *( Complex const &amp;num1, double num2 );</tt>
<br><tt>Complex operator *( double num1, Complex const &amp;num2 );</tt>
<dt><br>Semantics:
<dd>The<tt> operator *</tt> function is used to multiply<b> num1</b> by<b> num2</b> yielding a<tt> Complex</tt> object.
<br>The first<tt> operator *</tt> function multiplies two<tt> Complex</tt> objects.
<br><br>The second<tt> operator *</tt> function multiplies a<tt> Complex</tt> object and a floating-point value.&nbsp; In
 effect, the real and imaginary components of the<tt> Complex</tt> object are multiplied by the floating-point value.
<br><br>The third<tt> operator *</tt> function multiplies a floating-point value and a<tt> Complex</tt> object.&nbsp; In effect,
 the real and imaginary components of the<tt> Complex</tt> object are multiplied by the floating-point value.
<br><br>If the<tt> operator *</tt> function is used with a<tt> Complex</tt> object and an object of any other built-in numeric
 type, the non-<tt> Complex</tt> object is converted to a<tt> double</tt> and the second or third form of the<tt> operator
 *</tt> function is used.
<dt><br>Results:
<dd>The<tt> operator *</tt> function returns a<tt> Complex</tt> object that is the product of<b> num1</b> and<b> num2</b>.
<dt><br>See Also:
<dd><tt> operator +</tt>,<tt> operator -</tt>,<tt> operator /</tt>
<br><tt>Complex::operator *=</tt>
</dl>
<h2 id="Complex__operator_TELR"> operator *=() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Complex &amp;Complex::operator *=( Complex const &amp;num );</tt>
<br><tt> Complex &amp;Complex::operator *=( double num );</tt>
<dt><br>Semantics:
<dd>The<tt> operator *=</tt> public member function is used to multiply the<b> num</b> argument into the<tt> Complex</tt> object.
<br>The first form of the<tt> operator *=</tt> public member function multiplies the<tt> Complex</tt> object by the<tt> Complex</tt>
 parameter.
<br><br>The second form of the<tt> operator *=</tt> public member function multiplies the real and imaginary components of
 the<tt> Complex</tt> object by<b> num</b>.
<br><br>A call to the<tt> operator *=</tt> public member function where<b> num</b> is any of the other built-in numeric types,
 causes<b> num</b> to be promoted to<tt> double</tt> and the second form of the<tt> operator *=</tt> public member function
 to be used.
<dt><br>Results:
<dd>The<tt> operator *=</tt> public member function returns a reference to the target of the assignment.
<dt><br>See Also:
<dd><tt> operator *</tt>
<br><tt>Complex::operator +=</tt>,<tt> operator -=</tt>,<tt> operator /=</tt>,<tt> operator =</tt>
</dl>
<h2 id="Complex__operator_PLR"> operator +() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Complex Complex::operator +();</tt>
<dt><br>Semantics:
<dd>The unary<tt> operator +</tt> public member function is provided for completeness.&nbsp; It performs no operation on the<tt>
 Complex</tt> object.
<dt><br>Results:
<dd>The unary<tt> operator +</tt> public member function returns a<tt> Complex</tt> object with the same value as the original<tt>
 Complex</tt> object.
<dt><br>See Also:
<dd><tt> operator +</tt>
<br><tt>Complex::operator +=</tt>,<tt> operator -</tt>
</dl>
<h2 id="Complex_operator_PLR"> Complex operator +() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex operator +( Complex const &amp;num1, Complex const &amp;num2 );</tt>
<br><tt>Complex operator +( Complex const &amp;num1, double num2 );</tt>
<br><tt>Complex operator +( double num1, Complex const &amp;num2 );</tt>
<dt><br>Semantics:
<dd>The<tt> operator +</tt> function is used to add<b> num1</b> to<b> num2</b> yielding a<tt> Complex</tt> object.
<br>The first<tt> operator +</tt> function adds two<tt> Complex</tt> objects.
<br><br>The second<tt> operator +</tt> function adds a<tt> Complex</tt> object and a floating-point value.&nbsp; In effect,
 the floating-point value is added to the real component of the<tt> Complex</tt> object.
<br><br>The third<tt> operator +</tt> function adds a floating-point value and a<tt> Complex</tt> object.&nbsp; In effect,
 the floating-point value is added to the real component of the<tt> Complex</tt> object.
<br><br>If the<tt> operator +</tt> function is used with a<tt> Complex</tt> object and an object of any other built-in numeric
 type, the non-<tt> Complex</tt> object is converted to a<tt> double</tt> and the second or third form of the<tt> operator
 +</tt> function is used.
<dt><br>Results:
<dd>The<tt> operator +</tt> function returns a<tt> Complex</tt> object that is the sum of<b> num1</b> and<b> num2</b>.
<dt><br>See Also:
<dd><tt> operator *</tt>,<tt> operator -</tt>,<tt> operator /</tt>
<br><tt>Complex::operator +</tt>,<tt> operator +=</tt>
</dl>
<h2 id="Complex__operator_PELR"> operator +=() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Complex &amp;Complex::operator +=( Complex const &amp;num );</tt>
<br><tt> Complex &amp;Complex::operator +=( double num );</tt>
<dt><br>Semantics:
<dd>The<tt> operator +=</tt> public member function is used to add<b> num</b> to the value of the<tt> Complex</tt> object.&nbsp;
 The second form of the<tt> operator +=</tt> public member function adds<b> num</b> to the real component of the<tt> Complex</tt>
 object.
<br>A call to the<tt> operator +=</tt> public member function where<b> num</b> is any of the other built-in numeric types,
 causes<b> num</b> to be promoted to<tt> double</tt> and the second form of the<tt> operator +=</tt> public member function
 to be used.
<dt><br>Results:
<dd>The<tt> operator +=</tt> public member function returns a reference to the target of the assignment.
<dt><br>See Also:
<dd><tt> operator +</tt>
<br><tt>Complex::operator *=</tt>,<tt> operator +</tt>,<tt> operator /=</tt>,<tt> operator -=</tt>,<tt> operator =</tt>
</dl>
<h2 id="Complex__operator_MLR"> operator -() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Complex Complex::operator -();</tt>
<dt><br>Semantics:
<dd>The unary<tt> operator -</tt> public member function yields a<tt> Complex</tt> object with the real and imaginary components
 having the same magnitude as those of the original object, but with opposite sign.
<dt><br>Results:
<dd>The unary<tt> operator -</tt> public member function returns a<tt> Complex</tt> object with the same magnitude as the original<tt>
 Complex</tt> object and with opposite sign.
<dt><br>See Also:
<dd><tt> operator -</tt>
<br><tt>Complex::operator +</tt>,<tt> operator -=</tt>
</dl>
<h2 id="Complex_operator_MLR"> Complex operator -() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex operator -( Complex const &amp;num1, Complex const &amp;num2 );</tt>
<br><tt>Complex operator -( Complex const &amp;num1, double num2 );</tt>
<br><tt>Complex operator -( double num1, Complex const &amp;num2 );</tt>
<dt><br>Semantics:
<dd>The<tt> operator -</tt> function is used to subtract<b> num2</b> from<b> num1</b> yielding a<tt> Complex</tt> object.
<br>The first<tt> operator -</tt> function computes the difference between two<tt> Complex</tt> objects.
<br><br>The second<tt> operator -</tt> function computes the difference between a<tt> Complex</tt> object and a floating-point
 value.&nbsp; In effect, the floating-point value is subtracted from the real component of the<tt> Complex</tt> object.
<br><br>The third<tt> operator -</tt> function computes the difference between a floating-point value and a<tt> Complex</tt>
 object.&nbsp; In effect, the real component of the result is<b> num1</b> minus the real component of<b> num2</b> :CONT, and
 the imaginary component of the result is the negative of the imaginary component of<b> num2</b>.
<br><br>If the<tt> operator -</tt> function is used with a<tt> Complex</tt> object and an object of any other built-in numeric
 type, the non-<tt> Complex</tt> object is converted to a<tt> double</tt> and the second or third form of the<tt> operator
 -</tt> function is used.
<dt><br>Results:
<dd>The<tt> operator -</tt> function returns a<tt> Complex</tt> object that is the difference between<b> num1</b> and<b> num2</b>.
<dt><br>See Also:
<dd><tt> operator *</tt>,<tt> operator +</tt>,<tt> operator /</tt>
<br><tt>Complex::operator -</tt>,<tt> operator -=</tt>
</dl>
<h2 id="Complex__operator_MELR"> operator -=() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Complex &amp;Complex::operator -=( Complex const &amp;num );</tt>
<br><tt> Complex &amp;Complex::operator -=( double num );</tt>
<dt><br>Semantics:
<dd>The<tt> operator -=</tt> public member function is used to subtract<b> num</b> from the value of the<tt> Complex</tt> object.
&nbsp; The second form of the<tt> operator -=</tt> public member function subtracts<b> num</b> from the real component of
 the *obj..
<br>A call to the<tt> operator -=</tt> public member function where<b> num</b> is any of the other built-in numeric types,
 causes<b> num</b> to be promoted to<tt> double</tt> and the second form of the<tt> operator -=</tt> public member function
 to be used.
<dt><br>Results:
<dd>The<tt> operator -=</tt> public member function returns a reference to the target of the assignment.
<dt><br>See Also:
<dd><tt> operator -</tt>
<br><tt>Complex::operator *=</tt>,<tt> operator +=</tt>,<tt> operator -</tt>,<tt> operator /=</tt>,<tt> operator =</tt>
</dl>
<h2 id="Complex_operator_DLR"> Complex operator /() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex operator /( Complex const &amp;num1, Complex const &amp;num2 );</tt>
<br><tt>Complex operator /( Complex const &amp;num1, double num2 );</tt>
<br><tt>Complex operator /( double num1, Complex const &amp;num2 );</tt>
<dt><br>Semantics:
<dd>The<tt> operator /</tt> function is used to divide<b> num1</b> by<b> num2</b> yielding a<tt> Complex</tt> object.
<br>The first<tt> operator /</tt> function divides two<tt> Complex</tt> objects.
<br><br>The second<tt> operator /</tt> function divides a<tt> Complex</tt> object by a floating-point value.&nbsp; In effect,
 the real and imaginary components of the complex number are divided by the floating-point value.
<br><br>The third<tt> operator /</tt> function divides a floating-point value by a<tt> Complex</tt> object.&nbsp; Conceptually,
 the floating-point value is converted to a<tt> Complex</tt> object and then the division is done.
<br><br>If the<tt> operator /</tt> function is used with a<tt> Complex</tt> object and an object of any other built-in numeric
 type, the non-<tt> Complex</tt> object is converted to a<tt> double</tt> and the second or third form of the<tt> operator
 /</tt> function is used.
<dt><br>Results:
<dd>The<tt> operator /</tt> function returns a<tt> Complex</tt> object that is the quotient of<b> num1</b> divided by<b> num2</b>.
<dt><br>See Also:
<dd><tt> operator *</tt>,<tt> operator +</tt>,<tt> operator -</tt>
<br><tt>Complex::operator /=</tt>
</dl>
<h2 id="Complex__operator_DELR"> operator /=() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Complex &amp;Complex::operator /=( Complex const &amp;num );</tt>
<br><tt> Complex &amp;Complex::operator /=( double num );</tt>
<dt><br>Semantics:
<dd>The<tt> operator /=</tt> public member function is used to divide the<tt> Complex</tt> object by<b> num</b>.&nbsp; The second
 form of the<tt> operator /=</tt> public member function divides the real and imaginary components of the<tt> Complex</tt>
 object by<b> num</b>.
<br>A call to the<tt> operator /=</tt> public member function where<b> num</b> is any of the other built-in numeric types,
 causes<b> num</b> to be promoted to<tt> double</tt> and the second form of the<tt> operator /=</tt> public member function
 to be used.
<dt><br>Results:
<dd>The<tt> operator /=</tt> public member function returns a reference to the target of the assignment.
<dt><br>See Also:
<dd><tt> operator /</tt>
<br><tt>Complex::operator *=</tt>,<tt> operator +=</tt>,<tt> operator -=</tt>,<tt> operator =</tt>
</dl>
<h2 id="Complex_operator_XXLR"> Complex operator &lt;&lt;() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>friend ostream &amp;operator &lt;&lt;( ostream &amp;strm, Complex &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> operator &lt;&lt;</tt> function is used to write<tt> Complex</tt> objects to an I/O stream.&nbsp; The<tt> Complex</tt>
 object is always written in the form:
<br><tt>(real,imag)</tt>
<br><br>The real and imaginary components are written using the normal rules for formatting floating-point numbers.&nbsp;
 Any formatting options specified prior to inserting the<b> num</b> apply to both the real and imaginary components.&nbsp;
 If the real and imaginary components are to be inserted using different formats, the<tt> real</tt> and<tt> imag</tt> member
 functions should be used to insert each component separately.
<dt><br>Results:
<dd>The<tt> operator &lt;&lt;</tt> function returns a reference to the<b> strm</b> object.
<dt><br>See Also:
<dd><tt> istream</tt>
</dl>
<h2 id="Complex__operator_ELR"> operator =() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Complex &amp;Complex::operator =( Complex const &amp;num );</tt>
<br><tt> Complex &amp;Complex::operator =( double num );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is used to set the value of the<tt> Complex</tt> object to<b> num</b>.&nbsp;
 The first assignment operator copies the value of<b> num</b> into the<tt> Complex</tt> object.
<br>The second assignment operator sets the real component of the<tt> Complex</tt> object to<b> num</b> and the imaginary
 component to zero.
<br><br>A call to the<tt> operator =</tt> public member function where<b> num</b> is any of the other built-in numeric types,
 causes<b> num</b> to be promoted to<tt> double</tt> and the second form of the<tt> operator =</tt> public member function
 to be used.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function returns a reference to the target of the assignment.
<dt><br>See Also:
<dd><tt> Complex::operator *=</tt>,<tt> operator +=</tt>,<tt> operator -=</tt>,<tt> operator /=</tt>
</dl>
<h2 id="Complex_operator_EELR"> Complex operator ==() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>int operator ==( Complex const &amp;num1, Complex const &amp;num2 );</tt>
<br><tt>int operator ==( Complex const &amp;num1, double num2 );</tt>
<br><tt>int operator ==( double num1, Complex const &amp;num2 );</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> function compares<b> num1</b> and<b> num2</b> for equality.&nbsp; At least one of the arguments must
 be a<tt> Complex</tt> object for this function to be called.
<br>Two<tt> Complex</tt> objects are equal if their corresponding real and imaginary components are equal.
<br><br>If the<tt> operator ==</tt> function is used with a<tt> Complex</tt> object and an object of any other built-in numeric
 type, the non-<tt> Complex</tt> object is converted to a<tt> double</tt> and the second or third form of the<tt> operator
 ==</tt> function is used.
<dt><br>Results:
<dd>The<tt> operator ==</tt> function returns a non-zero value if<b> num1</b> is equal to<b> num2</b>, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> operator !=</tt>
</dl>
<h2 id="Complex_operator_YYLR"> Complex operator &gt;&gt;() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>friend istream &amp;operator &gt;&gt;( istream &amp;strm, Complex &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> operator &gt;&gt;</tt> function is used to read a<tt> Complex</tt> object from an I/O stream.&nbsp; A valid complex
 value is of one of the following forms:
<br><tt>(real,imag)</tt>
<br><br><tt>real,imag</tt>
<br><tt>(real)</tt>
<br>If the imaginary portion is omitted, zero is assumed.
<br><br>While reading a<tt> Complex</tt> object, whitespace is ignored before and between the various components of the number
 if the<tt> ios::skipws</tt> bit is set in<tt> ios::fmtflags</tt>.
<dt><br>Results:
<dd>The<tt> operator &gt;&gt;</tt> function returns a reference to<b> strm</b>.<b>&nbsp; num</b> contains the value read from<b>
 strm</b> on success, otherwise it is unchanged.
<dt><br>See Also:
<dd><tt> istream</tt>
</dl>
<h2 id="Complex_polarLR"> Complex polar() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex polar( double mag, double angle = 0.0 );</tt>
<dt><br>Semantics:
<dd>The<tt> polar</tt> function converts<b> mag</b> and<b> angle</b> (polar coordinates) into a complex number.&nbsp; The<b> angle</b>
 is optional and defaults to zero if it is unspecified.
<dt><br>Results:
<dd>The<tt> polar</tt> function returns a<tt> Complex</tt> object that is<b> mag</b> and<b> angle</b> interpreted as polar coordinates.
<dt><br>See Also:
<dd><tt> abs</tt>,<tt> arg</tt>,<tt> norm</tt>
</dl>
<h2 id="Complex_powLR"> Complex pow() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex pow( Complex const &amp;num, Complex const &amp;exp );</tt>
<br><tt>Complex pow( Complex const &amp;num, double exp );</tt>
<br><tt>Complex pow( double num, Complex const &amp;exp );</tt>
<br><tt>Complex pow( Complex const &amp;num, int exp );</tt>
<dt><br>Semantics:
<dd>The<tt> pow</tt> function computes<b> num</b> raised to the power<b> exp</b>.&nbsp; The various forms are provided to minimize
 the amount of floating-point calculation performed.
<dt><br>Results:
<dd>The<tt> pow</tt> function returns a<tt> Complex</tt> object that is<b> num</b> raised to the power a<tt> Complex</tt> object
 that is<b> exp</b>.
<dt><br>See Also:
<dd><tt> exp</tt>,<tt> log</tt>,<tt> log10</tt>,<tt> sqrt</tt>
</dl>
<h2 id="Complex__realLR"> real() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>double Complex::real();</tt>
<dt><br>Semantics:
<dd>The<tt> real</tt> public member function extracts the real component of the<tt> Complex</tt> object.
<dt><br>Results:
<dd>The<tt> real</tt> public member function returns the real component of the<tt> Complex</tt> object.
<dt><br>See Also:
<dd><tt> imag</tt>,<tt> real</tt>
<br><tt>Complex::imag</tt>
</dl>
<h2 id="Complex_realLR"> Complex real() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>double real( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> real</tt> function extracts the real component of<b> num</b>.
<dt><br>Results:
<dd>The<tt> real</tt> function returns the real component of<b> num</b>.
<dt><br>See Also:
<dd><tt> imag</tt>
<br><tt>Complex::imag</tt>,<tt> real</tt>
</dl>
<h2 id="Complex_sinLR"> Complex sin() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex sin( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> sin</tt> function computes the sine of<b> num</b>.
<dt><br>Results:
<dd>The<tt> sin</tt> function returns the sine of<b> num</b>.
<dt><br>See Also:
<dd><tt> asin</tt>,<tt> cos</tt>,<tt> tan</tt>
</dl>
<h2 id="Complex_sinhLR"> Complex sinh() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex sinh( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> sinh</tt> function computes the hyperbolic sine of<b> num</b>.
<dt><br>Results:
<dd>The<tt> sinh</tt> function returns the hyperbolic sine of<b> num</b>.
<dt><br>See Also:
<dd><tt> asinh</tt>,<tt> cosh</tt>,<tt> tanh</tt>
</dl>
<h2 id="Complex_sqrtLR"> Complex sqrt() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex sqrt( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> sqrt</tt> function computes the square root of<b> num</b>.
<dt><br>Results:
<dd>The<tt> sqrt</tt> function returns the square root of<b> num</b>.
<dt><br>See Also:
<dd><tt> exp</tt>,<tt> log</tt>,<tt> log10</tt>,<tt> pow</tt>
</dl>
<h2 id="Complex_tanLR"> Complex tan() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex tan( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> tan</tt> function computes the tangent of<b> num</b>.
<dt><br>Results:
<dd>The<tt> tan</tt> function returns the tangent of<b> num</b>.
<dt><br>See Also:
<dd><tt> atan</tt>,<tt> cos</tt>,<tt> sin</tt>
</dl>
<h2 id="Complex_tanhLR"> Complex tanh() &#91;Complex&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;complex.h&gt;</tt>
<br><tt>Complex tanh( Complex const &amp;num );</tt>
<dt><br>Semantics:
<dd>The<tt> tanh</tt> function computes the hyperbolic tangent of<b> num</b>.
<dt><br>Results:
<dd>The<tt> tanh</tt> function returns the hyperbolic tangent of<b> num</b>.
<dt><br>See Also:
<dd><tt> atanh</tt>,<tt> cosh</tt>,<tt> sinh</tt>
</dl>
<h1 id="Container_Exception_Classes"> Container Exception Classes </h1>
<br>This chapter describes exception handling for the container classes.
<h2 id="WCExcept_Class_Description"> WCExcept Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wcexcept.h</tt>
<br>The<tt> WCExcept</tt> class provides the exception handling for the container classes.&nbsp; If you have compiled your
 code with exception handling enabled, the C++ exception processing can be used to catch errors.&nbsp; Your source file must
 be compiled with the exception handling compile switch for C++ exception processing to occur.&nbsp; The container classes
 will attempt to set the container object into a reasonable state if there is an error and exception handling is not enabled,
 or if the trap for the specific error has not been enabled by your program.
<br>By default, no exception traps are enabled and no exceptions will be thrown.&nbsp; Exception traps are enabled by setting
 the exception state with the<tt> exceptions</tt> member function.
<br><br>The<tt> wcexcept.h</tt> header file is included by the header files for each of the container classes.&nbsp; There
 is normally no need to explicitly include the<tt> wcexcept.h</tt> header file, but no errors will result if it is included.
&nbsp; This class is inherited as a base class for each of the containers.&nbsp; You do not need to derive from it directly.
<br><br>The<tt> WCListExcept</tt> class (formally used by the list container classes) has been replaced by the<tt> WCExcept</tt>
 class.&nbsp; A typedef of the<tt> WCListExcept</tt> class to the<tt> WCExcept</tt> class and the<tt> wclist_state</tt> type
 to the<tt> wc_state</tt> type provide backward compatability with previous versions of the list containers.
<br><br><b>Public Enumerations</b>
<br><br>The following enumeration typedefs are declared in the public interface:
<br><br><tt>typedef int wc_state;</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following public member functions are declared:
<br><br><tt>WCExcept();</tt>
<br><tt> virtual ~WCExcept();</tt>
<br><tt> wc_state exceptions() const;</tt>
<br><tt> wc_state exceptions( wc_state );</tt>
</dl>
<h2 id="WCExcept__WCExceptLR"> WCExcept() &#91;WCExcept&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcexcept.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCExcept();</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> WCExcept</tt> constructor creates an<tt> WCExcept</tt> object.
<br>The public<tt> WCExcept</tt> constructor is used implicitly by the compiler when it generates a constructor for a derived
 class.&nbsp; It is automatically used by the list container classes, and should not be required in any user derived classes.
<dt><br>Results:
<dd>The public<tt> WCExcept</tt> constructor produces an initialized<tt> WCExcept</tt> object with no exception traps enabled.
<dt><br>See Also:
<dd><tt> ~WCExcept</tt>
</dl>
<h2 id="WCExcept____WCExceptLR"> ~WCExcept() &#91;WCExcept&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcexcept.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCExcept();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCExcept</tt> destructor does not do anything explicit.&nbsp; The call to the public<tt> ~WCExcept</tt> destructor
 is inserted implicitly by the compiler at the point where the object derived from<tt> WCExcept</tt> goes out of scope.
<dt><br>Results:
<dd>The object derived from<tt> WCExcept</tt> is destroyed.
<dt><br>See Also:
<dd><tt> WCExcept</tt>
</dl>
<h2 id="WCExcept__exceptionsLR"> exceptions() &#91;WCExcept&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcexcept.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>wc_state exceptions() const;</tt>
<br><tt> wc_state exceptions( wc_state set_flags );</tt>
<dt><br>Semantics:
<dd>The<tt> exceptions</tt> public member function queries and/or sets the bits that control which exceptions are enabled for
 the list class.&nbsp; Each bit corresponds to an exception, and is set if the exception is enabled.&nbsp; The first form
 of the<tt> exceptions</tt> public member function returns the current settings of the exception bits.&nbsp; The second form
 of the function sets the exception bits to those specified by<b> set_flags</b>.
<dt><br>Results:
<dd>The current exception bits are returned.&nbsp; If a new set of bits are being set, the returned value is the old set of exception
 bits.
</dl>
<h2 id="WCExcept__wc_state"> wc_state &#91;WCExcept&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcexcept.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>enum wcstate {</tt>
<br><tt>all_fine = 0x0000, // - no errors</tt>
<br><tt> check_none = all_fine,// - throw no exceptions</tt>
<br><tt> not_empty = 0x0001, // - container not empty</tt>
<br><tt> index_range = 0x0002, // - index is out of range</tt>
<br><tt> empty_container= 0x0004, // - empty container error</tt>
<br><tt> out_of_memory = 0x0008, // - allocation failed</tt>
<br><tt> resize_required= 0x0010, // - request needs resize</tt>
<br><tt> not_unique = 0x0020, // - adding duplicate</tt>
<br><tt> zero_buckets = 0x0040, // - resizing hash to zero</tt>
<br><tt> // value to use to check for all errors</tt>
<br><tt>check_all = (not_empty|index_range|empty_container</tt>
<br><tt> |out_of_memory|resize_required</tt>
<br><tt>|not_unique|zero_buckets)</tt>
<br><tt>};</tt>
<br><tt>typedef int wc_state;</tt>
<dt><br>Semantics:
<dd>The type<tt> WCExcept::wcstate</tt> is a set of bits representing the current state of the container object.&nbsp; The<tt>
 WCExcept::wc_state</tt> member typedef represents the same set of bits, but uses an<tt> int</tt> to represent the values,
 thereby avoiding problems made possible by the compiler's ability to use smaller types for enumerations.&nbsp; All uses of
 these bits should use the<tt> WCExcept::wc_state</tt> member typedef.
<br>The bit values defined by the<tt> WCExcept::wc_state</tt> member typedef can be read and set by the<tt> exceptions</tt>
 member function, which is also used to control exception handling.
<br><br>The<tt> WCExcept::not_empty</tt> bit setting traps the destruction of a container when the container has at one or
 more entries.&nbsp; If this error is not trapped, memory may not be properly released back to the system.
<br><br>The<tt> WCExcept::index_range</tt> state setting traps an attempt to access a container item by an index value that
 is either not positive or is larger than the index of the last item in the container.
<br><br>The<tt> WCExcept::empty_container</tt> bit setting traps an attempt to perform and invalid operation on a container
 with no entries.
<br><br>The<tt> WCExcept::out_of_memory</tt> bit setting traps any container class allocation failures.&nbsp; If this exception
 is not enabled, the operation in which the allocation failed will return a FALSE (zero) value.&nbsp; Container class copy
 constructors and assignment operators can also throw this exception, and if not enabled incomplete copies may result.
<br><br>The<tt> WCExcept::resize_required</tt> bit setting traps any vector operations which cannot be performed unless the
 vector is resized to a larger size.&nbsp; If this exception is not enabled, the vector class will attempt an appropriate
 resize when necessary for an operation.
<br><br>The<tt> WCExcept::not_unique</tt> bit setting traps an attempt to add a duplicate value to a set container, or a duplicate
 key to a dictionary container.&nbsp; The duplicate value is not added to the container object regardless of the exception
 trap state.
<br><br>The<tt> WCExcept::zero_buckets</tt> bit setting traps an attempt to resize of hash container to have zero buckets.
&nbsp; No resize is performed whether or not the exception is enabled.
</dl>
<h2 id="WCIterExcept_Class_Description"> WCIterExcept Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wcexcept.h</tt>
<br>The<tt> WCIterExcept</tt> class provides the exception handling for the container iterators.&nbsp; If you have compiled
 your code with exception handling enabled, the C++ exception processing can be used to catch errors.&nbsp; Your source file
 must be compiled with the exception handling compile switch for C++ exception processing to occur.&nbsp; The iterators will
 attempt to set the class into a reasonable state if there is an error and exception handling is not enabled, or if the trap
 for the specific error has not been enabled by your program.
<br>By default, no exception traps are enabled and no exceptions will be thrown.&nbsp; Exception traps are enabled by setting
 the exception state with the<tt> exceptions</tt> member function.
<br><br>The<tt> wcexcept.h</tt> header file is included by the header files for each of the iterator classes.&nbsp; There
 is normally no need to explicitly include the<tt> wcexcept.h</tt> header file, but no errors will result if it is included.
&nbsp; This class is inherited as part of the base construction for each of the iterators.&nbsp; You do not need to derive
 from it directly.
<br><br><b>Public Enumerations</b>
<br><br>The following enumeration typedefs are declared in the public interface:
<br><br><tt>typedef int wciter_state;</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following public member functions are declared:
<br><br><tt>WCIterExcept();</tt>
<br><tt> virtual ~WCIterExcept();</tt>
<br><tt> wciter_state exceptions() const;</tt>
<br><tt> wciter_state exceptions( wciter_state );</tt>
</dl>
<h2 id="WCIterExcept__WCIterExceptLR"> WCIterExcept() &#91;WCIterExcept&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcexcept.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCIterExcept();</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> WCIterExcept</tt> constructor creates an<tt> WCIterExcept</tt> object.
<br>The public<tt> WCIterExcept</tt> constructor is used implicitly by the compiler when it generates a constructor for a
 derived class.
<dt><br>Results:
<dd>The public<tt> WCIterExcept</tt> constructor produces an initialized<tt> WCIterExcept</tt> object with no exception traps
 enabled.
<dt><br>See Also:
<dd><tt> ~WCIterExcept</tt>
</dl>
<h2 id="WCIterExcept____WCIterExceptLR"> ~WCIterExcept() &#91;WCIterExcept&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcexcept.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCIterExcept();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCIterExcept</tt> destructor does not do anything explicit.&nbsp; The call to the public<tt> ~WCIterExcept</tt>
 destructor is inserted implicitly by the compiler at the point where the object derived from<tt> WCIterExcept</tt> goes out
 of scope.
<dt><br>Results:
<dd>The object derived from<tt> WCIterExcept</tt> is destroyed.
<dt><br>See Also:
<dd><tt> WCIterExcept</tt>
</dl>
<h2 id="WCIterExcept__exceptionsLR"> exceptions() &#91;WCIterExcept&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcexcept.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>wciter_state exceptions() const;</tt>
<br><tt> wciter_state exceptions( wciter_state set_flags );</tt>
<dt><br>Semantics:
<dd>The<tt> exceptions</tt> public member function queries and/or sets the bits that control which exceptions are enabled for
 the iterator class.&nbsp; Each bit corresponds to an exception, and is set if the exception is enabled.&nbsp; The first form
 of the<tt> exceptions</tt> public member function returns the current settings of the exception bits.&nbsp; The second form
 of the function sets the exception bits to those specified by<b> set_flags</b>.
<dt><br>Results:
<dd>The current exception bits are returned.&nbsp; If a new set of bits are being set, the returned value is the old set of exception
 bits.
</dl>
<h2 id="WCIterExcept__wciter_state"> wciter_state &#91;WCIterExcept&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcexcept.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>enum wciterstate {</tt>
<br><tt>all_fine = 0x0000, // - no errors</tt>
<br><tt> check_none = all_fine,// - disable all exceptions</tt>
<br><tt> undef_iter = 0x0001, // - position is undefined</tt>
<br><tt> undef_item = 0x0002, // - iterator item is undefined</tt>
<br><tt> iter_range = 0x0004, // - advance value is bad</tt>
<br><tt> // value to use to check for all errors</tt>
<br><tt>check_all= (undef_iter|undef_item|iter_range)</tt>
<br><tt> };</tt>
<br><tt>typedef int wciter_state;</tt>
<dt><br>Semantics:
<dd>The type<tt> WCIterExcept::wciterstate</tt> is a set of bits representing the current state of the iterator.&nbsp; The<tt>
 WCIterExcept::wciter_state</tt> member typedef represents the same set of bits, but uses an<tt> int</tt> to represent the
 values, thereby avoiding problems made possible by the compiler's ability to use smaller types for enumerations.&nbsp; All
 uses of these bits should use the<tt> WCIterExcept::wciter_state</tt> member typedef.
<br>The bit values defined by the<tt> WCIterExcept::wciter_state</tt> member typedef can be read and set by the member function<tt>
 exceptions</tt>, which is used to control exception handling.
<br><br>The<tt> WCIterExcept::undef_iter</tt> bit setting traps the use of the iterator when the position within the container
 object is undefined.&nbsp; Trying to operate on an iterator with no associated container object, increment an iterator which
 is after the last element, or decrement an iterator positioned before the first element is an undefined operation.
<br><br>The<tt> WCIterExcept::undef_item</tt> bit setting traps an attempt to obtain the current element of the iterator when
 the iterator has no associated container object, or is positioned either before or after the container elements.&nbsp; The<tt>
 undef_item</tt> exception can be thrown only by the<tt> key</tt> and<tt> value</tt> dictionary iterator member functions,
 and the<tt> current</tt> member function for non-dictionary iterators.
<br><br>The<tt> WCIterExcept::iter_range</tt> bit setting traps an attempt to use a iteration count value that would place
 the iterator more than one element past the end or before the beginning of the container elements.&nbsp; The<tt> iter_range</tt>
 exception can be thrown only by the<tt> operator +=</tt> and<tt> operator -=</tt> operators.
</dl>
<h1 id="Container_Allocators_and_Deallocators"> Container Allocators and Deallocators </h1>
<br><b>Example</b>
<br><br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>#include &lt;wcskipit.h&gt;</tt>
<br><tt>#include &lt;stdlib.h&gt;</tt>
<br><br><tt>#pragma warning 549 9</tt>
<br><br><tt>const int ElemsPerBlock = 50;</tt>
<br><br><tt>//</tt>
<br><tt>// Simple block allocation class.&nbsp; Allocate blocks for ElemsPerBlock</tt>
<br><tt>// elements, and use part of the block for each of the next ElemsPerBlock</tt>
<br><tt>// allocations, incrementing the number allocated elements.&nbsp; Repeat getting</tt>
<br><tt>// more blocks as needed.</tt>
<br><tt>//</tt>
<br><tt>// Store the blocks in an intrusive single linked list.</tt>
<br><tt>//</tt>
<br><tt>// On a element deallocation, assume we allocated the memory and just</tt>
<br><tt>// decrement the count of allocated elements.&nbsp; When the count gets to zero,</tt>
<br><tt>// free all allocated blocks</tt>
<br><tt>//</tt>
<br><tt>// This implementation assumes sizeof( char ) == 1</tt>
<br><tt>//</tt>
<br><br><tt>class BlockAlloc {</tt>
<br><tt>private:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // the size of elements (in bytes)</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned elem_size;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; // number of elements allocated</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned num_allocated;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; // free space of this number of elements available in first block</tt>
<br><tt>&nbsp;&nbsp;&nbsp; unsigned num_free_in_block;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; // list of blocks used to store elements (block are chunks of memory,</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // pointed by (char *) pointers.</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WCPtrSList&lt;char&gt; block_list;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; // pointer to the first block in the list</tt>
<br><tt>&nbsp;&nbsp;&nbsp; char *curr_block;</tt>
<br><br><tt>public:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; inline BlockAlloc( unsigned size )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : elem_size( size ), num_allocated(
 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , num_free_in_block( 0
 ) {};</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; inline BlockAlloc() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block_list.clearAndDestroy();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; };</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; // get memory for an element using block allocation</tt>
<br><tt>&nbsp;&nbsp;&nbsp; void *allocator( size_t elem_size );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; // free memory for an element using block allocation and deallocation</tt>
<br><tt>&nbsp;&nbsp;&nbsp; void deallocator( void *old_ptr, size_t elem_size );</tt>
<br><tt>};</tt>
<br><br><tt>void *BlockAlloc::allocator( size_t size ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // need a new block to perform allocation</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( num_free_in_block == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // allocate memory for ElemsPerBlock elements</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; curr_block = new char&#91; size * ElemsPerBlock &#93;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( curr_block == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // allocation failed</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // add new block to beginning of list</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( !block_list.insert( curr_block ) ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // allocation of list element failed</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete( curr_block );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( 0 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_free_in_block = ElemsPerBlock;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; // curr block points to a block of memory with some free memory</tt>
<br><tt>&nbsp;&nbsp;&nbsp; num_allocated++;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; num_free_in_block--;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // return pointer to a free part of the block, starting at the end</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // of the block</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( curr_block + num_free_in_block * size );</tt>
<br><tt>}</tt>
<br><br><tt>void BlockAlloc::deallocator( void *, size_t ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // just decrement the count</tt>
<br><tt>&nbsp;&nbsp;&nbsp; // don't free anything until all elements are deallocated</tt>
<br><tt>&nbsp;&nbsp;&nbsp; num_allocated--;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( num_allocated == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // all the elements allocated BlockAlloc object have now been</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // deallocated, free all the blocks</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; block_list.clearAndDestroy();</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num_free_in_block = 0;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br><tt>const unsigned NumTestElems = 200;</tt>
<br><br><tt>// array with random elements</tt>
<br><tt>static unsigned test_elems&#91; NumTestElems &#93;;</tt>
<br><br><tt>static void fill_test_elems() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; NumTestElems; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test_elems&#91; i &#93; = rand();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br><tt>void test_isv_list();</tt>
<br><tt>void test_val_list();</tt>
<br><tt>void test_val_skip_list();</tt>
<br><br><tt>void main() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; fill_test_elems();</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; test_isv_list();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; test_val_list();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; test_val_skip_list();</tt>
<br><tt>}</tt>
<br><br><tt>// An intrusive list class</tt>
<br><br><tt>class isvInt : public WCSLink {</tt>
<br><tt>public:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; static BlockAlloc memory_manage;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int data;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; isvInt( int datum ) : data( datum ) {};</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; void *operator new( size_t size ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( memory_manage.allocator( size ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; };</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; void operator delete( void *old, size_t size ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; memory_manage.deallocator( old, size );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; };</tt>
<br><tt>};</tt>
<br><br><tt>// define static member data</tt>
<br><tt>BlockAlloc isvInt::memory_manage( sizeof( isvInt ) );</tt>
<br><br><tt>void test_isv_list() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WCIsvSList&lt;isvInt&gt; list;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; NumTestElems; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.insert( new isvInt( test_elems&#91; i &#93; ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; WCIsvSListIter&lt;isvInt&gt; iter( list );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( ++iter ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; iter.current()-&gt;data &lt;&lt; &quot; &quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;\n\n\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.clearAndDestroy();</tt>
<br><tt>}</tt>
<br><br><tt>// WCValSList&lt;int&gt; memory allocator/dealloctor support</tt>
<br><tt>static BlockAlloc val_list_manager( WCValSListItemSize( int ) );</tt>
<br><br><tt>static void *val_list_alloc( size_t size ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( val_list_manager.allocator( size ) );</tt>
<br><tt>}</tt>
<br><br><tt>static void val_list_dealloc( void *old, size_t size ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; val_list_manager.deallocator( old, size );</tt>
<br><tt>}</tt>
<br><br><tt>// test WCValSList&lt;int&gt;</tt>
<br><tt>void test_val_list() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WCValSList&lt;int&gt; list( &amp;val_list_alloc, &amp;val_list_dealloc );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; NumTestElems; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.insert( test_elems&#91; i &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; WCValSListIter&lt;int&gt; iter( list );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( ++iter ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; iter.current() &lt;&lt; &quot; &quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;\n\n\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.clear();</tt>
<br><tt>}</tt>
<br><br><tt>// skip list allocator dealloctors: just use allocator and dealloctor</tt>
<br><tt>// functions on skip list elements with one and two pointers</tt>
<br><tt>// (this will handle 94% of the elements)</tt>
<br><tt>const int one_ptr_size = WCValSkipListItemSize( int, 1 );</tt>
<br><tt>const int two_ptr_size = WCValSkipListItemSize( int, 2 );</tt>
<br><br><tt>static BlockAlloc one_ptr_manager( one_ptr_size );</tt>
<br><tt>static BlockAlloc two_ptr_manager( two_ptr_size );</tt>
<br><br><tt>static void *val_skip_list_alloc( size_t size ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; switch( size ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case one_ptr_size:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( one_ptr_manager.allocator( size ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case two_ptr_size:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( two_ptr_manager.allocator( size ) );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return( new char&#91; size &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br><tt>static void val_skip_list_dealloc( void *old, size_t size ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; switch( size ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case one_ptr_size:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; one_ptr_manager.deallocator( old, size );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case two_ptr_size:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; two_ptr_manager.deallocator( old, size );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delete old;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br><tt>// test WCValSkipList&lt;int&gt;</tt>
<br><tt>void test_val_skip_list() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WCValSkipList&lt;int&gt; skiplist( WCSKIPLIST_PROB_QUARTER</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , WCDEFAULT_SKIPLIST_MAX_PTRS</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , &amp;val_skip_list_alloc</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , &amp;val_skip_list_dealloc );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; for( int i = 0; i &lt; NumTestElems; i++ ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; skiplist.insert( test_elems&#91; i &#93; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; WCValSkipListIter&lt;int&gt; iter( skiplist );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( ++iter ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; iter.current() &lt;&lt; &quot; &quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;\n\n\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; skiplist.clear();</tt>
<br><tt>}</tt>
<h1 id="Hash_Containers"> Hash Containers </h1>
<br>This chapter describes hash containers.
<h2 id="WCPtrHashDictXKey_ValueY_Class_Description"> WCPtrHashDict&lt;Key,Value&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wchash.h</tt>
<br>The<tt> WCPtrHashDict&lt;Key,Value&gt;</tt> class is a templated class used to store objects in a dictionary.&nbsp; Dictionaries
 store values with an associated key, which may be of any type.&nbsp; One example of a dictionary used in everyday life is
 the phone book.&nbsp; The phone numbers are the data values, and the customer name is the key.&nbsp; An example of a specialized
 dictionary is a vector, where the key value is the integer index.
<br>As an element is looked up or inserted into the dictionary, the associated key is hashed.&nbsp; Hashing converts the key
 into a numeric index value which is used to locate the value.&nbsp; The storage area referenced by the hash value is usually
 called a bucket.&nbsp; If more than one key results in the same hash, the values associated with the keys are placed in a
 list stored in the bucket.&nbsp; The equality operator of the key's type is used to locate the key-value pairs.
<br><br>In the description of each member function, the text<tt> Key</tt> is used to indicate the template parameter defining
 the type of the indices pointed to by the pointers stored in the dictionary.&nbsp; The text<tt> Value</tt> is used to indicate
 the template parameter defining the type of the data pointed to by the pointers stored in the dictionary.
<br><br>The constructor for the<tt> WCPtrHashDict&lt;Key,Value&gt;</tt> class requires a hashing function, which given a reference
 to<tt> Key,</tt> returns an<tt> unsigned</tt> value.&nbsp; The returned value modulo the number of buckets determines the
 bucket into which the key-value pair will be located.&nbsp; The return values of the hash function can be spread over the
 entire range of unsigned numbers.&nbsp; The hash function return value must be the same for values which are equivalent by
 the equivalence operator for<tt> Key.</tt>
<br><br>Note that pointers to the key values are stored in the dictionary.&nbsp; Destructors are not called on the keys pointed
 to.&nbsp; The key values pointed to in the dictionary should not be changed such that the equivalence to the old value is
 modified.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCPtrHashDict&lt;Key,Value&gt;</tt> class and provides the<tt>
 exceptions</tt> member function.&nbsp; This member function controls the exceptions which can be thrown by the<tt> WCPtrHashDict&lt;Key,Value&gt;</tt>
 object.&nbsp; No exceptions are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Key</b>
<br><br>The<tt> WCPtrHashDict&lt;Key,Value&gt;</tt> class requires<tt> Key</tt> to have:
<br>A well defined equivalence operator with constant parameters
<br><br>(<tt> int operator ==( const Key &amp; ) const</tt> ).
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCPtrHashDict( unsigned (*hash_fn)( const Key &amp; ), unsigned = WC_DEFAULT_HASH_SIZE );</tt>
<br><tt> WCPtrHashDict( unsigned (*hash_fn)( const Key &amp; ), unsigned = WC_DEFAULT_HASH_SIZE, void * (*user_alloc)( size_t
 size ), void (*user_dealloc)( void *old, size_t size ) );</tt>
<br><tt> WCPtrHashDict( const WCPtrHashDict &amp; );</tt>
<br><tt> virtual ~WCPtrHashDict();</tt>
<br><tt> static unsigned bitHash( const void *, size_t );</tt>
<br><tt> unsigned buckets() const;</tt>
<br><tt> void clear();</tt>
<br><tt> void clearAndDestroy();</tt>
<br><tt> int contains( const Key * ) const;</tt>
<br><tt> unsigned entries() const;</tt>
<br><tt> Value * find( const Key * ) const;</tt>
<br><tt> Value * findKeyAndValue( const Key *, Key * &amp; ) const;</tt>
<br><tt> void forAll( void (*user_fn)( Key *, Value *, void * ) , void * );</tt>
<br><tt> int insert( Key *, Value * );</tt>
<br><tt> int isEmpty() const;</tt>
<br><tt> Value * remove( const Key * );</tt>
<br><tt> void resize( unsigned );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>Value * &amp; operator &#91;&#93;( const Key &amp; );</tt>
<br><tt> const Value * &amp; operator &#91;&#93;( const Key &amp; ) const;</tt>
<br><tt> WCPtrHashDict &amp; operator =( const WCPtrHashDict &amp; );</tt>
<br><tt> int operator ==( const WCPtrHashDict &amp; ) const;</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__WCPtrHashDictLR"> WCPtrHashDict() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashDict( unsigned (*hash_fn)( const Key &amp; ),</tt>
<br><tt> unsigned = WC_DEFAULT_HASH_SIZE );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCPtrHashDict&lt;Key,Value&gt;</tt> constructor creates an<tt> WCPtrHashDict&lt;Key,Value&gt;</tt> object with
 no entries and with the number of buckets in the second optional parameter, which defaults to the constant<tt> WC_DEFAULT_HASH_SIZE</tt>
 (currently defined as 101).&nbsp; The number of buckets specified must be greater than zero, and will be forced to at least
 one.&nbsp; If the hash dictionary object can be created, but an allocation failure occurs when creating the buckets, the
 table will be created with zero buckets.&nbsp; If the<tt> out_of_memory</tt> exception is enabled, then attempting to insert
 into a hash table with zero buckets with throw an<tt> out_of_memory</tt> error.
<br>The hash function<tt> hash_fn</tt> is used to determine which bucket each key-value pair will be assigned.&nbsp; If no
 hash function exists, the static member function<tt> bitHash</tt> is available to help create one.
<dt><br>Results:
<dd>The public<tt> WCPtrHashDict&lt;Key,Value&gt;</tt> constructor creates an initialized<tt> WCPtrHashDict&lt;Key,Value&gt;</tt>
 object with the specified number of buckets and hash function.
<dt><br>See Also:
<dd><tt> ~WCPtrHashDict</tt>,<tt> bitHash</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashDict( unsigned (*hash_fn)( const Key &amp; ),</tt>
<br><tt> unsigned = WC_DEFAULT_HASH_SIZE,</tt>
<br><tt>void * (*user_alloc)( size_t ),</tt>
<br><tt>void (*user_dealloc)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>Allocator and deallocator functions are specified for use when entries are inserted and removed from the hash dictionary.
&nbsp; The semantics of this constructor are the same as the constructor without the memory management functions.
<br>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is passed
 the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic that the
 allocation function will always be called with the same size value for any particular instantiation of a hash dictionary.
&nbsp; To determine the size of the objects that the memory management functions will be required to allocate and free, the
 following macro may be used:
<br><br><tt>WCPtrHashDictItemSize( Key, Value )</tt>
<dt><br>Results:
<dd>The public<tt> WCPtrHashDict&lt;Key,Value&gt;</tt> constructor creates an initialized<tt> WCPtrHashDict&lt;Key,Value&gt;</tt>
 object with the specified number of buckets and hash function.
<dt><br>See Also:
<dd><tt> ~WCPtrHashDict</tt>,<tt> bitHash</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashDict( const WCPtrHashDict &amp; );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCPtrHashDict&lt;Key,Value&gt;</tt> constructor is the copy constructor for the<tt> WCPtrHashDict&lt;Key,Value&gt;</tt>
 class.&nbsp; The new dictionary is created with the same number of buckets, hash function, all values or pointers stored
 in the dictionary, and the exception trap states.&nbsp; If the hash dictionary object can be created, but an allocation failure
 occurs when creating the buckets, the table will be created with zero buckets.&nbsp; If there is not enough memory to copy
 all of the values in the dictionary, then only some will be copied, and the number of entries will correctly reflect the
 number copied.&nbsp; If all of the elements cannot be copied, then the<tt> out_of_memory</tt> exception is thrown if it is
 enabled.
<dt><br>Results:
<dd>The public<tt> WCPtrHashDict&lt;Key,Value&gt;</tt> constructor creates an<tt> WCPtrHashDict&lt;Key,Value&gt;</tt> object which
 is a copy of the passed dictionary.
<dt><br>See Also:
<dd><tt> ~WCPtrHashDict</tt>,<tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY____WCPtrHashDictLR"> ~WCPtrHashDict() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCPtrHashDict();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCPtrHashDict&lt;Key,Value&gt;</tt> destructor is the destructor for the<tt> WCPtrHashDict&lt;Key,Value&gt;</tt>
 class.&nbsp; If the number of dictionary elements is not zero and the<tt> not_empty</tt> exception is enabled, the exception
 is thrown.&nbsp; Otherwise, the dictionary elements are cleared using the<tt> clear</tt> member function.&nbsp; The objects
 which the dictionary elements point to are not deleted unless the<tt> clearAndDestroy</tt> member function is explicitly
 called before the destructor is called.&nbsp; The call to the public<tt> ~WCPtrHashDict&lt;Key,Value&gt;</tt> destructor
 is inserted implicitly by the compiler at the point where the<tt> WCPtrHashDict&lt;Key,Value&gt;</tt> object goes out of
 scope.
<dt><br>Results:
<dd>The public<tt> ~WCPtrHashDict&lt;Key,Value&gt;</tt> destructor destroys an<tt> WCPtrHashDict&lt;Key,Value&gt;</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__bitHashLR"> bitHash() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>static unsigned bitHash( void *, size_t );</tt>
<dt><br>Semantics:
<dd>The<tt> bitHash</tt> public member function can be used to implement a hashing function for any type.&nbsp; A hashing value
 is generated from the value stored for the number of specified bytes pointed to by the first parameter.
<dt><br>Results:
<dd>The<tt> bitHash</tt> public member function returns an unsigned value which can be used as the basis of a user defined hash
 function.
<dt><br>See Also:
<dd><tt> WCPtrHashDict</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__bucketsLR"> buckets() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned buckets const;</tt>
<dt><br>Semantics:
<dd>The<tt> buckets</tt> public member function is used to find the number of buckets contained in the<tt> WCPtrHashDict&lt;Key,Value&gt;</tt>
 object.
<dt><br>Results:
<dd>The<tt> buckets</tt> public member function returns the number of buckets in the dictionary.
<dt><br>See Also:
<dd><tt> resize</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__clearLR"> clear() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the dictionary so that it has no entries.&nbsp; The number of buckets
 remain unaffected.&nbsp; Objects pointed to by the dictionary elements are not deleted.&nbsp; The dictionary object is not
 destroyed and re-created by this function, so the object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function clears the dictionary to have no elements.
<dt><br>See Also:
<dd><tt> ~WCPtrHashDict</tt>,<tt> clearAndDestroy</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__clearAndDestroyLR"> clearAndDestroy() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clearAndDestroy();</tt>
<dt><br>Semantics:
<dd>The<tt> clearAndDestroy</tt> public member function is used to clear the dictionary and delete the objects pointed to by the
 dictionary elements.&nbsp; The dictionary object is not destroyed and re-created by this function, so the dictionary object
 destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clearAndDestroy</tt> public member function clears the dictionary by deleting the objects pointed to by the dictionary
 elements.
<dt><br>See Also:
<dd><tt> clear</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__containsLR"> contains() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int contains( const Key * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> contains</tt> public member function returns non-zero if an element with the specified key is stored in the dictionary,
 or zero if there is no equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the<tt> Key</tt>
 type.
<dt><br>Results:
<dd>The<tt> contains</tt> public member function returns a non-zero value if the<tt> Key</tt> is found in the dictionary.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> findKeyAndValue</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__entriesLR"> entries() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to return the current number of elements stored in the dictionary.
<dt><br>Results:
<dd>The<tt> entries</tt> public member function returns the number of elements in the dictionary.
<dt><br>See Also:
<dd><tt> buckets</tt>,<tt> isEmpty</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__findLR"> find() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value * find( const Key * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> find</tt> public member function is used to find an element with an equivalent key in the dictionary.&nbsp; If an
 equivalent element is found, a pointer to the element<tt> Value</tt> is returned.&nbsp; Zero is returned if the element is
 not found.&nbsp; Note that equivalence is based on the equivalence operator of the<tt> Key</tt> type.
<dt><br>Results:
<dd>The element equivalent to the passed key is located in the dictionary.
<dt><br>See Also:
<dd><tt> findKeyAndValue</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__findKeyAndValueLR"> findKeyAndValue() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value * findKeyAndValue( const Key *,</tt>
<br><tt> Key &amp;, Value &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> findKeyAndValue</tt> public member function is used to find an element in the dictionary with an key equivalent to
 the first parameter.&nbsp; If an equivalent element is found, a pointer to the element<tt> Value</tt> is returned.&nbsp;
 The reference to a<tt> Key</tt> passed as the second parameter is assigned the found element's key.&nbsp; Zero is returned
 if the element is not found.&nbsp; Note that equivalence is based on the equivalence operator of the<tt> Key</tt> type.
<dt><br>Results:
<dd>The element equivalent to the passed key is located in the dictionary.
<dt><br>See Also:
<dd><tt> findKeyAndValue</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__forAllLR"> forAll() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void forAll(</tt>
<br><tt> void (*user_fn)( Key *, Value *, void * ),</tt>
<br><tt>void * );</tt>
<dt><br>Semantics:
<dd>The<tt> forAll</tt> public member function causes the user supplied function to be invoked for every key-value pair in the
 dictionary.&nbsp; The user function has the prototype
<br><tt>void user_func( Key * key, Value * value, void * data );</tt>
<br><br>As the elements are visited, the user function is invoked with the<tt> Key</tt> and<tt> Value</tt> components of the
 element passed as the first two parameters.&nbsp; The second parameter of the<tt> forAll</tt> function is passed as the third
 parameter to the user function.&nbsp; This value can be used to pass any appropriate data from the main code to the user
 function.
<dt><br>Results:
<dd>The elements in the dictionary are all visited, with the user function being invoked for each one.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> findKeyAndValue</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__insertLR"> insert() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( Key *, Value * );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function inserts a key and value into the dictionary, using the hash function on the key
 to determine to which bucket it should be stored.&nbsp; If allocation of the node to store the key-value pair fails, then
 the<tt> out_of_memory</tt> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not
 be completed.
<br>At some point, the number of buckets initially selected may be too small for the number of elements inserted.&nbsp; The
 resize of the dictionary can be controlled by the insertion mechanism by using<tt> WCPtrHashDict</tt> as a base class, and
 providing an insert member function to do a resize when appropriate.&nbsp; This insert could then call<tt> WCPtrHashDict::insert</tt>
 to insert the element.&nbsp; Note that copy constructors and assignment operators are not inherited in your class, but you
 can provide the following inline definitions (assuming that the class inherited from WCPtrHashDict is named MyHashDict):
<br><br><tt>inline MyHashDict( const MyHashDict &amp;orig ) : WCPtrHashDict( orig ) {};</tt>
<br><tt>inline MyHashDict &amp;operator=( const MyHashDict &amp;orig ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( WCPtrHashDict::operator=( orig ) );</tt>
<br><tt>}</tt>
<dt><br>Results:
<dd>The<tt> insert</tt> public member function inserts a key and value into the dictionary.&nbsp; If the insert is successful,
 a non-zero will returned.&nbsp; A zero will be returned if the insert fails.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__isEmptyLR"> isEmpty() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if the dictionary is empty.
<dt><br>Results:
<dd>The<tt> isEmpty</tt> public member function returns zero if it contains at least one entry, non-zero if the dictionary is
 empty.
<dt><br>See Also:
<dd><tt> buckets</tt>,<tt> entries</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__operator_UVLR"> operator &#91;&#93;() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value * &amp; operator&#91;&#93;( const Key &amp; );</tt>
<dt><br>Semantics:
<dd><tt> operator &#91;&#93;</tt> is the dictionary index operator.&nbsp; A reference to the object stored in the dictionary with
 the given<tt> Key</tt> is returned.&nbsp; If no equivalent element is found, then a new key-value pair is created with the
 specified<tt> Key</tt> value, and initialized with the default constructor.&nbsp; The returned reference can then be assigned
 to, so that insertions can be made with the operator.&nbsp; If an allocation error occurs while inserting a new key-value
 pair, then the<tt> out_of_memory</tt> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, then a
 reference to address zero will be returned.&nbsp; This will result in a run-time error on systems which trap address zero
 references.
<dt><br>Results:
<dd>The<tt> operator &#91;&#93;</tt> public member function returns a reference to the element at the given key value.&nbsp; If
 the key does not exist, a reference to a created element is returned.&nbsp; The result of the operator may be assigned to.
<dt><br>See Also:
<dd><tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value * const &amp; operator&#91;&#93;( const Key * ) const;</tt>
<dt><br>Semantics:
<dd><tt> operator &#91;&#93;</tt> is the dictionary index operator.&nbsp; A constant reference to the object stored in the dictionary
 with the given<tt> Key</tt> is returned.&nbsp; If no equivalent element is found, then the<tt> index_range</tt> exception
 is thrown if it is enabled.&nbsp; If the exception is not enabled, then a reference to address zero will be returned.&nbsp;
 This will result in a run-time error on systems which trap address zero references.
<dt><br>Results:
<dd>The<tt> operator &#91;&#93;</tt> public member function returns a constant reference to the element at the given key value.
&nbsp; The result of the operator may not be assigned to.
<dt><br>See Also:
<dd><tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__operator_ELR"> operator =() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashDict &amp; operator =( const WCPtrHashDict &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the<tt> WCPtrHashDict&lt;Key,Value&gt;</tt>
 class.&nbsp; The left hand side dictionary is first cleared using the<tt> clear</tt> member function, and then the right
 hand side dictionary is copied.&nbsp; The hash function, exception trap states, and all of the dictionary elements are copied.
&nbsp; If an allocation failure occurs when creating the buckets, the table will be created with zero buckets, and the<tt>
 out_of_memory</tt> exception is thrown if it is enabled.&nbsp; If there is not enough memory to copy all of the values or
 pointers in the dictionary, then only some will be copied, and the<tt> out_of_memory</tt> exception is thrown if it is enabled.
&nbsp; The number of entries will correctly reflect the number copied.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the left hand side dictionary to be a copy of the right hand side.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__operator_EELR"> operator ==() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ==( const WCPtrHashDict &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the<tt> WCPtrHashDict&lt;Key,Value&gt;</tt>
 class.&nbsp; Two dictionary objects are equivalent if they are the same object and share the same address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side and right hand side dictionary are the same object.&nbsp; A FALSE
 (zero) value is returned otherwise.
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__removeLR"> remove() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value * remove( const Key * );</tt>
<dt><br>Semantics:
<dd>The<tt> remove</tt> public member function is used to remove the specified element from the dictionary.&nbsp; If an equivalent
 element is found, the pointer value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence
 is based on the equivalence operator of the<tt> Key</tt> type.
<dt><br>Results:
<dd>The element is removed from the dictionary if it found.
</dl>
<h2 id="WCPtrHashDictXKey_ValueY__resizeLR"> resize() &#91;WCPtrHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void resize( unsigned );</tt>
<dt><br>Semantics:
<dd>The<tt> resize</tt> public member function is used to change the number of buckets contained in the dictionary.&nbsp; If the
 new number is larger than the previous dictionary size, then the hash function will be used on all of the stored elements
 to determine which bucket they should be stored into.&nbsp; Entries are not destroyed or created in the process of being
 moved.&nbsp; If there is not enough memory to resize the dictionary, the<tt> out_of_memory</tt> exception is thrown if it
 is enabled, and the dictionary will contain the number of buckets it contained before the resize.&nbsp; If the new number
 is zero, then the<tt> zero_buckets</tt> exception is thrown if it is enabled, and no resize will be performed.&nbsp; The
 dictionary is guaranteed to contain the same number of entries after the resize.
<dt><br>Results:
<dd>The dictionary is resized to the new number of buckets.
<dt><br>See Also:
<dd><tt> WCExcept::out_of_memory</tt>,<tt> WCExcept::zero_buckets</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY__WCPtrHashSetXTypeY_Class_Description"> WCPtrHashTable&lt;Type&gt;, WCPtrHashSet&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wchash.h</tt>
<br><tt>WCPtrHashTable&lt;Type&gt;</tt> and<tt> WCPtrHashSet&lt;Type&gt;</tt> classes are templated classes used to store
 objects in a hash.&nbsp; A hash saves objects in such a way as to make it efficient to locate and retrieve an element.&nbsp;
 As an element is looked up or inserted into the hash, the value of the element is hashed.&nbsp; Hashing results in a numeric
 index which is used to locate the value.&nbsp; The storage area referenced by the hash value is usually called a bucket.
&nbsp; If more than one element results in the same hash, the value associated with the hash is placed in a list stored in
 the bucket.&nbsp; A hash table allows more than one copy of an element that is equivalent, while the hash set allows only
 one copy.&nbsp; The equality operator of the element's type is used to locate the value.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the template parameter defining
 the type of the data pointed to by the pointers stored in the hash.
<br><br>The constructor for the<tt> WCPtrHashTable&lt;Type&gt;</tt> and<tt> WCPtrHashSet&lt;Type&gt;</tt> classes requires
 a hashing function, which given a reference to<tt> Type,</tt> returns an<tt> unsigned</tt> value.&nbsp; The returned value
 modulo the number of buckets determines the bucket into which the element will be located.&nbsp; The return values of the
 hash function can be spread over the entire range of unsigned numbers.&nbsp; The hash function return value must be the same
 for values which are equivalent by the equivalence operator for<tt> Type.</tt>
<br><br>Note that pointers to the elements are stored in the hash.&nbsp; Destructors are not called on the elements pointed
 to.&nbsp; The data values pointed to in the hash should not be changed such that the equivalence to the old value is modified.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCPtrHashTable&lt;Type&gt;</tt> and<tt> WCPtrHashSet&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCPtrHashTable&lt;Type&gt;</tt> and<tt> WCPtrHashSet&lt;Type&gt;</tt> objects.&nbsp; No exceptions are
 enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Type</b>
<br><br>The<tt> WCPtrHashTable&lt;Type&gt;</tt> and<tt> WCPtrHashSet&lt;Type&gt;</tt> classes requires<tt> Type</tt> to have:
<br>A well defined equivalence operator with constant parameters
<br><br>(<tt> int operator ==( const Type &amp; ) const</tt> ).
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCPtrHashSet( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE );</tt>
<br><tt> WCPtrHashSet( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE, void * (*user_alloc)( size_t
 size ), void (*user_dealloc)( void *old, size_t size ) );</tt>
<br><tt> WCPtrHashSet( const WCPtrHashSet &amp; );</tt>
<br><tt> virtual ~WCPtrHashSet();</tt>
<br><tt> WCPtrHashTable( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE );</tt>
<br><tt> WCPtrHashTable( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE, void * (*user_alloc)( size_t
 size ), void (*user_dealloc)( void *old, size_t size ) );</tt>
<br><tt> WCPtrHashTable( const WCPtrHashTable &amp; );</tt>
<br><tt> virtual ~WCPtrHashTable();</tt>
<br><tt> static unsigned bitHash( const void *, size_t );</tt>
<br><tt> unsigned buckets() const;</tt>
<br><tt> void clear();</tt>
<br><tt> void clearAndDestroy();</tt>
<br><tt> int contains( const Type * ) const;</tt>
<br><tt> unsigned entries() const;</tt>
<br><tt> Type * find( const Type * ) const;</tt>
<br><tt> void forAll( void (*user_fn)( Type *, void * ) , void * );</tt>
<br><tt> int insert( Type * );</tt>
<br><tt> int isEmpty() const;</tt>
<br><tt> Type * remove( const Type * );</tt>
<br><tt> void resize( unsigned );</tt>
<br><br>The following public member functions are available for the<tt> WCPtrHashTable</tt> class only:
<br><br><tt>unsigned occurrencesOf( const Type * ) const;</tt>
<br><tt> unsigned removeAll( const Type * );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>WCPtrHashSet &amp; operator =( const WCPtrHashSet &amp; );</tt>
<br><tt> int operator ==( const WCPtrHashSet &amp; ) const;</tt>
<br><tt> WCPtrHashTable &amp; operator =( const WCPtrHashTable &amp; );</tt>
<br><tt> int operator ==( const WCPtrHashTable &amp; ) const;</tt>
</dl>
<h2 id="WCPtrHashSetXTypeY__WCPtrHashSetLR"> WCPtrHashSet() &#91;WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashSet( unsigned (*hash_fn)( const Type &amp; ),</tt>
<br><tt> unsigned = WC_DEFAULT_HASH_SIZE );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrHashSet&lt;Type&gt;</tt> constructor creates a<tt> WCPtrHashSet</tt> object with no entries and with the number
 of buckets in the second optional parameter, which defaults to the constant<tt> WC_DEFAULT_HASH_SIZE</tt> (currently defined
 as 101).&nbsp; The number of buckets specified must be greater than zero, and will be forced to at least one.&nbsp; If the
 hash object can be created, but an allocation failure occurs when creating the buckets, the table will be created with zero
 buckets.&nbsp; If the<tt> out_of_memory</tt> exception is enabled, then attempting to insert into a hash table with zero
 buckets with throw an<tt> out_of_memory</tt> error.
<br>The hash function<tt> hash_fn</tt> is used to determine which bucket each value will be assigned to.&nbsp; If no hash
 function exists, the static member function<tt> bitHash</tt> is available to help create one.
<dt><br>Results:
<dd>The<tt> WCPtrHashSet&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrHashSet</tt> object with the specified number
 of buckets and hash function.
<dt><br>See Also:
<dd><tt> ~WCPtrHashSet</tt>,<tt> bitHash</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashSet( unsigned (*hash_fn)( const Type &amp; ),</tt>
<br><tt> unsigned = WC_DEFAULT_HASH_SIZE,</tt>
<br><tt>void * (*user_alloc)( size_t ),</tt>
<br><tt>void (*user_dealloc)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>Allocator and deallocator functions are specified for use when entries are inserted and removed from the hash.&nbsp; The semantics
 of this constructor are the same as the constructor without the memory management functions.
<br>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is passed
 the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic that the
 allocation function will always be called with the same size value for any particular instantiation of a hash.&nbsp; To determine
 the size of the objects that the memory management functions will be required to allocate and free, the following macro may
 be used:
<br><br><tt>WCPtrHashSetItemSize( Type )</tt>
<dt><br>Results:
<dd>The<tt> WCPtrHashSet&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrHashSet</tt> object with the specified number
 of buckets and hash function.
<dt><br>See Also:
<dd><tt> ~WCPtrHashSet</tt>,<tt> bitHash</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashSet( const WCPtrHashSet &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrHashSet&lt;Type&gt;</tt> is the copy constructor for the<tt> WCPtrHashSet</tt> class.&nbsp; The new hash is created
 with the same number of buckets, hash function, all values or pointers stored in the hash, and the exception trap states.
&nbsp; If the hash object can be created, but an allocation failure occurs when creating the buckets, the hash will be created
 with zero buckets.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied, and the
 number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<tt> out_of_memory</tt>
 exception is thrown if it is enabled.
<dt><br>Results:
<dd>The<tt> WCPtrHashSet&lt;Type&gt;</tt> constructor creates a<tt> WCPtrHashSet</tt> object which is a copy of the passed hash.
<dt><br>See Also:
<dd><tt> ~WCPtrHashSet</tt>,<tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrHashSetXTypeY____WCPtrHashSetLR"> ~WCPtrHashSet() &#91;WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCPtrHashSet();</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrHashSet&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCPtrHashSet</tt> class.&nbsp; If the number
 of elements is not zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise, the hash
 elements are cleared using the<tt> clear</tt> member function.&nbsp; The objects which the hash elements point to are not
 deleted unless the<tt> clearAndDestroy</tt> member function is explicitly called before the destructor is called.&nbsp; The
 call to the<tt> WCPtrHashSet&lt;Type&gt;</tt> destructor is inserted implicitly by the compiler at the point where the<tt>
 WCPtrHashSet</tt> object goes out of scope.
<dt><br>Results:
<dd>The call to the<tt> WCPtrHashSet&lt;Type&gt;</tt> destructor destroys a<tt> WCPtrHashSet</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY__WCPtrHashTableLR"> WCPtrHashTable() &#91;WCPtrHashTable&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashTable( unsigned (*hash_fn)( const Type &amp; ),</tt>
<br><tt> unsigned = WC_DEFAULT_HASH_SIZE );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrHashTable&lt;Type&gt;</tt> constructor creates a<tt> WCPtrHashTable</tt> object with no entries and with the
 number of buckets in the second optional parameter, which defaults to the constant<tt> WC_DEFAULT_HASH_SIZE</tt> (currently
 defined as 101).&nbsp; The number of buckets specified must be greater than zero, and will be forced to at least one.&nbsp;
 If the hash object can be created, but an allocation failure occurs when creating the buckets, the table will be created
 with zero buckets.&nbsp; If the<tt> out_of_memory</tt> exception is enabled, then attempting to insert into a hash table
 with zero buckets with throw an<tt> out_of_memory</tt> error.
<br>The hash function<tt> hash_fn</tt> is used to determine which bucket each value will be assigned to.&nbsp; If no hash
 function exists, the static member function<tt> bitHash</tt> is available to help create one.
<dt><br>Results:
<dd>The<tt> WCPtrHashTable&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrHashTable</tt> object with the specified
 number of buckets and hash function.
<dt><br>See Also:
<dd><tt> ~WCPtrHashTable</tt>,<tt> bitHash</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashTable( unsigned (*hash_fn)( const Type &amp; ),</tt>
<br><tt> unsigned = WC_DEFAULT_HASH_SIZE,</tt>
<br><tt>void * (*user_alloc)( size_t ),</tt>
<br><tt>void (*user_dealloc)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>Allocator and deallocator functions are specified for use when entries are inserted and removed from the hash.&nbsp; The semantics
 of this constructor are the same as the constructor without the memory management functions.
<br>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is passed
 the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic that the
 allocation function will always be called with the same size value for any particular instantiation of a hash.&nbsp; To determine
 the size of the objects that the memory management functions will be required to allocate and free, the following macro may
 be used:
<br><br><tt>WCPtrHashTableItemSize( Type )</tt>
<dt><br>Results:
<dd>The<tt> WCPtrHashTable&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrHashTable</tt> object with the specified
 number of buckets and hash function.
<dt><br>See Also:
<dd><tt> ~WCPtrHashTable</tt>,<tt> bitHash</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashTable( const WCPtrHashTable &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrHashTable&lt;Type&gt;</tt> is the copy constructor for the<tt> WCPtrHashTable</tt> class.&nbsp; The new hash
 is created with the same number of buckets, hash function, all values or pointers stored in the hash, and the exception trap
 states.&nbsp; If the hash object can be created, but an allocation failure occurs when creating the buckets, the hash will
 be created with zero buckets.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied,
 and the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<tt>
 out_of_memory</tt> exception is thrown if it is enabled.
<dt><br>Results:
<dd>The<tt> WCPtrHashTable&lt;Type&gt;</tt> constructor creates a<tt> WCPtrHashTable</tt> object which is a copy of the passed
 hash.
<dt><br>See Also:
<dd><tt> ~WCPtrHashTable</tt>,<tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY____WCPtrHashTableLR"> ~WCPtrHashTable() &#91;WCPtrHashTable&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCPtrHashTable();</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrHashTable&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCPtrHashTable</tt> class.&nbsp; If the number
 of elements is not zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise, the hash
 elements are cleared using the<tt> clear</tt> member function.&nbsp; The objects which the hash elements point to are not
 deleted unless the<tt> clearAndDestroy</tt> member function is explicitly called before the destructor is called.&nbsp; The
 call to the<tt> WCPtrHashTable&lt;Type&gt;</tt> destructor is inserted implicitly by the compiler at the point where the<tt>
 WCPtrHashTable</tt> object goes out of scope.
<dt><br>Results:
<dd>The call to the<tt> WCPtrHashTable&lt;Type&gt;</tt> destructor destroys a<tt> WCPtrHashTable</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY__bitHashLR__WCPtrHashSetXTypeY__bitHashLR"> bitHash() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>static unsigned bitHash( void *, size_t );</tt>
<dt><br>Semantics:
<dd>The<tt> bitHash</tt> public member function can be used to implement a hashing function for any type.&nbsp; A hashing value
 is generated from the value stored for the number of specified bytes pointed to by the first parameter.
<dt><br>Results:
<dd>The<tt> bitHash</tt> public member function returns an unsigned value which can be used as the basis of a user defined hash
 function.
<dt><br>See Also:
<dd><tt> WCPtrHashSet</tt>,<tt> WCPtrHashTable</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY__bucketsLR__WCPtrHashSetXTypeY__bucketsLR"> buckets() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned buckets() const;</tt>
<dt><br>Semantics:
<dd>The<tt> buckets</tt> public member function is used to find the number of buckets contained in the hash object.
<dt><br>Results:
<dd>The<tt> buckets</tt> public member function returns the number of buckets in the hash.
<dt><br>See Also:
<dd><tt> resize</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY__clearLR__WCPtrHashSetXTypeY__clearLR"> clear() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the hash so that it has no entries.&nbsp; The number of buckets
 remain unaffected.&nbsp; Objects pointed to by the hash elements are not deleted.&nbsp; The hash object is not destroyed
 and re-created by this function, so the object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function clears the hash to have no elements.
<dt><br>See Also:
<dd><tt> ~WCPtrHashSet</tt>,<tt> ~WCPtrHashTable</tt>,<tt> clearAndDestroy</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY_WCPtrHashSetXTypeY__clearAndDestroyLR"> clearAndDestroy() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clearAndDestroy();</tt>
<dt><br>Semantics:
<dd>The<tt> clearAndDestroy</tt> public member function is used to clear the hash and delete the objects pointed to by the hash
 elements.&nbsp; The hash object is not destroyed and re-created by this function, so the hash object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clearAndDestroy</tt> public member function clears the hash by deleting the objects pointed to by the hash elements.
<dt><br>See Also:
<dd><tt> clear</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY__containsLR__WCPtrHashSetXTypeY__containsLR"> contains() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int contains( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> contains</tt> public member function returns non-zero if the element is stored in the hash, or zero if there is no
 equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The<tt> contains</tt> public member function returns a non-zero value if the element is found in the hash.
<dt><br>See Also:
<dd><tt> find</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY__entriesLR__WCPtrHashSetXTypeY__entriesLR"> entries() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to return the current number of elements stored in the hash.
<dt><br>Results:
<dd>The<tt> entries</tt> public member function returns the number of elements in the hash.
<dt><br>See Also:
<dd><tt> buckets</tt>,<tt> isEmpty</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY__findLR__WCPtrHashSetXTypeY__findLR"> find() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * find( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> find</tt> public member function is used to find an element with an equivalent key in the hash.&nbsp; If an equivalent
 element is found, a pointer to the element is returned.&nbsp; Zero is returned if the element is not found.&nbsp; Note that
 equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The element equivalent to the passed key is located in the hash.
</dl>
<h2 id="WCPtrHashTableXTypeY__forAllLR__WCPtrHashSetXTypeY__forAllLR"> forAll() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void forAll(</tt>
<br><tt> void (*user_fn)( Type *, void * ),</tt>
<br><tt>void * );</tt>
<dt><br>Semantics:
<dd>The<tt> forAll</tt> public member function causes the user supplied function to be invoked for every value in the hash.&nbsp;
 The user function has the prototype
<br><tt>void user_func( Type * value, void * data );</tt>
<br><br>As the elements are visited, the user function is invoked with the element passed as the first.&nbsp; The second parameter
 of the<tt> forAll</tt> function is passed as the second parameter to the user function.&nbsp; This value can be used to pass
 any appropriate data from the main code to the user function.
<dt><br>Results:
<dd>The elements in the hash are all visited, with the user function being invoked for each one.
<dt><br>See Also:
<dd><tt> find</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY__insertLR__WCPtrHashSetXTypeY__insertLR"> insert() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function inserts a value into the hash, using the hash function to determine to which bucket
 it should be stored.&nbsp; If allocation of the node to store the value fails, then the<tt> out_of_memory</tt> exception
 is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not be completed.
<br>With a<tt> WCPtrHashSet,</tt> there must be only one equivalent element in the set.&nbsp; If an element equivalent to
 the inserted element is already in the hash set, the hash set will remain unchanged, and the<tt> not_unique</tt> exception
 is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not be completed.
<br><br>At some point, the number of buckets initially selected may be too small for the number of elements inserted.&nbsp;
 The resize of the hash can be controlled by the insertion mechanism by using<tt> WCPtrHashSet</tt> (or<tt> WCPtrHashTable</tt>)
 as a base class, and providing an insert member function to do a resize when appropriate.&nbsp; This insert could then call<tt>
 WCPtrHashSet::insert</tt> (or<tt> WCPtrHashTable::insert</tt>) to insert the element.&nbsp; Note that copy constructors and
 assignment operators are not inherited in your class, but you can provide the following inline definitions (assuming that
 the class inherited from WCPtrHashTable is named MyHashTable):
<br><br><tt>inline MyHashTable( const MyHashTable &amp;orig )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; : WCPtrHashTable( orig ) {};</tt>
<br><tt>inline MyHashTable &amp;operator=( const MyHashTable &amp;orig ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( WCPtrHashTable::operator=( orig ) );</tt>
<br><tt>}</tt>
<dt><br>Results:
<dd>The<tt> insert</tt> public member function inserts a value into the hash.&nbsp; If the insert is successful, a non-zero will
 returned.&nbsp; A zero will be returned if the insert fails.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY__isEmptyLR__WCPtrHashSetXTypeY__isEmptyLR"> isEmpty() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if the hash is empty.
<dt><br>Results:
<dd>The<tt> isEmpty</tt> public member function returns zero if it contains at least one entry, non-zero if the hash is empty.
<dt><br>See Also:
<dd><tt> buckets</tt>,<tt> entries</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY__occurencesOfLR"> occurencesOf() &#91;WCPtrHashTable&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned occurrencesOf( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> occurencesOf</tt> public member function is used to return the current number of elements stored in the hash which
 are equivalent to the passed value.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The<tt> occurencesOf</tt> public member function returns the number of elements in the hash.
<dt><br>See Also:
<dd><tt> buckets</tt>,<tt> entries</tt>,<tt> find</tt>,<tt> isEmpty</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY__operator_ELR__WCPtrHashSetXTypeY__operator_ELR"> operator =() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashSet &amp; operator =( const WCPtrHashSet &amp; );</tt>
<br><tt> WCPtrHashTable &amp; operator =( const WCPtrHashTable &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the<tt> WCPtrHashTable&lt;Type&gt;</tt> and<tt>
 WCPtrHashSet&lt;Type&gt;</tt> classes.&nbsp; The left hand side hash is first cleared using the<tt> clear</tt> member function,
 and then the right hand side hash is copied.&nbsp; The hash function, exception trap states, and all of the hash elements
 are copied.&nbsp; If an allocation failure occurs when creating the buckets, the table will be created with zero buckets,
 and the<tt> out_of_memory</tt> exception is thrown if it is enabled.&nbsp; If there is not enough memory to copy all of the
 values or pointers in the hash, then only some will be copied, and the<tt> out_of_memory</tt> exception is thrown if it is
 enabled.&nbsp; The number of entries will correctly reflect the number copied.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the left hand side hash to be a copy of the right hand side.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrHashTableXTypeY__operator_EELR__WCPtrHashSetXTypeY__operator_EELR"> operator ==() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ==( const WCPtrHashSet &amp; ) const;</tt>
<br><tt> int operator ==( const WCPtrHashTable &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the<tt> WCPtrHashTable&lt;Type&gt;</tt> and<tt>
 WCPtrHashSet&lt;Type&gt;</tt> classes.&nbsp; Two hash objects are equivalent if they are the same object and share the same
 address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side and right hand side hash are the same object.&nbsp; A FALSE (zero)
 value is returned otherwise.
</dl>
<h2 id="WCPtrHashTableXTypeY__removeLR__WCPtrHashSetXTypeY__removeLR"> remove() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * remove( const Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> remove</tt> public member function is used to remove the specified element from the hash.&nbsp; If an equivalent element
 is found, the pointer value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; If the hash is a table
 and there is more than one element equivalent to the specified element, then the first equivalent element added to the table
 is removed.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The element is removed from the hash if it found.
</dl>
<h2 id="WCPtrHashTableXTypeY__removeAllLR"> removeAll() &#91;WCPtrHashTable&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned removeAll( const Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> removeAll</tt> public member function is used to remove all elements equivalent to the specified element from the
 hash.&nbsp; Zero is returned if no equivalent elements are found.&nbsp; Note that equivalence is based on the equivalence
 operator of the element type.
<dt><br>Results:
<dd>All equivalent elements are removed from the hash.
</dl>
<h2 id="WCPtrHashTableXTypeY__resizeLR__WCPtrHashSetXTypeY__resizeLR"> resize() &#91;WCPtrHashTable&lt;Type&gt;,WCPtrHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void resize( unsigned );</tt>
<dt><br>Semantics:
<dd>The<tt> resize</tt> public member function is used to change the number of buckets contained in the hash.&nbsp; If the new
 number is larger than the previous hash size, then the hash function will be used on all of the stored elements to determine
 which bucket they should be stored into.&nbsp; Entries are not destroyed or created in the process of being moved.&nbsp;
 If there is not enough memory to resize the hash, the<tt> out_of_memory</tt> exception is thrown if it is enabled, and the
 hash will contain the number of buckets it contained before the resize.&nbsp; If the new number is zero, then the<tt> zero_buckets</tt>
 exception is thrown if it is enabled, and no resize will be performed.&nbsp; The hash is guaranteed to contain the same number
 of entries after the resize.
<dt><br>Results:
<dd>The hash is resized to the new number of buckets.
<dt><br>See Also:
<dd><tt> WCExcept::out_of_memory</tt>,<tt> WCExcept::zero_buckets</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY_Class_Description"> WCValHashDict&lt;Key,Value&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wchash.h</tt>
<br>The<tt> WCValHashDict&lt;Key,Value&gt;</tt> class is a templated class used to store objects in a dictionary.&nbsp; Dictionaries
 store values with an associated key, which may be of any type.&nbsp; One example of a dictionary used in everyday life is
 the phone book.&nbsp; The phone numbers are the data values, and the customer name is the key.&nbsp; An example of a specialized
 dictionary is a vector, where the key value is the integer index.
<br>As an element is looked up or inserted into the dictionary, the associated key is hashed.&nbsp; Hashing converts the key
 into a numeric index value which is used to locate the value.&nbsp; The storage area referenced by the hash value is usually
 called a bucket.&nbsp; If more than one key results in the same hash, the values associated with the keys are placed in a
 list stored in the bucket.&nbsp; The equality operator of the key's type is used to locate the key-value pairs.
<br><br>In the description of each member function, the text<tt> Key</tt> is used to indicate the template parameter defining
 the type of the indices used to store data in the dictionary.&nbsp; The text<tt> Value</tt> is used to indicate the template
 parameter defining the type of the data stored in the dictionary.
<br><br>The constructor for the<tt> WCValHashDict&lt;Key,Value&gt;</tt> class requires a hashing function, which given a reference
 to<tt> Key,</tt> returns an<tt> unsigned</tt> value.&nbsp; The returned value modulo the number of buckets determines the
 bucket into which the key-value pair will be located.&nbsp; The return values of the hash function can be spread over the
 entire range of unsigned numbers.&nbsp; The hash function return value must be the same for values which are equivalent by
 the equivalence operator for<tt> Key.</tt>
<br><br>Values are copied into the dictionary, which could be undesirable if the stored objects are complicated and copying
 is expensive.&nbsp; Value dictionaries should not be used to store objects of a base class if any derived types of different
 sizes would be stored in the dictionary, or if the destructor for a derived class must be called.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCValHashDict&lt;Key,Value&gt;</tt> class and provides the<tt>
 exceptions</tt> member function.&nbsp; This member function controls the exceptions which can be thrown by the<tt> WCValHashDict&lt;Key,Value&gt;</tt>
 object.&nbsp; No exceptions are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Key and Value</b>
<br><br>The<tt> WCValHashDict&lt;Key,Value&gt;</tt> class requires<tt> Key</tt> to have:
<br>A default constructor (<tt> Key::Key()</tt> ).
<br><br>A well defined copy constructor (<tt> Key::Key( const Key &amp; )</tt> ).
<br><br>A well defined assignment operator (<tt> Key &amp; operator =( const Key &amp; )</tt> ).
<br><br>A well defined equivalence operator with constant parameters
<br><br>(<tt> int operator ==( const Key &amp; ) const</tt> ).
<br>The<tt> WCValHashDict&lt;Key,Value&gt;</tt> class requires<tt> Value</tt> to have:
<br><br>A default constructor (<tt> Value::Value()</tt> ).
<br><br>A well defined copy constructor (<tt> Value::Value( const Value &amp; )</tt> ).
<br><br>A well defined assignment operator (<tt> Value &amp; operator =( const Value &amp; )</tt> ).
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCValHashDict( unsigned (*hash_fn)( const Key &amp; ), unsigned = WC_DEFAULT_HASH_SIZE );</tt>
<br><tt> WCValHashDict( unsigned (*hash_fn)( const Key &amp; ), unsigned = WC_DEFAULT_HASH_SIZE, void * (*user_alloc)( size_t
 size ), void (*user_dealloc)( void *old, size_t size ) );</tt>
<br><tt> WCValHashDict( const WCValHashDict &amp; );</tt>
<br><tt> virtual ~WCValHashDict();</tt>
<br><tt> static unsigned bitHash( const void *, size_t );</tt>
<br><tt> unsigned buckets() const;</tt>
<br><tt> void clear();</tt>
<br><tt> int contains( const Key &amp; ) const;</tt>
<br><tt> unsigned entries() const;</tt>
<br><tt> int find( const Key &amp;, Value &amp; ) const;</tt>
<br><tt> int findKeyAndValue( const Key &amp;, Key &amp;, Value &amp; ) const;</tt>
<br><tt> void forAll( void (*user_fn)( Key, Value, void * ), void * );</tt>
<br><tt> int insert( const Key &amp;, const Value &amp; );</tt>
<br><tt> int isEmpty() const;</tt>
<br><tt> int remove( const Key &amp; );</tt>
<br><tt> void resize( unsigned );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>Value &amp; operator &#91;&#93;( const Key &amp; );</tt>
<br><tt> const Value &amp; operator &#91;&#93;( const Key &amp; ) const;</tt>
<br><tt> WCValHashDict &amp; operator =( const WCValHashDict &amp; );</tt>
<br><tt> int operator ==( const WCValHashDict &amp; ) const;</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__WCValHashDictLR"> WCValHashDict() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashDict( unsigned (*hash_fn)( const Key &amp; ),</tt>
<br><tt> unsigned = WC_DEFAULT_HASH_SIZE );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCValHashDict&lt;Key,Value&gt;</tt> constructor creates an<tt> WCValHashDict&lt;Key,Value&gt;</tt> object with
 no entries and with the number of buckets in the second optional parameter, which defaults to the constant<tt> WC_DEFAULT_HASH_SIZE</tt>
 (currently defined as 101).&nbsp; The number of buckets specified must be greater than zero, and will be forced to at least
 one.&nbsp; If the hash dictionary object can be created, but an allocation failure occurs when creating the buckets, the
 table will be created with zero buckets.&nbsp; If the<tt> out_of_memory</tt> exception is enabled, then attempting to insert
 into a hash table with zero buckets with throw an<tt> out_of_memory</tt> error.
<br>The hash function<tt> hash_fn</tt> is used to determine which bucket each key-value pair will be assigned.&nbsp; If no
 hash function exists, the static member function<tt> bitHash</tt> is available to help create one.
<dt><br>Results:
<dd>The public<tt> WCValHashDict&lt;Key,Value&gt;</tt> constructor creates an initialized<tt> WCValHashDict&lt;Key,Value&gt;</tt>
 object with the specified number of buckets and hash function.
<dt><br>See Also:
<dd><tt> ~WCValHashDict</tt>,<tt> bitHash</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashDict( unsigned (*hash_fn)( const Key &amp; ),</tt>
<br><tt> unsigned = WC_DEFAULT_HASH_SIZE,</tt>
<br><tt>void * (*user_alloc)( size_t ),</tt>
<br><tt>void (*user_dealloc)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>Allocator and deallocator functions are specified for use when entries are inserted and removed from the hash dictionary.
&nbsp; The semantics of this constructor are the same as the constructor without the memory management functions.
<br>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is passed
 the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic that the
 allocation function will always be called with the same size value for any particular instantiation of a hash dictionary.
&nbsp; To determine the size of the objects that the memory management functions will be required to allocate and free, the
 following macro may be used:
<br><br><tt>WCValHashDictItemSize( Key, Value )</tt>
<dt><br>Results:
<dd>The public<tt> WCValHashDict&lt;Key,Value&gt;</tt> constructor creates an initialized<tt> WCValHashDict&lt;Key,Value&gt;</tt>
 object with the specified number of buckets and hash function.
<dt><br>See Also:
<dd><tt> ~WCValHashDict</tt>,<tt> bitHash</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashDict( const WCValHashDict &amp; );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCValHashDict&lt;Key,Value&gt;</tt> constructor is the copy constructor for the<tt> WCValHashDict&lt;Key,Value&gt;</tt>
 class.&nbsp; The new dictionary is created with the same number of buckets, hash function, all values or pointers stored
 in the dictionary, and the exception trap states.&nbsp; If the hash dictionary object can be created, but an allocation failure
 occurs when creating the buckets, the table will be created with zero buckets.&nbsp; If there is not enough memory to copy
 all of the values in the dictionary, then only some will be copied, and the number of entries will correctly reflect the
 number copied.&nbsp; If all of the elements cannot be copied, then the<tt> out_of_memory</tt> exception is thrown if it is
 enabled.
<dt><br>Results:
<dd>The public<tt> WCValHashDict&lt;Key,Value&gt;</tt> constructor creates an<tt> WCValHashDict&lt;Key,Value&gt;</tt> object which
 is a copy of the passed dictionary.
<dt><br>See Also:
<dd><tt> ~WCValHashDict</tt>,<tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY____WCValHashDictLR"> ~WCValHashDict() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCValHashDict();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCValHashDict&lt;Key,Value&gt;</tt> destructor is the destructor for the<tt> WCValHashDict&lt;Key,Value&gt;</tt>
 class.&nbsp; If the number of dictionary elements is not zero and the<tt> not_empty</tt> exception is enabled, the exception
 is thrown.&nbsp; Otherwise, the dictionary elements are cleared using the<tt> clear</tt> member function.&nbsp; The call
 to the public<tt> ~WCValHashDict&lt;Key,Value&gt;</tt> destructor is inserted implicitly by the compiler at the point where
 the<tt> WCValHashDict&lt;Key,Value&gt;</tt> object goes out of scope.
<dt><br>Results:
<dd>The public<tt> ~WCValHashDict&lt;Key,Value&gt;</tt> destructor destroys an<tt> WCValHashDict&lt;Key,Value&gt;</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__bitHashLR"> bitHash() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>static unsigned bitHash( void *, size_t );</tt>
<dt><br>Semantics:
<dd>The<tt> bitHash</tt> public member function can be used to implement a hashing function for any type.&nbsp; A hashing value
 is generated from the value stored for the number of specified bytes pointed to by the first parameter.&nbsp; For example:
<br><tt>unsigned my_hash_fn( const int &amp; key ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( WCValHashDict&lt;int,String&gt;::bitHash( &amp;key, sizeof( int ) );</tt>
<br><tt>}</tt>
<br><tt>WCValHashDict&lt;int,String&gt; data_object( &amp;my_hash_fn );</tt>
<dt><br>Results:
<dd>The<tt> bitHash</tt> public member function returns an unsigned value which can be used as the basis of a user defined hash
 function.
<dt><br>See Also:
<dd><tt> WCValHashDict</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__bucketsLR"> buckets() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned buckets const;</tt>
<dt><br>Semantics:
<dd>The<tt> buckets</tt> public member function is used to find the number of buckets contained in the<tt> WCValHashDict&lt;Key,Value&gt;</tt>
 object.
<dt><br>Results:
<dd>The<tt> buckets</tt> public member function returns the number of buckets in the dictionary.
<dt><br>See Also:
<dd><tt> resize</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__clearLR"> clear() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the dictionary so that it has no entries.&nbsp; The number of buckets
 remain unaffected.&nbsp; Elements stored in the dictionary are destroyed using the destructors of<tt> Key</tt> and of<tt>
 Value.</tt>&nbsp; The dictionary object is not destroyed and re-created by this function, so the object destructor is not
 invoked.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function clears the dictionary to have no elements.
<dt><br>See Also:
<dd><tt> ~WCValHashDict</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__containsLR"> contains() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int contains( const Key &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> contains</tt> public member function returns non-zero if an element with the specified key is stored in the dictionary,
 or zero if there is no equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the<tt> Key</tt>
 type.
<dt><br>Results:
<dd>The<tt> contains</tt> public member function returns a non-zero value if the<tt> Key</tt> is found in the dictionary.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> findKeyAndValue</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__entriesLR"> entries() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to return the current number of elements stored in the dictionary.
<dt><br>Results:
<dd>The<tt> entries</tt> public member function returns the number of elements in the dictionary.
<dt><br>See Also:
<dd><tt> buckets</tt>,<tt> isEmpty</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__findLR"> find() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int find( const Key &amp;, Value &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> find</tt> public member function is used to find an element with an equivalent key in the dictionary.&nbsp; If an
 equivalent element is found, a non-zero value is returned.&nbsp; The reference to a<tt> Value</tt> passed as the second argument
 is assigned the found element's<tt> Value.</tt>&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence
 is based on the equivalence operator of the<tt> Key</tt> type.
<dt><br>Results:
<dd>The element equivalent to the passed key is located in the dictionary.
<dt><br>See Also:
<dd><tt> findKeyAndValue</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__findKeyAndValueLR"> findKeyAndValue() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int findKeyAndValue( const Key &amp;, Key &amp;, Value &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> findKeyAndValue</tt> public member function is used to find an element in the dictionary with an key equivalent to
 the first parameter.&nbsp; If an equivalent element is found, a non-zero value is returned.&nbsp; The reference to a<tt>
 Key</tt> passed as the second parameter is assigned the found element's key.&nbsp; The reference to a<tt> Value</tt> passed
 as the third argument is assigned the found element's<tt> Value.</tt>&nbsp; Zero is returned if the element is not found.
&nbsp; Note that equivalence is based on the equivalence operator of the<tt> Key</tt> type.
<dt><br>Results:
<dd>The element equivalent to the passed key is located in the dictionary.
<dt><br>See Also:
<dd><tt> findKeyAndValue</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__forAllLR"> forAll() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void forAll(</tt>
<br><tt> void (*user_fn)( Key, Value, void * ),</tt>
<br><tt>void * );</tt>
<dt><br>Semantics:
<dd>The<tt> forAll</tt> public member function causes the user supplied function to be invoked for every key-value pair in the
 dictionary.&nbsp; The user function has the prototype
<br><tt>void user_func( Key key, Value value, void * data );</tt>
<br><br>As the elements are visited, the user function is invoked with the<tt> Key</tt> and<tt> Value</tt> components of the
 element passed as the first two parameters.&nbsp; The second parameter of the<tt> forAll</tt> function is passed as the third
 parameter to the user function.&nbsp; This value can be used to pass any appropriate data from the main code to the user
 function.
<dt><br>Results:
<dd>The elements in the dictionary are all visited, with the user function being invoked for each one.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> findKeyAndValue</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__insertLR"> insert() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( const Key &amp;, const Value &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function inserts a key and value into the dictionary, using the hash function on the key
 to determine to which bucket it should be stored.&nbsp; If allocation of the node to store the key-value pair fails, then
 the<tt> out_of_memory</tt> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not
 be completed.
<br>At some point, the number of buckets initially selected may be too small for the number of elements inserted.&nbsp; The
 resize of the dictionary can be controlled by the insertion mechanism by using<tt> WCValHashDict</tt> as a base class, and
 providing an insert member function to do a resize when appropriate.&nbsp; This insert could then call<tt> WCValHashDict::insert</tt>
 to insert the element.&nbsp; Note that copy constructors and assignment operators are not inherited in your class, but you
 can provide the following inline definitions (assuming that the class inherited from WCValHashDict is named MyHashDict):
<br><br><tt>inline MyHashDict( const MyHashDict &amp;orig ) : WCValHashDict( orig ) {};</tt>
<br><tt>inline MyHashDict &amp;operator=( const MyHashDict &amp;orig ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( WCValHashDict::operator=( orig ) );</tt>
<br><tt>}</tt>
<dt><br>Results:
<dd>The<tt> insert</tt> public member function inserts a key and value into the dictionary.&nbsp; If the insert is successful,
 a non-zero will returned.&nbsp; A zero will be returned if the insert fails.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__isEmptyLR"> isEmpty() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if the dictionary is empty.
<dt><br>Results:
<dd>The<tt> isEmpty</tt> public member function returns zero if it contains at least one entry, non-zero if the dictionary is
 empty.
<dt><br>See Also:
<dd><tt> buckets</tt>,<tt> entries</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__operator_UVLR"> operator &#91;&#93;() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value &amp; operator&#91;&#93;( const Key &amp; );</tt>
<dt><br>Semantics:
<dd><tt> operator &#91;&#93;</tt> is the dictionary index operator.&nbsp; A reference to the object stored in the dictionary with
 the given<tt> Key</tt> is returned.&nbsp; If no equivalent element is found, then a new key-value pair is created with the
 specified<tt> Key</tt> value, and initialized with the default constructor.&nbsp; The returned reference can then be assigned
 to, so that insertions can be made with the operator.
<br><tt>WCValHashDict&lt;int,String&gt; data_object( &amp;my_hash_fn );</tt>
<br><tt>data_object&#91; 5 &#93; = &quot;Hello&quot;;</tt>
<br><br>If an allocation error occurs while inserting a new key-value pair, then the<tt> out_of_memory</tt> exception is thrown
 if it is enabled.&nbsp; If the exception is not enabled, then a reference to address zero will be returned.&nbsp; This will
 result in a run-time error on systems which trap address zero references.
<dt><br>Results:
<dd>The<tt> operator &#91;&#93;</tt> public member function returns a reference to the element at the given key value.&nbsp; If
 the key does not exist, a reference to a created element is returned.&nbsp; The result of the operator may be assigned to.
<dt><br>See Also:
<dd><tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>const Value &amp; operator&#91;&#93;( const Key &amp; ) const;</tt>
<dt><br>Semantics:
<dd><tt> operator &#91;&#93;</tt> is the dictionary index operator.&nbsp; A constant reference to the object stored in the dictionary
 with the given<tt> Key</tt> is returned.&nbsp; If no equivalent element is found, then the<tt> index_range</tt> exception
 is thrown if it is enabled.&nbsp; If the exception is not enabled, then a reference to address zero will be returned.&nbsp;
 This will result in a run-time error on systems which trap address zero references.
<dt><br>Results:
<dd>The<tt> operator &#91;&#93;</tt> public member function returns a constant reference to the element at the given key value.
&nbsp; The result of the operator may not be assigned to.
<dt><br>See Also:
<dd><tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__operator_ELR"> operator =() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashDict &amp; operator =( const WCValHashDict &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the<tt> WCValHashDict&lt;Key,Value&gt;</tt>
 class.&nbsp; The left hand side dictionary is first cleared using the<tt> clear</tt> member function, and then the right
 hand side dictionary is copied.&nbsp; The hash function, exception trap states, and all of the dictionary elements are copied.
&nbsp; If an allocation failure occurs when creating the buckets, the table will be created with zero buckets, and the<tt>
 out_of_memory</tt> exception is thrown if it is enabled.&nbsp; If there is not enough memory to copy all of the values or
 pointers in the dictionary, then only some will be copied, and the<tt> out_of_memory</tt> exception is thrown if it is enabled.
&nbsp; The number of entries will correctly reflect the number copied.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the left hand side dictionary to be a copy of the right hand side.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValHashDictXKey_ValueY__operator_EELR"> operator ==() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ==( const WCValHashDict &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the<tt> WCValHashDict&lt;Key,Value&gt;</tt>
 class.&nbsp; Two dictionary objects are equivalent if they are the same object and share the same address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side and right hand side dictionary are the same object.&nbsp; A FALSE
 (zero) value is returned otherwise.
</dl>
<h2 id="WCValHashDictXKey_ValueY__removeLR"> remove() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int remove( const Key &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> remove</tt> public member function is used to remove the specified element from the dictionary.&nbsp; If an equivalent
 element is found, a non-zero value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence
 is based on the equivalence operator of the<tt> Key</tt> type.
<dt><br>Results:
<dd>The element is removed from the dictionary if it found.
</dl>
<h2 id="WCValHashDictXKey_ValueY__resizeLR"> resize() &#91;WCValHashDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void resize( unsigned );</tt>
<dt><br>Semantics:
<dd>The<tt> resize</tt> public member function is used to change the number of buckets contained in the dictionary.&nbsp; If the
 new number is larger than the previous dictionary size, then the hash function will be used on all of the stored elements
 to determine which bucket they should be stored into.&nbsp; Entries are not destroyed or created in the process of being
 moved.&nbsp; If there is not enough memory to resize the dictionary, the<tt> out_of_memory</tt> exception is thrown if it
 is enabled, and the dictionary will contain the number of buckets it contained before the resize.&nbsp; If the new number
 is zero, then the<tt> zero_buckets</tt> exception is thrown if it is enabled, and no resize will be performed.&nbsp; The
 dictionary is guaranteed to contain the same number of entries after the resize.
<dt><br>Results:
<dd>The dictionary is resized to the new number of buckets.
<dt><br>See Also:
<dd><tt> WCExcept::out_of_memory</tt>,<tt> WCExcept::zero_buckets</tt>
</dl>
<h2 id="WCValHashTableXTypeY__WCValHashSetXTypeY_Class_Description"> WCValHashTable&lt;Type&gt;, WCValHashSet&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wchash.h</tt>
<br><tt>WCValHashTable&lt;Type&gt;</tt> and<tt> WCValHashSet&lt;Type&gt;</tt> classes are templated classes used to store
 objects in a hash.&nbsp; A hash saves objects in such a way as to make it efficient to locate and retrieve an element.&nbsp;
 As an element is looked up or inserted into the hash, the value of the element is hashed.&nbsp; Hashing results in a numeric
 index which is used to locate the value.&nbsp; The storage area referenced by the hash value is usually called a bucket.
&nbsp; If more than one element results in the same hash, the value associated with the hash is placed in a list stored in
 the bucket.&nbsp; A hash table allows more than one copy of an element that is equivalent, while the hash set allows only
 one copy.&nbsp; The equality operator of the element's type is used to locate the value.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the template parameter defining
 the type of the data to be stored in the hash.
<br><br>The constructor for the<tt> WCValHashTable&lt;Type&gt;</tt> and<tt> WCValHashSet&lt;Type&gt;</tt> classes requires
 a hashing function, which given a reference to<tt> Type,</tt> returns an<tt> unsigned</tt> value.&nbsp; The returned value
 modulo the number of buckets determines the bucket into which the element will be located.&nbsp; The return values of the
 hash function can be spread over the entire range of unsigned numbers.&nbsp; The hash function return value must be the same
 for values which are equivalent by the equivalence operator for<tt> Type.</tt>
<br><br>Values are copied into the hash, which could be undesirable if the stored objects are complicated and copying is expensive.
&nbsp; Value hashes should not be used to store objects of a base class if any derived types of different sizes would be stored
 in the hash, or if the destructor for a derived class must be called.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCValHashTable&lt;Type&gt;</tt> and<tt> WCValHashSet&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCValHashTable&lt;Type&gt;</tt> and<tt> WCValHashSet&lt;Type&gt;</tt> objects.&nbsp; No exceptions are
 enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Type</b>
<br><br>The<tt> WCValHashTable&lt;Type&gt;</tt> and<tt> WCValHashSet&lt;Type&gt;</tt> classes requires<tt> Type</tt> to have:
<br>A default constructor (<tt> Type::Type()</tt> ).
<br><br>A well defined copy constructor (<tt> Type::Type( const Type &amp; )</tt> ).
<br><br>A well defined assignment operator (<tt> Type &amp; operator =( const Type &amp; )</tt> ).
<br><br>A well defined equivalence operator with constant parameters
<br><br>(<tt> int operator ==( const Type &amp; ) const</tt> ).
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCValHashSet( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE );</tt>
<br><tt> WCValHashSet( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE, void * (*user_alloc)( size_t
 size ), void (*user_dealloc)( void *old, size_t size ) );</tt>
<br><tt> WCValHashSet( const WCValHashSet &amp; );</tt>
<br><tt> virtual ~WCValHashSet();</tt>
<br><tt> WCValHashTable( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE );</tt>
<br><tt> WCValHashTable( unsigned (*hash_fn)( const Type &amp; ), unsigned = WC_DEFAULT_HASH_SIZE, void * (*user_alloc)( size_t
 size ), void (*user_dealloc)( void *old, size_t size ) );</tt>
<br><tt> WCValHashTable( const WCValHashTable &amp; );</tt>
<br><tt> virtual ~WCValHashTable();</tt>
<br><tt> static unsigned bitHash( const void *, size_t );</tt>
<br><tt> unsigned buckets() const;</tt>
<br><tt> void clear();</tt>
<br><tt> int contains( const Type &amp; ) const;</tt>
<br><tt> unsigned entries() const;</tt>
<br><tt> int find( const Type &amp;, Type &amp; ) const;</tt>
<br><tt> void forAll( void (*user_fn)( Type, void * ), void * );</tt>
<br><tt> int insert( const Type &amp; );</tt>
<br><tt> int isEmpty() const;</tt>
<br><tt> int remove( const Type &amp; );</tt>
<br><tt> void resize( unsigned );</tt>
<br><br>The following public member functions are available for the<tt> WCValHashTable</tt> class only:
<br><br><tt>unsigned occurrencesOf( const Type &amp; ) const;</tt>
<br><tt> unsigned removeAll( const Type &amp; );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>WCValHashSet &amp; operator =( const WCValHashSet &amp; );</tt>
<br><tt> int operator ==( const WCValHashSet &amp; ) const;</tt>
<br><tt> WCValHashTable &amp; operator =( const WCValHashTable &amp; );</tt>
<br><tt> int operator ==( const WCValHashTable &amp; ) const;</tt>
</dl>
<h2 id="WCValHashSetXTypeY__WCValHashSetLR"> WCValHashSet() &#91;WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashSet( unsigned (*hash_fn)( const Type &amp; ),</tt>
<br><tt> unsigned = WC_DEFAULT_HASH_SIZE );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValHashSet&lt;Type&gt;</tt> constructor creates a<tt> WCValHashSet</tt> object with no entries and with the number
 of buckets in the second optional parameter, which defaults to the constant<tt> WC_DEFAULT_HASH_SIZE</tt> (currently defined
 as 101).&nbsp; The number of buckets specified must be greater than zero, and will be forced to at least one.&nbsp; If the
 hash object can be created, but an allocation failure occurs when creating the buckets, the table will be created with zero
 buckets.&nbsp; If the<tt> out_of_memory</tt> exception is enabled, then attempting to insert into a hash table with zero
 buckets with throw an<tt> out_of_memory</tt> error.
<br>The hash function<tt> hash_fn</tt> is used to determine which bucket each value will be assigned to.&nbsp; If no hash
 function exists, the static member function<tt> bitHash</tt> is available to help create one.
<dt><br>Results:
<dd>The<tt> WCValHashSet&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValHashSet</tt> object with the specified number
 of buckets and hash function.
<dt><br>See Also:
<dd><tt> ~WCValHashSet</tt>,<tt> bitHash</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashSet( unsigned (*hash_fn)( const Type &amp; ),</tt>
<br><tt> unsigned = WC_DEFAULT_HASH_SIZE,</tt>
<br><tt>void * (*user_alloc)( size_t ),</tt>
<br><tt>void (*user_dealloc)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>Allocator and deallocator functions are specified for use when entries are inserted and removed from the hash.&nbsp; The semantics
 of this constructor are the same as the constructor without the memory management functions.
<br>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is passed
 the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic that the
 allocation function will always be called with the same size value for any particular instantiation of a hash.&nbsp; To determine
 the size of the objects that the memory management functions will be required to allocate and free, the following macro may
 be used:
<br><br><tt>WCValHashSetItemSize( Type )</tt>
<dt><br>Results:
<dd>The<tt> WCValHashSet&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValHashSet</tt> object with the specified number
 of buckets and hash function.
<dt><br>See Also:
<dd><tt> ~WCValHashSet</tt>,<tt> bitHash</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashSet( const WCValHashSet &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValHashSet&lt;Type&gt;</tt> is the copy constructor for the<tt> WCValHashSet</tt> class.&nbsp; The new hash is created
 with the same number of buckets, hash function, all values or pointers stored in the hash, and the exception trap states.
&nbsp; If the hash object can be created, but an allocation failure occurs when creating the buckets, the hash will be created
 with zero buckets.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied, and the
 number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<tt> out_of_memory</tt>
 exception is thrown if it is enabled.
<dt><br>Results:
<dd>The<tt> WCValHashSet&lt;Type&gt;</tt> constructor creates a<tt> WCValHashSet</tt> object which is a copy of the passed hash.
<dt><br>See Also:
<dd><tt> ~WCValHashSet</tt>,<tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValHashSetXTypeY____WCValHashSetLR"> ~WCValHashSet() &#91;WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCValHashSet();</tt>
<dt><br>Semantics:
<dd>The<tt> WCValHashSet&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCValHashSet</tt> class.&nbsp; If the number
 of elements is not zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise, the hash
 elements are cleared using the<tt> clear</tt> member function.&nbsp; The call to the<tt> WCValHashSet&lt;Type&gt;</tt> destructor
 is inserted implicitly by the compiler at the point where the<tt> WCValHashSet</tt> object goes out of scope.
<dt><br>Results:
<dd>The call to the<tt> WCValHashSet&lt;Type&gt;</tt> destructor destroys a<tt> WCValHashSet</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCValHashTableXTypeY__WCValHashTableLR"> WCValHashTable() &#91;WCValHashTable&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashTable( unsigned (*hash_fn)( const Type &amp; ),</tt>
<br><tt> unsigned = WC_DEFAULT_HASH_SIZE );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValHashTable&lt;Type&gt;</tt> constructor creates a<tt> WCValHashTable</tt> object with no entries and with the
 number of buckets in the second optional parameter, which defaults to the constant<tt> WC_DEFAULT_HASH_SIZE</tt> (currently
 defined as 101).&nbsp; The number of buckets specified must be greater than zero, and will be forced to at least one.&nbsp;
 If the hash object can be created, but an allocation failure occurs when creating the buckets, the table will be created
 with zero buckets.&nbsp; If the<tt> out_of_memory</tt> exception is enabled, then attempting to insert into a hash table
 with zero buckets with throw an<tt> out_of_memory</tt> error.
<br>The hash function<tt> hash_fn</tt> is used to determine which bucket each value will be assigned to.&nbsp; If no hash
 function exists, the static member function<tt> bitHash</tt> is available to help create one.
<dt><br>Results:
<dd>The<tt> WCValHashTable&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValHashTable</tt> object with the specified
 number of buckets and hash function.
<dt><br>See Also:
<dd><tt> ~WCValHashTable</tt>,<tt> bitHash</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashTable( unsigned (*hash_fn)( const Type &amp; ),</tt>
<br><tt> unsigned = WC_DEFAULT_HASH_SIZE,</tt>
<br><tt>void * (*user_alloc)( size_t ),</tt>
<br><tt>void (*user_dealloc)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>Allocator and deallocator functions are specified for use when entries are inserted and removed from the hash.&nbsp; The semantics
 of this constructor are the same as the constructor without the memory management functions.
<br>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is passed
 the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic that the
 allocation function will always be called with the same size value for any particular instantiation of a hash.&nbsp; To determine
 the size of the objects that the memory management functions will be required to allocate and free, the following macro may
 be used:
<br><br><tt>WCValHashTableItemSize( Type )</tt>
<dt><br>Results:
<dd>The<tt> WCValHashTable&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValHashTable</tt> object with the specified
 number of buckets and hash function.
<dt><br>See Also:
<dd><tt> ~WCValHashTable</tt>,<tt> bitHash</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashTable( const WCValHashTable &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValHashTable&lt;Type&gt;</tt> is the copy constructor for the<tt> WCValHashTable</tt> class.&nbsp; The new hash
 is created with the same number of buckets, hash function, all values or pointers stored in the hash, and the exception trap
 states.&nbsp; If the hash object can be created, but an allocation failure occurs when creating the buckets, the hash will
 be created with zero buckets.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied,
 and the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<tt>
 out_of_memory</tt> exception is thrown if it is enabled.
<dt><br>Results:
<dd>The<tt> WCValHashTable&lt;Type&gt;</tt> constructor creates a<tt> WCValHashTable</tt> object which is a copy of the passed
 hash.
<dt><br>See Also:
<dd><tt> ~WCValHashTable</tt>,<tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValHashTableXTypeY____WCValHashTableLR"> ~WCValHashTable() &#91;WCValHashTable&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCValHashTable();</tt>
<dt><br>Semantics:
<dd>The<tt> WCValHashTable&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCValHashTable</tt> class.&nbsp; If the number
 of elements is not zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise, the hash
 elements are cleared using the<tt> clear</tt> member function.&nbsp; The call to the<tt> WCValHashTable&lt;Type&gt;</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> WCValHashTable</tt> object goes out of scope.
<dt><br>Results:
<dd>The call to the<tt> WCValHashTable&lt;Type&gt;</tt> destructor destroys a<tt> WCValHashTable</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCValHashTableXTypeY__bitHashLR__WCValHashSetXTypeY__bitHashLR"> bitHash() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>static unsigned bitHash( void *, size_t );</tt>
<dt><br>Semantics:
<dd>The<tt> bitHash</tt> public member function can be used to implement a hashing function for any type.&nbsp; A hashing value
 is generated from the value stored for the number of specified bytes pointed to by the first parameter.&nbsp; For example:
<br><tt>unsigned my_hash_fn( const int &amp; elem ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( WCValHashSet&lt;int,String&gt;::bitHash(&amp;elem, sizeof(int));</tt>
<br><tt>}</tt>
<br><tt>WCValHashSet&lt;int&gt; data_object( &amp;my_hash_fn );</tt>
<dt><br>Results:
<dd>The<tt> bitHash</tt> public member function returns an unsigned value which can be used as the basis of a user defined hash
 function.
<dt><br>See Also:
<dd><tt> WCValHashSet</tt>,<tt> WCValHashTable</tt>
</dl>
<h2 id="WCValHashTableXTypeY__bucketsLR__WCValHashSetXTypeY__bucketsLR"> buckets() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned buckets() const;</tt>
<dt><br>Semantics:
<dd>The<tt> buckets</tt> public member function is used to find the number of buckets contained in the hash object.
<dt><br>Results:
<dd>The<tt> buckets</tt> public member function returns the number of buckets in the hash.
<dt><br>See Also:
<dd><tt> resize</tt>
</dl>
<h2 id="WCValHashTableXTypeY__clearLR__WCValHashSetXTypeY__clearLR"> clear() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the hash so that it has no entries.&nbsp; The number of buckets
 remain unaffected.&nbsp; Elements stored in the hash are destroyed using the destructors of<tt> Type.</tt>&nbsp; The hash
 object is not destroyed and re-created by this function, so the object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function clears the hash to have no elements.
<dt><br>See Also:
<dd><tt> ~WCValHashSet</tt>,<tt> ~WCValHashTable</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCValHashTableXTypeY__containsLR__WCValHashSetXTypeY__containsLR"> contains() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int contains( const Type &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> contains</tt> public member function returns non-zero if the element is stored in the hash, or zero if there is no
 equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The<tt> contains</tt> public member function returns a non-zero value if the element is found in the hash.
<dt><br>See Also:
<dd><tt> find</tt>
</dl>
<h2 id="WCValHashTableXTypeY__entriesLR__WCValHashSetXTypeY__entriesLR"> entries() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to return the current number of elements stored in the hash.
<dt><br>Results:
<dd>The<tt> entries</tt> public member function returns the number of elements in the hash.
<dt><br>See Also:
<dd><tt> buckets</tt>,<tt> isEmpty</tt>
</dl>
<h2 id="WCValHashTableXTypeY__findLR__WCValHashSetXTypeY__findLR"> find() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int find( const Type &amp;, Type &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> find</tt> public member function is used to find an element with an equivalent key in the hash.&nbsp; If an equivalent
 element is found, a non-zero value is returned.&nbsp; The reference to the element passed as the second argument is assigned
 the found element's value.&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence is based on the
 equivalence operator of the element type.
<dt><br>Results:
<dd>The element equivalent to the passed key is located in the hash.
</dl>
<h2 id="WCValHashTableXTypeY__forAllLR__WCValHashSetXTypeY__forAllLR"> forAll() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void forAll(</tt>
<br><tt> void (*user_fn)( Type, void * ),</tt>
<br><tt>void * );</tt>
<dt><br>Semantics:
<dd>The<tt> forAll</tt> public member function causes the user supplied function to be invoked for every value in the hash.&nbsp;
 The user function has the prototype
<br><tt>void user_func( Type &amp; value, void * data );</tt>
<br><br>As the elements are visited, the user function is invoked with the element passed as the first.&nbsp; The second parameter
 of the<tt> forAll</tt> function is passed as the second parameter to the user function.&nbsp; This value can be used to pass
 any appropriate data from the main code to the user function.
<dt><br>Results:
<dd>The elements in the hash are all visited, with the user function being invoked for each one.
<dt><br>See Also:
<dd><tt> find</tt>
</dl>
<h2 id="WCValHashTableXTypeY__insertLR__WCValHashSetXTypeY__insertLR"> insert() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function inserts a value into the hash, using the hash function to determine to which bucket
 it should be stored.&nbsp; If allocation of the node to store the value fails, then the<tt> out_of_memory</tt> exception
 is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not be completed.
<br>With a<tt> WCValHashSet,</tt> there must be only one equivalent element in the set.&nbsp; If an element equivalent to
 the inserted element is already in the hash set, the hash set will remain unchanged, and the<tt> not_unique</tt> exception
 is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not be completed.
<br><br>At some point, the number of buckets initially selected may be too small for the number of elements inserted.&nbsp;
 The resize of the hash can be controlled by the insertion mechanism by using<tt> WCValHashSet</tt> (or<tt> WCValHashTable</tt>)
 as a base class, and providing an insert member function to do a resize when appropriate.&nbsp; This insert could then call<tt>
 WCValHashSet::insert</tt> (or<tt> WCValHashTable::insert</tt>) to insert the element.&nbsp; Note that copy constructors and
 assignment operators are not inherited in your class, but you can provide the following inline definitions (assuming that
 the class inherited from WCValHashTable is named MyHashTable):
<br><br><tt>inline MyHashTable( const MyHashTable &amp;orig )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; : WCValHashTable( orig ) {};</tt>
<br><tt>inline MyHashTable &amp;operator=( const MyHashTable &amp;orig ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; return( WCValHashTable::operator=( orig ) );</tt>
<br><tt>}</tt>
<dt><br>Results:
<dd>The<tt> insert</tt> public member function inserts a value into the hash.&nbsp; If the insert is successful, a non-zero will
 returned.&nbsp; A zero will be returned if the insert fails.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValHashTableXTypeY__isEmptyLR__WCValHashSetXTypeY__isEmptyLR"> isEmpty() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if the hash is empty.
<dt><br>Results:
<dd>The<tt> isEmpty</tt> public member function returns zero if it contains at least one entry, non-zero if the hash is empty.
<dt><br>See Also:
<dd><tt> buckets</tt>,<tt> entries</tt>
</dl>
<h2 id="WCValHashTableXTypeY__occurencesOfLR"> occurencesOf() &#91;WCValHashTable&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned occurrencesOf( const Type &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> occurencesOf</tt> public member function is used to return the current number of elements stored in the hash which
 are equivalent to the passed value.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The<tt> occurencesOf</tt> public member function returns the number of elements in the hash.
<dt><br>See Also:
<dd><tt> buckets</tt>,<tt> entries</tt>,<tt> find</tt>,<tt> isEmpty</tt>
</dl>
<h2 id="WCValHashTableXTypeY__operator_ELR__WCValHashSetXTypeY__operator_ELR"> operator =() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashSet &amp; operator =( const WCValHashSet &amp; );</tt>
<br><tt> WCValHashTable &amp; operator =( const WCValHashTable &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the<tt> WCValHashTable&lt;Type&gt;</tt> and<tt>
 WCValHashSet&lt;Type&gt;</tt> classes.&nbsp; The left hand side hash is first cleared using the<tt> clear</tt> member function,
 and then the right hand side hash is copied.&nbsp; The hash function, exception trap states, and all of the hash elements
 are copied.&nbsp; If an allocation failure occurs when creating the buckets, the table will be created with zero buckets,
 and the<tt> out_of_memory</tt> exception is thrown if it is enabled.&nbsp; If there is not enough memory to copy all of the
 values or pointers in the hash, then only some will be copied, and the<tt> out_of_memory</tt> exception is thrown if it is
 enabled.&nbsp; The number of entries will correctly reflect the number copied.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the left hand side hash to be a copy of the right hand side.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValHashTableXTypeY__operator_EELR__WCValHashSetXTypeY__operator_EELR"> operator ==() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ==( const WCValHashSet &amp; ) const;</tt>
<br><tt> int operator ==( const WCValHashTable &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the<tt> WCValHashTable&lt;Type&gt;</tt> and<tt>
 WCValHashSet&lt;Type&gt;</tt> classes.&nbsp; Two hash objects are equivalent if they are the same object and share the same
 address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side and right hand side hash are the same object.&nbsp; A FALSE (zero)
 value is returned otherwise.
</dl>
<h2 id="WCValHashTableXTypeY__removeLR__WCValHashSetXTypeY__removeLR"> remove() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int remove( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> remove</tt> public member function is used to remove the specified element from the hash.&nbsp; If an equivalent element
 is found, a non-zero value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; If the hash is a table
 and there is more than one element equivalent to the specified element, then the first equivalent element added to the table
 is removed.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The element is removed from the hash if it found.
</dl>
<h2 id="WCValHashTableXTypeY__removeAllLR"> removeAll() &#91;WCValHashTable&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned removeAll( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> removeAll</tt> public member function is used to remove all elements equivalent to the specified element from the
 hash.&nbsp; Zero is returned if no equivalent elements are found.&nbsp; Note that equivalence is based on the equivalence
 operator of the element type.
<dt><br>Results:
<dd>All equivalent elements are removed from the hash.
</dl>
<h2 id="WCValHashTableXTypeY__resizeLR__WCValHashSetXTypeY__resizeLR"> resize() &#91;WCValHashTable&lt;Type&gt;,WCValHashSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchash.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void resize( unsigned );</tt>
<dt><br>Semantics:
<dd>The<tt> resize</tt> public member function is used to change the number of buckets contained in the hash.&nbsp; If the new
 number is larger than the previous hash size, then the hash function will be used on all of the stored elements to determine
 which bucket they should be stored into.&nbsp; Entries are not destroyed or created in the process of being moved.&nbsp;
 If there is not enough memory to resize the hash, the<tt> out_of_memory</tt> exception is thrown if it is enabled, and the
 hash will contain the number of buckets it contained before the resize.&nbsp; If the new number is zero, then the<tt> zero_buckets</tt>
 exception is thrown if it is enabled, and no resize will be performed.&nbsp; The hash is guaranteed to contain the same number
 of entries after the resize.
<dt><br>Results:
<dd>The hash is resized to the new number of buckets.
<dt><br>See Also:
<dd><tt> WCExcept::out_of_memory</tt>,<tt> WCExcept::zero_buckets</tt>
</dl>
<h1 id="Hash_Iterators"> Hash Iterators </h1>
<br>Hash iterators are used to step through a hash one or more elements at a time.&nbsp; Iterators which are newly constructed
 or reset are positioned before the first element in the hash.&nbsp; The hash may be traversed one element at a time using
 the pre-increment or call operator.&nbsp; An increment operation causing the iterator to be positioned after the end of the
 hash returns zero.&nbsp; Further increments will cause the<tt> undef_iter</tt> exception to be thrown, if it is enabled.
&nbsp; The<tt> WCIterExcept</tt> class provides the common exception handling control interface for all of the iterators.
<br><br>Since the iterator classes are all template classes, most of the functionality was derived from common base classes.
&nbsp; In the listing of class member functions, those public member functions which appear to be in the iterator class but
 are actually defined in the common base class are identified as if they were explicitly specified in the iterator class.
<h2 id="WCPtrHashDictIterXKey_ValueY_Class_Description"> WCPtrHashDictIter&lt;Key,Value&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wchiter.h</tt>
<br>The<tt> WCPtrHashDictIter&lt;Key,Value&gt;</tt> class is the templated class used to create iterator objects for<tt> WCPtrHashDict&lt;Key,Value&gt;</tt>
 objects.&nbsp; In the description of each member function, the text<tt> Key</tt> is used to indicate the template parameter
 defining the type of the indices pointed to by the pointers stored in the dictionary.&nbsp; The text<tt> Value</tt> is used
 to indicate the template parameter defining the type of the data pointed to by the pointers stored in the dictionary.&nbsp;
 The<tt> WCIterExcept</tt> class is a base class of the<tt> WCPtrHashDictIter&lt;Key,Value&gt;</tt> class and provides the<tt>
 exceptions</tt> member function.&nbsp; This member function controls the exceptions which can be thrown by the<tt> WCPtrHashDictIter&lt;Key,Value&gt;</tt>
 object.&nbsp; No exceptions are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCPtrHashDictIter();</tt>
<br><tt> WCPtrHashDictIter( const WCPtrHashDict&lt;Key,Value&gt; &amp; );</tt>
<br><tt> ~WCPtrHashDictIter();</tt>
<br><tt> const WCPtrHashDict&lt;Key,Value&gt; *container() const;</tt>
<br><tt> Key *key();</tt>
<br><tt> void reset();</tt>
<br><tt> void reset( WCPtrHashDict&lt;Key,Value&gt; &amp; );</tt>
<br><tt> Value * value();</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>int operator ()();</tt>
<br><tt> int operator ++();</tt>
</dl>
<h2 id="WCPtrHashDictIterXKey_ValueY__WCPtrHashDictIterLR"> WCPtrHashDictIter() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashDictIter();</tt>
<dt><br>Semantics:
<dd>The public<tt> WCPtrHashDictIter&lt;Key,Value&gt;</tt> constructor is the default constructor for the class and initializes
 the iterator with no hash to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator
 with a hash to iterate over.
<dt><br>Results:
<dd>The public<tt> WCPtrHashDictIter&lt;Key,Value&gt;</tt> constructor creates an initialized<tt> WCPtrHashDictIter</tt> hash
 iterator object.
<dt><br>See Also:
<dd><tt> ~WCPtrHashDictIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashDictIter( WCPtrHashDict&lt;Key,Value&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCPtrHashDictIter&lt;Key,Value&gt;</tt> constructor is a constructor for the class.&nbsp; The value passed
 as a parameter is a<tt> WCPtrHashDict</tt> hash object.&nbsp; The iterator will be initialized for that hash object and positioned
 before the first hash element.&nbsp; To position the iterator to a valid element within the hash, increment it using one
 of the<tt> operator ++</tt> or<tt> operator ()</tt> operators.
<dt><br>Results:
<dd>The public<tt> WCPtrHashDictIter&lt;Key,Value&gt;</tt> constructor creates an initialized<tt> WCPtrHashDictIter</tt> hash
 iterator object positioned before the first element in the hash.
<dt><br>See Also:
<dd><tt> ~WCPtrHashDictIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> reset</tt>
</dl>
<h2 id="WCPtrHashDictIterXKey_ValueY____WCPtrHashDictIterLR"> ~WCPtrHashDictIter() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCPtrHashDictIter();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCPtrHashDictIter&lt;Key,Value&gt;</tt> destructor is the destructor for the class.&nbsp; The call to the
 destructor is inserted implicitly by the compiler at the point where the<tt> WCPtrHashDictIter</tt> hash iterator object
 goes out of scope.
<dt><br>Results:
<dd>The<tt> WCPtrHashDictIter</tt> hash iterator object is destroyed.
<dt><br>See Also:
<dd><tt> WCPtrHashDictIter</tt>
</dl>
<h2 id="WCPtrHashDictIterXKey_ValueY__containerLR"> container() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashDict&lt;Key,Value&gt; *container() const;</tt>
<dt><br>Semantics:
<dd>The<tt> container</tt> public member function returns a pointer to the hash container object.&nbsp; If the iterator has not
 been initialized with a hash object, and the<tt> undef_iter</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>A pointer to the hash object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
 with a hash.
<dt><br>See Also:
<dd><tt> WCPtrHashDictIter</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrHashDictIterXKey_ValueY__keyLR"> key() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Key *key();</tt>
<dt><br>Semantics:
<dd>The<tt> key</tt> public member function returns a pointer to the<tt> Key</tt> value of the hash item at the current iterator
 position.
<br>If the iterator is not associated with a hash, or the iterator position is either before the first element or past the
 last element in the hash, the current iterator position is undefined.&nbsp; In this case the<tt> undef_item</tt> exception
 is thrown, if enabled.
<dt><br>Results:
<dd>A pointer to<tt> Key</tt> at the current iterator element is returned.&nbsp; If the current element is undefined, an undefined
 pointer is returned.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> operator ++</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_item</tt>
</dl>
<h2 id="WCPtrHashDictIterXKey_ValueY__operator_LRLR"> operator ()() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ()();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ()</tt> public member function is the call operator for the class.&nbsp; The hash element which follows the
 current item is set to be the new current item.&nbsp; If the previous current item was the last element in the hash, the
 iterator is positioned after the end of the hash.
<br>The<tt> operator ()</tt> public member function has the same semantics as the pre-increment operator,<tt> operator ++.</tt>
<br><br>If the iterator was positioned before the first hash element, the current item will be set to the first element.&nbsp;
 If the hash is empty, the iterator will be positioned after the end of the hash.
<br><br>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
 the hash, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ()</tt> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the hash.
<dt><br>See Also:
<dd><tt> operator ++</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrHashDictIterXKey_ValueY__operator_PPLR"> operator ++() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ++();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ++</tt> public member function is the pre-increment operator for the class.&nbsp; The hash element which
 follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
 hash, the iterator is positioned after the end of the hash.
<br>The<tt> operator ++</tt> public member function has the same semantics as the call operator,<tt> operator ().</tt>
<br><br>The current item will be set to the first hash element if the iterator was positioned before the first element in
 the hash.&nbsp; If the hash is empty, the iterator will be positioned after the end of the hash.
<br><br>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
 the hash, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ++</tt> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the hash.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrHashDictIterXKey_ValueY__resetLR"> reset() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void reset();</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to the initial state, positioning the iterator before the first
 element in the associated hash.
<dt><br>Results:
<dd>The iterator is positioned before the first hash element.
<dt><br>See Also:
<dd><tt> WCPtrHashDictIter</tt>,<tt> container</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void reset( WCPtrHashDict&lt;Key,Value&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to operate on the specified hash.&nbsp; The iterator is positioned
 before the first element in the hash.
<dt><br>Results:
<dd>The iterator is positioned before the first element of the specified hash.
<dt><br>See Also:
<dd><tt> WCPtrHashDictIter</tt>,<tt> container</tt>
</dl>
<h2 id="WCPtrHashDictIterXKey_ValueY__valueLR"> value() &#91;WCPtrHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value *value();</tt>
<dt><br>Semantics:
<dd>The<tt> value</tt> public member function returns a pointer to the<tt> Value</tt> the current iterator position.
<br>If the iterator is not associated with a hash, or the iterator position is either before the first element or past the
 last element in the hash, the current iterator position is undefined.&nbsp; In this case the<tt> undef_item</tt> exception
 is thrown, if enabled.
<dt><br>Results:
<dd>A pointer to the<tt> Value</tt> at the current iterator element is returned.&nbsp; If the current element is undefined, an
 undefined pointer is returned.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> operator ++</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_item</tt>
</dl>
<h2 id="WCValHashDictIterXKey_ValueY_Class_Description"> WCValHashDictIter&lt;Key,Value&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wchiter.h</tt>
<br>The<tt> WCValHashDictIter&lt;Key,Value&gt;</tt> class is the templated class used to create iterator objects for<tt> WCValHashDict&lt;Key,Value&gt;</tt>
 objects.&nbsp; In the description of each member function, the text<tt> Key</tt> is used to indicate the template parameter
 defining the type of the indices used to store data in the dictionary.&nbsp; The text<tt> Value</tt> is used to indicate
 the template parameter defining the type of the data stored in the dictionary.&nbsp; The<tt> WCIterExcept</tt> class is a
 base class of the<tt> WCValHashDictIter&lt;Key,Value&gt;</tt> class and provides the<tt> exceptions</tt> member function.
&nbsp; This member function controls the exceptions which can be thrown by the<tt> WCValHashDictIter&lt;Key,Value&gt;</tt>
 object.&nbsp; No exceptions are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCValHashDictIter();</tt>
<br><tt> WCValHashDictIter( const WCValHashDict&lt;Key,Value&gt; &amp; );</tt>
<br><tt> ~WCValHashDictIter();</tt>
<br><tt> const WCValHashDict&lt;Key,Value&gt; *container() const;</tt>
<br><tt> Key key();</tt>
<br><tt> void reset();</tt>
<br><tt> void reset( WCValHashDict&lt;Key,Value&gt; &amp; );</tt>
<br><tt> Value value();</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>int operator ()();</tt>
<br><tt> int operator ++();</tt>
</dl>
<h2 id="WCValHashDictIterXKey_ValueY__WCValHashDictIterLR"> WCValHashDictIter() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashDictIter();</tt>
<dt><br>Semantics:
<dd>The public<tt> WCValHashDictIter&lt;Key,Value&gt;</tt> constructor is the default constructor for the class and initializes
 the iterator with no hash to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator
 with a hash to iterate over.
<dt><br>Results:
<dd>The public<tt> WCValHashDictIter&lt;Key,Value&gt;</tt> constructor creates an initialized<tt> WCValHashDictIter</tt> hash
 iterator object.
<dt><br>See Also:
<dd><tt> ~WCValHashDictIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashDictIter( WCValHashDict&lt;Key,Value&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCValHashDictIter&lt;Key,Value&gt;</tt> constructor is a constructor for the class.&nbsp; The value passed
 as a parameter is a<tt> WCValHashDict</tt> hash object.&nbsp; The iterator will be initialized for that hash object and positioned
 before the first hash element.&nbsp; To position the iterator to a valid element within the hash, increment it using one
 of the<tt> operator ++</tt> or<tt> operator ()</tt> operators.
<dt><br>Results:
<dd>The public<tt> WCValHashDictIter&lt;Key,Value&gt;</tt> constructor creates an initialized<tt> WCValHashDictIter</tt> hash
 iterator object positioned before the first element in the hash.
<dt><br>See Also:
<dd><tt> ~WCValHashDictIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> reset</tt>
</dl>
<h2 id="WCValHashDictIterXKey_ValueY____WCValHashDictIterLR"> ~WCValHashDictIter() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCValHashDictIter();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCValHashDictIter&lt;Key,Value&gt;</tt> destructor is the destructor for the class.&nbsp; The call to the
 destructor is inserted implicitly by the compiler at the point where the<tt> WCValHashDictIter</tt> hash iterator object
 goes out of scope.
<dt><br>Results:
<dd>The<tt> WCValHashDictIter</tt> hash iterator object is destroyed.
<dt><br>See Also:
<dd><tt> WCValHashDictIter</tt>
</dl>
<h2 id="WCValHashDictIterXKey_ValueY__containerLR"> container() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashDict&lt;Key,Value&gt; *container() const;</tt>
<dt><br>Semantics:
<dd>The<tt> container</tt> public member function returns a pointer to the hash container object.&nbsp; If the iterator has not
 been initialized with a hash object, and the<tt> undef_iter</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>A pointer to the hash object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
 with a hash.
<dt><br>See Also:
<dd><tt> WCValHashDictIter</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValHashDictIterXKey_ValueY__keyLR"> key() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Key key();</tt>
<dt><br>Semantics:
<dd>The<tt> key</tt> public member function returns the value of<tt> Key</tt> at the current iterator position.
<br>If the iterator is not associated with a hash, or the iterator position is either before the first element or past the
 last element in the hash, the current iterator position is undefined.&nbsp; In this case the<tt> undef_item</tt> exception
 is thrown, if enabled.
<dt><br>Results:
<dd>The value of<tt> Key</tt> at the current iterator element is returned.&nbsp; If the current element is undefined, a default
 initialized object is returned.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> operator ++</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_item</tt>
</dl>
<h2 id="WCValHashDictIterXKey_ValueY__operator_LRLR"> operator ()() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ()();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ()</tt> public member function is the call operator for the class.&nbsp; The hash element which follows the
 current item is set to be the new current item.&nbsp; If the previous current item was the last element in the hash, the
 iterator is positioned after the end of the hash.
<br>The<tt> operator ()</tt> public member function has the same semantics as the pre-increment operator,<tt> operator ++.</tt>
<br><br>If the iterator was positioned before the first hash element, the current item will be set to the first element.&nbsp;
 If the hash is empty, the iterator will be positioned after the end of the hash.
<br><br>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
 the hash, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ()</tt> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the hash.
<dt><br>See Also:
<dd><tt> operator ++</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValHashDictIterXKey_ValueY__operator_PPLR"> operator ++() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ++();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ++</tt> public member function is the pre-increment operator for the class.&nbsp; The hash element which
 follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
 hash, the iterator is positioned after the end of the hash.
<br>The<tt> operator ++</tt> public member function has the same semantics as the call operator,<tt> operator ().</tt>
<br><br>The current item will be set to the first hash element if the iterator was positioned before the first element in
 the hash.&nbsp; If the hash is empty, the iterator will be positioned after the end of the hash.
<br><br>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
 the hash, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ++</tt> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the hash.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValHashDictIterXKey_ValueY__resetLR"> reset() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void reset();</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to the initial state, positioning the iterator before the first
 element in the associated hash.
<dt><br>Results:
<dd>The iterator is positioned before the first hash element.
<dt><br>See Also:
<dd><tt> WCValHashDictIter</tt>,<tt> container</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void reset( WCValHashDict&lt;Key,Value&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to operate on the specified hash.&nbsp; The iterator is positioned
 before the first element in the hash.
<dt><br>Results:
<dd>The iterator is positioned before the first element of the specified hash.
<dt><br>See Also:
<dd><tt> WCValHashDictIter</tt>,<tt> container</tt>
</dl>
<h2 id="WCValHashDictIterXKey_ValueY__valueLR"> value() &#91;WCValHashDictIter&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value value();</tt>
<dt><br>Semantics:
<dd>The<tt> value</tt> public member function returns the value of<tt> Value</tt> at the current iterator position.
<br>If the iterator is not associated with a hash, or the iterator position is either before the first element or past the
 last element in the hash, the current iterator position is undefined.&nbsp; In this case the<tt> undef_item</tt> exception
 is thrown, if enabled.
<dt><br>Results:
<dd>The value of the<tt> Value</tt> at the current iterator element is returned.&nbsp; If the current element is undefined, a
 default initialized object is returned.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> operator ++</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_item</tt>
</dl>
<h2 id="WCPtrHashSetIterXTypeY__WCPtrHashTableIterXTypeY_Class_Description"> WCPtrHashSetIter&lt;Type&gt;, WCPtrHashTableIter&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wchiter.h</tt>
<br>The<tt> WCPtrHashSetIter&lt;Type&gt;</tt> and<tt> WCPtrHashTableIter&lt;Type&gt;</tt> classes are the templated classes
 used to create iterator objects for<tt> WCPtrHashTable&lt;Type&gt;</tt> and<tt> WCPtrHashSet&lt;Type&gt;</tt> objects.&nbsp;
 In the description of each member function, the text<tt> Type</tt> is used to indicate the hash element type specified as
 the template parameter.&nbsp; The<tt> WCIterExcept</tt> class is a base class of the<tt> WCPtrHashSetIter&lt;Type&gt;</tt>
 and<tt> WCPtrHashTableIter&lt;Type&gt;</tt> classes and provides the<tt> exceptions</tt> member function.&nbsp; This member
 function controls the exceptions which can be thrown by the<tt> WCPtrHashSetIter&lt;Type&gt;</tt> and<tt> WCPtrHashTableIter&lt;Type&gt;</tt>
 objects.&nbsp; No exceptions are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCPtrHashSetIter();</tt>
<br><tt> WCPtrHashSetIter( const WCPtrHashSet&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCPtrHashSetIter();</tt>
<br><tt> WCPtrHashTableIter();</tt>
<br><tt> WCPtrHashTableIter( const WCPtrHashTable&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCPtrHashTableIter();</tt>
<br><tt> const WCPtrHashTable&lt;Type&gt; *container() const;</tt>
<br><tt> const WCPtrHashSet&lt;Type&gt; *container() const;</tt>
<br><tt> Type *current() const;</tt>
<br><tt> void reset();</tt>
<br><tt> void WCPtrHashSetIter&lt;Type&gt;::reset( WCPtrHashSet&lt;Type&gt; &amp; );</tt>
<br><tt> void WCPtrHashTableIter&lt;Type&gt;::reset( WCPtrHashTable&lt;Type&gt; &amp; );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>int operator ()();</tt>
<br><tt> int operator ++();</tt>
</dl>
<h2 id="WCPtrHashSetIterXTypeY__WCPtrHashSetIterLR"> WCPtrHashSetIter() &#91;WCPtrHashSetIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashSetIter();</tt>
<dt><br>Semantics:
<dd>The public<tt> WCPtrHashSetIter&lt;Type&gt;</tt> constructor is the default constructor for the class and initializes the
 iterator with no hash to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with
 a hash to iterate over.
<dt><br>Results:
<dd>The public<tt> WCPtrHashSetIter&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrHashSetIter</tt> hash iterator
 object.
<dt><br>See Also:
<dd><tt> ~WCPtrHashSetIter</tt>,<tt> WCPtrHashTableIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashSetIter( WCPtrHashSet&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCPtrHashSetIter&lt;Type&gt;</tt> constructor is a constructor for the class.&nbsp; The value passed as a parameter
 is a<tt> WCPtrHashSet</tt> hash object.&nbsp; The iterator will be initialized for that hash object and positioned before
 the first hash element.&nbsp; To position the iterator to a valid element within the hash, increment it using one of the<tt>
 operator ++</tt> or<tt> operator ()</tt> operators.
<dt><br>Results:
<dd>The public<tt> WCPtrHashSetIter&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrHashSetIter</tt> hash iterator
 object positioned before the first element in the hash.
<dt><br>See Also:
<dd><tt> ~WCPtrHashSetIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> reset</tt>
</dl>
<h2 id="WCPtrHashSetIterXTypeY____WCPtrHashSetIterLR"> ~WCPtrHashSetIter() &#91;WCPtrHashSetIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCPtrHashSetIter();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCPtrHashSetIter&lt;Type&gt;</tt> destructor is the destructor for the class.&nbsp; The call to the destructor
 is inserted implicitly by the compiler at the point where the<tt> WCPtrHashSetIter</tt> hash iterator object goes out of
 scope.
<dt><br>Results:
<dd>The<tt> WCPtrHashSetIter</tt> hash iterator object is destroyed.
<dt><br>See Also:
<dd><tt> WCPtrHashSetIter</tt>,<tt> WCPtrHashTableIter</tt>
</dl>
<h2 id="WCPtrHashTableIterXTypeY__WCPtrHashTableIterLR"> WCPtrHashTableIter() &#91;WCPtrHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashTableIter();</tt>
<dt><br>Semantics:
<dd>The public<tt> WCPtrHashTableIter&lt;Type&gt;</tt> constructor is the default constructor for the class and initializes the
 iterator with no hash to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with
 a hash to iterate over.
<dt><br>Results:
<dd>The public<tt> WCPtrHashTableIter&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrHashTableIter</tt> hash iterator
 object.
<dt><br>See Also:
<dd><tt> ~WCPtrHashTableIter</tt>,<tt> WCPtrHashSetIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashTableIter( WCPtrHashTable&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCPtrHashTableIter&lt;Type&gt;</tt> constructor is a constructor for the class.&nbsp; The value passed as a
 parameter is a<tt> WCPtrHashTable</tt> hash object.&nbsp; The iterator will be initialized for that hash object and positioned
 before the first hash element.&nbsp; To position the iterator to a valid element within the hash, increment it using one
 of the<tt> operator ++</tt> or<tt> operator ()</tt> operators.
<dt><br>Results:
<dd>The public<tt> WCPtrHashTableIter&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrHashTableIter</tt> hash iterator
 object positioned before the first element in the hash.
<dt><br>See Also:
<dd><tt> ~WCPtrHashTableIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> reset</tt>
</dl>
<h2 id="WCPtrHashTableIterXTypeY____WCPtrHashTableIterLR"> ~WCPtrHashTableIter() &#91;WCPtrHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCPtrHashTableIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrHashTableIter&lt;Type&gt;</tt> destructor is the destructor for the class.&nbsp; The call to the destructor is
 inserted implicitly by the compiler at the point where the<tt> WCPtrHashTableIter</tt> hash iterator object goes out of scope.
<dt><br>Results:
<dd>The<tt> WCPtrHashTableIter</tt> hash iterator object is destroyed.
<dt><br>See Also:
<dd><tt> WCPtrHashSetIter</tt>,<tt> WCPtrHashTableIter</tt>
</dl>
<h2 id="WCPtrHashSetIterXTypeY_WCPtrHashTableIterXTypeY__containerLR"> container() &#91;WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrHashTable&lt;Type&gt; *WCPtrHashTableIter&lt;Type&gt;::container() const;</tt>
<br><tt> WCPtrHashSet&lt;Type&gt; *WCPtrHashSetIter&lt;Type&gt;::container() const;</tt>
<dt><br>Semantics:
<dd>The<tt> container</tt> public member function returns a pointer to the hash container object.&nbsp; If the iterator has not
 been initialized with a hash object, and the<tt> undef_iter</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>A pointer to the hash object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
 with a hash.
<dt><br>See Also:
<dd><tt> WCPtrHashSetIter</tt>,<tt> WCPtrHashTableIter</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrHashSetIterXTypeY__currentLR__WCPtrHashTableIterXTypeY__currentLR"> current() &#91;WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type *current();</tt>
<dt><br>Semantics:
<dd>The<tt> current</tt> public member function returns a pointer to the hash item at the current iterator position.
<br>If the iterator is not associated with a hash, or the iterator position is either before the first element or past the
 last element in the hash, the current iterator position is undefined.&nbsp; In this case the<tt> undef_item</tt> exception
 is thrown, if enabled.
<dt><br>Results:
<dd>A pointer to the current iterator element is returned.&nbsp; If the current element is undefined, NULL(0) is returned.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> operator ++</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_item</tt>
</dl>
<h2 id="WCPtrHashSetIterXTypeY_WCPtrHashTableIterXTypeY__operator_LRLR"> operator ()() &#91;WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ()();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ()</tt> public member function is the call operator for the class.&nbsp; The hash element which follows the
 current item is set to be the new current item.&nbsp; If the previous current item was the last element in the hash, the
 iterator is positioned after the end of the hash.
<br>The<tt> operator ()</tt> public member function has the same semantics as the pre-increment operator,<tt> operator ++.</tt>
<br><br>If the iterator was positioned before the first hash element, the current item will be set to the first element.&nbsp;
 If the hash is empty, the iterator will be positioned after the end of the hash.
<br><br>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
 the hash, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ()</tt> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the hash.
<dt><br>See Also:
<dd><tt> operator ++</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrHashSetIterXTypeY_WCPtrHashTableIterXTypeY__operator_PPLR"> operator ++() &#91;WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ++();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ++</tt> public member function is the pre-increment operator for the class.&nbsp; The hash element which
 follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
 hash, the iterator is positioned after the end of the hash.
<br>The<tt> operator ++</tt> public member function has the same semantics as the call operator,<tt> operator ().</tt>
<br><br>The current item will be set to the first hash element if the iterator was positioned before the first element in
 the hash.&nbsp; If the hash is empty, the iterator will be positioned after the end of the hash.
<br><br>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
 the hash, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ++</tt> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the hash.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrHashSetIterXTypeY__resetLR__WCPtrHashTableIterXTypeY__resetLR"> reset() &#91;WCPtrHashSetIter&lt;Type&gt;,WCPtrHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void reset();</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to the initial state, positioning the iterator before the first
 element in the associated hash.
<dt><br>Results:
<dd>The iterator is positioned before the first hash element.
<dt><br>See Also:
<dd><tt> WCPtrHashSetIter</tt>,<tt> WCPtrHashTableIter</tt>,<tt> container</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void WCPtrHashSetIter&lt;Type&gt;::reset( WCPtrHashSet&lt;Type&gt; &amp; );</tt>
<br><tt> void WCPtrHashTableIter&lt;Type&gt;::reset( WCPtrHashTable&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to operate on the specified hash.&nbsp; The iterator is positioned
 before the first element in the hash.
<dt><br>Results:
<dd>The iterator is positioned before the first element of the specified hash.
<dt><br>See Also:
<dd><tt> WCPtrHashSetIter</tt>,<tt> WCPtrHashTableIter</tt>,<tt> container</tt>
</dl>
<h2 id="WCValHashSetIterXTypeY__WCValHashTableIterXTypeY_Class_Description"> WCValHashSetIter&lt;Type&gt;, WCValHashTableIter&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wchiter.h</tt>
<br>The<tt> WCValHashSetIter&lt;Type&gt;</tt> and<tt> WCValHashTableIter&lt;Type&gt;</tt> classes are the templated classes
 used to create iterator objects for<tt> WCValHashTable&lt;Type&gt;</tt> and<tt> WCValHashSet&lt;Type&gt;</tt> objects.&nbsp;
 In the description of each member function, the text<tt> Type</tt> is used to indicate the hash element type specified as
 the template parameter.&nbsp; The<tt> WCIterExcept</tt> class is a base class of the<tt> WCValHashSetIter&lt;Type&gt;</tt>
 and<tt> WCValHashTableIter&lt;Type&gt;</tt> classes and provides the<tt> exceptions</tt> member function.&nbsp; This member
 function controls the exceptions which can be thrown by the<tt> WCValHashSetIter&lt;Type&gt;</tt> and<tt> WCValHashTableIter&lt;Type&gt;</tt>
 objects.&nbsp; No exceptions are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCValHashSetIter();</tt>
<br><tt> WCValHashSetIter( const WCValHashSet&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCValHashSetIter();</tt>
<br><tt> WCValHashTableIter();</tt>
<br><tt> WCValHashTableIter( const WCValHashTable&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCValHashTableIter();</tt>
<br><tt> const WCValHashTable&lt;Type&gt; *container() const;</tt>
<br><tt> const WCValHashSet&lt;Type&gt; *container() const;</tt>
<br><tt> Type current() const;</tt>
<br><tt> void reset();</tt>
<br><tt> void WCValHashSetIter&lt;Type&gt;::reset( WCValHashSet&lt;Type&gt; &amp; );</tt>
<br><tt> void WCValHashTableIter&lt;Type&gt;::reset( WCValHashTable&lt;Type&gt; &amp; );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>int operator ()();</tt>
<br><tt> int operator ++();</tt>
</dl>
<h2 id="WCValHashSetIterXTypeY__WCValHashSetIterLR"> WCValHashSetIter() &#91;WCValHashSetIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashSetIter();</tt>
<dt><br>Semantics:
<dd>The public<tt> WCValHashSetIter&lt;Type&gt;</tt> constructor is the default constructor for the class and initializes the
 iterator with no hash to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with
 a hash to iterate over.
<dt><br>Results:
<dd>The public<tt> WCValHashSetIter&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValHashSetIter</tt> hash iterator
 object.
<dt><br>See Also:
<dd><tt> ~WCValHashSetIter</tt>,<tt> WCValHashTableIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashSetIter( WCValHashSet&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCValHashSetIter&lt;Type&gt;</tt> constructor is a constructor for the class.&nbsp; The value passed as a parameter
 is a<tt> WCValHashSet</tt> hash object.&nbsp; The iterator will be initialized for that hash object and positioned before
 the first hash element.&nbsp; To position the iterator to a valid element within the hash, increment it using one of the<tt>
 operator ++</tt> or<tt> operator ()</tt> operators.
<dt><br>Results:
<dd>The public<tt> WCValHashSetIter&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValHashSetIter</tt> hash iterator
 object positioned before the first element in the hash.
<dt><br>See Also:
<dd><tt> ~WCValHashSetIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> reset</tt>
</dl>
<h2 id="WCValHashSetIterXTypeY____WCValHashSetIterLR"> ~WCValHashSetIter() &#91;WCValHashSetIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCValHashSetIter();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCValHashSetIter&lt;Type&gt;</tt> destructor is the destructor for the class.&nbsp; The call to the destructor
 is inserted implicitly by the compiler at the point where the<tt> WCValHashSetIter</tt> hash iterator object goes out of
 scope.
<dt><br>Results:
<dd>The<tt> WCValHashSetIter</tt> hash iterator object is destroyed.
<dt><br>See Also:
<dd><tt> WCValHashSetIter</tt>,<tt> WCValHashTableIter</tt>
</dl>
<h2 id="WCValHashTableIterXTypeY__WCValHashTableIterLR"> WCValHashTableIter() &#91;WCValHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashTableIter();</tt>
<dt><br>Semantics:
<dd>The public<tt> WCValHashTableIter&lt;Type&gt;</tt> constructor is the default constructor for the class and initializes the
 iterator with no hash to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with
 a hash to iterate over.
<dt><br>Results:
<dd>The public<tt> WCValHashTableIter&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValHashTableIter</tt> hash iterator
 object.
<dt><br>See Also:
<dd><tt> ~WCValHashTableIter</tt>,<tt> WCValHashSetIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashTableIter( WCValHashTable&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCValHashTableIter&lt;Type&gt;</tt> constructor is a constructor for the class.&nbsp; The value passed as a
 parameter is a<tt> WCValHashTable</tt> hash object.&nbsp; The iterator will be initialized for that hash object and positioned
 before the first hash element.&nbsp; To position the iterator to a valid element within the hash, increment it using one
 of the<tt> operator ++</tt> or<tt> operator ()</tt> operators.
<dt><br>Results:
<dd>The public<tt> WCValHashTableIter&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValHashTableIter</tt> hash iterator
 object positioned before the first element in the hash.
<dt><br>See Also:
<dd><tt> ~WCValHashTableIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> reset</tt>
</dl>
<h2 id="WCValHashTableIterXTypeY____WCValHashTableIterLR"> ~WCValHashTableIter() &#91;WCValHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCValHashTableIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCValHashTableIter&lt;Type&gt;</tt> destructor is the destructor for the class.&nbsp; The call to the destructor is
 inserted implicitly by the compiler at the point where the<tt> WCValHashTableIter</tt> hash iterator object goes out of scope.
<dt><br>Results:
<dd>The<tt> WCValHashTableIter</tt> hash iterator object is destroyed.
<dt><br>See Also:
<dd><tt> WCValHashSetIter</tt>,<tt> WCValHashTableIter</tt>
</dl>
<h2 id="WCValHashSetIterXTypeY_WCValHashTableIterXTypeY__containerLR"> container() &#91;WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValHashTable&lt;Type&gt; *WCValHashTableIter&lt;Type&gt;::container() const;</tt>
<br><tt> WCValHashSet&lt;Type&gt; *WCValHashSetIter&lt;Type&gt;::container() const;</tt>
<dt><br>Semantics:
<dd>The<tt> container</tt> public member function returns a pointer to the hash container object.&nbsp; If the iterator has not
 been initialized with a hash object, and the<tt> undef_iter</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>A pointer to the hash object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
 with a hash.
<dt><br>See Also:
<dd><tt> WCValHashSetIter</tt>,<tt> WCValHashTableIter</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValHashSetIterXTypeY__currentLR__WCValHashTableIterXTypeY__currentLR"> current() &#91;WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type current();</tt>
<dt><br>Semantics:
<dd>The<tt> current</tt> public member function returns the value of the hash element at the current iterator position.
<br>If the iterator is not associated with a hash, or the iterator position is either before the first element or past the
 last element in the hash, the current iterator position is undefined.&nbsp; In this case the<tt> undef_item</tt> exception
 is thrown, if enabled.
<dt><br>Results:
<dd>The value at the current iterator element is returned.&nbsp; If the current element is undefined, a default initialized object
 is returned.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> operator ++</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_item</tt>
</dl>
<h2 id="WCValHashSetIterXTypeY_WCValHashTableIterXTypeY__operator_LRLR"> operator ()() &#91;WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ()();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ()</tt> public member function is the call operator for the class.&nbsp; The hash element which follows the
 current item is set to be the new current item.&nbsp; If the previous current item was the last element in the hash, the
 iterator is positioned after the end of the hash.
<br>The<tt> operator ()</tt> public member function has the same semantics as the pre-increment operator,<tt> operator ++.</tt>
<br><br>If the iterator was positioned before the first hash element, the current item will be set to the first element.&nbsp;
 If the hash is empty, the iterator will be positioned after the end of the hash.
<br><br>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
 the hash, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ()</tt> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the hash.
<dt><br>See Also:
<dd><tt> operator ++</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValHashSetIterXTypeY_WCValHashTableIterXTypeY__operator_PPLR"> operator ++() &#91;WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ++();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ++</tt> public member function is the pre-increment operator for the class.&nbsp; The hash element which
 follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
 hash, the iterator is positioned after the end of the hash.
<br>The<tt> operator ++</tt> public member function has the same semantics as the call operator,<tt> operator ().</tt>
<br><br>The current item will be set to the first hash element if the iterator was positioned before the first element in
 the hash.&nbsp; If the hash is empty, the iterator will be positioned after the end of the hash.
<br><br>If the iterator is not associated with a hash or the iterator position before the increment was past the last element
 the hash, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ++</tt> public member function returns a non-zero value if the iterator is positioned on a hash item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the hash.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValHashSetIterXTypeY__resetLR__WCValHashTableIterXTypeY__resetLR"> reset() &#91;WCValHashSetIter&lt;Type&gt;,WCValHashTableIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void reset();</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to the initial state, positioning the iterator before the first
 element in the associated hash.
<dt><br>Results:
<dd>The iterator is positioned before the first hash element.
<dt><br>See Also:
<dd><tt> WCValHashSetIter</tt>,<tt> WCValHashTableIter</tt>,<tt> container</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wchiter.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void WCValHashSetIter&lt;Type&gt;::reset( WCValHashSet&lt;Type&gt; &amp; );</tt>
<br><tt> void WCValHashTableIter&lt;Type&gt;::reset( WCValHashTable&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to operate on the specified hash.&nbsp; The iterator is positioned
 before the first element in the hash.
<dt><br>Results:
<dd>The iterator is positioned before the first element of the specified hash.
<dt><br>See Also:
<dd><tt> WCValHashSetIter</tt>,<tt> WCValHashTableIter</tt>,<tt> container</tt>
</dl>
<h1 id="List_Containers"> List Containers </h1>
<br>List containers are single or double linked lists.&nbsp; The choice of which type of list to use is determined by the
 direction in which the list is traversed and by what is stored in the list.&nbsp; A list to which items are just added and
 removed may be most efficiently implemented as a single linked list.&nbsp; If frequent retrievals of items at given indexes
 within the list are made, double linked lists can offer some improved search performance.
<br><br>There are three sets of list container classes:&nbsp; value, pointer and intrusive.
<br><br>Value lists are the simplest to use but have the most requirements on the type stored in the lists.&nbsp; Copies are
 made of the values stored in the list, which could be undesirable if the stored objects are complicated and copying is expensive.
&nbsp; Value lists should not be used to store objects of a base class if any derived types of different sizes would be stored
 in the list, or if the destructor for the derived class must be called.&nbsp; The<tt> WCValSList&lt;Type&gt;</tt> container
 class implements single linked value lists, and the<tt> WCValDList&lt;Type&gt;</tt> class double linked value lists.
<br><br>Pointer list elements store pointers to objects.&nbsp; No creating, copying or destroying of objects stored in the
 list occurs.&nbsp; The only requirement of the type pointed to is that an equivalence operator is provided so that lookups
 can be performed.&nbsp; The<tt> WCPtrSList&lt;Type&gt;</tt> class implements single linked pointer lists, and the<tt> WCPtrDList&lt;Type&gt;</tt>
 class double linked pointer lists.
<br><br>Intrusive lists require that the list elements are objects derived from the<tt> WCSLink</tt> or<tt> WCDLink</tt> class,
 depending on whether a single or double linked list is used.&nbsp; The list classes require nothing else from the list elements.
&nbsp; No creating, destroying or copying of any object is performed by the intrusive list classes, and must be done by the
 user of the class.&nbsp; One advantage of an intrusive list is a list element can be removed from one list and inserted into
 another list without creating new list element objects or deleting old objects.&nbsp; The<tt> WCIsvSList&lt;Type&gt;</tt>
 class implements single linked intrusive lists, and the<tt> WCIsvDList&lt;Type&gt;</tt> class double linked intrusive lists.
<br><br>A list may be traversed using the corresponding list iterator class.&nbsp; Iterators allow lists to be stepped through
 one or more elements at a time.&nbsp; The iterator classes which correspond to single linked list containers have some functionality
 inhibited.&nbsp; If backward traversal is required, the double linked containers and iterators must be used.
<br><br>The classes are presented in alphabetical order.&nbsp; The<tt> WCSLink</tt> and<tt> WCDLink</tt> class provide a common
 control interface for the list elements for the intrusive classes.
<br><br>Since the container classes are all template classes, deriving most of the functionality from common base classes
 was used.&nbsp; In the listing of class member functions, those public member functions which appear to be in the container
 class but are actually defined in the common base class are identified as if they were explicitly specified in the container
 class.
<h2 id="WCDLink_Class_Description"> WCDLink Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wclcom.h</tt>
<dt><br>Derived from:
<dd><tt> WCSLink</tt>
<br>The<tt> WCDLink</tt> class is the building block for all of the double linked list classes.&nbsp; It is implemented in
 terms of the<tt> WCSLink</tt> base class.&nbsp; Since no user data is stored directly with it, the<tt> WCDLink</tt> class
 should only be used as a base class to derive a user defined class.
<br>When creating a double linked intrusive list, the<tt> WCDLink</tt> class is used to derive the user defined class that
 holds the data to be inserted into the list.
<br><br>The<tt> wclcom.h</tt> header file is included by the<tt> wclist.h</tt> header file.&nbsp; There is no need to explicitly
 include the<tt> wclcom.h</tt> header file unless the<tt> wclist.h</tt> header file is not included.&nbsp; No errors will
 result if it is included.
<br><br>Note that the destructor is non-virtual so that list elements are of minimum size.&nbsp; Objects created as a class
 derived from the<tt> WCDLink</tt> class, but destroyed while typed as a<tt> WCDLink</tt> object will not invoke the destructor
 of the derived class.
<br><br><b>Public Member Functions</b>
<br><br>The following public member functions are declared:
<br><br><tt>WCDLink();</tt>
<br><tt> ~WCDLink();</tt>
<dt><br>See Also:
<dd><tt> WCSLink</tt>
</dl>
<h2 id="WCDLink__WCDLinkLR"> WCDLink() &#91;WCDLink&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCDLink();</tt>
<dt><br>Semantics:
<dd>The public<tt> WCDLink</tt> constructor creates an<tt> WCDLink</tt> object.&nbsp; The public<tt> WCDLink</tt> constructor
 is used implicitly by the compiler when it generates a constructor for a derived class.
<dt><br>Results:
<dd>The public<tt> WCDLink</tt> constructor produces an initialized<tt> WCDLink</tt> object.
<dt><br>See Also:
<dd><tt> ~WCDLink</tt>
</dl>
<h2 id="WCDLink____WCDLinkLR"> ~WCDLink() &#91;WCDLink&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCDLink();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCDLink</tt> destructor does not do anything explicit.&nbsp; The call to the public<tt> ~WCDLink</tt> destructor
 is inserted implicitly by the compiler at the point where the object derived from WCDLink goes out of scope.
<dt><br>Results:
<dd>The object derived from WCDLink is destroyed.
<dt><br>See Also:
<dd><tt> WCDLink</tt>
</dl>
<h2 id="WCIsvSListXTypeY__WCIsvDListXTypeY_Class_Description"> WCIsvSList&lt;Type&gt;, WCIsvDList&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wclist.h</tt>
<br>The<tt> WCIsvSList&lt;Type&gt;</tt> and<tt> WCIsvDList&lt;Type&gt;</tt> classes are the templated classes used to create
 objects which are single or double linked lists.&nbsp; The created list is intrusive, which means that list elements which
 are inserted must be created with a library supplied base class.&nbsp; The class<tt> WCSLink</tt> provides the base class
 definition for single linked lists, and should be inherited by the definition of any list item for single linked lists.&nbsp;
 It provides the linkage that is used to traverse the list elements.&nbsp; Similarly, the class<tt> WCDLink</tt> provides
 the base class definition for double lists, and should be inherited by the definition of any list item for double lists.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the type value specified as the
 template parameter.<tt>&nbsp; Type</tt> is the type of the list elements, derived from<tt> WCSLink</tt> or<tt> WCDLink.</tt>
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCIsvSList&lt;Type&gt;</tt> and<tt> WCIsvDList&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCIsvSList&lt;Type&gt;</tt> and<tt> WCIsvDList&lt;Type&gt;</tt> objects.&nbsp; No exceptions are enabled
 unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Type</b>
<br><br>The<tt> WCIsvSList&lt;Type&gt;</tt> class requires only that<tt> Type</tt> is derived from<tt> WCSLink.</tt>&nbsp;
 The<tt> WCIsvDList&lt;Type&gt;</tt> class requires only that<tt> Type</tt> is derived from<tt> WCDLink.</tt>
<br><br><b>Private Member Functions</b>
<br><br>In an intrusive list, copying a list is undefined.&nbsp; Setting the copy constructor and assignment operator as private
 is the standard mechanism to ensure a copy cannot be made.&nbsp; The following member functions are declared private:
<br><br><tt>void WCIsvSList( const WCIsvSList &amp; );</tt>
<br><tt> void WCIsvDList( const WCIsvDList &amp; );</tt>
<br><tt> WCIsvSList &amp; WCIsvSList::operator =( const WCIsvSList &amp; );</tt>
<br><tt> WCIsvDList &amp; WCIsvDList::operator =( const WCIsvDList &amp; );</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCIsvSList();</tt>
<br><tt> ~WCIsvSList();</tt>
<br><tt> WCIsvDList();</tt>
<br><tt> ~WCIsvDList();</tt>
<br><tt> int append( Type * );</tt>
<br><tt> void clear();</tt>
<br><tt> void clearAndDestroy();</tt>
<br><tt> int contains( const Type * ) const;</tt>
<br><tt> int entries() const;</tt>
<br><tt> Type * find( int = 0 ) const;</tt>
<br><tt> Type * findLast() const;</tt>
<br><tt> void forAll( void (*)( Type *, void * ), void *);</tt>
<br><tt> Type * get( int = 0 );</tt>
<br><tt> int index( const Type * ) const;</tt>
<br><tt> int index( int (*)( const Type *, void * ), void * ) const;</tt>
<br><tt> int insert( Type * );</tt>
<br><tt> int isEmpty() const;</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>int WCIsvSList::operator ==( const WCIsvSList &amp; ) const;</tt>
<br><tt> int WCIsvDList::operator ==( const WCIsvDList &amp; ) const;</tt>
<br><br><b>Sample Program Using an Intrusive List</b>
<br><br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><br><tt>class int_ddata : public WCDLink {</tt>
<br><tt>public:</tt>
<br><tt>&nbsp;&nbsp;&nbsp; inline int_ddata() {};</tt>
<br><tt>&nbsp;&nbsp;&nbsp; inline int_ddata() {};</tt>
<br><tt>&nbsp;&nbsp;&nbsp; inline int_ddata( int datum ) : info( datum ) {};</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; info;</tt>
<br><tt>};</tt>
<br><br><tt>static void test1( void );</tt>
<br><br><tt>void data_isv_prt( int_ddata * data, void * str ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; (char *)str &lt;&lt; &quot;&#91;&quot; &lt;&lt; data-&gt;info &lt;&lt; &quot;&#93;\n&quot;;</tt>
<br><tt>}</tt>
<br><br><tt>void main() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; try {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test1();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } catch( ... ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;we caught an unexpected exception\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout.flush();</tt>
<br><tt>}</tt>
<br><br><tt>void test1 ( void ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WCIsvDList&lt;int_ddata&gt;&nbsp;&nbsp; list;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int_ddata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data1(1);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int_ddata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data2(2);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int_ddata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data3(3);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int_ddata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data4(4);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int_ddata&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data5(5);</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; list.exceptions( WCExcept::check_all );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.append( &amp;data2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.append( &amp;data3 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.append( &amp;data4 );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; list.insert( &amp;data1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.append( &amp;data5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;&lt;intrusive double list for int_ddata&gt;\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.forAll( data_isv_prt, &quot;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; data_isv_prt( list.find( 3 ), &quot;&lt;the fourth element&gt;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; data_isv_prt( list.get( 2 ), &quot;&lt;the third element&gt;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; data_isv_prt( list.get(), &quot;&lt;the first element&gt;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.clear();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout.flush();</tt>
<br><tt>}</tt>
</dl>
<h2 id="WCIsvSListXTypeY__WCIsvSListLR"> WCIsvSList() &#91;WCIsvSList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCIsvSList();</tt>
<dt><br>Semantics:
<dd>The<tt> WCIsvSList</tt> public member function creates an empty<tt> WCIsvSList</tt> object.
<dt><br>Results:
<dd>The<tt> WCIsvSList</tt> public member function produces an initialized<tt> WCIsvSList</tt> object.
<dt><br>See Also:
<dd><tt> ~WCIsvSList</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>private:</tt>
<br><tt>void WCIsvSList( const WCIsvSList &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCIsvSList</tt> private member function is the copy constructor for the single linked list class.&nbsp; Making a copy
 of the list object would result in a error condition, since intrusive lists cannot share data items with other lists.
</dl>
<h2 id="WCIsvSListXTypeY____WCIsvSListLR"> ~WCIsvSList() &#91;WCIsvSList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCIsvSList();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCIsvSList</tt> public member function destroys the<tt> WCIsvSList</tt> object.&nbsp; If the list is not empty and
 the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; If the<tt> not_empty</tt> exception is not enabled
 and the list is not empty, the list is cleared using the<tt> clear</tt> member function.&nbsp; The call to the<tt> ~WCIsvSList</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCIsvSList</tt> object goes out
 of scope.
<dt><br>Results:
<dd>The<tt> WCIsvSList</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCIsvSList</tt>,<tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCIsvDListXTypeY__WCIsvDListLR"> WCIsvDList() &#91;WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCIsvDList();</tt>
<dt><br>Semantics:
<dd>The<tt> WCIsvDList</tt> public member function creates an empty<tt> WCIsvDList</tt> object.
<dt><br>Results:
<dd>The<tt> WCIsvDList</tt> public member function produces an initialized<tt> WCIsvDList</tt> object.
<dt><br>See Also:
<dd><tt> ~WCIsvDList</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>private:</tt>
<br><tt>WCIsvDList( const WCIsvDList &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCIsvDList</tt> private member function is the copy constructor for the double linked list class.&nbsp; Making a copy
 of the list object would result in a error condition, since intrusive lists cannot share data items with other lists.
</dl>
<h2 id="WCIsvDListXTypeY____WCIsvDListLR"> ~WCIsvDList() &#91;WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCIsvDList();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCIsvDList</tt> public member function destroys the<tt> WCIsvDList</tt> object.&nbsp; If the list is not empty and
 the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; If the<tt> not_empty</tt> exception is not enabled
 and the list is not empty, the list is cleared using the<tt> clear</tt> member function.&nbsp; The call to the<tt> ~WCIsvDList</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCIsvDList</tt> object goes out
 of scope.
<dt><br>Results:
<dd>The<tt> WCIsvDList</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCIsvDList</tt>,<tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCIsvSListXTypeY__appendLR__WCIsvDListXTypeY__appendLR"> append() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int append( Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> append</tt> public member function is used to append the list element object to the end of the list.&nbsp; The address
 of (a pointer to) the list element object should be passed, not the value.&nbsp; Since the linkage information is stored
 in the list element, it is not possible for the element to be in more than one list, or in the same list more than once.
<br>The passed list element should be constructed using the appropriate link class as a base.<tt>&nbsp; WCSLink</tt> must
 be used as a list element base class for single linked lists, and<tt> WCDLink</tt> must be used as a list element base class
 for double linked lists.
<dt><br>Results:
<dd>The list element is appended to the end of the list and a TRUE value (non-zero) is returned.
<dt><br>See Also:
<dd><tt> insert</tt>
</dl>
<h2 id="WCIsvSListXTypeY__clearLR__WCIsvDListXTypeY__clearLR"> clear() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the list object and set it to the state of the object just after
 the initial construction.&nbsp; The list object is not destroyed and re-created by this operator, so the object destructor
 is not invoked.&nbsp; The list elements are not cleared.&nbsp; Any list items still in the list are lost unless pointed to
 by some pointer object in the program code.
<br>If any of the list elements are not allocated with<tt> new</tt> (local variable or global list elements), then the<tt>
 clear</tt> public member function must be used.&nbsp; When all list elements are allocated with<tt> new,</tt> the<tt> clearAndDestory</tt>
 member function should be used.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function resets the list object to the state of the object immediately after the initial
 construction.
<dt><br>See Also:
<dd><tt> ~WCIsvSList</tt>,<tt> ~WCIsvDList</tt>,<tt> clearAndDestroy</tt>,<tt> get</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCIsvSListXTypeY_WCIsvDListXTypeY__clearAndDestroyLR"> clearAndDestroy() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clearAndDestroy();</tt>
<dt><br>Semantics:
<dd>The<tt> clearAndDestroy</tt> public member function is used to clear the list object and set it to the state of the object
 just after the initial construction.&nbsp; The list object is not destroyed and re-created by this operator, so the object
 destructor is not invoked.&nbsp; The link elements are deleted before the list is re-initialized.
<br>If any elements in the list were not allocated by the<tt> new</tt> operator, the<tt> clearAndDestroy</tt> public member
 function must not be called.&nbsp; The<tt> clearAndDestroy</tt> public member function destroys each list element with the
 destructor for<tt> Type</tt> even if the list element was created as an object derived from<tt> Type,</tt> unless<tt> Type</tt>
 has a pure virtual destructor.
<dt><br>Results:
<dd>The<tt> clearAndDestroy</tt> public member function resets the list object to the initial state of the object immediately
 after the initial construction and deletes the list elements.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> get</tt>
</dl>
<h2 id="WCIsvSListXTypeY__containsLR__WCIsvDListXTypeY__containsLR"> contains() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int contains( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> contains</tt> public member function is used to determine if a list element object is already contained in the list.
&nbsp; The address of (a pointer to) the list element object should be passed, not the value.&nbsp; Each list element is compared
 to the passed element object to determine if it has the same address.&nbsp; Note that the comparison is of the addresses
 of the elements, not the contained values.
<dt><br>Results:
<dd>Zero(0) is returned if the passed list element object is not found in the list.&nbsp; A non-zero result is returned if the
 element is found in the list.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> index</tt>
</dl>
<h2 id="WCIsvSListXTypeY__entriesLR__WCIsvDListXTypeY__entriesLR"> entries() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to determine the number of list elements contained in the list object.
<dt><br>Results:
<dd>The number of entries stored in the list is returned, zero(0) is returned if there are no list elements.
<dt><br>See Also:
<dd><tt> isEmpty</tt>
</dl>
<h2 id="WCIsvSListXTypeY__findLR__WCIsvDListXTypeY__findLR"> find() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * find( int = 0 ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> find</tt> public member function returns a pointer to a list element in the list object.&nbsp; The list element is
 not removed from the list, so care must be taken not to delete the element returned to you.&nbsp; The optional parameter
 specifies which element to locate, and defaults to the first element.&nbsp; Since the first element of the list is the zero'th
 element, the last element will be the number of list entries minus one.
<br>If the list is empty and the<tt> empty_container</tt> exception is enabled, the exception is thrown.&nbsp; If the<tt>
 index_range</tt> exception is enabled, the exception is thrown if the index value is negative or is greater than the number
 of list entries minus one.
<dt><br>Results:
<dd>A pointer to the selected list element or the closest list element is returned.&nbsp; If the index value is negative, the
 closest list element is the first element.&nbsp; The last element is the closest element if the index value is greater than
 the number of list entries minus one.&nbsp; A value of NULL(0) is returned if there are no elements in the list.
<dt><br>See Also:
<dd><tt> findLast</tt>,<tt> get</tt>,<tt> index</tt>,<tt> isEmpty</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCIsvSListXTypeY__findLastLR__WCIsvDListXTypeY__findLastLR"> findLast() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * findLast() const;</tt>
<dt><br>Semantics:
<dd>The<tt> findLast</tt> public member function returns a pointer to the last list element in the list object.&nbsp; The list
 element is not removed from the list, so care must be taken not to delete the element returned to you.
<br>If the list is empty, one of two exceptions can be thrown.&nbsp; If the<tt> empty_container</tt> exception is enabled,
 it is thrown.&nbsp; The<tt> index_range</tt> exception is thrown if it is enabled and the<tt> empty_container</tt> exception
 is not enabled.
<dt><br>Results:
<dd>A pointer to the last list element is returned.&nbsp; A value of NULL(0) is returned if there are no elements in the list.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> get</tt>,<tt> isEmpty</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCIsvSListXTypeY__forAllLR__WCIsvDListXTypeY__forAllLR"> forAll() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void forAll( void (*fn)( Type *, void * ), void *);</tt>
<dt><br>Semantics:
<dd>The<tt> forAll</tt> public member function is used to cause the function<b> fn</b> to be invoked for each list element.&nbsp;
 The<b> fn</b> function should have the prototype
<br><tt>void (*fn)( Type *, void * )</tt>
<br><br>The first parameter of<b> fn</b> shall accept a pointer to the list element currently active.&nbsp; The second argument
 passed to<b> fn</b> is the second argument of the<tt> forAll</tt> function.&nbsp; This allows a callback function to be defined
 which can accept data appropriate for the point at which the<tt> forAll</tt> function is invoked.
<dt><br>See Also:
<dd><tt> WCIsvConstSListIter</tt>,<tt> WCIsvConstDListIter</tt>,<tt> WCIsvSListIter</tt>,<tt> WCIsvDListIter</tt>
</dl>
<h2 id="WCIsvSListXTypeY__getLR__WCIsvDListXTypeY__getLR"> get() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * get( int = 0 );</tt>
<dt><br>Semantics:
<dd>The<tt> get</tt> public member function returns a pointer to a list element in the list object.&nbsp; The list element is
 also removed from the list.&nbsp; The optional parameter specifies which element to remove, and defaults to the first element.
&nbsp; Since the first element of the list is the zero'th element, the last element will be the number of list entries minus
 one.
<br>If the list is empty and the<tt> empty_container</tt> exception is enabled, the exception is thrown.&nbsp; If the<tt>
 index_range</tt> exception trap is enabled, the exception is thrown if the index value is negative or is greater than the
 number of list entries minus one.
<dt><br>Results:
<dd>A pointer to the selected list element or the closest list element is removed and returned.&nbsp; If the index value is negative,
 the closest list element is the first element.&nbsp; The last element is the closest element if the index value is greater
 than the number of list entries minus one.&nbsp; A value of NULL(0) is returned if there are no elements in the list.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> find</tt>,<tt> index</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCIsvSListXTypeY__indexLR__WCIsvDListXTypeY__indexLR"> index() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int index( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> index</tt> public member function is used to determine the index of the first list element equivalent to the passed
 element.&nbsp; The address of (a pointer to) the list element object should be passed, not the value.&nbsp; Each list element
 is compared to the passed element object to determine if it has the same address.&nbsp; Note that the comparison is of the
 addresses of the elements, not the contained values.
<dt><br>Results:
<dd>The index of the first element equivalent to the passed element is returned.&nbsp; If the passed element is not in the list,
 negative one (-1) is returned.
<dt><br>See Also:
<dd><tt> contains</tt>,<tt> find</tt>,<tt> get</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int index( int (*test_fn)( const Type *, void * ),</tt>
<br><tt> void * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> index</tt> public member function is used to determine the index of the first list element for which the supplied<b>
 test_fn</b> function returns true.&nbsp; The<b> test_fn</b> function must have the prototype:
<br><tt>int (*test_fn)( const Type *, void * );</tt>
<br><br>Each list element is passed in turn to the<b> test_fn</b> function as the first argument.&nbsp; The second parameter
 passed is the second argument of the<tt> index</tt> function.&nbsp; This allows the<b> test_fn</b> callback function to accept
 data appropriate for the point at which the<tt> index</tt> function is invoked.&nbsp; The supplied<b> test_fn</b> shall return
 a TRUE (non-zero) value when the index of the passed element is desired.&nbsp; Otherwise, a FALSE (zero) value shall be returned.
<dt><br>Results:
<dd>The index of the first list element for which the<b> test_fn</b> function returns non-zero is returned.&nbsp; If the<b> test_fn</b>
 function returns zero for all list elements, negative one (-1) is returned.
<dt><br>See Also:
<dd><tt> contains</tt>,<tt> find</tt>,<tt> get</tt>
</dl>
<h2 id="WCIsvSListXTypeY__insertLR__WCIsvDListXTypeY__insertLR"> insert() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function is used to insert the list element object to the beginning of the list.&nbsp; The
 address of (a pointer to) the list element object should be passed, not the value.&nbsp; Since the linkage information is
 stored in the list element, it is not possible for the element to be in more than one list, or in the same list more than
 once.
<br>The passed list element should be constructed using the appropriate link class as a base.<tt>&nbsp; WCSLink</tt> must
 be used as a list element base class for single linked lists, and<tt> WCDLink</tt> must be used as a list element base class
 for double linked lists.
<dt><br>Results:
<dd>The list element is inserted as the first element of the list and a TRUE value (non-zero) is returned.
<dt><br>See Also:
<dd><tt> append</tt>
</dl>
<h2 id="WCIsvSListXTypeY__isEmptyLR__WCIsvDListXTypeY__isEmptyLR"> isEmpty() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if a list object has any list elements contained in it.
<dt><br>Results:
<dd>A TRUE value (non-zero) is returned if the list object does not have any list elements contained within it.&nbsp; A FALSE
 (zero) result is returned if the list contains at least one element.
<dt><br>See Also:
<dd><tt> entries</tt>
</dl>
<h2 id="WCIsvSListXTypeY__operator_ELR__WCIsvDListXTypeY__operator_ELR"> operator =() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>private:</tt>
<br><tt>WCIsvSList &amp; WCIsvSList::operator =( const WCIsvSList &amp; );</tt>
<br><tt> WCIsvDList &amp; WCIsvDList::operator =( const WCIsvDList &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> private member function is the assignment operator for the class.&nbsp; Since making a copy of the
 list object would result in a error condition, it is made inaccessible by making it a private operator.
</dl>
<h2 id="WCIsvSListXTypeY__operator_EELR__WCIsvDListXTypeY__operator_EELR"> operator ==() &#91;WCIsvSList&lt;Type&gt;,WCIsvDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int WCIsvSList::operator ==( const WCIsvSList &amp; ) const;</tt>
<br><tt> int WCIsvDList::operator ==( const WCIsvDList &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the<tt> WCIsvSList&lt;Type&gt;</tt> and<tt>
 WCIsvDList&lt;Type&gt;</tt> classes.&nbsp; Two list objects are equivalent if they are the same object and share the same
 address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side object and the right hand side objects are the same object.&nbsp;
 A FALSE (zero) value is returned otherwise.
</dl>
<h2 id="WCPtrSListXTypeY__WCPtrDListXTypeY_Class_Description"> WCPtrSList&lt;Type&gt;, WCPtrDList&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wclist.h</tt>
<br>The<tt> WCPtrSList&lt;Type&gt;</tt> and<tt> WCPtrDList&lt;Type&gt;</tt> classes are the templated classes used to create
 objects which are single or double linked lists.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the type value specified as the
 template parameter.&nbsp; The pointers stored in the list point to values of type<tt> Type.</tt>
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCPtrSList&lt;Type&gt;</tt> and<tt> WCPtrDList&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCPtrSList&lt;Type&gt;</tt> and<tt> WCPtrDList&lt;Type&gt;</tt> objects.&nbsp; No exceptions are enabled
 unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Type</b>
<br><br>The<tt> WCPtrSList&lt;Type&gt;</tt> and<tt> WCPtrDList&lt;Type&gt;</tt> classes requires<tt> Type</tt> to have:
<br>(1) an equivalence operator with constant parameters
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type::operator ==( const Type &amp; ) const</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCPtrSList();</tt>
<br><tt> WCPtrSList( void * (*)( size_t ), void (*)( void *, size_t ));</tt>
<br><tt> WCPtrSList( const WCPtrSList &amp; );</tt>
<br><tt> ~WCPtrSList();</tt>
<br><tt> WCPtrDList();</tt>
<br><tt> WCPtrDList( void * (*)( size_t ), void (*)( void *, size_t ));</tt>
<br><tt> WCPtrDList( const WCPtrDList &amp; );</tt>
<br><tt> ~WCPtrDList();</tt>
<br><tt> int append( Type * );</tt>
<br><tt> void clear();</tt>
<br><tt> void clearAndDestroy();</tt>
<br><tt> int contains( const Type * ) const;</tt>
<br><tt> int entries() const;</tt>
<br><tt> Type * find( int = 0 ) const;</tt>
<br><tt> Type * findLast() const;</tt>
<br><tt> void forAll( void (*)( Type *, void * ), void *) const;</tt>
<br><tt> Type * get( int = 0 );</tt>
<br><tt> int index( const Type * ) const;</tt>
<br><tt> int insert( Type * );</tt>
<br><tt> int isEmpty() const;</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>WCPtrSList &amp; WCPtrSList::operator =( const WCPtrSList &amp; );</tt>
<br><tt> WCPtrDList &amp; WCPtrDList::operator =( const WCPtrDList &amp; );</tt>
<br><tt> int WCPtrSList::operator ==( const WCPtrSList &amp; ) const;</tt>
<br><tt> int WCPtrDList::operator ==( const WCPtrDList &amp; ) const;</tt>
<br><br><b>Sample Program Using a Pointer List</b>
<br><br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><br><tt>static void test1( void );</tt>
<br><br><tt>void data_ptr_prt( int * data, void * str ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; (char *)str &lt;&lt; &quot;&#91;&quot; &lt;&lt; *data &lt;&lt; &quot;&#93;\n&quot;;</tt>
<br><tt>}</tt>
<br><br><tt>void main() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; try {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test1();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } catch( ... ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;we caught an unexpected exception\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout.flush();</tt>
<br><tt>}</tt>
<br><br><tt>void test1 ( void ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WCPtrDList&lt;int&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; data1(1);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; data2(2);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; data3(3);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; data4(4);</tt>
<br><tt>&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; data5(5);</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; list.append( &amp;data2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.append( &amp;data3 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.append( &amp;data4 );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; list.insert( &amp;data1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.append( &amp;data5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;&lt;pointer double list for int&gt;\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.forAll( data_ptr_prt, &quot;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; data_ptr_prt( list.find( 3 ), &quot;&lt;the fourth element&gt;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; data_ptr_prt( list.get( 2 ), &quot;&lt;the third element&gt;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; data_ptr_prt( list.get(), &quot;&lt;the first element&gt;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.clear();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout.flush();</tt>
<br><tt>}</tt>
</dl>
<h2 id="WCPtrSListXTypeY__WCPtrSListLR"> WCPtrSList() &#91;WCPtrSList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSList();</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSList</tt> public member function creates an empty<tt> WCPtrSList</tt> object.
<dt><br>Results:
<dd>The<tt> WCPtrSList</tt> public member function produces an initialized<tt> WCPtrSList</tt> object.
<dt><br>See Also:
<dd><tt> WCPtrSList</tt>,<tt> ~WCPtrSList</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSList( void *(*allocator)( size_t ),</tt>
<br><tt> void (*deallocator)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSList</tt> public member function creates an empty<tt> WCPtrSList&lt;Type&gt;</tt> object.&nbsp; The<b> allocator</b>
 function is registered to perform all memory allocations of the list elements, and the<b> deallocator</b> function to perform
 all freeing of the list elements' memory.&nbsp; These functions provide the ability to control how the allocation and freeing
 of memory is performed, allowing for more efficient memory handling than the general purpose global<tt> operator new()</tt>
 and<tt> operator delete()</tt> can provide.&nbsp; Memory management optimizations may potentially be made through the<b>
 allocator</b> and<b> deallocator</b> functions, but are not recommended before managing memory is understood and determined
 to be worth while.
<br>The<b> allocator</b> function shall return a pointer to allocated memory of size at least the argument, or zero(0) if
 the allocation cannot be performed.&nbsp; Initialization of the memory returned is performed by the<tt> WCPtrSList&lt;Type&gt;</tt>
 class.
<br><br>The<tt> WCPtrSList&lt;Type&gt;</tt> class calls the<b> deallocator</b> function only on memory allocated by the<b>
 allocator</b> function.&nbsp; The<b> deallocator</b> shall free the memory pointed to by the first argument which is of size
 the second argument.&nbsp; The size passed to the<b> deallocator</b> function is guaranteed to be the same size passed to
 the<b> allocator</b> function when the memory was allocated.
<br><br>The<b> allocator</b> and<b> deallocator</b> functions may assume that for a list object instance, the<b> allocator</b>
 is always called with the same first argument (the size of the memory to be allocated).&nbsp; The<tt> WCValSListItemSize(Type)</tt>
 macro returns the size of the elements which are allocated by the<b> allocator</b> function.
<dt><br>Results:
<dd>The<tt> WCPtrSList</tt> public member function creates an initialized<tt> WCPtrSList&lt;Type&gt;</tt> object and registers
 the<b> allocator</b> and<b> deallocator</b> functions.
<dt><br>See Also:
<dd><tt> WCPtrSList</tt>,<tt> ~WCPtrSList</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void WCPtrSList( const WCPtrSList &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSList</tt> public member function is the copy constructor for the single linked list class.&nbsp; All of the
 list elements are copied to the new list, as well as the exception trap states, and any registered<b> allocator</b> and<b>
 deallocator</b> functions.
<br>If all of the elements cannot be copied and the<tt> out_of_memory</tt> is enabled in the list being copied, the exception
 is thrown.&nbsp; The new list is created in a valid state, even if all of the list elements could not be copied.
<dt><br>Results:
<dd>The<tt> WCPtrSList</tt> public member function produces a copy of the list.
<dt><br>See Also:
<dd><tt> WCPtrSList</tt>,<tt> ~WCPtrSList</tt>,<tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrSListXTypeY____WCPtrSListLR"> ~WCPtrSList() &#91;WCPtrSList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCPtrSList();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCPtrSList</tt> public member function destroys the<tt> WCPtrSList</tt> object.&nbsp; If the list is not empty and
 the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; If the<tt> not_empty</tt> exception is not enabled
 and the list is not empty, the list is cleared using the<tt> clear</tt> member function.&nbsp; The call to the<tt> ~WCPtrSList</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCPtrSList</tt> object goes out
 of scope.
<dt><br>Results:
<dd>The<tt> WCPtrSList</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCPtrSList</tt>,<tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCPtrDListXTypeY__WCPtrDListLR"> WCPtrDList() &#91;WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrDList();</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrDList</tt> public member function creates an empty<tt> WCPtrDList</tt> object.
<dt><br>Results:
<dd>The<tt> WCPtrDList</tt> public member function produces an initialized<tt> WCPtrDList</tt> object.
<dt><br>See Also:
<dd><tt> WCPtrDList</tt>,<tt> ~WCPtrDList</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrDList( void *(*allocator)( size_t ),</tt>
<br><tt> void (*deallocator)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrDList</tt> public member function creates an empty<tt> WCPtrDList&lt;Type&gt;</tt> object.&nbsp; The<b> allocator</b>
 function is registered to perform all memory allocations of the list elements, and the<b> deallocator</b> function to perform
 all freeing of the list elements' memory.&nbsp; These functions provide the ability to control how the allocation and freeing
 of memory is performed, allowing for more efficient memory handling than the general purpose global<tt> operator new()</tt>
 and<tt> operator delete()</tt> can provide.&nbsp; Memory management optimizations may potentially be made through the<b>
 allocator</b> and<b> deallocator</b> functions, but are not recommended before managing memory is understood and determined
 to be worth while.
<br>The<b> allocator</b> function shall return a pointer to allocated memory of size at least the argument, or zero(0) if
 the allocation cannot be performed.&nbsp; Initialization of the memory returned is performed by the<tt> WCPtrDList&lt;Type&gt;</tt>
 class.
<br><br>The<tt> WCPtrDList&lt;Type&gt;</tt> class calls the<b> deallocator</b> function only on memory allocated by the<b>
 allocator</b> function.&nbsp; The<b> deallocator</b> shall free the memory pointed to by the first argument which is of size
 the second argument.&nbsp; The size passed to the<b> deallocator</b> function is guaranteed to be the same size passed to
 the<b> allocator</b> function when the memory was allocated.
<br><br>The<b> allocator</b> and<b> deallocator</b> functions may assume that for a list object instance, the<b> allocator</b>
 is always called with the same first argument (the size of the memory to be allocated).&nbsp; The<tt> WCValDListItemSize(Type)</tt>
 macro returns the size of the elements which are allocated by the<b> allocator</b> function.
<dt><br>Results:
<dd>The<tt> WCPtrDList</tt> public member function creates an initialized<tt> WCPtrDList&lt;Type&gt;</tt> object and registers
 the<b> allocator</b> and<b> deallocator</b> functions.
<dt><br>See Also:
<dd><tt> WCPtrDList</tt>,<tt> ~WCPtrDList</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrDList( const WCPtrDList &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrDList</tt> public member function is the copy constructor for the double linked list class.&nbsp; All of the
 list elements are copied to the new list, as well as the exception trap states, and any registered<b> allocator</b> and<b>
 deallocator</b> functions.
<br>If all of the elements cannot be copied and the<tt> out_of_memory</tt> is enabled in the list being copied, the exception
 is thrown.&nbsp; The new list is created in a valid state, even if all of the list elements could not be copied.
<dt><br>Results:
<dd>The<tt> WCPtrDList</tt> public member function produces a copy of the list.
<dt><br>See Also:
<dd><tt> WCPtrDList</tt>,<tt> ~WCPtrDList</tt>,<tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrDListXTypeY____WCPtrDListLR"> ~WCPtrDList() &#91;WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCPtrDList();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCPtrDList</tt> public member function destroys the<tt> WCPtrDList</tt> object.&nbsp; If the list is not empty and
 the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; If the<tt> not_empty</tt> exception is not enabled
 and the list is not empty, the list is cleared using the<tt> clear</tt> member function.&nbsp; The call to the<tt> ~WCPtrDList</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCPtrDList</tt> object goes out
 of scope.
<dt><br>Results:
<dd>The<tt> WCPtrDList</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCPtrDList</tt>,<tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCPtrSListXTypeY__appendLR__WCPtrDListXTypeY__appendLR"> append() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int append( Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> append</tt> public member function is used to append the data to the end of the list.
<br>If the<tt> out_of_memory</tt> exception is enabled and the append fails, the exception is thrown.
<dt><br>Results:
<dd>The data element is appended to the end of the list.&nbsp; A TRUE value (non-zero) is returned if the append is successful.
&nbsp; A FALSE (zero) result is returned if the append fails.
<dt><br>See Also:
<dd><tt> insert</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrSListXTypeY__clearLR__WCPtrDListXTypeY__clearLR"> clear() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the list object and set it to the state of the object just after
 the initial construction.&nbsp; The list object is not destroyed and re-created by this operator, so the object destructor
 is not invoked.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function resets the list object to the state of the object immediately after the initial
 construction.
<dt><br>See Also:
<dd><tt> ~WCPtrSList</tt>,<tt> ~WCPtrDList</tt>,<tt> clearAndDestroy</tt>,<tt> get</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCPtrSListXTypeY_WCPtrDListXTypeY__clearAndDestroyLR"> clearAndDestroy() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clearAndDestroy();</tt>
<dt><br>Semantics:
<dd>The<tt> clearAndDestroy</tt> public member function is used to clear the list object and set it to the state of the object
 just after the initial construction.&nbsp; The list object is not destroyed and re-created by this operator, so the object
 destructor is not invoked.&nbsp; Before the list object is re-initialized, the the values pointed to by the list elements
 are deleted.
<dt><br>Results:
<dd>The<tt> clearAndDestroy</tt> public member function resets the list object to the initial state of the object immediately
 after the initial construction and deletes the list elements.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> get</tt>
</dl>
<h2 id="WCPtrSListXTypeY__containsLR__WCPtrDListXTypeY__containsLR"> contains() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int contains( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> contains</tt> public member function is used to determine if a list element object is already contained in the list.
&nbsp; Each list element is compared to the passed element using<tt> Type's operator ==</tt> to determine if the passed element
 is contained in the list.&nbsp; Note that the comparison is of the objects pointed to.
<dt><br>Results:
<dd>Zero(0) is returned if the passed list element object is not found in the list.&nbsp; A non-zero result is returned if the
 element is found in the list.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> index</tt>
</dl>
<h2 id="WCPtrSListXTypeY__entriesLR__WCPtrDListXTypeY__entriesLR"> entries() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to determine the number of list elements contained in the list object.
<dt><br>Results:
<dd>The number of entries stored in the list is returned, zero(0) is returned if there are no list elements.
<dt><br>See Also:
<dd><tt> isEmpty</tt>
</dl>
<h2 id="WCPtrSListXTypeY__findLR__WCPtrDListXTypeY__findLR"> find() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * find( int = 0 ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> find</tt> public member function returns the value of a list element in the list object.&nbsp; The optional parameter
 specifies which element to locate, and defaults to the first element.&nbsp; Since the first element of the list is the zero'th
 element, the last element will be the number of list entries minus one.
<br>If the list is empty and the<tt> empty_container</tt> exception is enabled, the exception is thrown.&nbsp; If the<tt>
 index_range</tt> exception is enabled, the exception is thrown if the index value is negative or is greater than the number
 of list entries minus one.
<dt><br>Results:
<dd>The value of the selected list element or the closest element is returned.&nbsp; If the index value is negative, the closest
 list element is the first element.&nbsp; The last element is the closest element if the index value is greater than the number
 of list entries minus one.&nbsp; An uninitialized pointer is returned if there are no elements in the list.
<dt><br>See Also:
<dd><tt> findLast</tt>,<tt> get</tt>,<tt> index</tt>,<tt> isEmpty</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCPtrSListXTypeY__findLastLR__WCPtrDListXTypeY__findLastLR"> findLast() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * findLast() const;</tt>
<dt><br>Semantics:
<dd>The<tt> findLast</tt> public member function returns the value of the last list element in the list object.
<br>If the list is empty, one of two exceptions can be thrown.&nbsp; If the<tt> empty_container</tt> exception is enabled,
 it is thrown.&nbsp; The<tt> index_range</tt> exception is thrown if it is enabled and the<tt> empty_container</tt> exception
 is not enabled.
<dt><br>Results:
<dd>The value of the last list element is returned.&nbsp; An uninitialized pointer is returned if there are no elements in the
 list.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> get</tt>,<tt> isEmpty</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCPtrSListXTypeY__forAllLR__WCPtrDListXTypeY__forAllLR"> forAll() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void forAll( void (*)( Type *, void * ), void *) const;</tt>
<dt><br>Semantics:
<dd>The<tt> forAll</tt> public member function is used to cause the function<b> fn</b> to be invoked for each list element.&nbsp;
 The<b> fn</b> function should have the prototype
<br><tt>void (*fn)( Type *, void * )</tt>
<br><br>The first parameter of<b> fn</b> shall accept the value of the list element currently active.&nbsp; The second argument
 passed to<b> fn</b> is the second argument of the<tt> forAll</tt> function.&nbsp; This allows a callback function to be defined
 which can accept data appropriate for the point at which the<tt> forAll</tt> function is invoked.
<dt><br>See Also:
<dd><tt> WCPtrConstSListIter</tt>,<tt> WCPtrConstDListIter</tt>,<tt> WCPtrSListIter</tt>,<tt> WCPtrDListIter</tt>
</dl>
<h2 id="WCPtrSListXTypeY__getLR__WCPtrDListXTypeY__getLR"> get() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * get( int = 0 );</tt>
<dt><br>Semantics:
<dd>The<tt> get</tt> public member function returns the value of the list element in the list object.&nbsp; The list element is
 also removed from the list.&nbsp; The optional parameter specifies which element to remove, and defaults to the first element.
&nbsp; Since the first element of the list is the zero'th element, the last element will be the number of list entries minus
 one.
<br>If the list is empty and the<tt> empty_container</tt> exception is enabled, the exception is thrown.&nbsp; If the<tt>
 index_range</tt> exception trap is enabled, the exception is thrown if the index value is negative or is greater than the
 number of list entries minus one.
<dt><br>Results:
<dd>The value of the selected list element or the closest element is removed and returned.&nbsp; If the index value is negative,
 the closest list element is the first element.&nbsp; The last element is the closest element if the index value is greater
 than the number of list entries minus one.&nbsp; An uninitialized pointer is returned if there are no elements in the list.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> find</tt>,<tt> index</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCPtrSListXTypeY__indexLR__WCPtrDListXTypeY__indexLR"> index() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int index( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> index</tt> public member function is used to determine the index of the first list element equivalent to the passed
 element.&nbsp; Each list element is compared to the passed element using<tt> Type's operator ==</tt> until the passed element
 is found, or all list elements have been checked.&nbsp; Note that the comparison is of the objects pointed to.
<dt><br>Results:
<dd>The index of the first element equivalent to the passed element is returned.&nbsp; If the passed element is not in the list,
 negative one (-1) is returned.
<dt><br>See Also:
<dd><tt> contains</tt>,<tt> find</tt>,<tt> get</tt>
</dl>
<h2 id="WCPtrSListXTypeY__insertLR__WCPtrDListXTypeY__insertLR"> insert() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function is used to insert the data as the first element of the list.
<br>If the<tt> out_of_memory</tt> exception is enabled and the insert fails, the exception is thrown.
<dt><br>Results:
<dd>The data element is inserted into the beginning of the list.&nbsp; A TRUE value (non-zero) is returned if the insert is successful.
&nbsp; A FALSE (zero) result is returned if the insert fails.
<dt><br>See Also:
<dd><tt> append</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrSListXTypeY__isEmptyLR__WCPtrDListXTypeY__isEmptyLR"> isEmpty() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if a list object has any list elements contained in it.
<dt><br>Results:
<dd>A TRUE value (non-zero) is returned if the list object does not have any list elements contained within it.&nbsp; A FALSE
 (zero) result is returned if the list contains at least one element.
<dt><br>See Also:
<dd><tt> entries</tt>
</dl>
<h2 id="WCPtrSListXTypeY__operator_ELR__WCPtrDListXTypeY__operator_ELR"> operator =() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSList &amp; WCPtrSList::operator =( const WCPtrSList &amp; );</tt>
<br><tt> WCPtrDList &amp; WCPtrDList::operator =( const WCPtrDList &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the class.&nbsp; The left hand side of the assignment
 is first cleared with the<tt> clear</tt> member function.&nbsp; All elements in the right hand side list are then copied,
 as well as the exception trap states, and any registered<b> allocator</b> and<b> deallocator</b> functions.
<br>If all of the elements cannot be copied and the<tt> out_of_memory</tt> is enabled in the right hand side list, the exception
 is thrown.&nbsp; The new list is created in a valid state, even if all of the list elements could not be copied.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the right hand side to the left hand side and returns a reference to
 the left hand side.
<dt><br>See Also:
<dd><tt> WCPtrSList</tt>,<tt> WCPtrDList</tt>,<tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrSListXTypeY__operator_EELR__WCPtrDListXTypeY__operator_EELR"> operator ==() &#91;WCPtrSList&lt;Type&gt;,WCPtrDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int WCPtrSList::operator ==( const WCPtrSList &amp; ) const;</tt>
<br><tt> int WCPtrDList::operator ==( const WCPtrDList &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the<tt> WCPtrSList&lt;Type&gt;</tt> and<tt>
 WCPtrDList&lt;Type&gt;</tt> classes.&nbsp; Two list objects are equivalent if they are the same object and share the same
 address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side object and the right hand side objects are the same object.&nbsp;
 A FALSE (zero) value is returned otherwise.
</dl>
<h2 id="WCSLink_Class_Description"> WCSLink Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wclcom.h</tt>
<dt><br>Derived by:
<dd><tt> WCDLink</tt>
<br>The<tt> WCSLink</tt> class is the building block for all of the list classes.&nbsp; It provides the link that is used
 to traverse the list elements.&nbsp; The double link classes use the<tt> WCSLink</tt> class to implement both links.&nbsp;
 Since no user data is stored directly with it, the<tt> WCSLink</tt> class should only be used as a base class to derive a
 user defined class.
<br>When creating a single linked intrusive list, the<tt> WCSLink</tt> class is used to derive the user defined class that
 holds the data to be inserted into the list.
<br><br>The<tt> wclcom.h</tt> header file is included by the<tt> wclist.h</tt> header file.&nbsp; There is no need to explicitly
 include the<tt> wclcom.h</tt> header file unless the<tt> wclist.h</tt> header file is not included.&nbsp; No errors will
 result if it is included unnecessarily.
<br><br>Note that the destructor is non-virtual so that list elements are of minimum size.&nbsp; Objects created as a class
 derived from the<tt> WCSLink</tt> class, but destroyed while typed as a<tt> WCSLink</tt> object will not invoke the destructor
 of the derived class.
<br><br><b>Public Member Functions</b>
<br><br>The following public member functions are declared:
<br><br><tt>WCSLink();</tt>
<br><tt> ~WCSLink();</tt>
<dt><br>See Also:
<dd><tt> WCDLink</tt>
</dl>
<h2 id="WCSLink__WCSLinkLR"> WCSLink() &#91;WCSLink&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclcom.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCSLink();</tt>
<dt><br>Semantics:
<dd>The public<tt> WCSLink</tt> constructor creates an<tt> WCSLink</tt> object.&nbsp; The public<tt> WCSLink</tt> constructor
 is used implicitly by the compiler when it generates a constructor for a derived class.
<dt><br>Results:
<dd>The public<tt> WCSLink</tt> constructor produces an initialized<tt> WCSLink</tt> object.
<dt><br>See Also:
<dd><tt> ~WCSLink</tt>
</dl>
<h2 id="WCSLink____WCSLinkLR"> ~WCSLink() &#91;WCSLink&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclcom.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCSLink();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCSLink</tt> destructor does not do anything explicit.&nbsp; The call to the public<tt> ~WCSLink</tt> destructor
 is inserted implicitly by the compiler at the point where the object derived from WCSLink goes out of scope.
<dt><br>Results:
<dd>The object derived from WCSLink is destroyed.
<dt><br>See Also:
<dd><tt> WCSLink</tt>
</dl>
<h2 id="WCValSListXTypeY__WCValDListXTypeY_Class_Description"> WCValSList&lt;Type&gt;, WCValDList&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wclist.h</tt>
<br>The<tt> WCValSList&lt;Type&gt;</tt> and<tt> WCValDList&lt;Type&gt;</tt> classes are the templated classes used to create
 objects which are single or double linked lists.&nbsp; Values are copied into the list, which could be undesirable if the
 stored objects are complicated and copying is expensive.&nbsp; Value lists should not be used to store objects of a base
 class if any derived types of different sizes would be stored in the list, or if the destructor for a derived class must
 be called.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the type value specified as the
 template parameter.<tt>&nbsp; Type</tt> is the type of the values stored in the list.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCValSList&lt;Type&gt;</tt> and<tt> WCValDList&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCValSList&lt;Type&gt;</tt> and<tt> WCValDList&lt;Type&gt;</tt> objects.&nbsp; No exceptions are enabled
 unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Type</b>
<br><br>The<tt> WCValSList&lt;Type&gt;</tt> and<tt> WCValDList&lt;Type&gt;</tt> classes requires<tt> Type</tt> to have:
<br>(1) a default constructor (<tt> Type::Type()</tt> ).
<br><br>(2) a well defined copy constructor (<tt> Type::Type( const Type &amp; )</tt> ).
<br><br>(3) an equivalence operator with constant parameters
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type::operator ==( const Type &amp; ) const</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCValSList();</tt>
<br><tt> WCValSList( void * (*)( size_t ), void (*)( void *, size_t ));</tt>
<br><tt> WCValSList( const WCValSList &amp; );</tt>
<br><tt> ~WCValSList();</tt>
<br><tt> WCValDList();</tt>
<br><tt> WCValDList( void * (*)( size_t ), void (*)( void *, size_t ));</tt>
<br><tt> WCValDList( const WCValDList &amp; );</tt>
<br><tt> ~WCValDList();</tt>
<br><tt> int append( const Type &amp; );</tt>
<br><tt> void clear();</tt>
<br><tt> void clearAndDestroy();</tt>
<br><tt> int contains( const Type &amp; ) const;</tt>
<br><tt> int entries() const;</tt>
<br><tt> Type find( int = 0 ) const;</tt>
<br><tt> Type findLast() const;</tt>
<br><tt> void forAll( void (*)( Type, void * ), void *) const;</tt>
<br><tt> Type get( int = 0 );</tt>
<br><tt> int index( const Type &amp; ) const;</tt>
<br><tt> int insert( const Type &amp; );</tt>
<br><tt> int isEmpty() const;</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>WCValSList &amp; WCValSList::operator =( const WCValSList &amp; );</tt>
<br><tt> WCValDList &amp; WCValDList::operator =( const WCValDList &amp; );</tt>
<br><tt> int WCValSList::operator ==( const WCValSList &amp; ) const;</tt>
<br><tt> int WCValDList::operator ==( const WCValDList &amp; ) const;</tt>
<br><br><b>Sample Program Using a Value List</b>
<br><br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><br><tt>static void test1( void );</tt>
<br><br><tt>void data_val_prt( int data, void * str ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; (char *)str &lt;&lt; &quot;&#91;&quot; &lt;&lt; data &lt;&lt; &quot;&#93;\n&quot;;</tt>
<br><tt>}</tt>
<br><br><tt>void main() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; try {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test1();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } catch( ... ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;we caught an unexpected exception\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout.flush();</tt>
<br><tt>}</tt>
<br><br><tt>void test1 ( void ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WCValDList&lt;int&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; list.append( 2 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.append( 3 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.append( 4 );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; list.insert( 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.append( 5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;&lt;value double list for int&gt;\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.forAll( data_val_prt, &quot;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; data_val_prt( list.find( 3 ), &quot;&lt;the fourth element&gt;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; data_val_prt( list.get( 2 ), &quot;&lt;the third element&gt;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; data_val_prt( list.get(), &quot;&lt;the first element&gt;&quot; );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; list.clear();</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout.flush();</tt>
<br><tt>}</tt>
</dl>
<h2 id="WCValSListXTypeY__WCValSListLR"> WCValSList() &#91;WCValSList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSList();</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSList</tt> public member function creates an empty<tt> WCValSList</tt> object.
<dt><br>Results:
<dd>The<tt> WCValSList</tt> public member function produces an initialized<tt> WCValSList</tt> object.
<dt><br>See Also:
<dd><tt> WCValSList</tt>,<tt> ~WCValSList</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSList( void *(*allocator)( size_t ),</tt>
<br><tt> void (*deallocator)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSList</tt> public member function creates an empty<tt> WCValSList&lt;Type&gt;</tt> object.&nbsp; The<b> allocator</b>
 function is registered to perform all memory allocations of the list elements, and the<b> deallocator</b> function to perform
 all freeing of the list elements' memory.&nbsp; These functions provide the ability to control how the allocation and freeing
 of memory is performed, allowing for more efficient memory handling than the general purpose global<tt> operator new()</tt>
 and<tt> operator delete()</tt> can provide.&nbsp; Memory management optimizations may potentially be made through the<b>
 allocator</b> and<b> deallocator</b> functions, but are not recommended before managing memory is understood and determined
 to be worth while.
<br>The<b> allocator</b> function shall return a pointer to allocated memory of size at least the argument, or zero(0) if
 the allocation cannot be performed.&nbsp; Initialization of the memory returned is performed by the<tt> WCValSList&lt;Type&gt;</tt>
 class.
<br><br>The<tt> WCValSList&lt;Type&gt;</tt> class calls the<b> deallocator</b> function only on memory allocated by the<b>
 allocator</b> function.&nbsp; The<b> deallocator</b> shall free the memory pointed to by the first argument which is of size
 the second argument.&nbsp; The size passed to the<b> deallocator</b> function is guaranteed to be the same size passed to
 the<b> allocator</b> function when the memory was allocated.
<br><br>The<b> allocator</b> and<b> deallocator</b> functions may assume that for a list object instance, the<b> allocator</b>
 is always called with the same first argument (the size of the memory to be allocated).&nbsp; The<tt> WCValSListItemSize(Type)</tt>
 macro returns the size of the elements which are allocated by the<b> allocator</b> function.
<dt><br>Results:
<dd>The<tt> WCValSList</tt> public member function creates an initialized<tt> WCValSList&lt;Type&gt;</tt> object and registers
 the<b> allocator</b> and<b> deallocator</b> functions.
<dt><br>See Also:
<dd><tt> WCValSList</tt>,<tt> ~WCValSList</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void WCValSList( const WCValSList &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSList</tt> public member function is the copy constructor for the single linked list class.&nbsp; All of the
 list elements are copied to the new list, as well as the exception trap states, and any registered<b> allocator</b> and<b>
 deallocator</b> functions.<tt>&nbsp; Type's</tt> copy constructor is invoked to copy the values contained by the list elements.
<br>If all of the elements cannot be copied and the<tt> out_of_memory</tt> is enabled in the list being copied, the exception
 is thrown.&nbsp; The new list is created in a valid state, even if all of the list elements could not be copied.
<dt><br>Results:
<dd>The<tt> WCValSList</tt> public member function produces a copy of the list.
<dt><br>See Also:
<dd><tt> WCValSList</tt>,<tt> ~WCValSList</tt>,<tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValSListXTypeY____WCValSListLR"> ~WCValSList() &#91;WCValSList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCValSList();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCValSList</tt> public member function destroys the<tt> WCValSList</tt> object.&nbsp; If the list is not empty and
 the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; If the<tt> not_empty</tt> exception is not enabled
 and the list is not empty, the list is cleared using the<tt> clear</tt> member function.&nbsp; The call to the<tt> ~WCValSList</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCValSList</tt> object goes out
 of scope.
<dt><br>Results:
<dd>The<tt> WCValSList</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCValSList</tt>,<tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCValDListXTypeY__WCValDListLR"> WCValDList() &#91;WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValDList();</tt>
<dt><br>Semantics:
<dd>The<tt> WCValDList</tt> public member function creates an empty<tt> WCValDList</tt> object.
<dt><br>Results:
<dd>The<tt> WCValDList</tt> public member function produces an initialized<tt> WCValDList</tt> object.
<dt><br>See Also:
<dd><tt> WCValDList</tt>,<tt> ~WCValDList</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValDList( void *(*allocator)( size_t ),</tt>
<br><tt> void (*deallocator)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValDList</tt> public member function creates an empty<tt> WCValDList&lt;Type&gt;</tt> object.&nbsp; The<b> allocator</b>
 function is registered to perform all memory allocations of the list elements, and the<b> deallocator</b> function to perform
 all freeing of the list elements' memory.&nbsp; These functions provide the ability to control how the allocation and freeing
 of memory is performed, allowing for more efficient memory handling than the general purpose global<tt> operator new()</tt>
 and<tt> operator delete()</tt> can provide.&nbsp; Memory management optimizations may potentially be made through the<b>
 allocator</b> and<b> deallocator</b> functions, but are not recommended before managing memory is understood and determined
 to be worth while.
<br>The<b> allocator</b> function shall return a pointer to allocated memory of size at least the argument, or zero(0) if
 the allocation cannot be performed.&nbsp; Initialization of the memory returned is performed by the<tt> WCValDList&lt;Type&gt;</tt>
 class.
<br><br>The<tt> WCValDList&lt;Type&gt;</tt> class calls the<b> deallocator</b> function only on memory allocated by the<b>
 allocator</b> function.&nbsp; The<b> deallocator</b> shall free the memory pointed to by the first argument which is of size
 the second argument.&nbsp; The size passed to the<b> deallocator</b> function is guaranteed to be the same size passed to
 the<b> allocator</b> function when the memory was allocated.
<br><br>The<b> allocator</b> and<b> deallocator</b> functions may assume that for a list object instance, the<b> allocator</b>
 is always called with the same first argument (the size of the memory to be allocated).&nbsp; The<tt> WCValDListItemSize(Type)</tt>
 macro returns the size of the elements which are allocated by the<b> allocator</b> function.
<dt><br>Results:
<dd>The<tt> WCValDList</tt> public member function creates an initialized<tt> WCValDList&lt;Type&gt;</tt> object and registers
 the<b> allocator</b> and<b> deallocator</b> functions.
<dt><br>See Also:
<dd><tt> WCValDList</tt>,<tt> ~WCValDList</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValDList( const WCValDList &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValDList</tt> public member function is the copy constructor for the double linked list class.&nbsp; All of the
 list elements are copied to the new list, as well as the exception trap states, and any registered<b> allocator</b> and<b>
 deallocator</b> functions.<tt>&nbsp; Type's</tt> copy constructor is invoked to copy the values contained by the list elements.
<br>If all of the elements cannot be copied and the<tt> out_of_memory</tt> is enabled in the list being copied, the exception
 is thrown.&nbsp; The new list is created in a valid state, even if all of the list elements could not be copied.
<dt><br>Results:
<dd>The<tt> WCValDList</tt> public member function produces a copy of the list.
<dt><br>See Also:
<dd><tt> WCValDList</tt>,<tt> ~WCValDList</tt>,<tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValDListXTypeY____WCValDListLR"> ~WCValDList() &#91;WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCValDList();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCValDList</tt> public member function destroys the<tt> WCValDList</tt> object.&nbsp; If the list is not empty and
 the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; If the<tt> not_empty</tt> exception is not enabled
 and the list is not empty, the list is cleared using the<tt> clear</tt> member function.&nbsp; The call to the<tt> ~WCValDList</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCValDList</tt> object goes out
 of scope.
<dt><br>Results:
<dd>The<tt> WCValDList</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCValDList</tt>,<tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCValSListXTypeY__appendLR__WCValDListXTypeY__appendLR"> append() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int append( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> append</tt> public member function is used to append the data to the end of the list.&nbsp; The data stored in the
 list is a copy of the data passed as a parameter.
<br>If the<tt> out_of_memory</tt> exception is enabled and the append fails, the exception is thrown.
<dt><br>Results:
<dd>The data element is appended to the end of the list.&nbsp; A TRUE value (non-zero) is returned if the append is successful.
&nbsp; A FALSE (zero) result is returned if the append fails.
<dt><br>See Also:
<dd><tt> insert</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValSListXTypeY__clearLR__WCValDListXTypeY__clearLR"> clear() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the list object and set it to the state of the object just after
 the initial construction.&nbsp; The list object is not destroyed and re-created by this operator, so the object destructor
 is not invoked.
<br>The<tt> clear</tt> public member function has the same sematics as the<tt> clearAndDestroy</tt> member function.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function resets the list object to the state of the object immediately after the initial
 construction.
<dt><br>See Also:
<dd><tt> ~WCValSList</tt>,<tt> ~WCValDList</tt>,<tt> clearAndDestroy</tt>,<tt> get</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCValSListXTypeY_WCValDListXTypeY__clearAndDestroyLR"> clearAndDestroy() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clearAndDestroy();</tt>
<dt><br>Semantics:
<dd>The<tt> clearAndDestroy</tt> public member function is used to clear the list object and set it to the state of the object
 just after the initial construction.&nbsp; The list object is not destroyed and re-created by this operator, so the object
 destructor is not invoked.
<br>Before the list object is re-initialized, the delete operator is called for each list element.
<dt><br>Results:
<dd>The<tt> clearAndDestroy</tt> public member function resets the list object to the initial state of the object immediately
 after the initial construction.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> get</tt>
</dl>
<h2 id="WCValSListXTypeY__containsLR__WCValDListXTypeY__containsLR"> contains() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int contains( const Type &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> contains</tt> public member function is used to determine if a list element object is already contained in the list.
&nbsp; Each list element is compared to the passed element using<tt> Type's operator ==</tt> to determine if the passed element
 is contained in the list.
<dt><br>Results:
<dd>Zero(0) is returned if the passed list element object is not found in the list.&nbsp; A non-zero result is returned if the
 element is found in the list.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> index</tt>
</dl>
<h2 id="WCValSListXTypeY__entriesLR__WCValDListXTypeY__entriesLR"> entries() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to determine the number of list elements contained in the list object.
<dt><br>Results:
<dd>The number of entries stored in the list is returned, zero(0) is returned if there are no list elements.
<dt><br>See Also:
<dd><tt> isEmpty</tt>
</dl>
<h2 id="WCValSListXTypeY__findLR__WCValDListXTypeY__findLR"> find() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type find( int = 0 ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> find</tt> public member function returns the value of a list element in the list object.&nbsp; The optional parameter
 specifies which element to locate, and defaults to the first element.&nbsp; Since the first element of the list is the zero'th
 element, the last element will be the number of list entries minus one.
<br>If the list is empty and the<tt> empty_container</tt> exception is enabled, the exception is thrown.&nbsp; If the<tt>
 index_range</tt> exception is enabled, the exception is thrown if the index value is negative or is greater than the number
 of list entries minus one.
<dt><br>Results:
<dd>The value of the selected list element or the closest element is returned.&nbsp; If the index value is negative, the closest
 list element is the first element.&nbsp; The last element is the closest element if the index value is greater than the number
 of list entries minus one.&nbsp; A default initialized value is returned if there are no elements in the list.
<dt><br>See Also:
<dd><tt> findLast</tt>,<tt> get</tt>,<tt> index</tt>,<tt> isEmpty</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCValSListXTypeY__findLastLR__WCValDListXTypeY__findLastLR"> findLast() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type findLast() const;</tt>
<dt><br>Semantics:
<dd>The<tt> findLast</tt> public member function returns the value of the last list element in the list object.
<br>If the list is empty, one of two exceptions can be thrown.&nbsp; If the<tt> empty_container</tt> exception is enabled,
 it is thrown.&nbsp; The<tt> index_range</tt> exception is thrown if it is enabled and the<tt> empty_container</tt> exception
 is not enabled.
<dt><br>Results:
<dd>The value of the last list element is returned.&nbsp; A default initialized value is returned if there are no elements in
 the list.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> get</tt>,<tt> isEmpty</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCValSListXTypeY__forAllLR__WCValDListXTypeY__forAllLR"> forAll() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void forAll( void (*)( Type, void * ), void *) const;</tt>
<dt><br>Semantics:
<dd>The<tt> forAll</tt> public member function is used to cause the function<b> fn</b> to be invoked for each list element.&nbsp;
 The<b> fn</b> function should have the prototype
<br><tt>void (*fn)( Type, void * )</tt>
<br><br>The first parameter of<b> fn</b> shall accept the value of the list element currently active.&nbsp; The second argument
 passed to<b> fn</b> is the second argument of the<tt> forAll</tt> function.&nbsp; This allows a callback function to be defined
 which can accept data appropriate for the point at which the<tt> forAll</tt> function is invoked.
<dt><br>See Also:
<dd><tt> WCValConstSListIter</tt>,<tt> WCValConstDListIter</tt>,<tt> WCValSListIter</tt>,<tt> WCValDListIter</tt>
</dl>
<h2 id="WCValSListXTypeY__getLR__WCValDListXTypeY__getLR"> get() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type get( int = 0 );</tt>
<dt><br>Semantics:
<dd>The<tt> get</tt> public member function returns the value of the list element in the list object.&nbsp; The list element is
 also removed from the list.&nbsp; The optional parameter specifies which element to remove, and defaults to the first element.
&nbsp; Since the first element of the list is the zero'th element, the last element will be the number of list entries minus
 one.
<br>If the list is empty and the<tt> empty_container</tt> exception is enabled, the exception is thrown.&nbsp; If the<tt>
 index_range</tt> exception trap is enabled, the exception is thrown if the index value is negative or is greater than the
 number of list entries minus one.
<dt><br>Results:
<dd>The value of the selected list element or the closest element is removed and returned.&nbsp; If the index value is negative,
 the closest list element is the first element.&nbsp; The last element is the closest element if the index value is greater
 than the number of list entries minus one.&nbsp; A default initialized value is returned if there are no elements in the
 list.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> find</tt>,<tt> index</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCValSListXTypeY__indexLR__WCValDListXTypeY__indexLR"> index() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int index( const Type &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> index</tt> public member function is used to determine the index of the first list element equivalent to the passed
 element.&nbsp; Each list element is compared to the passed element using<tt> Type's operator ==</tt> until the passed element
 is found, or all list elements have been checked.
<dt><br>Results:
<dd>The index of the first element equivalent to the passed element is returned.&nbsp; If the passed element is not in the list,
 negative one (-1) is returned.
<dt><br>See Also:
<dd><tt> contains</tt>,<tt> find</tt>,<tt> get</tt>
</dl>
<h2 id="WCValSListXTypeY__insertLR__WCValDListXTypeY__insertLR"> insert() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function is used to insert the data as the first element of the list.&nbsp; The data stored
 in the list is a copy of the data passed as a parameter.
<br>If the<tt> out_of_memory</tt> exception is enabled and the insert fails, the exception is thrown.
<dt><br>Results:
<dd>The data element is inserted into the beginning of the list.&nbsp; A TRUE value (non-zero) is returned if the insert is successful.
&nbsp; A FALSE (zero) result is returned if the insert fails.
<dt><br>See Also:
<dd><tt> append</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValSListXTypeY__isEmptyLR__WCValDListXTypeY__isEmptyLR"> isEmpty() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if a list object has any list elements contained in it.
<dt><br>Results:
<dd>A TRUE value (non-zero) is returned if the list object does not have any list elements contained within it.&nbsp; A FALSE
 (zero) result is returned if the list contains at least one element.
<dt><br>See Also:
<dd><tt> entries</tt>
</dl>
<h2 id="WCValSListXTypeY__operator_ELR__WCValDListXTypeY__operator_ELR"> operator =() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSList &amp; WCValSList::operator =( const WCValSList &amp; );</tt>
<br><tt> WCValDList &amp; WCValDList::operator =( const WCValDList &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the class.&nbsp; The left hand side of the assignment
 is first cleared with the<tt> clear</tt> member function.&nbsp; All elements in the right hand side list are then copied,
 as well as the exception trap states, and any registered<b> allocator</b> and<b> deallocator</b> functions.<tt>&nbsp; Type's</tt>
 copy constructor is invoked to copy the values contained by the list elements.
<br>If all of the elements cannot be copied and the<tt> out_of_memory</tt> is enabled in the right hand side list, the exception
 is thrown.&nbsp; The new list is created in a valid state, even if all of the list elements could not be copied.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the right hand side to the left hand side and returns a reference to
 the left hand side.
<dt><br>See Also:
<dd><tt> WCValSList</tt>,<tt> WCValDList</tt>,<tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValSListXTypeY__operator_EELR__WCValDListXTypeY__operator_EELR"> operator ==() &#91;WCValSList&lt;Type&gt;,WCValDList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclist.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int WCValSList::operator ==( const WCValSList &amp; ) const;</tt>
<br><tt> int WCValDList::operator ==( const WCValDList &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the<tt> WCValSList&lt;Type&gt;</tt> and<tt>
 WCValDList&lt;Type&gt;</tt> classes.&nbsp; Two list objects are equivalent if they are the same object and share the same
 address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side object and the right hand side objects are the same object.&nbsp;
 A FALSE (zero) value is returned otherwise.
</dl>
<h1 id="List_Iterators"> List Iterators </h1>
<br>List iterators operate on single or double linked lists.&nbsp; They are used to step through a list one or more elements
 at a time.&nbsp; The choice of which type of iterator to use is determined by the list you wish to iterate over.&nbsp; For
 example, to iterate over a non-constant<tt> WCIsvDList&lt;Type&gt;</tt> object, use the<tt> WCIsvDListIter&lt;Type&gt;</tt>
 class.&nbsp; A constant<tt> WCValSList&lt;Type&gt;</tt> object can be iterated using the<tt> WCValConstSListIter&lt;Type&gt;</tt>
 class.&nbsp; The iterators which correspond to the single link list containers have some functionality inhibited.&nbsp; If
 backward traversal is required, the double linked containers and corresponding iterators must be used.
<br><br>Like all WATCOM iterators, newly constructed and reset iterators are positioned before the first element in the list.
&nbsp; The list may be traversed one element at a time using the pre-increment or call operator.&nbsp; An increment operation
 causing the iterator to be positioned after the end of the list returns zero.&nbsp; Further increments will cause the<tt>
 undef_iter</tt> exception to be thrown, if it is enabled.&nbsp; This behaviour allows lists to be traversed simply using
 a while loop, and is demonstrated in the examples for the iterator classes.
<br><br>The classes are presented in alphabetical order.&nbsp; The<tt> WCIterExcept</tt> class provides the common exception
 handling control interface for all of the iterators.
<br><br>Since the iterator classes are all template classes, deriving most of the functionality from common base classes was
 used.&nbsp; In the listing of class member functions, those public member functions which appear to be in the iterator class
 but are actually defined in the common base class are identified as if they were explicitly specified in the iterator class.
<h2 id="WCIsvConstSListIterXTypeY__WCIsvConstDListIterXTypeY_Class_Description"> WCIsvConstSListIter&lt;Type&gt;, WCIsvConstDListIter&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wclistit.h</tt>
<br>The<tt> WCIsvConstSListIter&lt;Type&gt;</tt> and<tt> WCIsvConstDListIter&lt;Type&gt;</tt> classes are the templated classes
 used to create iterator objects for constant single and double linked list objects.&nbsp; These classes may be used to iterate
 over non-constant lists, but the<tt> WCIsvDListIter&lt;Type&gt;</tt> and<tt> WCIsvSListIter&lt;Type&gt;</tt> classes provide
 additional functionality for only non-constant lists.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the list element type specified
 as the template parameter.
<br><br>The<tt> WCIterExcept</tt> class is a base class of the<tt> WCIsvConstSListIter&lt;Type&gt;</tt> and<tt> WCIsvConstDListIter&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCIsvConstSListIter&lt;Type&gt;</tt> and<tt> WCIsvConstDListIter&lt;Type&gt;</tt> objects.&nbsp; No
 exceptions are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Private Member Functions</b>
<br><br>Some functionality supported by base classes of the iterator are not appropriate for the constant list iterator classes.
&nbsp; Setting those functions as private members in the derived class is the standard mechanism to prevent them from being
 invoked.
<br><br><tt>int append( Type * );</tt>
<br><tt> int insert( Type * );</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCIsvConstSListIter();</tt>
<br><tt> WCIsvConstSListIter( const WCIsvSList&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCIsvConstSListIter();</tt>
<br><tt> WCIsvConstDListIter();</tt>
<br><tt> WCIsvConstDListIter( const WCIsvDList&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCIsvConstDListIter();</tt>
<br><tt> const WCIsvSList&lt;Type&gt; *WCIsvConstSListIter&lt;Type&gt;::container() const;</tt>
<br><tt> const WCIsvDList&lt;Type&gt; *WCIsvConstDListIter&lt;Type&gt;::container() const;</tt>
<br><tt> Type * current() const;</tt>
<br><tt> void reset();</tt>
<br><tt> void WCIsvConstSListIter&lt;Type&gt;::reset( const WCIsvSList&lt;Type&gt; &amp; );</tt>
<br><tt> void WCIsvConstDListIter&lt;Type&gt;::reset( const WCIsvDList&lt;Type&gt; &amp; );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>Type * operator ()();</tt>
<br><tt> Type * operator ++();</tt>
<br><tt> Type * operator +=( int );</tt>
<br><br>In the iterators for double linked lists only:
<br><br><tt>Type * operator --();</tt>
<br><tt> Type * operator -=( int );</tt>
<dt><br>See Also:
<dd><tt> WCIsvSList::forAll</tt>,<tt> WCIsvDList::forAll</tt>
</dl>
<h2 id="WCIsvConstSListIterXTypeY__WCIsvConstSListIterLR"> WCIsvConstSListIter() &#91;WCIsvConstSListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCIsvConstSListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCIsvConstSListIter</tt> public member function is the default constructor for the class and initializes the iterator
 with no list to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with a list to
 iterate over.
<dt><br>Results:
<dd>The<tt> WCIsvConstSListIter</tt> public member function creates an initialized<tt> WCIsvConstSListIter</tt> object.
<dt><br>See Also:
<dd><tt> WCIsvConstSListIter</tt>,<tt> ~WCIsvConstSListIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCIsvConstSListIter( const WCIsvSList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCIsvConstSListIter</tt> public member function is a constructor for the class.&nbsp; The value passed as a parameter
 is a<tt> WCIsvSList</tt> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
 first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<tt>
 operator ++, operator (),</tt> or<tt> operator +=</tt> operators.
<dt><br>Results:
<dd>The<tt> WCIsvConstSListIter</tt> public member function creates an initialized<tt> WCIsvConstSListIter</tt> object positioned
 before the first element in the list.
<dt><br>See Also:
<dd><tt> ~WCIsvConstSListIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> reset</tt>
</dl>
<h2 id="WCIsvConstSListIterXTypeY____WCIsvConstSListIterLR"> ~WCIsvConstSListIter() &#91;WCIsvConstSListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCIsvConstSListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCIsvConstSListIter</tt> public member function is the destructor for the class.&nbsp; The call to the<tt> ~WCIsvConstSListIter</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCIsvConstSListIter</tt> object
 goes out of scope.
<dt><br>Results:
<dd>The<tt> WCIsvConstSListIter</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCIsvConstSListIter</tt>
</dl>
<h2 id="WCIsvConstDListIterXTypeY__WCIsvConstDListIterLR"> WCIsvConstDListIter() &#91;WCIsvConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCIsvConstDListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCIsvConstDListIter</tt> public member function is the default constructor for the class and initializes the iterator
 with no list to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with a list to
 iterate over.
<dt><br>Results:
<dd>The<tt> WCIsvConstDListIter</tt> public member function creates an initialized<tt> WCIsvConstDListIter</tt> object.
<dt><br>See Also:
<dd><tt> WCIsvConstDListIter</tt>,<tt> ~WCIsvConstDListIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCIsvConstDListIter( const WCIsvDList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCIsvConstDListIter</tt> public member function is a constructor for the class.&nbsp; The value passed as a parameter
 is the<tt> WCIsvDList</tt> list object.&nbsp; The iterator will be initialized for that list object and positioned before
 the first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<tt>
 operator ++, operator (),</tt> or<tt> operator +=</tt> operators.
<dt><br>Results:
<dd>The<tt> WCIsvConstDListIter</tt> public member function creates an initialized<tt> WCIsvConstDListIter</tt> object positioned
 before the first list element.
<dt><br>See Also:
<dd><tt> WCIsvConstDListIter</tt>,<tt> ~WCIsvConstDListIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt>
 reset</tt>
</dl>
<h2 id="WCIsvConstDListIterXTypeY____WCIsvConstDListIterLR"> ~WCIsvConstDListIter() &#91;WCIsvConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCIsvConstDListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCIsvConstDListIter</tt> public member function is the destructor for the class.&nbsp; The call to the<tt> ~WCIsvConstDListIter</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCIsvConstDListIter</tt> object
 goes out of scope.
<dt><br>Results:
<dd>The<tt> WCIsvConstDListIter</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCIsvConstDListIter</tt>
</dl>
<h2 id="WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__containerLR"> container() &#91;WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>const WCIsvSList&lt;Type&gt; *WCIsvConstSListIter&lt;Type&gt;::container() const;</tt>
<br><tt> const WCIsvDList&lt;Type&gt; *WCIsvConstDListIter&lt;Type&gt;::container() const;</tt>
<dt><br>Semantics:
<dd>The<tt> container</tt> public member function returns a pointer to the list container object.&nbsp; If the iterator has not
 been initialized with a list object, and the<tt> undef_iter</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>A pointer to the list object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
 with a list.
<dt><br>See Also:
<dd><tt> WCIsvConstSListIter</tt>,<tt> WCIsvConstDListIter</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvConstSListIterXTypeY__currentLR__WCIsvConstDListIterXTypeY__currentLR"> current() &#91;WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * current();</tt>
<dt><br>Semantics:
<dd>The<tt> current</tt> public member function returns a pointer to the list item at the current iterator position.
<br>If the iterator is not associated with a list, or the iterator position is either before the first element or past the
 last element in the list, the current iterator position is undefined.&nbsp; In this case the<tt> undef_item</tt> exception
 is thrown, if enabled.
<dt><br>Results:
<dd>A pointer to the current list element is returned.&nbsp; If the current element is undefined, NULL(0) is returned.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_item</tt>
</dl>
<h2 id="WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__operator_LRLR"> operator ()() &#91;WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * operator ()();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ()</tt> public member function is the call operator for the class.&nbsp; The list element which follows the
 current item is set to be the new current item.&nbsp; If the previous current item was the last element in the list, the
 iterator is positioned after the end of the list.
<br>The<tt> operator ()</tt> public member function has the same semantics as the pre-increment operator,<tt> operator ++.</tt>
<br><br>If the iterator was positioned before the first element in the list, the current item will be set to the first element
 in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<br><br>If the iterator is not associated with a list or the iterator position before the increment was past the last element
 the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ()</tt> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
 the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__operator_PPLR"> operator ++() &#91;WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * operator ++();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ++</tt> public member function is the pre-increment operator for the class.&nbsp; The list element which
 follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
 list, the iterator is positioned after the end of the list.
<br>The<tt> operator ++</tt> public member function has the same semantics as the call operator,<tt> operator ().</tt>
<br><br>If the iterator was positioned before the first element in the list, the current item will be set to the first element
 in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<br><br>If the iterator is not associated with a list or the iterator position before the increment was past the last element
 the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ++</tt> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
 the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvConstSListIterXTypeY_WCIsvConstDListIterXTypeY__operator_PELR"> operator +=() &#91;WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * operator +=( int );</tt>
<dt><br>Semantics:
<dd>The<tt> operator +=</tt> public member function accepts an integer value that causes the iterator to move that many elements
 after the current item.&nbsp; If the iterator was positioned before the first element in the list, the operation will set
 the current item to be the given element in the list.
<br>If the current item was after the last element in the list previous to the iteration, and the<tt> undef_iter</tt> exception
 is enabled, the exception will be thrown.&nbsp; Attempting to increment the iterator position more than element after the
 end of the list, or by less than one element causes the<tt> iter_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator +=</tt> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
 the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::iter_range</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvConstDListIterXTypeY__operator_MMLR"> operator --() &#91;WCIsvConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * operator --();</tt>
<dt><br>Semantics:
<dd>The<tt> operator --</tt> public member function is the pre-decrement operator for the class.&nbsp; The list element previous
 to the current item is set to be the new current item.&nbsp; If the current item was the first element in the list, the iterator
 is positioned before the first element in the list.&nbsp; If the list is empty, the iterator will be positioned before the
 start of the list.
<br>If the iterator was positioned after the last element in the list, the current item will be set to the last element.
<br><br>If the iterator is not associated with a list or the iterator position previous to the decrement was before the first
 element the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator --</tt> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
 the iterator is decremented past the first element of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvConstDListIterXTypeY__operator_MELR"> operator -=() &#91;WCIsvConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * operator -=( int );</tt>
<dt><br>Semantics:
<dd>The<tt> operator -=</tt> public member function accepts an integer value that causes the iterator to move that many elements
 before the current item.&nbsp; If the iterator was positioned after the last element in the list, the operation will set
 the current item to be the given number of elements from the end of the list.
<br>If the current item was before the first element in the list previous to the iteration, and the<tt> undef_iter</tt> exception
 is enabled, the exception will be thrown.&nbsp; Attempting to decrement the iterator position more than one element before
 the beginning of the list, or by less than one element causes the<tt> iter_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator -=</tt> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
 the iterator is decremented past the first element in the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::iter_range</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvConstSListIterXTypeY__resetLR__WCIsvConstDListIterXTypeY__resetLR"> reset() &#91;WCIsvConstSListIter&lt;Type&gt;,WCIsvConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void reset();</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to the initial state, positioning the iterator before the first
 element in the associated list.
<dt><br>Results:
<dd>The iterator is positioned before the first list element.
<dt><br>See Also:
<dd><tt> WCIsvConstSListIter</tt>,<tt> WCIsvConstDListIter</tt>,<tt> container</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void WCIsvConstSListIter&lt;Type&gt;::reset( const WCIsvSList&lt;Type&gt; &amp; );</tt>
<br><tt> void WCIsvConstDListIter&lt;Type&gt;::reset( const WCIsvDList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to operate on the specified list.&nbsp; The iterator is positioned
 before the first element in the list.
<dt><br>Results:
<dd>The iterator is positioned before the first element of the specified list.
<dt><br>See Also:
<dd><tt> WCIsvConstSListIter</tt>,<tt> WCIsvConstDListIter</tt>,<tt> container</tt>
</dl>
<h2 id="WCIsvSListIterXTypeY__WCIsvDListIterXTypeY_Class_Description"> WCIsvSListIter&lt;Type&gt;, WCIsvDListIter&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wclistit.h</tt>
<br>The<tt> WCIsvSListIter&lt;Type&gt;</tt> and<tt> WCIsvDListIter&lt;Type&gt;</tt> classes are the templated classes used
 to create iterator objects for single and double linked list objects.&nbsp; These classes can be used only for non-constant
 lists.&nbsp; The<tt> WCIsvDConstListIter&lt;Type&gt;</tt> and<tt> WCIsvSConstListIter&lt;Type&gt;</tt> classes are provided
 to iterate over constant lists.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the list element type specified
 as the template parameter.
<br><br>The<tt> WCIterExcept</tt> class is a base class of the<tt> WCIsvSListIter&lt;Type&gt;</tt> and<tt> WCIsvDListIter&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCIsvSListIter&lt;Type&gt;</tt> and<tt> WCIsvDListIter&lt;Type&gt;</tt> objects.&nbsp; No exceptions
 are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Private Member Functions</b>
<br><br>Some functionality supported by base classes of the iterator are not appropriate in the single linked list iterator
 classes.&nbsp; Setting those functions as private members in the derived class is the standard mechanism to prevent them
 from being invoked.&nbsp; The following member functions are declared in the single linked list iterator private interface:
<br><br><tt>Type * operator --();</tt>
<br><tt> Type * operator -=( int );</tt>
<br><tt> int insert( Type * );</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCIsvSListIter();</tt>
<br><tt> WCIsvSListIter( WCIsvSList&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCIsvSListIter();</tt>
<br><tt> WCIsvDListIter();</tt>
<br><tt> WCIsvDListIter( WCIsvDList&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCIsvDListIter();</tt>
<br><tt> int append( Type * );</tt>
<br><tt> WCIsvSList&lt;Type&gt; *WCIsvSListIter&lt;Type&gt;::container() const;</tt>
<br><tt> WCIsvDList&lt;Type&gt; *WCIsvDListIter&lt;Type&gt;::container() const;</tt>
<br><tt> Type * current() const;</tt>
<br><tt> void reset();</tt>
<br><tt> void WCIsvSListIter&lt;Type&gt;::reset( WCIsvSList&lt;Type&gt; &amp; );</tt>
<br><tt> void WCIsvDListIter&lt;Type&gt;::reset( WCIsvDList&lt;Type&gt; &amp; );</tt>
<br><br>In the iterators for double linked lists only:
<br><br><tt>int insert( Type * );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>Type * operator ()();</tt>
<br><tt> Type * operator ++();</tt>
<br><tt> Type * operator +=( int );</tt>
<br><br>In the iterators for double linked lists only:
<br><br><tt>Type * operator --();</tt>
<br><tt> Type * operator -=( int );</tt>
<dt><br>See Also:
<dd><tt> WCIsvSList::forAll</tt>,<tt> WCIsvDList::forAll</tt>
</dl>
<h2 id="WCIsvSListIterXTypeY__WCIsvSListIterLR"> WCIsvSListIter() &#91;WCIsvSListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCIsvSListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCIsvSListIter</tt> public member function is the default constructor for the class and initializes the iterator with
 no list to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with a list to iterate
 over.
<dt><br>Results:
<dd>The<tt> WCIsvSListIter</tt> public member function creates an initialized<tt> WCIsvSListIter</tt> object.
<dt><br>See Also:
<dd><tt> WCIsvSListIter</tt>,<tt> ~WCIsvSListIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCIsvSListIter( WCIsvSList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCIsvSListIter</tt> public member function is a constructor for the class.&nbsp; The value passed as a parameter is
 a<tt> WCIsvSList</tt> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
 first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<tt>
 operator ++, operator (),</tt> or<tt> operator +=</tt> operators.
<dt><br>Results:
<dd>The<tt> WCIsvSListIter</tt> public member function creates an initialized<tt> WCIsvSListIter</tt> object positioned before
 the first element in the list.
<dt><br>See Also:
<dd><tt> ~WCIsvSListIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> reset</tt>
</dl>
<h2 id="WCIsvSListIterXTypeY____WCIsvSListIterLR"> ~WCIsvSListIter() &#91;WCIsvSListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCIsvSListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCIsvSListIter</tt> public member function is the destructor for the class.&nbsp; The call to the<tt> ~WCIsvSListIter</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCIsvSListIter</tt> object goes
 out of scope.
<dt><br>Results:
<dd>The<tt> WCIsvSListIter</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCIsvSListIter</tt>
</dl>
<h2 id="WCIsvDListIterXTypeY__WCIsvDListIterLR"> WCIsvDListIter() &#91;WCIsvDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCIsvDListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCIsvDListIter</tt> public member function is the default constructor for the class and initializes the iterator with
 no list to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with a list to iterate
 over.
<dt><br>Results:
<dd>The<tt> WCIsvDListIter</tt> public member function creates an initialized<tt> WCIsvDListIter</tt> object.
<dt><br>See Also:
<dd><tt> WCIsvDListIter</tt>,<tt> ~WCIsvDListIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCIsvDListIter( WCIsvDList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCIsvDListIter</tt> public member function is a constructor for the class.&nbsp; The value passed as a parameter is
 the<tt> WCIsvDList</tt> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
 first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<tt>
 operator ++, operator (),</tt> or<tt> operator +=</tt> operators.
<dt><br>Results:
<dd>The<tt> WCIsvDListIter</tt> public member function creates an initialized<tt> WCIsvDListIter</tt> object positioned before
 the first list element.
<dt><br>See Also:
<dd><tt> WCIsvDListIter</tt>,<tt> ~WCIsvDListIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt>
 reset</tt>
</dl>
<h2 id="WCIsvDListIterXTypeY____WCIsvDListIterLR"> ~WCIsvDListIter() &#91;WCIsvDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCIsvDListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCIsvDListIter</tt> public member function is the destructor for the class.&nbsp; The call to the<tt> ~WCIsvDListIter</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCIsvDListIter</tt> object goes
 out of scope.
<dt><br>Results:
<dd>The<tt> WCIsvDListIter</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCIsvDListIter</tt>
</dl>
<h2 id="WCIsvSListIterXTypeY__appendLR__WCIsvDListIterXTypeY__appendLR"> append() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int append( Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> append</tt> public member function inserts a new element into the list container object.&nbsp; The new element is
 inserted after the current iterator item.
<br>If the iterator is not associated with a list, or the iterator position is either before the first element or past the
 last element in the list, the current iterator position is undefined.&nbsp; The element is not appended.&nbsp; If the<tt>
 undef_iter</tt> exception is enabled, it is thrown.
<dt><br>Results:
<dd>The new element is inserted after the current iterator item.&nbsp; A TRUE value (non-zero) is returned if the append is successful.
&nbsp; A FALSE (zero) result is returned if the append fails.
<dt><br>See Also:
<dd><tt> insert</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__containerLR"> container() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCIsvSList&lt;Type&gt; *WCIsvSListIter&lt;Type&gt;::container() const;</tt>
<br><tt> WCIsvDList&lt;Type&gt; *WCIsvDListIter&lt;Type&gt;::container() const;</tt>
<dt><br>Semantics:
<dd>The<tt> container</tt> public member function returns a pointer to the list container object.&nbsp; If the iterator has not
 been initialized with a list object, and the<tt> undef_iter</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>A pointer to the list object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
 with a list.
<dt><br>See Also:
<dd><tt> WCIsvSListIter</tt>,<tt> WCIsvDListIter</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvSListIterXTypeY__currentLR__WCIsvDListIterXTypeY__currentLR"> current() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * current();</tt>
<dt><br>Semantics:
<dd>The<tt> current</tt> public member function returns a pointer to the list item at the current iterator position.
<br>If the iterator is not associated with a list, or the iterator position is either before the first element or past the
 last element in the list, the current iterator position is undefined.&nbsp; In this case the<tt> undef_item</tt> exception
 is thrown, if enabled.
<dt><br>Results:
<dd>A pointer to the current list element is returned.&nbsp; If the current element is undefined, NULL(0) is returned.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_item</tt>
</dl>
<h2 id="WCIsvDListIterXTypeY__insertLR"> insert() &#91;WCIsvDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function inserts a new element into the list container object.&nbsp; The new element is
 inserted before the current iterator item.&nbsp; This process uses the previous link in the double linked list, so the<tt>
 insert</tt> public member function is not allowed with single linked lists.
<br>If the iterator is not associated with a list, or the iterator position is either before the first element or past the
 last element in the list, the current iterator position is undefined.&nbsp; The element is not inserted.&nbsp; If the<tt>
 undef_iter</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>The new element is inserted before the current iterator item.&nbsp; A TRUE value (non-zero) is returned if the insert is successful.
&nbsp; A FALSE (zero) result is returned if the insert fails.
<dt><br>See Also:
<dd><tt> append</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__operator_LRLR"> operator ()() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * operator ()();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ()</tt> public member function is the call operator for the class.&nbsp; The list element which follows the
 current item is set to be the new current item.&nbsp; If the previous current item was the last element in the list, the
 iterator is positioned after the end of the list.
<br>The<tt> operator ()</tt> public member function has the same semantics as the pre-increment operator,<tt> operator ++.</tt>
<br><br>If the iterator was positioned before the first element in the list, the current item will be set to the first element
 in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<br><br>If the iterator is not associated with a list or the iterator position before the increment was past the last element
 the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ()</tt> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
 the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__operator_PPLR"> operator ++() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * operator ++();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ++</tt> public member function is the pre-increment operator for the class.&nbsp; The list element which
 follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
 list, the iterator is positioned after the end of the list.
<br>The<tt> operator ++</tt> public member function has the same semantics as the call operator,<tt> operator ().</tt>
<br><br>If the iterator was positioned before the first element in the list, the current item will be set to the first element
 in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<br><br>If the iterator is not associated with a list or the iterator position before the increment was past the last element
 the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ++</tt> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
 the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvSListIterXTypeY_WCIsvDListIterXTypeY__operator_PELR"> operator +=() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * operator +=( int );</tt>
<dt><br>Semantics:
<dd>The<tt> operator +=</tt> public member function accepts an integer value that causes the iterator to move that many elements
 after the current item.&nbsp; If the iterator was positioned before the first element in the list, the operation will set
 the current item to be the given element in the list.
<br>If the current item was after the last element in the list previous to the iteration, and the<tt> undef_iter</tt> exception
 is enabled, the exception will be thrown.&nbsp; Attempting to increment the iterator position more than element after the
 end of the list, or by less than one element causes the<tt> iter_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator +=</tt> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
 the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::iter_range</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvDListIterXTypeY__operator_MMLR"> operator --() &#91;WCIsvDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * operator --();</tt>
<dt><br>Semantics:
<dd>The<tt> operator --</tt> public member function is the pre-decrement operator for the class.&nbsp; The list element previous
 to the current item is set to be the new current item.&nbsp; If the current item was the first element in the list, the iterator
 is positioned before the first element in the list.&nbsp; If the list is empty, the iterator will be positioned before the
 start of the list.
<br>If the iterator was positioned after the last element in the list, the current item will be set to the last element.
<br><br>If the iterator is not associated with a list or the iterator position previous to the decrement was before the first
 element the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator --</tt> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
 the iterator is decremented past the first element of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvDListIterXTypeY__operator_MELR"> operator -=() &#91;WCIsvDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * operator -=( int );</tt>
<dt><br>Semantics:
<dd>The<tt> operator -=</tt> public member function accepts an integer value that causes the iterator to move that many elements
 before the current item.&nbsp; If the iterator was positioned after the last element in the list, the operation will set
 the current item to be the given number of elements from the end of the list.
<br>If the current item was before the first element in the list previous to the iteration, and the<tt> undef_iter</tt> exception
 is enabled, the exception will be thrown.&nbsp; Attempting to decrement the iterator position more than one element before
 the beginning of the list, or by less than one element causes the<tt> iter_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator -=</tt> public member function returns a pointer to the new current item.&nbsp; NULL(0) is returned when
 the iterator is decremented past the first element in the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::iter_range</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCIsvSListIterXTypeY__resetLR__WCIsvDListIterXTypeY__resetLR"> reset() &#91;WCIsvSListIter&lt;Type&gt;,WCIsvDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void reset();</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to the initial state, positioning the iterator before the first
 element in the associated list.
<dt><br>Results:
<dd>The iterator is positioned before the first list element.
<dt><br>See Also:
<dd><tt> WCIsvSListIter</tt>,<tt> WCIsvDListIter</tt>,<tt> container</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void WCIsvSListIter&lt;Type&gt;::reset( WCIsvSList&lt;Type&gt; &amp; );</tt>
<br><tt> void WCIsvDListIter&lt;Type&gt;::reset( WCIsvDList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to operate on the specified list.&nbsp; The iterator is positioned
 before the first element in the list.
<dt><br>Results:
<dd>The iterator is positioned before the first element of the specified list.
<dt><br>See Also:
<dd><tt> WCIsvSListIter</tt>,<tt> WCIsvDListIter</tt>,<tt> container</tt>
</dl>
<h2 id="WCPtrConstSListIterXTypeY__WCPtrConstDListIterXTypeY_Class_Description"> WCPtrConstSListIter&lt;Type&gt;, WCPtrConstDListIter&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wclistit.h</tt>
<br>The<tt> WCPtrConstSListIter&lt;Type&gt;</tt> and<tt> WCPtrConstDListIter&lt;Type&gt;</tt> classes are the templated classes
 used to create iterator objects for constant single and double linked list objects.&nbsp; These classes may be used to iterate
 over non-constant lists, but the<tt> WCPtrDListIter&lt;Type&gt;</tt> and<tt> WCPtrSListIter&lt;Type&gt;</tt> classes provide
 additional functionality for only non-constant lists.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the list element type specified
 as the template parameter.
<br><br>The<tt> WCIterExcept</tt> class is a base class of the<tt> WCPtrConstSListIter&lt;Type&gt;</tt> and<tt> WCPtrConstDListIter&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCPtrConstSListIter&lt;Type&gt;</tt> and<tt> WCPtrConstDListIter&lt;Type&gt;</tt> objects.&nbsp; No
 exceptions are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Private Member Functions</b>
<br><br>Some functionality supported by base classes of the iterator are not appropriate for the constant list iterator classes.
&nbsp; Setting those functions as private members in the derived class is the standard mechanism to prevent them from being
 invoked.
<br><br><tt>int append( Type * );</tt>
<br><tt> int insert( Type * );</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCPtrConstSListIter();</tt>
<br><tt> WCPtrConstSListIter( const WCPtrSList&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCPtrConstSListIter();</tt>
<br><tt> WCPtrConstDListIter();</tt>
<br><tt> WCPtrConstDListIter( const WCPtrDList&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCPtrConstDListIter();</tt>
<br><tt> const WCPtrSList&lt;Type&gt; *WCPtrConstSListIter&lt;Type&gt;::container() const;</tt>
<br><tt> const WCPtrDList&lt;Type&gt; *WCPtrConstDListIter&lt;Type&gt;::container() const;</tt>
<br><tt> Type * current() const;</tt>
<br><tt> void reset();</tt>
<br><tt> void WCPtrConstSListIter&lt;Type&gt;::reset( const WCPtrSList&lt;Type&gt; &amp; );</tt>
<br><tt> void WCPtrConstDListIter&lt;Type&gt;::reset( const WCPtrDList&lt;Type&gt; &amp; );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>int operator ()();</tt>
<br><tt> int operator ++();</tt>
<br><tt> int operator +=( int );</tt>
<br><br>In the iterators for double linked lists only:
<br><br><tt>int operator --();</tt>
<br><tt> int operator -=( int );</tt>
<dt><br>See Also:
<dd><tt> WCPtrSList::forAll</tt>,<tt> WCPtrDList::forAll</tt>
</dl>
<h2 id="WCPtrConstSListIterXTypeY__WCPtrConstSListIterLR"> WCPtrConstSListIter() &#91;WCPtrConstSListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrConstSListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrConstSListIter</tt> public member function is the default constructor for the class and initializes the iterator
 with no list to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with a list to
 iterate over.
<dt><br>Results:
<dd>The<tt> WCPtrConstSListIter</tt> public member function creates an initialized<tt> WCPtrConstSListIter</tt> object.
<dt><br>See Also:
<dd><tt> WCPtrConstSListIter</tt>,<tt> ~WCPtrConstSListIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrConstSListIter( const WCPtrSList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrConstSListIter</tt> public member function is a constructor for the class.&nbsp; The value passed as a parameter
 is a<tt> WCPtrSList</tt> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
 first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<tt>
 operator ++, operator (),</tt> or<tt> operator +=</tt> operators.
<dt><br>Results:
<dd>The<tt> WCPtrConstSListIter</tt> public member function creates an initialized<tt> WCPtrConstSListIter</tt> object positioned
 before the first element in the list.
<dt><br>See Also:
<dd><tt> ~WCPtrConstSListIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> reset</tt>
</dl>
<h2 id="WCPtrConstSListIterXTypeY____WCPtrConstSListIterLR"> ~WCPtrConstSListIter() &#91;WCPtrConstSListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCPtrConstSListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCPtrConstSListIter</tt> public member function is the destructor for the class.&nbsp; The call to the<tt> ~WCPtrConstSListIter</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCPtrConstSListIter</tt> object
 goes out of scope.
<dt><br>Results:
<dd>The<tt> WCPtrConstSListIter</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCPtrConstSListIter</tt>
</dl>
<h2 id="WCPtrConstDListIterXTypeY__WCPtrConstDListIterLR"> WCPtrConstDListIter() &#91;WCPtrConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrConstDListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrConstDListIter</tt> public member function is the default constructor for the class and initializes the iterator
 with no list to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with a list to
 iterate over.
<dt><br>Results:
<dd>The<tt> WCPtrConstDListIter</tt> public member function creates an initialized<tt> WCPtrConstDListIter</tt> object.
<dt><br>See Also:
<dd><tt> WCPtrConstDListIter</tt>,<tt> ~WCPtrConstDListIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrConstDListIter( const WCPtrDList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrConstDListIter</tt> public member function is a constructor for the class.&nbsp; The value passed as a parameter
 is the<tt> WCPtrDList</tt> list object.&nbsp; The iterator will be initialized for that list object and positioned before
 the first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<tt>
 operator ++, operator (),</tt> or<tt> operator +=</tt> operators.
<dt><br>Results:
<dd>The<tt> WCPtrConstDListIter</tt> public member function creates an initialized<tt> WCPtrConstDListIter</tt> object positioned
 before the first list element.
<dt><br>See Also:
<dd><tt> WCPtrConstDListIter</tt>,<tt> ~WCPtrConstDListIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt>
 reset</tt>
</dl>
<h2 id="WCPtrConstDListIterXTypeY____WCPtrConstDListIterLR"> ~WCPtrConstDListIter() &#91;WCPtrConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCPtrConstDListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCPtrConstDListIter</tt> public member function is the destructor for the class.&nbsp; The call to the<tt> ~WCPtrConstDListIter</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCPtrConstDListIter</tt> object
 goes out of scope.
<dt><br>Results:
<dd>The<tt> WCPtrConstDListIter</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCPtrConstDListIter</tt>
</dl>
<h2 id="WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__containerLR"> container() &#91;WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>const WCPtrSList&lt;Type&gt; *WCPtrConstSListIter&lt;Type&gt;::container() const;</tt>
<br><tt> const WCPtrDList&lt;Type&gt; *WCPtrConstDListIter&lt;Type&gt;::container() const;</tt>
<dt><br>Semantics:
<dd>The<tt> container</tt> public member function returns a pointer to the list container object.&nbsp; If the iterator has not
 been initialized with a list object, and the<tt> undef_iter</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>A pointer to the list object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
 with a list.
<dt><br>See Also:
<dd><tt> WCPtrConstSListIter</tt>,<tt> WCPtrConstDListIter</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrConstSListIterXTypeY__currentLR__WCPtrConstDListIterXTypeY__currentLR"> current() &#91;WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * current();</tt>
<dt><br>Semantics:
<dd>The<tt> current</tt> public member function returns a pointer to the list item at the current iterator position.
<br>If the iterator is not associated with a list, or the iterator position is either before the first element or past the
 last element in the list, the current iterator position is undefined.&nbsp; In this case the<tt> undef_item</tt> exception
 is thrown, if enabled.
<dt><br>Results:
<dd>A pointer to the current list element is returned.&nbsp; If the current element is undefined, an uninitialized pointer is
 returned.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_item</tt>
</dl>
<h2 id="WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__operator_LRLR"> operator ()() &#91;WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ()();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ()</tt> public member function is the call operator for the class.&nbsp; The list element which follows the
 current item is set to be the new current item.&nbsp; If the previous current item was the last element in the list, the
 iterator is positioned after the end of the list.
<br>The<tt> operator ()</tt> public member function has the same semantics as the pre-increment operator,<tt> operator ++.</tt>
<br><br>If the iterator was positioned before the first element in the list, the current item will be set to the first element
 in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<br><br>If the iterator is not associated with a list or the iterator position before the increment was past the last element
 the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ()</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__operator_PPLR"> operator ++() &#91;WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ++();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ++</tt> public member function is the pre-increment operator for the class.&nbsp; The list element which
 follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
 list, the iterator is positioned after the end of the list.
<br>The<tt> operator ++</tt> public member function has the same semantics as the call operator,<tt> operator ().</tt>
<br><br>If the iterator was positioned before the first element in the list, the current item will be set to the first element
 in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<br><br>If the iterator is not associated with a list or the iterator position before the increment was past the last element
 the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ++</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrConstSListIterXTypeY_WCPtrConstDListIterXTypeY__operator_PELR"> operator +=() &#91;WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator +=( int );</tt>
<dt><br>Semantics:
<dd>The<tt> operator +=</tt> public member function accepts an integer value that causes the iterator to move that many elements
 after the current item.&nbsp; If the iterator was positioned before the first element in the list, the operation will set
 the current item to be the given element in the list.
<br>If the current item was after the last element in the list previous to the iteration, and the<tt> undef_iter</tt> exception
 is enabled, the exception will be thrown.&nbsp; Attempting to increment the iterator position more than element after the
 end of the list, or by less than one element causes the<tt> iter_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator +=</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::iter_range</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrConstDListIterXTypeY__operator_MMLR"> operator --() &#91;WCPtrConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator --();</tt>
<dt><br>Semantics:
<dd>The<tt> operator --</tt> public member function is the pre-decrement operator for the class.&nbsp; The list element previous
 to the current item is set to be the new current item.&nbsp; If the current item was the first element in the list, the iterator
 is positioned before the first element in the list.&nbsp; If the list is empty, the iterator will be positioned before the
 start of the list.
<br>If the iterator was positioned after the last element in the list, the current item will be set to the last element.
<br><br>If the iterator is not associated with a list or the iterator position previous to the decrement was before the first
 element the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator --</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is decremented past the first element of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrConstDListIterXTypeY__operator_MELR"> operator -=() &#91;WCPtrConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator -=( int );</tt>
<dt><br>Semantics:
<dd>The<tt> operator -=</tt> public member function accepts an integer value that causes the iterator to move that many elements
 before the current item.&nbsp; If the iterator was positioned after the last element in the list, the operation will set
 the current item to be the given number of elements from the end of the list.
<br>If the current item was before the first element in the list previous to the iteration, and the<tt> undef_iter</tt> exception
 is enabled, the exception will be thrown.&nbsp; Attempting to decrement the iterator position more than one element before
 the beginning of the list, or by less than one element causes the<tt> iter_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator -=</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is decremented past the first element in the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::iter_range</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrConstSListIterXTypeY__resetLR__WCPtrConstDListIterXTypeY__resetLR"> reset() &#91;WCPtrConstSListIter&lt;Type&gt;,WCPtrConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void reset();</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to the initial state, positioning the iterator before the first
 element in the associated list.
<dt><br>Results:
<dd>The iterator is positioned before the first list element.
<dt><br>See Also:
<dd><tt> WCPtrConstSListIter</tt>,<tt> WCPtrConstDListIter</tt>,<tt> container</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void WCPtrConstSListIter&lt;Type&gt;::reset( const WCPtrSList&lt;Type&gt; &amp; );</tt>
<br><tt> void WCPtrConstDListIter&lt;Type&gt;::reset( const WCPtrDList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to operate on the specified list.&nbsp; The iterator is positioned
 before the first element in the list.
<dt><br>Results:
<dd>The iterator is positioned before the first element of the specified list.
<dt><br>See Also:
<dd><tt> WCPtrConstSListIter</tt>,<tt> WCPtrConstDListIter</tt>,<tt> container</tt>
</dl>
<h2 id="WCPtrSListIterXTypeY__WCPtrDListIterXTypeY_Class_Description"> WCPtrSListIter&lt;Type&gt;, WCPtrDListIter&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wclistit.h</tt>
<br>The<tt> WCPtrSListIter&lt;Type&gt;</tt> and<tt> WCPtrDListIter&lt;Type&gt;</tt> classes are the templated classes used
 to create iterator objects for single and double linked list objects.&nbsp; These classes can be used only for non-constant
 lists.&nbsp; The<tt> WCPtrDConstListIter&lt;Type&gt;</tt> and<tt> WCPtrSConstListIter&lt;Type&gt;</tt> classes are provided
 to iterate over constant lists.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the list element type specified
 as the template parameter.
<br><br>The<tt> WCIterExcept</tt> class is a base class of the<tt> WCPtrSListIter&lt;Type&gt;</tt> and<tt> WCPtrDListIter&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCPtrSListIter&lt;Type&gt;</tt> and<tt> WCPtrDListIter&lt;Type&gt;</tt> objects.&nbsp; No exceptions
 are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Private Member Functions</b>
<br><br>Some functionality supported by base classes of the iterator are not appropriate in the single linked list iterator
 classes.&nbsp; Setting those functions as private members in the derived class is the standard mechanism to prevent them
 from being invoked.&nbsp; The following member functions are declared in the single linked list iterator private interface:
<br><br><tt>int operator --();</tt>
<br><tt> int operator -=( int );</tt>
<br><tt> int insert( Type * );</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCPtrSListIter();</tt>
<br><tt> WCPtrSListIter( WCPtrSList&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCPtrSListIter();</tt>
<br><tt> WCPtrDListIter();</tt>
<br><tt> WCPtrDListIter( WCPtrDList&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCPtrDListIter();</tt>
<br><tt> int append( Type * );</tt>
<br><tt> WCPtrSList&lt;Type&gt; *WCPtrSListIter&lt;Type&gt;::container() const;</tt>
<br><tt> WCPtrDList&lt;Type&gt; *WCPtrDListIter&lt;Type&gt;::container() const;</tt>
<br><tt> Type * current() const;</tt>
<br><tt> void reset();</tt>
<br><tt> void WCPtrSListIter&lt;Type&gt;::reset( WCPtrSList&lt;Type&gt; &amp; );</tt>
<br><tt> void WCPtrDListIter&lt;Type&gt;::reset( WCPtrDList&lt;Type&gt; &amp; );</tt>
<br><br>In the iterators for double linked lists only:
<br><br><tt>int insert( Type * );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>int operator ()();</tt>
<br><tt> int operator ++();</tt>
<br><tt> int operator +=( int );</tt>
<br><br>In the iterators for double linked lists only:
<br><br><tt>int operator --();</tt>
<br><tt> int operator -=( int );</tt>
<dt><br>See Also:
<dd><tt> WCPtrSList::forAll</tt>,<tt> WCPtrDList::forAll</tt>
</dl>
<h2 id="WCPtrSListIterXTypeY__WCPtrSListIterLR"> WCPtrSListIter() &#91;WCPtrSListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSListIter</tt> public member function is the default constructor for the class and initializes the iterator with
 no list to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with a list to iterate
 over.
<dt><br>Results:
<dd>The<tt> WCPtrSListIter</tt> public member function creates an initialized<tt> WCPtrSListIter</tt> object.
<dt><br>See Also:
<dd><tt> WCPtrSListIter</tt>,<tt> ~WCPtrSListIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSListIter( WCPtrSList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSListIter</tt> public member function is a constructor for the class.&nbsp; The value passed as a parameter is
 a<tt> WCPtrSList</tt> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
 first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<tt>
 operator ++, operator (),</tt> or<tt> operator +=</tt> operators.
<dt><br>Results:
<dd>The<tt> WCPtrSListIter</tt> public member function creates an initialized<tt> WCPtrSListIter</tt> object positioned before
 the first element in the list.
<dt><br>See Also:
<dd><tt> ~WCPtrSListIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> reset</tt>
</dl>
<h2 id="WCPtrSListIterXTypeY____WCPtrSListIterLR"> ~WCPtrSListIter() &#91;WCPtrSListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCPtrSListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCPtrSListIter</tt> public member function is the destructor for the class.&nbsp; The call to the<tt> ~WCPtrSListIter</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCPtrSListIter</tt> object goes
 out of scope.
<dt><br>Results:
<dd>The<tt> WCPtrSListIter</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCPtrSListIter</tt>
</dl>
<h2 id="WCPtrDListIterXTypeY__WCPtrDListIterLR"> WCPtrDListIter() &#91;WCPtrDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrDListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrDListIter</tt> public member function is the default constructor for the class and initializes the iterator with
 no list to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with a list to iterate
 over.
<dt><br>Results:
<dd>The<tt> WCPtrDListIter</tt> public member function creates an initialized<tt> WCPtrDListIter</tt> object.
<dt><br>See Also:
<dd><tt> WCPtrDListIter</tt>,<tt> ~WCPtrDListIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrDListIter( WCPtrDList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrDListIter</tt> public member function is a constructor for the class.&nbsp; The value passed as a parameter is
 the<tt> WCPtrDList</tt> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
 first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<tt>
 operator ++, operator (),</tt> or<tt> operator +=</tt> operators.
<dt><br>Results:
<dd>The<tt> WCPtrDListIter</tt> public member function creates an initialized<tt> WCPtrDListIter</tt> object positioned before
 the first list element.
<dt><br>See Also:
<dd><tt> WCPtrDListIter</tt>,<tt> ~WCPtrDListIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt>
 reset</tt>
</dl>
<h2 id="WCPtrDListIterXTypeY____WCPtrDListIterLR"> ~WCPtrDListIter() &#91;WCPtrDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCPtrDListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCPtrDListIter</tt> public member function is the destructor for the class.&nbsp; The call to the<tt> ~WCPtrDListIter</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCPtrDListIter</tt> object goes
 out of scope.
<dt><br>Results:
<dd>The<tt> WCPtrDListIter</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCPtrDListIter</tt>
</dl>
<h2 id="WCPtrSListIterXTypeY__appendLR__WCPtrDListIterXTypeY__appendLR"> append() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int append( Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> append</tt> public member function inserts a new element into the list container object.&nbsp; The new element is
 inserted after the current iterator item.
<br>If the iterator is not associated with a list, or the iterator position is either before the first element or past the
 last element in the list, the current iterator position is undefined.&nbsp; The element is not appended.&nbsp; If the<tt>
 undef_iter</tt> exception is enabled, it is thrown.
<br><br>If the append fails, the<tt> out_of_memory</tt> exception is thrown, if enabled in the list being iterated over.&nbsp;
 The list remains unchanged.
<dt><br>Results:
<dd>The new element is inserted after the current iterator item.&nbsp; A TRUE value (non-zero) is returned if the append is successful.
&nbsp; A FALSE (zero) result is returned if the append fails.
<dt><br>See Also:
<dd><tt> insert</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__containerLR"> container() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSList&lt;Type&gt; *WCPtrSListIter&lt;Type&gt;::container() const;</tt>
<br><tt> WCPtrDList&lt;Type&gt; *WCPtrDListIter&lt;Type&gt;::container() const;</tt>
<dt><br>Semantics:
<dd>The<tt> container</tt> public member function returns a pointer to the list container object.&nbsp; If the iterator has not
 been initialized with a list object, and the<tt> undef_iter</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>A pointer to the list object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
 with a list.
<dt><br>See Also:
<dd><tt> WCPtrSListIter</tt>,<tt> WCPtrDListIter</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrSListIterXTypeY__currentLR__WCPtrDListIterXTypeY__currentLR"> current() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * current();</tt>
<dt><br>Semantics:
<dd>The<tt> current</tt> public member function returns a pointer to the list item at the current iterator position.
<br>If the iterator is not associated with a list, or the iterator position is either before the first element or past the
 last element in the list, the current iterator position is undefined.&nbsp; In this case the<tt> undef_item</tt> exception
 is thrown, if enabled.
<dt><br>Results:
<dd>A pointer to the current list element is returned.&nbsp; If the current element is undefined, an uninitialized pointer is
 returned.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_item</tt>
</dl>
<h2 id="WCPtrDListIterXTypeY__insertLR"> insert() &#91;WCPtrDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function inserts a new element into the list container object.&nbsp; The new element is
 inserted before the current iterator item.&nbsp; This process uses the previous link in the double linked list, so the<tt>
 insert</tt> public member function is not allowed with single linked lists.
<br>If the iterator is not associated with a list, or the iterator position is either before the first element or past the
 last element in the list, the current iterator position is undefined.&nbsp; The element is not inserted.&nbsp; If the<tt>
 undef_iter</tt> exception is enabled, the exception is thrown.
<br><br>If the insert fails and the<tt> out_of_memory</tt> exception is enabled in the list being iterated over, the exception
 is thrown.&nbsp; The list remains unchanged.
<dt><br>Results:
<dd>The new element is inserted before the current iterator item.&nbsp; A TRUE value (non-zero) is returned if the insert is successful.
&nbsp; A FALSE (zero) result is returned if the insert fails.
<dt><br>See Also:
<dd><tt> append</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__operator_LRLR"> operator ()() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ()();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ()</tt> public member function is the call operator for the class.&nbsp; The list element which follows the
 current item is set to be the new current item.&nbsp; If the previous current item was the last element in the list, the
 iterator is positioned after the end of the list.
<br>The<tt> operator ()</tt> public member function has the same semantics as the pre-increment operator,<tt> operator ++.</tt>
<br><br>If the iterator was positioned before the first element in the list, the current item will be set to the first element
 in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<br><br>If the iterator is not associated with a list or the iterator position before the increment was past the last element
 the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ()</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__operator_PPLR"> operator ++() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ++();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ++</tt> public member function is the pre-increment operator for the class.&nbsp; The list element which
 follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
 list, the iterator is positioned after the end of the list.
<br>The<tt> operator ++</tt> public member function has the same semantics as the call operator,<tt> operator ().</tt>
<br><br>If the iterator was positioned before the first element in the list, the current item will be set to the first element
 in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<br><br>If the iterator is not associated with a list or the iterator position before the increment was past the last element
 the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ++</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrSListIterXTypeY_WCPtrDListIterXTypeY__operator_PELR"> operator +=() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator +=( int );</tt>
<dt><br>Semantics:
<dd>The<tt> operator +=</tt> public member function accepts an integer value that causes the iterator to move that many elements
 after the current item.&nbsp; If the iterator was positioned before the first element in the list, the operation will set
 the current item to be the given element in the list.
<br>If the current item was after the last element in the list previous to the iteration, and the<tt> undef_iter</tt> exception
 is enabled, the exception will be thrown.&nbsp; Attempting to increment the iterator position more than element after the
 end of the list, or by less than one element causes the<tt> iter_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator +=</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::iter_range</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrDListIterXTypeY__operator_MMLR"> operator --() &#91;WCPtrDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator --();</tt>
<dt><br>Semantics:
<dd>The<tt> operator --</tt> public member function is the pre-decrement operator for the class.&nbsp; The list element previous
 to the current item is set to be the new current item.&nbsp; If the current item was the first element in the list, the iterator
 is positioned before the first element in the list.&nbsp; If the list is empty, the iterator will be positioned before the
 start of the list.
<br>If the iterator was positioned after the last element in the list, the current item will be set to the last element.
<br><br>If the iterator is not associated with a list or the iterator position previous to the decrement was before the first
 element the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator --</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is decremented past the first element of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrDListIterXTypeY__operator_MELR"> operator -=() &#91;WCPtrDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator -=( int );</tt>
<dt><br>Semantics:
<dd>The<tt> operator -=</tt> public member function accepts an integer value that causes the iterator to move that many elements
 before the current item.&nbsp; If the iterator was positioned after the last element in the list, the operation will set
 the current item to be the given number of elements from the end of the list.
<br>If the current item was before the first element in the list previous to the iteration, and the<tt> undef_iter</tt> exception
 is enabled, the exception will be thrown.&nbsp; Attempting to decrement the iterator position more than one element before
 the beginning of the list, or by less than one element causes the<tt> iter_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator -=</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is decremented past the first element in the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::iter_range</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCPtrSListIterXTypeY__resetLR__WCPtrDListIterXTypeY__resetLR"> reset() &#91;WCPtrSListIter&lt;Type&gt;,WCPtrDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void reset();</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to the initial state, positioning the iterator before the first
 element in the associated list.
<dt><br>Results:
<dd>The iterator is positioned before the first list element.
<dt><br>See Also:
<dd><tt> WCPtrSListIter</tt>,<tt> WCPtrDListIter</tt>,<tt> container</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void WCPtrSListIter&lt;Type&gt;::reset( WCPtrSList&lt;Type&gt; &amp; );</tt>
<br><tt> void WCPtrDListIter&lt;Type&gt;::reset( WCPtrDList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to operate on the specified list.&nbsp; The iterator is positioned
 before the first element in the list.
<dt><br>Results:
<dd>The iterator is positioned before the first element of the specified list.
<dt><br>See Also:
<dd><tt> WCPtrSListIter</tt>,<tt> WCPtrDListIter</tt>,<tt> container</tt>
</dl>
<h2 id="WCValConstSListIterXTypeY__WCValConstDListIterXTypeY_Class_Description"> WCValConstSListIter&lt;Type&gt;, WCValConstDListIter&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wclistit.h</tt>
<br>The<tt> WCValConstSListIter&lt;Type&gt;</tt> and<tt> WCValConstDListIter&lt;Type&gt;</tt> classes are the templated classes
 used to create iterator objects for constant single and double linked list objects.&nbsp; These classes may be used to iterate
 over non-constant lists, but the<tt> WCValDListIter&lt;Type&gt;</tt> and<tt> WCValSListIter&lt;Type&gt;</tt> classes provide
 additional functionality for only non-constant lists.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the list element type specified
 as the template parameter.
<br><br>The<tt> WCIterExcept</tt> class is a base class of the<tt> WCValConstSListIter&lt;Type&gt;</tt> and<tt> WCValConstDListIter&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCValConstSListIter&lt;Type&gt;</tt> and<tt> WCValConstDListIter&lt;Type&gt;</tt> objects.&nbsp; No
 exceptions are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Private Member Functions</b>
<br><br>Some functionality supported by base classes of the iterator are not appropriate for the constant list iterator classes.
&nbsp; Setting those functions as private members in the derived class is the standard mechanism to prevent them from being
 invoked.
<br><br><tt>int append( Type &amp; );</tt>
<br><tt> int insert( Type &amp; );</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCValConstSListIter();</tt>
<br><tt> WCValConstSListIter( const WCValSList&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCValConstSListIter();</tt>
<br><tt> WCValConstDListIter();</tt>
<br><tt> WCValConstDListIter( const WCValDList&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCValConstDListIter();</tt>
<br><tt> const WCValSList&lt;Type&gt; *WCValConstSListIter&lt;Type&gt;::container() const;</tt>
<br><tt> const WCValDList&lt;Type&gt; *WCValConstDListIter&lt;Type&gt;::container() const;</tt>
<br><tt> Type current() const;</tt>
<br><tt> void reset();</tt>
<br><tt> void WCValConstSListIter&lt;Type&gt;::reset( const WCValSList&lt;Type&gt; &amp; );</tt>
<br><tt> void WCValConstDListIter&lt;Type&gt;::reset( const WCValDList&lt;Type&gt; &amp; );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>int operator ()();</tt>
<br><tt> int operator ++();</tt>
<br><tt> int operator +=( int );</tt>
<br><br>In the iterators for double linked lists only:
<br><br><tt>int operator --();</tt>
<br><tt> int operator -=( int );</tt>
<dt><br>See Also:
<dd><tt> WCValSList::forAll</tt>,<tt> WCValDList::forAll</tt>
</dl>
<h2 id="WCValConstSListIterXTypeY__WCValConstSListIterLR"> WCValConstSListIter() &#91;WCValConstSListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValConstSListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCValConstSListIter</tt> public member function is the default constructor for the class and initializes the iterator
 with no list to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with a list to
 iterate over.
<dt><br>Results:
<dd>The<tt> WCValConstSListIter</tt> public member function creates an initialized<tt> WCValConstSListIter</tt> object.
<dt><br>See Also:
<dd><tt> WCValConstSListIter</tt>,<tt> ~WCValConstSListIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValConstSListIter( const WCValSList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValConstSListIter</tt> public member function is a constructor for the class.&nbsp; The value passed as a parameter
 is a<tt> WCValSList</tt> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
 first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<tt>
 operator ++, operator (),</tt> or<tt> operator +=</tt> operators.
<dt><br>Results:
<dd>The<tt> WCValConstSListIter</tt> public member function creates an initialized<tt> WCValConstSListIter</tt> object positioned
 before the first element in the list.
<dt><br>See Also:
<dd><tt> ~WCValConstSListIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> reset</tt>
</dl>
<h2 id="WCValConstSListIterXTypeY____WCValConstSListIterLR"> ~WCValConstSListIter() &#91;WCValConstSListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCValConstSListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCValConstSListIter</tt> public member function is the destructor for the class.&nbsp; The call to the<tt> ~WCValConstSListIter</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCValConstSListIter</tt> object
 goes out of scope.
<dt><br>Results:
<dd>The<tt> WCValConstSListIter</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCValConstSListIter</tt>
</dl>
<h2 id="WCValConstDListIterXTypeY__WCValConstDListIterLR"> WCValConstDListIter() &#91;WCValConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValConstDListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCValConstDListIter</tt> public member function is the default constructor for the class and initializes the iterator
 with no list to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with a list to
 iterate over.
<dt><br>Results:
<dd>The<tt> WCValConstDListIter</tt> public member function creates an initialized<tt> WCValConstDListIter</tt> object.
<dt><br>See Also:
<dd><tt> WCValConstDListIter</tt>,<tt> ~WCValConstDListIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValConstDListIter( const WCValDList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValConstDListIter</tt> public member function is a constructor for the class.&nbsp; The value passed as a parameter
 is the<tt> WCValDList</tt> list object.&nbsp; The iterator will be initialized for that list object and positioned before
 the first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<tt>
 operator ++, operator (),</tt> or<tt> operator +=</tt> operators.
<dt><br>Results:
<dd>The<tt> WCValConstDListIter</tt> public member function creates an initialized<tt> WCValConstDListIter</tt> object positioned
 before the first list element.
<dt><br>See Also:
<dd><tt> WCValConstDListIter</tt>,<tt> ~WCValConstDListIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt>
 reset</tt>
</dl>
<h2 id="WCValConstDListIterXTypeY____WCValConstDListIterLR"> ~WCValConstDListIter() &#91;WCValConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCValConstDListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCValConstDListIter</tt> public member function is the destructor for the class.&nbsp; The call to the<tt> ~WCValConstDListIter</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCValConstDListIter</tt> object
 goes out of scope.
<dt><br>Results:
<dd>The<tt> WCValConstDListIter</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCValConstDListIter</tt>
</dl>
<h2 id="WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__containerLR"> container() &#91;WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>const WCValSList&lt;Type&gt; *WCValConstSListIter&lt;Type&gt;::container() const;</tt>
<br><tt> const WCValDList&lt;Type&gt; *WCValConstDListIter&lt;Type&gt;::container() const;</tt>
<dt><br>Semantics:
<dd>The<tt> container</tt> public member function returns a pointer to the list container object.&nbsp; If the iterator has not
 been initialized with a list object, and the<tt> undef_iter</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>A pointer to the list object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
 with a list.
<dt><br>See Also:
<dd><tt> WCValConstSListIter</tt>,<tt> WCValConstDListIter</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValConstSListIterXTypeY__currentLR__WCValConstDListIterXTypeY__currentLR"> current() &#91;WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type current();</tt>
<dt><br>Semantics:
<dd>The<tt> current</tt> public member function returns the value of the list element at the current iterator position.
<br>If the iterator is not associated with a list, or the iterator position is either before the first element or past the
 last element in the list, the current iterator position is undefined.&nbsp; In this case the<tt> undef_item</tt> exception
 is thrown, if enabled.
<dt><br>Results:
<dd>The value at the current iterator element is returned.&nbsp; If the current element is undefined, a default initialized object
 is returned.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_item</tt>
</dl>
<h2 id="WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__operator_LRLR"> operator ()() &#91;WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ()();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ()</tt> public member function is the call operator for the class.&nbsp; The list element which follows the
 current item is set to be the new current item.&nbsp; If the previous current item was the last element in the list, the
 iterator is positioned after the end of the list.
<br>The<tt> operator ()</tt> public member function has the same semantics as the pre-increment operator,<tt> operator ++.</tt>
<br><br>If the iterator was positioned before the first element in the list, the current item will be set to the first element
 in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<br><br>If the iterator is not associated with a list or the iterator position before the increment was past the last element
 the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ()</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__operator_PPLR"> operator ++() &#91;WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ++();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ++</tt> public member function is the pre-increment operator for the class.&nbsp; The list element which
 follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
 list, the iterator is positioned after the end of the list.
<br>The<tt> operator ++</tt> public member function has the same semantics as the call operator,<tt> operator ().</tt>
<br><br>If the iterator was positioned before the first element in the list, the current item will be set to the first element
 in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<br><br>If the iterator is not associated with a list or the iterator position before the increment was past the last element
 the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ++</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValConstSListIterXTypeY_WCValConstDListIterXTypeY__operator_PELR"> operator +=() &#91;WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator +=( int );</tt>
<dt><br>Semantics:
<dd>The<tt> operator +=</tt> public member function accepts an integer value that causes the iterator to move that many elements
 after the current item.&nbsp; If the iterator was positioned before the first element in the list, the operation will set
 the current item to be the given element in the list.
<br>If the current item was after the last element in the list previous to the iteration, and the<tt> undef_iter</tt> exception
 is enabled, the exception will be thrown.&nbsp; Attempting to increment the iterator position more than element after the
 end of the list, or by less than one element causes the<tt> iter_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator +=</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::iter_range</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValConstDListIterXTypeY__operator_MMLR"> operator --() &#91;WCValConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator --();</tt>
<dt><br>Semantics:
<dd>The<tt> operator --</tt> public member function is the pre-decrement operator for the class.&nbsp; The list element previous
 to the current item is set to be the new current item.&nbsp; If the current item was the first element in the list, the iterator
 is positioned before the first element in the list.&nbsp; If the list is empty, the iterator will be positioned before the
 start of the list.
<br>If the iterator was positioned after the last element in the list, the current item will be set to the last element.
<br><br>If the iterator is not associated with a list or the iterator position previous to the decrement was before the first
 element the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator --</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is decremented past the first element of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValConstDListIterXTypeY__operator_MELR"> operator -=() &#91;WCValConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator -=( int );</tt>
<dt><br>Semantics:
<dd>The<tt> operator -=</tt> public member function accepts an integer value that causes the iterator to move that many elements
 before the current item.&nbsp; If the iterator was positioned after the last element in the list, the operation will set
 the current item to be the given number of elements from the end of the list.
<br>If the current item was before the first element in the list previous to the iteration, and the<tt> undef_iter</tt> exception
 is enabled, the exception will be thrown.&nbsp; Attempting to decrement the iterator position more than one element before
 the beginning of the list, or by less than one element causes the<tt> iter_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator -=</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is decremented past the first element in the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::iter_range</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValConstSListIterXTypeY__resetLR__WCValConstDListIterXTypeY__resetLR"> reset() &#91;WCValConstSListIter&lt;Type&gt;,WCValConstDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void reset();</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to the initial state, positioning the iterator before the first
 element in the associated list.
<dt><br>Results:
<dd>The iterator is positioned before the first list element.
<dt><br>See Also:
<dd><tt> WCValConstSListIter</tt>,<tt> WCValConstDListIter</tt>,<tt> container</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void WCValConstSListIter&lt;Type&gt;::reset( const WCValSList&lt;Type&gt; &amp; );</tt>
<br><tt> void WCValConstDListIter&lt;Type&gt;::reset( const WCValDList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to operate on the specified list.&nbsp; The iterator is positioned
 before the first element in the list.
<dt><br>Results:
<dd>The iterator is positioned before the first element of the specified list.
<dt><br>See Also:
<dd><tt> WCValConstSListIter</tt>,<tt> WCValConstDListIter</tt>,<tt> container</tt>
</dl>
<h2 id="WCValSListIterXTypeY__WCValDListIterXTypeY_Class_Description"> WCValSListIter&lt;Type&gt;, WCValDListIter&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wclistit.h</tt>
<br>The<tt> WCValSListIter&lt;Type&gt;</tt> and<tt> WCValDListIter&lt;Type&gt;</tt> classes are the templated classes used
 to create iterator objects for single and double linked list objects.&nbsp; These classes can be used only for non-constant
 lists.&nbsp; The<tt> WCValDConstListIter&lt;Type&gt;</tt> and<tt> WCValSConstListIter&lt;Type&gt;</tt> classes are provided
 to iterate over constant lists.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the list element type specified
 as the template parameter.
<br><br>The<tt> WCIterExcept</tt> class is a base class of the<tt> WCValSListIter&lt;Type&gt;</tt> and<tt> WCValDListIter&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCValSListIter&lt;Type&gt;</tt> and<tt> WCValDListIter&lt;Type&gt;</tt> objects.&nbsp; No exceptions
 are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Private Member Functions</b>
<br><br>Some functionality supported by base classes of the iterator are not appropriate in the single linked list iterator
 classes.&nbsp; Setting those functions as private members in the derived class is the standard mechanism to prevent them
 from being invoked.&nbsp; The following member functions are declared in the single linked list iterator private interface:
<br><br><tt>int operator --();</tt>
<br><tt> int operator -=( int );</tt>
<br><tt> int insert( Type &amp; );</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCValSListIter();</tt>
<br><tt> WCValSListIter( WCValSList&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCValSListIter();</tt>
<br><tt> WCValDListIter();</tt>
<br><tt> WCValDListIter( WCValDList&lt;Type&gt; &amp; );</tt>
<br><tt> ~WCValDListIter();</tt>
<br><tt> int append( Type &amp; );</tt>
<br><tt> WCValSList&lt;Type&gt; *WCValSListIter&lt;Type&gt;::container() const;</tt>
<br><tt> WCValDList&lt;Type&gt; *WCValDListIter&lt;Type&gt;::container() const;</tt>
<br><tt> Type current() const;</tt>
<br><tt> void reset();</tt>
<br><tt> void WCValSListIter&lt;Type&gt;::reset( WCValSList&lt;Type&gt; &amp; );</tt>
<br><tt> void WCValDListIter&lt;Type&gt;::reset( WCValDList&lt;Type&gt; &amp; );</tt>
<br><br>In the iterators for double linked lists only:
<br><br><tt>int insert( Type &amp; );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>int operator ()();</tt>
<br><tt> int operator ++();</tt>
<br><tt> int operator +=( int );</tt>
<br><br>In the iterators for double linked lists only:
<br><br><tt>int operator --();</tt>
<br><tt> int operator -=( int );</tt>
<dt><br>See Also:
<dd><tt> WCValSList::forAll</tt>,<tt> WCValDList::forAll</tt>
<br><b>Sample Program Using Value List Iterators</b>
<br><br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><br><tt>//</tt>
<br><tt>// insert elem after all elements in the list less than or equal to</tt>
<br><tt>// elem</tt>
<br><tt>//</tt>
<br><br><tt>void insert_in_order( WCValDList&lt;int&gt; &amp;list, int elem ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; if( list.entries() == 0 ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cannot insert in an empty list using a iterator</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.insert( elem );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; } else {</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WCValDListIter&lt;int&gt; iter( list );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( ++iter ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( iter.current() &gt; elem ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // insert elem before first
 element in list greater</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // than elem</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iter.insert( elem );</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // iterated past the end of the list</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // append elem to the end of the list</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; list.append( elem );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
<br><br><tt>void main() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WCValDList&lt;int&gt; list;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; insert_in_order( list, 5 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; insert_in_order( list, 20 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; insert_in_order( list, 1 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; insert_in_order( list, 25 );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;List elements in ascending order:\n&quot;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; WCValDListIter&lt;int&gt; iter( list );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( ++iter ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; iter.current() &lt;&lt; &quot;\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;List elements in descending order\n&quot;;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; // iterator is past the end of the list</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( --iter ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; iter.current() &lt;&lt; &quot;\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; }</tt>
<br><tt>}</tt>
</dl>
<h2 id="WCValSListIterXTypeY__WCValSListIterLR"> WCValSListIter() &#91;WCValSListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSListIter</tt> public member function is the default constructor for the class and initializes the iterator with
 no list to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with a list to iterate
 over.
<dt><br>Results:
<dd>The<tt> WCValSListIter</tt> public member function creates an initialized<tt> WCValSListIter</tt> object.
<dt><br>See Also:
<dd><tt> WCValSListIter</tt>,<tt> ~WCValSListIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSListIter( WCValSList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSListIter</tt> public member function is a constructor for the class.&nbsp; The value passed as a parameter is
 a<tt> WCValSList</tt> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
 first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<tt>
 operator ++, operator (),</tt> or<tt> operator +=</tt> operators.
<dt><br>Results:
<dd>The<tt> WCValSListIter</tt> public member function creates an initialized<tt> WCValSListIter</tt> object positioned before
 the first element in the list.
<dt><br>See Also:
<dd><tt> ~WCValSListIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> reset</tt>
</dl>
<h2 id="WCValSListIterXTypeY____WCValSListIterLR"> ~WCValSListIter() &#91;WCValSListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCValSListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCValSListIter</tt> public member function is the destructor for the class.&nbsp; The call to the<tt> ~WCValSListIter</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCValSListIter</tt> object goes
 out of scope.
<dt><br>Results:
<dd>The<tt> WCValSListIter</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCValSListIter</tt>
</dl>
<h2 id="WCValDListIterXTypeY__WCValDListIterLR"> WCValDListIter() &#91;WCValDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValDListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> WCValDListIter</tt> public member function is the default constructor for the class and initializes the iterator with
 no list to operate on.&nbsp; The<tt> reset</tt> member function must be called to provide the iterator with a list to iterate
 over.
<dt><br>Results:
<dd>The<tt> WCValDListIter</tt> public member function creates an initialized<tt> WCValDListIter</tt> object.
<dt><br>See Also:
<dd><tt> WCValDListIter</tt>,<tt> ~WCValDListIter</tt>,<tt> reset</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValDListIter( WCValDList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValDListIter</tt> public member function is a constructor for the class.&nbsp; The value passed as a parameter is
 the<tt> WCValDList</tt> list object.&nbsp; The iterator will be initialized for that list object and positioned before the
 first list element.&nbsp; To position the iterator to a valid element within the list, increment it using any of the<tt>
 operator ++, operator (),</tt> or<tt> operator +=</tt> operators.
<dt><br>Results:
<dd>The<tt> WCValDListIter</tt> public member function creates an initialized<tt> WCValDListIter</tt> object positioned before
 the first list element.
<dt><br>See Also:
<dd><tt> WCValDListIter</tt>,<tt> ~WCValDListIter</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt>
 reset</tt>
</dl>
<h2 id="WCValDListIterXTypeY____WCValDListIterLR"> ~WCValDListIter() &#91;WCValDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>~WCValDListIter();</tt>
<dt><br>Semantics:
<dd>The<tt> ~WCValDListIter</tt> public member function is the destructor for the class.&nbsp; The call to the<tt> ~WCValDListIter</tt>
 public member function is inserted implicitly by the compiler at the point where the<tt> WCValDListIter</tt> object goes
 out of scope.
<dt><br>Results:
<dd>The<tt> WCValDListIter</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCValDListIter</tt>
</dl>
<h2 id="WCValSListIterXTypeY__appendLR__WCValDListIterXTypeY__appendLR"> append() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int append( Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> append</tt> public member function inserts a new element into the list container object.&nbsp; The new element is
 inserted after the current iterator item.
<br>If the iterator is not associated with a list, or the iterator position is either before the first element or past the
 last element in the list, the current iterator position is undefined.&nbsp; The element is not appended.&nbsp; If the<tt>
 undef_iter</tt> exception is enabled, it is thrown.
<br><br>If the append fails, the<tt> out_of_memory</tt> exception is thrown, if enabled in the list being iterated over.&nbsp;
 The list remains unchanged.
<dt><br>Results:
<dd>The new element is inserted after the current iterator item.&nbsp; A TRUE value (non-zero) is returned if the append is successful.
&nbsp; A FALSE (zero) result is returned if the append fails.
<dt><br>See Also:
<dd><tt> insert</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValSListIterXTypeY_WCValDListIterXTypeY__containerLR"> container() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSList&lt;Type&gt; *WCValSListIter&lt;Type&gt;::container() const;</tt>
<br><tt> WCValDList&lt;Type&gt; *WCValDListIter&lt;Type&gt;::container() const;</tt>
<dt><br>Semantics:
<dd>The<tt> container</tt> public member function returns a pointer to the list container object.&nbsp; If the iterator has not
 been initialized with a list object, and the<tt> undef_iter</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>A pointer to the list object associated with the iterator is returned, or NULL(0) if the iterator has not been initialized
 with a list.
<dt><br>See Also:
<dd><tt> WCValSListIter</tt>,<tt> WCValDListIter</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValSListIterXTypeY__currentLR__WCValDListIterXTypeY__currentLR"> current() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type current();</tt>
<dt><br>Semantics:
<dd>The<tt> current</tt> public member function returns the value of the list element at the current iterator position.
<br>If the iterator is not associated with a list, or the iterator position is either before the first element or past the
 last element in the list, the current iterator position is undefined.&nbsp; In this case the<tt> undef_item</tt> exception
 is thrown, if enabled.
<dt><br>Results:
<dd>The value at the current iterator element is returned.&nbsp; If the current element is undefined, a default initialized object
 is returned.
<dt><br>See Also:
<dd><tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_item</tt>
</dl>
<h2 id="WCValDListIterXTypeY__insertLR"> insert() &#91;WCValDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function inserts a new element into the list container object.&nbsp; The new element is
 inserted before the current iterator item.&nbsp; This process uses the previous link in the double linked list, so the<tt>
 insert</tt> public member function is not allowed with single linked lists.
<br>If the iterator is not associated with a list, or the iterator position is either before the first element or past the
 last element in the list, the current iterator position is undefined.&nbsp; The element is not inserted.&nbsp; If the<tt>
 undef_iter</tt> exception is enabled, the exception is thrown.
<br><br>If the insert fails and the<tt> out_of_memory</tt> exception is enabled in the list being iterated over, the exception
 is thrown.&nbsp; The list remains unchanged.
<dt><br>Results:
<dd>The new element is inserted before the current iterator item.&nbsp; A TRUE value (non-zero) is returned if the insert is successful.
&nbsp; A FALSE (zero) result is returned if the insert fails.
<dt><br>See Also:
<dd><tt> append</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValSListIterXTypeY_WCValDListIterXTypeY__operator_LRLR"> operator ()() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ()();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ()</tt> public member function is the call operator for the class.&nbsp; The list element which follows the
 current item is set to be the new current item.&nbsp; If the previous current item was the last element in the list, the
 iterator is positioned after the end of the list.
<br>The<tt> operator ()</tt> public member function has the same semantics as the pre-increment operator,<tt> operator ++.</tt>
<br><br>If the iterator was positioned before the first element in the list, the current item will be set to the first element
 in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<br><br>If the iterator is not associated with a list or the iterator position before the increment was past the last element
 the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ()</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValSListIterXTypeY_WCValDListIterXTypeY__operator_PPLR"> operator ++() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ++();</tt>
<dt><br>Semantics:
<dd>The<tt> operator ++</tt> public member function is the pre-increment operator for the class.&nbsp; The list element which
 follows the current item is set to be the new current item.&nbsp; If the previous current item was the last element in the
 list, the iterator is positioned after the end of the list.
<br>The<tt> operator ++</tt> public member function has the same semantics as the call operator,<tt> operator ().</tt>
<br><br>If the iterator was positioned before the first element in the list, the current item will be set to the first element
 in the list.&nbsp; If the list is empty, the iterator will be positioned after the end of the list.
<br><br>If the iterator is not associated with a list or the iterator position before the increment was past the last element
 the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator ++</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValSListIterXTypeY_WCValDListIterXTypeY__operator_PELR"> operator +=() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator +=( int );</tt>
<dt><br>Semantics:
<dd>The<tt> operator +=</tt> public member function accepts an integer value that causes the iterator to move that many elements
 after the current item.&nbsp; If the iterator was positioned before the first element in the list, the operation will set
 the current item to be the given element in the list.
<br>If the current item was after the last element in the list previous to the iteration, and the<tt> undef_iter</tt> exception
 is enabled, the exception will be thrown.&nbsp; Attempting to increment the iterator position more than element after the
 end of the list, or by less than one element causes the<tt> iter_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator +=</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is incremented past the end of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator --</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::iter_range</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValDListIterXTypeY__operator_MMLR"> operator --() &#91;WCValDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator --();</tt>
<dt><br>Semantics:
<dd>The<tt> operator --</tt> public member function is the pre-decrement operator for the class.&nbsp; The list element previous
 to the current item is set to be the new current item.&nbsp; If the current item was the first element in the list, the iterator
 is positioned before the first element in the list.&nbsp; If the list is empty, the iterator will be positioned before the
 start of the list.
<br>If the iterator was positioned after the last element in the list, the current item will be set to the last element.
<br><br>If the iterator is not associated with a list or the iterator position previous to the decrement was before the first
 element the list, the<tt> undef_iter</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator --</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is decremented past the first element of the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator -=</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValDListIterXTypeY__operator_MELR"> operator -=() &#91;WCValDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator -=( int );</tt>
<dt><br>Semantics:
<dd>The<tt> operator -=</tt> public member function accepts an integer value that causes the iterator to move that many elements
 before the current item.&nbsp; If the iterator was positioned after the last element in the list, the operation will set
 the current item to be the given number of elements from the end of the list.
<br>If the current item was before the first element in the list previous to the iteration, and the<tt> undef_iter</tt> exception
 is enabled, the exception will be thrown.&nbsp; Attempting to decrement the iterator position more than one element before
 the beginning of the list, or by less than one element causes the<tt> iter_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator -=</tt> public member function returns a non-zero value if the iterator is positioned on a list item.&nbsp;
 Zero(0) is returned when the iterator is decremented past the first element in the list.
<dt><br>See Also:
<dd><tt> current</tt>,<tt> operator ()</tt>,<tt> operator ++</tt>,<tt> operator +=</tt>,<tt> operator --</tt>,<tt> reset</tt>,<tt>
 WCIterExcept::iter_range</tt>,<tt> WCIterExcept::undef_iter</tt>
</dl>
<h2 id="WCValSListIterXTypeY__resetLR__WCValDListIterXTypeY__resetLR"> reset() &#91;WCValSListIter&lt;Type&gt;,WCValDListIter&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void reset();</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to the initial state, positioning the iterator before the first
 element in the associated list.
<dt><br>Results:
<dd>The iterator is positioned before the first list element.
<dt><br>See Also:
<dd><tt> WCValSListIter</tt>,<tt> WCValDListIter</tt>,<tt> container</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wclistit.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void WCValSListIter&lt;Type&gt;::reset( WCValSList&lt;Type&gt; &amp; );</tt>
<br><tt> void WCValDListIter&lt;Type&gt;::reset( WCValDList&lt;Type&gt; &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> reset</tt> public member function resets the iterator to operate on the specified list.&nbsp; The iterator is positioned
 before the first element in the list.
<dt><br>Results:
<dd>The iterator is positioned before the first element of the specified list.
<dt><br>See Also:
<dd><tt> WCValSListIter</tt>,<tt> WCValDListIter</tt>,<tt> container</tt>
</dl>
<h1 id="Queue_Container"> Queue Container </h1>
<br>Queue containers maintain an ordered collection of data which is retrieved in the order in which the data was entered
 into the queue.&nbsp; The queue class is implemented as a templated class, allowing the use of any data type as the queue
 data.
<br><br>A second template parameter specifies the storage class used to implement the queue.&nbsp; The<tt> WCValSList, WCIsvSList</tt>
 and<tt> WCPtrSList</tt> classes are appropriate storage classes.
<h2 id="WCQueueXType_FTypeY_Class_Description"> WCQueue&lt;Type,FType&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wcqueue.h</tt>
<br>The<tt> WCQueue&lt;Type,FType&gt;</tt> class is a templated class used to create objects which maintain data in a queue.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the template parameter defining
 the type of the elements stored in the queue.&nbsp; The text<tt> FType</tt> is used to indicate the template parameter defining
 the storage class used to maintain the queue.
<br><br>For example, to create a queue of integers, the<tt> WCQueue&lt;int,WCValSList&lt;int&gt; &gt;</tt> class can be used.
&nbsp; The<tt> WCQueue&lt;int *,WCPtrSList&lt;int&gt; &gt;</tt> class will create a queue of pointers to integers.&nbsp; To
 create an intrusive queue of objects of type<b> isv_link</b> (derived from the<tt> WCSLink</tt> class), the<tt> WCQueue&lt;</tt><b>
 isv_link</b><tt> *,WCIsvSList&lt;</tt><b> isv_link</b><tt> &gt; &gt;</tt> class can be used.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCQueue&lt;Type,FType&gt;</tt> class and provides the<tt> exceptions</tt>
 member function.&nbsp; This member function controls the exceptions which can be thrown by the<tt> WCQueue&lt;Type,FType&gt;</tt>
 object.&nbsp; No exceptions are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Type</b>
<br><br><tt>Type</tt> must provide any constructors and/or operators required by the<tt> FType</tt> class.
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCQueue();</tt>
<br><tt> WCQueue( void *(*)( size_t ), void (*)( void *, size_t ) );</tt>
<br><tt> ~WCQueue();</tt>
<br><tt> void clear();</tt>
<br><tt> int entries() const;</tt>
<br><tt> Type first() const;</tt>
<br><tt> Type get();</tt>
<br><tt> int insert( const Type &amp; );</tt>
<br><tt> int isEmpty() const;</tt>
<br><tt> Type last() const;</tt>
<br><br><b>Sample Program Using a Queue</b>
<br><br><tt>#include &lt;wcqueue.h&gt;</tt>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><br><tt>main() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WCQueue&lt;int,WCValSList&lt;int&gt; &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; queue;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; queue.insert( 7 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; queue.insert( 8 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; queue.insert( 9 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; queue.insert( 10 );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;\nNumber of queue entries: &quot; &lt;&lt; queue.entries() &lt;&lt; &quot;\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;First entry = &#91;&quot; &lt;&lt; queue.first() &lt;&lt; &quot;&#93;\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;Last entry = &#91;&quot; &lt;&lt; queue.last() &lt;&lt; &quot;&#93;\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( !queue.isEmpty() ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; queue.get() &lt;&lt; &quot;\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; };</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout.flush();</tt>
<br><tt>}</tt>
</dl>
<h2 id="WCQueueXType_FTypeY__WCQueueLR"> WCQueue() &#91;WCQueue&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcqueue.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCQueue();</tt>
<dt><br>Semantics:
<dd>The public<tt> WCQueue&lt;Type,FType&gt;</tt> constructor creates an empty<tt> WCQueue&lt;Type,FType&gt;</tt> object.&nbsp;
 The<tt> FType</tt> storage class constructor performs the initialization.
<dt><br>Results:
<dd>The public<tt> WCQueue&lt;Type,FType&gt;</tt> constructor creates an initialized<tt> WCQueue&lt;Type,FType&gt;</tt> object.
<dt><br>See Also:
<dd><tt> ~WCQueue&lt;Type,FType&gt;</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcqueue.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCQueue( void *(*allocator)( size_t ),</tt>
<br><tt> void (*deallocator)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCQueue&lt;Type,FType&gt;</tt> constructor creates an empty<tt> WCQueue&lt;Type,FType&gt;</tt> object.&nbsp;
 If<tt> FType</tt> is either the<tt> WCValSList</tt> or<tt> WCPtrSList</tt> class, then the<b> allocator</b> function is registered
 to perform all memory allocations of the queue elements, and the<b> deallocator</b> function to perform all freeing of the
 queue elements' memory.&nbsp; The<b> allocator</b> and<b> deallocator</b> functions are ignored if<tt> FType</tt> is the<tt>
 WCIsvSList</tt> class.&nbsp; These functions provide the ability to control how the allocation and freeing of memory is performed,
 allowing for more efficient memory handling than the general purpose global<tt> operator new()</tt> and<tt> operator delete()</tt>
 can provide.&nbsp; Memory management optimizations may potentially be made through the<b> allocator</b> and<b> deallocator</b>
 functions, but are not recommended before managing memory is understood and determined to be worth while.
<br>The<b> allocator</b> function shall return a pointer to allocated memory of size at least the argument, or zero(0) if
 the allocation cannot be performed.&nbsp; Initialization of the memory returned is performed by the<tt> WCQueue&lt;Type,FType&gt;</tt>
 class.
<br><br>The<tt> WCQueue&lt;Type,FType&gt;</tt> class calls the<b> deallocator</b> function only on memory allocated by the<b>
 allocator</b> function.&nbsp; The<b> deallocator</b> shall free the memory pointed to by the first argument which is of size
 the second argument.&nbsp; The size passed to the<b> deallocator</b> function is guaranteed to be the same size passed to
 the<b> allocator</b> function when the memory was allocated.
<br><br>The<b> allocator</b> and<b> deallocator</b> functions may assume that for a list object instance, the<b> allocator</b>
 is always called with the same first argument (the size of the memory to be allocated).&nbsp; If<tt> FType</tt> is the<tt>
 WCValSList&lt;Type&gt;</tt> class, then the<tt> WCValSListItemSize( Type )</tt> macro returns the size of the elements which
 are allocated by the<b> allocator</b> function.&nbsp; Similarly, the<tt> WCPtrSListItemSize( Type )</tt> macro returns the
 size of<tt> WCPtrSList&lt;Type&gt;</tt> elements.
<br><br>The<tt> FType</tt> storage class constructor performs the initialization of the queue.
<dt><br>Results:
<dd>The public<tt> WCQueue&lt;Type,FType&gt;</tt> constructor creates an initialized<tt> WCQueue&lt;Type,FType&gt;</tt> object
 and registers the<b> allocator</b> and<b> deallocator</b> functions.
<dt><br>See Also:
<dd><tt> WCQueue&lt;Type,FType&gt;</tt>,<tt> ~WCQueue&lt;Type,FType&gt;</tt>
</dl>
<h2 id="WCQueueXType_FTypeY____WCQueueLR"> ~WCQueue() &#91;WCQueue&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcqueue.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCQueue();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCQueue&lt;Type,FType&gt;</tt> destructor destroys the<tt> WCQueue&lt;Type,FType&gt;</tt> object.&nbsp; The<tt>
 FType</tt> storage class destructor performs the destruction.&nbsp; The call to the public<tt> ~WCQueue&lt;Type,FType&gt;</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> WCQueue&lt;Type,FType&gt;</tt> object goes out
 of scope.
<br>If the<tt> not_empty</tt> exception is enabled, the exception is thrown if the queue is not empty of queue elements.
<dt><br>Results:
<dd>The<tt> WCQueue&lt;Type,FType&gt;</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCQueue&lt;Type,FType&gt;</tt>,<tt> clear</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCQueueXType_FTypeY__clearLR"> clear() &#91;WCQueue&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcqueue.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the queue object and set it to the state of the object just after
 the initial construction.&nbsp; The queue object is not destroyed and re-created by this operator, so the object destructor
 is not invoked.&nbsp; The queue elements are not cleared by the queue class.&nbsp; However, the class used to maintain the
 queue,<tt> FType,</tt> may clear the items as part of the clear function for that class.&nbsp; If it does not clear the items,
 any queue items still in the list are lost unless pointed to by some pointer object in the program code.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function resets the queue object to the state of the object immediately after the initial
 construction.
<dt><br>See Also:
<dd><tt> ~WCQueue&lt;Type,FType&gt;</tt>,<tt> isEmpty</tt>
</dl>
<h2 id="WCQueueXType_FTypeY__entriesLR"> entries() &#91;WCQueue&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcqueue.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to determine the number of queue elements contained in the list object.
<dt><br>Results:
<dd>The number of elements in the queue is returned.&nbsp; Zero(0) is returned if there are no queue elements.
<dt><br>See Also:
<dd><tt> isEmpty</tt>
</dl>
<h2 id="WCQueueXType_FTypeY__firstLR"> first() &#91;WCQueue&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcqueue.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type first() const;</tt>
<dt><br>Semantics:
<dd>The<tt> first</tt> public member function returns a queue element from the beginning of the queue object.&nbsp; The queue
 element is not removed from the queue.
<br>If the queue is empty, one of two exceptions can be thrown.&nbsp; If the<tt> empty_container</tt> exception is enabled,
 then it will be thrown.&nbsp; Otherwise, the<tt> index_range</tt> exception will be thrown, if enabled.
<dt><br>Results:
<dd>The first queue element is returned.&nbsp; If there are no elements in the queue, the return value is determined by the<tt>
 find</tt> member function of the<tt> FType</tt> class.
<dt><br>See Also:
<dd><tt> get</tt>,<tt> isEmpty</tt>,<tt> last</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>,<tt> FType::find</tt>
</dl>
<h2 id="WCQueueXType_FTypeY__getLR"> get() &#91;WCQueue&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcqueue.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type get();</tt>
<dt><br>Semantics:
<dd>The<tt> get</tt> public member function returns the queue element which was first inserted into the queue object.&nbsp; The
 queue element is also removed from the queue.
<br>If the queue is empty, one of two exceptions can be thrown.&nbsp; If the<tt> empty_container</tt> exception is enabled,
 then it will be thrown.&nbsp; Otherwise, the<tt> index_range</tt> exception will be thrown, if enabled.
<dt><br>Results:
<dd>The first element in the queue is removed and returned.&nbsp; If there are no elements in the queue, the return value is determined
 by the<tt> get</tt> member function of the<tt> FType</tt> class.
<dt><br>See Also:
<dd><tt> first</tt>,<tt> insert</tt>,<tt> isEmpty</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>,<tt>
 FType::get</tt>
</dl>
<h2 id="WCQueueXType_FTypeY__insertLR"> insert() &#91;WCQueue&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcqueue.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function is used to insert the data into the queue.&nbsp; It will be the last element in
 the queue, and the last to be retrieved.
<br>If the insert fails, the<tt> out_of_memory</tt> exception will be thrown, if enabled.&nbsp; The queue will remain unchanged.
<dt><br>Results:
<dd>The queue element is inserted at the end of the queue.&nbsp; A TRUE value (non-zero) is returned if the insert is successful.
&nbsp; A FALSE (zero) result is returned if the insert fails.
<dt><br>See Also:
<dd><tt> get</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCQueueXType_FTypeY__isEmptyLR"> isEmpty() &#91;WCQueue&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcqueue.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if a queue object has any queue elements contained in it.
<dt><br>Results:
<dd>A TRUE value (non-zero) is returned if the queue object does not have any queue elements contained within it.&nbsp; A FALSE
 (zero) result is returned if the queue contains at least one element.
<dt><br>See Also:
<dd><tt> entries</tt>
</dl>
<h2 id="WCQueueXType_FTypeY__lastLR"> last() &#91;WCQueue&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcqueue.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type last() const;</tt>
<dt><br>Semantics:
<dd>The<tt> last</tt> public member function returns a queue element from the end of the queue object.&nbsp; The queue element
 is not removed from the queue.
<br>If the queue is empty, one of two exceptions can be thrown.&nbsp; If the<tt> empty_container</tt> exception is enabled,
 then it will be thrown.&nbsp; Otherwise, the<tt> index_range</tt> exception will be thrown, if enabled.
<dt><br>Results:
<dd>The last queue element is returned.&nbsp; If there are no elements in the queue, the return value is determined by the<tt>
 find</tt> member function of the<tt> FType</tt> class.
<dt><br>See Also:
<dd><tt> first</tt>,<tt> get</tt>,<tt> isEmpty</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>,<tt> FType::find</tt>
</dl>
<h1 id="Skip_List_Containers"> Skip List Containers </h1>
<br>This chapter describes skip list containers.
<h2 id="WCPtrSkipListDictXKey_ValueY_Class_Description"> WCPtrSkipListDict&lt;Key,Value&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wcskip.h</tt>
<br>The<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt> class is a templated class used to store objects in a dictionary.&nbsp;
 Dictionaries store values with an associated key, which may be of any type.&nbsp; One example of a dictionary used in everyday
 life is the phone book.&nbsp; The phone numbers are the data values, and the customer name is the key.&nbsp; The equality
 operator of the key's type is used to locate the key-value pairs.
<br>In the description of each member function, the text<tt> Key</tt> is used to indicate the template parameter defining
 the type of the indices pointed to by the pointers stored in the dictionary.&nbsp; The text<tt> Value</tt> is used to indicate
 the template parameter defining the type of the data pointed to by the pointers stored in the dictionary.
<br><br>Note that pointers to the key values are stored in the dictionary.&nbsp; Destructors are not called on the keys pointed
 to.&nbsp; The key values pointed to in the dictionary should not be changed such that the equivalence to the old value is
 modified.
<br><br>The iterator classes for skip lists have the same function and operator interface as the hash iterators classes.&nbsp;
 See the chapter on hash iterators for more information.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt> class and provides
 the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can be thrown by the<tt>
 WCPtrSkipListDict&lt;Key,Value&gt;</tt> object.&nbsp; No exceptions are enabled unless they are set by the<tt> exceptions</tt>
 member function.
<br><br><b>Requirements of Key</b>
<br><br>The<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt> class requires<tt> Key</tt> to have:
<br>A well defined equivalence operator with constant parameters
<br><br>(<tt> int operator ==( const Key &amp; ) const</tt> ).
<br>A well defined operator less than with constant parameters
<br><br>(<tt> int operator &lt;( const Key &amp; ) const</tt> ).
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCPtrSkipListDict( unsigned = WCSkipListDict_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</tt>
<br><tt> WCPtrSkipListDict( unsigned = WCSkipListDict_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS, void * (*user_alloc)(
 size_t size ), void (*user_dealloc)( void *old, size_t size ) );</tt>
<br><tt> WCPtrSkipListDict( const WCPtrSkipListDict &amp; );</tt>
<br><tt> virtual ~WCPtrSkipListDict();</tt>
<br><tt> void clear();</tt>
<br><tt> void clearAndDestroy();</tt>
<br><tt> int contains( const Key * ) const;</tt>
<br><tt> unsigned entries() const;</tt>
<br><tt> Value * find( const Key * ) const;</tt>
<br><tt> Value * findKeyAndValue( const Key *, Key * &amp; ) const;</tt>
<br><tt> void forAll( void (*user_fn)( Key *, Value *, void * ), void * );</tt>
<br><tt> int insert( Key *, Value * );</tt>
<br><tt> int isEmpty() const;</tt>
<br><tt> Value * remove( const Key * );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>Value * &amp; operator &#91;&#93;( const Key * );</tt>
<br><tt> Value * const &amp; operator &#91;&#93;( const Key * ) const;</tt>
<br><tt> WCPtrSkipListDict &amp; operator =( const WCPtrSkipListDict &amp; );</tt>
<br><tt> int operator ==( const WCPtrSkipListDict &amp; ) const;</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__WCPtrSkipListDictLR"> WCPtrSkipListDict() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSkipListDict( unsigned = WCSKIPLIST_PROB_QUARTER,</tt>
<br><tt> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt> constructor creates an<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt>
 object with no entries.&nbsp; The first optional parameter, which defaults to the constant<tt> WCSKIPLIST_PROB_QUARTER,</tt>
 determines the probability of having a certain number of pointers in each skip list node.&nbsp; The second optional parameter,
 which defaults to the constant<tt> WCDEFAULT_SKIPLIST_MAX_PTRS,</tt> determines the maximum number of pointers that are allowed
 in any skip list node.<tt>&nbsp; WCDEFAULT_SKIPLIST_MAX_PTRS</tt> is the maximum effective value of the second parameter.
&nbsp; If an allocation failure occurs while creating the skip list, the<tt> out_of_memory</tt> exception is thrown if the<tt>
 out_of_memory</tt> exception is enabled.
<dt><br>Results:
<dd>The public<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt> constructor creates an initialized<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt>
 object.
<dt><br>See Also:
<dd><tt> ~WCPtrSkipListDict&lt;Key,Value&gt;</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSkipListDict( unsigned = WCSKIPLIST_PROB_QUARTER,</tt>
<br><tt> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS,</tt>
<br><tt>void * (*user_alloc)( size_t ),</tt>
<br><tt>void (*user_dealloc)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>Allocator and deallocator functions are specified for use when entries are inserted and removed from the list dictionary.
&nbsp; The semantics of this constructor are the same as the constructor without the memory management functions.
<br>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is passed
 the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic that the
 allocation function will always be called with the same size value for any particular instantiation of a list dictionary.
&nbsp; To determine the size of the objects that the memory management functions will be required to allocate and free, the
 following macro may be used:
<br><br><tt>WCPtrSkipListDictItemSize( Key, Value, num_of_pointers )</tt>
<dt><br>Results:
<dd>The public<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt> constructor creates an initialized<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt>
 object.
<dt><br>See Also:
<dd><tt> ~WCPtrSkipListDict&lt;Key,Value&gt;</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSkipListDict( const WCPtrSkipListDict &amp; );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt> constructor is the copy constructor for the<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt>
 class.&nbsp; The new skip list is created with the same probability and maximum pointers, all values or pointers stored in
 the list, and the exception trap states.&nbsp; If there is not enough memory to copy all of the values, then only some will
 be copied, and the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied,
 then the<tt> out_of_memory</tt> exception is thrown if it is enabled.
<dt><br>Results:
<dd>The public<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt> constructor creates an<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt>
 object which is a copy of the passed dictionary.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY____WCPtrSkipListDictLR"> ~WCPtrSkipListDict() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCPtrSkipListDict();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCPtrSkipListDict&lt;Key,Value&gt;</tt> destructor is the destructor for the<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt>
 class.&nbsp; If the number of dictionary elements is not zero and the<tt> not_empty</tt> exception is enabled, the exception
 is thrown.&nbsp; Otherwise, the dictionary elements are cleared using the<tt> clear</tt> member function.&nbsp; The objects
 which the dictionary elements point to are not deleted unless the<tt> clearAndDestroy</tt> member function is explicitly
 called before the destructor is called.&nbsp; The call to the public<tt> ~WCPtrSkipListDict&lt;Key,Value&gt;</tt> destructor
 is inserted implicitly by the compiler at the point where the<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt> object goes out
 of scope.
<dt><br>Results:
<dd>The public<tt> ~WCPtrSkipListDict&lt;Key,Value&gt;</tt> destructor destroys an<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt>
 object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__clearLR"> clear() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the dictionary so that it has no entries.&nbsp; Objects pointed
 to by the dictionary elements are not deleted.&nbsp; The dictionary object is not destroyed and re-created by this function,
 so the object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function clears the dictionary to have no elements.
<dt><br>See Also:
<dd><tt> ~WCPtrSkipListDict&lt;Key,Value&gt;</tt>,<tt> clearAndDestroy</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__clearAndDestroyLR"> clearAndDestroy() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clearAndDestroy();</tt>
<dt><br>Semantics:
<dd>The<tt> clearAndDestroy</tt> public member function is used to clear the dictionary and delete the objects pointed to by the
 dictionary elements.&nbsp; The dictionary object is not destroyed and re-created by this function, so the dictionary object
 destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clearAndDestroy</tt> public member function clears the dictionary by deleting the objects pointed to by the dictionary
 elements.
<dt><br>See Also:
<dd><tt> clear</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__containsLR"> contains() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int contains( const Key * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> contains</tt> public member function returns non-zero if an element with the specified key is stored in the dictionary,
 or zero if there is no equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the<tt> Key</tt>
 type.
<dt><br>Results:
<dd>The<tt> contains</tt> public member function returns a non-zero value if the<tt> Key</tt> is found in the dictionary.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> findKeyAndValue</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__entriesLR"> entries() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to return the current number of elements stored in the dictionary.
<dt><br>Results:
<dd>The<tt> entries</tt> public member function returns the number of elements in the dictionary.
<dt><br>See Also:
<dd><tt> isEmpty</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__findLR"> find() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value * find( const Key * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> find</tt> public member function is used to find an element with an equivalent key in the dictionary.&nbsp; If an
 equivalent element is found, a pointer to the element<tt> Value</tt> is returned.&nbsp; Zero is returned if the element is
 not found.&nbsp; Note that equivalence is based on the equivalence operator of the<tt> Key</tt> type.
<dt><br>Results:
<dd>The element equivalent to the passed key is located in the dictionary.
<dt><br>See Also:
<dd><tt> findKeyAndValue</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__findKeyAndValueLR"> findKeyAndValue() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value * findKeyAndValue( const Key *, Key * &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> findKeyAndValue</tt> public member function is used to find an element in the dictionary with an key equivalent to
 the first parameter.&nbsp; If an equivalent element is found, a pointer to the element<tt> Value</tt> is returned.&nbsp;
 The reference to a<tt> Key</tt> passed as the second parameter is assigned the found element's key.&nbsp; Zero is returned
 if the element is not found.&nbsp; Note that equivalence is based on the equivalence operator of the<tt> Key</tt> type.
<dt><br>Results:
<dd>The element equivalent to the passed key is located in the dictionary.
<dt><br>See Also:
<dd><tt> findKeyAndValue</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__forAllLR"> forAll() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void forAll(</tt>
<br><tt> void (*user_fn)( Key *, Value *, void * ),</tt>
<br><tt>void * );</tt>
<dt><br>Semantics:
<dd>The<tt> forAll</tt> public member function causes the user supplied function to be invoked for every key-value pair in the
 dictionary.&nbsp; The user function has the prototype
<br><tt>void user_func( Key * key, Value * value, void * data );</tt>
<br><br>As the elements are visited, the user function is invoked with the<tt> Key</tt> and<tt> Value</tt> components of the
 element passed as the first two parameters.&nbsp; The second parameter of the<tt> forAll</tt> function is passed as the third
 parameter to the user function.&nbsp; This value can be used to pass any appropriate data from the main code to the user
 function.
<dt><br>Results:
<dd>The elements in the dictionary are all visited, with the user function being invoked for each one.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> findKeyAndValue</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__insertLR"> insert() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( Key *, Value * );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function inserts a key and value into the dictionary.&nbsp; If allocation of the node to
 store the key-value pair fails, then the<tt> out_of_memory</tt> exception is thrown if it is enabled.&nbsp; If the exception
 is not enabled, the insert will not be completed.
<dt><br>Results:
<dd>The<tt> insert</tt> public member function inserts a key and value into the dictionary.&nbsp; If the insert is successful,
 a non-zero will returned.&nbsp; A zero will be returned if the insert fails.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__isEmptyLR"> isEmpty() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if the dictionary is empty.
<dt><br>Results:
<dd>The<tt> isEmpty</tt> public member function returns zero if it contains at least one entry, non-zero if the dictionary is
 empty.
<dt><br>See Also:
<dd><tt> entries</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__operator_UVLR"> operator &#91;&#93;() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value * &amp; operator&#91;&#93;( const Key * );</tt>
<dt><br>Semantics:
<dd><tt> operator &#91;&#93;</tt> is the dictionary index operator.&nbsp; A reference to the object stored in the dictionary with
 the given<tt> Key</tt> is returned.&nbsp; If no equivalent element is found, then a new key-value pair is created with the
 specified<tt> Key</tt> value, and initialized with the default constructor.&nbsp; The returned reference can then be assigned
 to, so that insertions can be made with the operator.&nbsp; If an allocation error occurs while inserting a new key-value
 pair, then the<tt> out_of_memory</tt> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, then a
 reference to address zero will be returned.&nbsp; This will result in a run-time error on systems which trap address zero
 references.
<dt><br>Results:
<dd>The<tt> operator &#91;&#93;</tt> public member function returns a reference to the element at the given key value.&nbsp; If
 the key does not exist, a reference to a created element is returned.&nbsp; The result of the operator may be assigned to.
<dt><br>See Also:
<dd><tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value * const &amp; operator&#91;&#93;( const Key * ) const;</tt>
<dt><br>Semantics:
<dd><tt> operator &#91;&#93;</tt> is the dictionary index operator.&nbsp; A constant reference to the object stored in the dictionary
 with the given<tt> Key</tt> is returned.&nbsp; If no equivalent element is found, then the<tt> index_range</tt> exception
 is thrown if it is enabled.&nbsp; If the exception is not enabled, then a reference to address zero will be returned.&nbsp;
 This will result in a run-time error on systems which trap address zero references.
<dt><br>Results:
<dd>The<tt> operator &#91;&#93;</tt> public member function returns a constant reference to the element at the given key value.
&nbsp; The result of the operator may not be assigned to.
<dt><br>See Also:
<dd><tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__operator_ELR"> operator =() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSkipListDict &amp; operator =( const WCPtrSkipListDict &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt>
 class.&nbsp; The left hand side dictionary is first cleared using the<tt> clear</tt> member function, and then the right
 hand side dictionary is copied.&nbsp; The new skip list is created with the same probability and maximum pointers, all values
 or pointers stored in the list, and the exception trap states.&nbsp; If there is not enough memory to copy all of the values
 or pointers in the dictionary, then only some will be copied, and the<tt> out_of_memory</tt> exception is thrown if it is
 enabled.&nbsp; The number of entries will correctly reflect the number copied.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the left hand side dictionary to be a copy of the right hand side.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__operator_EELR"> operator ==() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ==( const WCPtrSkipListDict &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the<tt> WCPtrSkipListDict&lt;Key,Value&gt;</tt>
 class.&nbsp; Two dictionary objects are equivalent if they are the same object and share the same address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side and right hand side dictionary are the same object.&nbsp; A FALSE
 (zero) value is returned otherwise.
</dl>
<h2 id="WCPtrSkipListDictXKey_ValueY__removeLR"> remove() &#91;WCPtrSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value * remove( const Key * );</tt>
<dt><br>Semantics:
<dd>The<tt> remove</tt> public member function is used to remove the specified element from the dictionary.&nbsp; If an equivalent
 element is found, the pointer value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence
 is based on the equivalence operator of the<tt> Key</tt> type.
<dt><br>Results:
<dd>The element is removed from the dictionary if it found.
</dl>
<h2 id="WCPtrSkipListXTypeY__WCPtrSkipListSetXTypeY_Class_Description"> WCPtrSkipList&lt;Type&gt;, WCPtrSkipListSet&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wcskip.h</tt>
<br><tt>WCPtrSkipList&lt;Type&gt;</tt> and<tt> WCPtrSkipListSet&lt;Type&gt;</tt> classes are templated classes used to store
 objects in a skip list.&nbsp; A skip list is a probabilistic alternative to balanced trees, and provides a reasonable performance
 balance to insertion, search, and deletion.&nbsp; A skip list allows more than one copy of an element that is equivalent,
 while the skip list set allows only one copy.&nbsp; The equality operator of the element's type is used to locate the value.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the template parameter defining
 the type of the data pointed to by the pointers stored in the list.
<br><br>Note that pointers to the elements are stored in the list.&nbsp; Destructors are not called on the elements pointed
 to.&nbsp; The data values pointed to in the list should not be changed such that the equivalence to the old value is modified.
<br><br>The iterator classes for skip lists have the same function and operator interface as the hash iterators classes.&nbsp;
 See the chapter on hash iterators for more information.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCPtrSkipList&lt;Type&gt;</tt> and<tt> WCPtrSkipListSet&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCPtrSkipList&lt;Type&gt;</tt> and<tt> WCPtrSkipListSet&lt;Type&gt;</tt> objects.&nbsp; No exceptions
 are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Type</b>
<br><br>The<tt> WCPtrSkipList&lt;Type&gt;</tt> and<tt> WCPtrSkipListSet&lt;Type&gt;</tt> classes requires<tt> Type</tt> to
 have:
<br>A well defined equivalence operator
<br><br>(<tt> int operator ==( const Type &amp; ) const</tt> ).
<br>A well defined less than operator
<br><br>(<tt> int operator &lt;( const Type &amp; ) const</tt> ).
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCPtrSkipList( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</tt>
<br><tt> WCPtrSkipList( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS, void * (*user_alloc)(
 size_t size ), void (*user_dealloc)( void *old, size_t size ) );</tt>
<br><tt> WCPtrSkipList( const WCPtrSkipList &amp; );</tt>
<br><tt> virtual ~WCPtrSkipList();</tt>
<br><tt> WCPtrSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</tt>
<br><tt> WCPtrSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS, void * (*user_alloc)(
 size_t size ), void (*user_dealloc)( void *old, size_t size ) );</tt>
<br><tt> WCPtrSkipListSet( const WCPtrSkipListSet &amp; );</tt>
<br><tt> virtual ~WCPtrSkipListSet();</tt>
<br><tt> void clear();</tt>
<br><tt> void clearAndDestroy();</tt>
<br><tt> int contains( const Type * ) const;</tt>
<br><tt> unsigned entries() const;</tt>
<br><tt> Type * find( const Type * ) const;</tt>
<br><tt> void forAll( void (*user_fn)( Type *, void * ) , void * );</tt>
<br><tt> int insert( Type * );</tt>
<br><tt> int isEmpty() const;</tt>
<br><tt> Type * remove( const Type * );</tt>
<br><br>The following public member functions are available for the<tt> WCPtrSkipList</tt> class only:
<br><br><tt>unsigned occurrencesOf( const Type * ) const;</tt>
<br><tt> unsigned removeAll( const Type * );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>WCPtrSkipList &amp; operator =( const WCPtrSkipList &amp; );</tt>
<br><tt> int operator ==( const WCPtrSkipList &amp; ) const;</tt>
<br><tt> WCPtrSkipListSet &amp; operator =( const WCPtrSkipListSet &amp; );</tt>
<br><tt> int operator ==( const WCPtrSkipListSet &amp; ) const;</tt>
</dl>
<h2 id="WCPtrSkipListSetXTypeY__WCPtrSkipListSetLR"> WCPtrSkipListSet() &#91;WCPtrSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER,</tt>
<br><tt> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSkipListSet&lt;Type&gt;</tt> constructor creates a<tt> WCPtrSkipListSet</tt> object with no entries.&nbsp; The
 first optional parameter, which defaults to the constant<tt> WCSKIPLIST_PROB_QUARTER,</tt> determines the probability of
 having a certain number of pointers in each skip list node.&nbsp; The second optional parameter, which defaults to the constant<tt>
 WCDEFAULT_SKIPLIST_MAX_PTRS,</tt> determines the maximum number of pointers that are allowed in any skip list node.<tt>&nbsp;
 WCDEFAULT_SKIPLIST_MAX_PTRS</tt> is the maximum effective value of the second parameter.&nbsp; If an allocation failure occurs
 while creating the skip list, the<tt> out_of_memory</tt> exception is thrown if the<tt> out_of_memory</tt> exception is enabled.
<dt><br>Results:
<dd>The<tt> WCPtrSkipListSet&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrSkipListSet</tt> object.
<dt><br>See Also:
<dd><tt> ~WCPtrSkipList&lt;Type&gt;</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER,</tt>
<br><tt> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS,</tt>
<br><tt>void * (*user_alloc)( size_t ),</tt>
<br><tt>void (*user_dealloc)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>Allocator and deallocator functions are specified for use when entries are inserted and removed from the list.&nbsp; The semantics
 of this constructor are the same as the constructor without the memory management functions.
<br>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is passed
 the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic that the
 allocation function will always be called with the same size value for any particular instantiation of a skip list.&nbsp;
 To determine the size of the objects that the memory management functions will be required to allocate and free, the following
 macro may be used:
<br><br><tt>WCPtrSkipListSetItemSize( Type, num_of_pointers )</tt>
<dt><br>Results:
<dd>The<tt> WCPtrSkipListSet&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrSkipListSet</tt> object.
<dt><br>See Also:
<dd><tt> ~WCPtrSkipList&lt;Type&gt;</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSkipListSet( const WCPtrSkipListSet &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSkipListSet&lt;Type&gt;</tt> constructor is the copy constructor for the<tt> WCPtrSkipListSet</tt> class.&nbsp;
 The new skip list is created with the same probability and maximum pointers, all values or pointers stored in the list, and
 the exception trap states.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied,
 and the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<tt>
 out_of_memory</tt> exception is thrown if it is enabled.
<dt><br>Results:
<dd>The<tt> WCPtrSkipListSet&lt;Type&gt;</tt> constructor creates a<tt> WCPtrSkipListSet</tt> object which is a copy of the passed
 list.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrSkipListSetXTypeY____WCPtrSkipListSetLR"> ~WCPtrSkipListSet() &#91;WCPtrSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCPtrSkipListSet();</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSkipListSet&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCPtrSkipListSet</tt> class.&nbsp; If the
 number of elements is not zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise,
 the list elements are cleared using the<tt> clear</tt> member function.&nbsp; The objects which the list elements point to
 are not deleted unless the<tt> clearAndDestroy</tt> member function is explicitly called before the destructor is called.
&nbsp; The call to the<tt> WCPtrSkipListSet&lt;Type&gt;</tt> destructor is inserted implicitly by the compiler at the point
 where the<tt> WCPtrSkipListSet</tt> object goes out of scope.
<dt><br>Results:
<dd>The call to the<tt> WCPtrSkipListSet&lt;Type&gt;</tt> destructor destroys a<tt> WCPtrSkipListSet</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCPtrSkipListXTypeY__WCPtrSkipListLR"> WCPtrSkipList() &#91;WCPtrSkipList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSkipList( unsigned = WCSKIPLIST_PROB_QUARTER,</tt>
<br><tt> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSkipList&lt;Type&gt;</tt> constructor creates a<tt> WCPtrSkipList</tt> object with no entries.&nbsp; The first
 optional parameter, which defaults to the constant<tt> WCSKIPLIST_PROB_QUARTER,</tt> determines the probability of having
 a certain number of pointers in each skip list node.&nbsp; The second optional parameter, which defaults to the constant<tt>
 WCDEFAULT_SKIPLIST_MAX_PTRS,</tt> determines the maximum number of pointers that are allowed in any skip list node.<tt>&nbsp;
 WCDEFAULT_SKIPLIST_MAX_PTRS</tt> is the maximum effective value of the second parameter.&nbsp; If an allocation failure occurs
 while creating the skip list, the<tt> out_of_memory</tt> exception is thrown if the<tt> out_of_memory</tt> exception is enabled.
<dt><br>Results:
<dd>The<tt> WCPtrSkipList&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrSkipList</tt> object.
<dt><br>See Also:
<dd><tt> ~WCPtrSkipList&lt;Type&gt;</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSkipList( unsigned = WCSKIPLIST_PROB_QUARTER,</tt>
<br><tt> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS,</tt>
<br><tt>void * (*user_alloc)( size_t ),</tt>
<br><tt>void (*user_dealloc)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>Allocator and deallocator functions are specified for use when entries are inserted and removed from the list.&nbsp; The semantics
 of this constructor are the same as the constructor without the memory management functions.
<br>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is passed
 the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic that the
 allocation function will always be called with the same size value for any particular instantiation of a skip list.&nbsp;
 To determine the size of the objects that the memory management functions will be required to allocate and free, the following
 macro may be used:
<br><br><tt>WCPtrSkipListItemSize( Type, num_of_pointers )</tt>
<dt><br>Results:
<dd>The<tt> WCPtrSkipList&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrSkipList</tt> object.
<dt><br>See Also:
<dd><tt> ~WCPtrSkipList&lt;Type&gt;</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSkipList( const WCPtrSkipList &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSkipList&lt;Type&gt;</tt> constructor is the copy constructor for the<tt> WCPtrSkipList</tt> class.&nbsp; The
 new skip list is created with the same probability and maximum pointers, all values or pointers stored in the list, and the
 exception trap states.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied, and
 the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<tt>
 out_of_memory</tt> exception is thrown if it is enabled.
<dt><br>Results:
<dd>The<tt> WCPtrSkipList&lt;Type&gt;</tt> constructor creates a<tt> WCPtrSkipList</tt> object which is a copy of the passed list.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrSkipListXTypeY____WCPtrSkipListLR"> ~WCPtrSkipList() &#91;WCPtrSkipList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCPtrSkipList();</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSkipList&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCPtrSkipList</tt> class.&nbsp; If the number
 of elements is not zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise, the list
 elements are cleared using the<tt> clear</tt> member function.&nbsp; The objects which the list elements point to are not
 deleted unless the<tt> clearAndDestroy</tt> member function is explicitly called before the destructor is called.&nbsp; The
 call to the<tt> WCPtrSkipList&lt;Type&gt;</tt> destructor is inserted implicitly by the compiler at the point where the<tt>
 WCPtrSkipList</tt> object goes out of scope.
<dt><br>Results:
<dd>The call to the<tt> WCPtrSkipList&lt;Type&gt;</tt> destructor destroys a<tt> WCPtrSkipList</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCPtrSkipListXTypeY__clearLR__WCPtrSkipListSetXTypeY__clearLR"> clear() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the list so that it has no entries.&nbsp; Objects pointed to by
 the list elements are not deleted.&nbsp; The list object is not destroyed and re-created by this function, so the object
 destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function clears the list to have no elements.
<dt><br>See Also:
<dd><tt> ~WCPtrSkipList&lt;Type&gt;</tt>,<tt> clearAndDestroy</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCPtrSkipListXTypeY_WCPtrSkipListSetXTypeY__clearAndDestroyLR"> clearAndDestroy() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clearAndDestroy();</tt>
<dt><br>Semantics:
<dd>The<tt> clearAndDestroy</tt> public member function is used to clear the list and delete the objects pointed to by the list
 elements.&nbsp; The list object is not destroyed and re-created by this function, so the list object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clearAndDestroy</tt> public member function clears the list by deleting the objects pointed to by the list elements,
 and then removing the list elements from the list.
<dt><br>See Also:
<dd><tt> clear</tt>
</dl>
<h2 id="WCPtrSkipListXTypeY__containsLR__WCPtrSkipListSetXTypeY__containsLR"> contains() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int contains( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> contains</tt> public member function returns non-zero if the element is stored in the list, or zero if there is no
 equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The<tt> contains</tt> public member function returns a non-zero value if the element is found in the list.
<dt><br>See Also:
<dd><tt> find</tt>
</dl>
<h2 id="WCPtrSkipListXTypeY__entriesLR__WCPtrSkipListSetXTypeY__entriesLR"> entries() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to return the current number of elements stored in the list.
<dt><br>Results:
<dd>The<tt> entries</tt> public member function returns the number of elements in the list.
<dt><br>See Also:
<dd><tt> isEmpty</tt>
</dl>
<h2 id="WCPtrSkipListXTypeY__findLR__WCPtrSkipListSetXTypeY__findLR"> find() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * find( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> find</tt> public member function is used to find an element with an equivalent value in the list.&nbsp; If an equivalent
 element is found, a pointer to the element is returned.&nbsp; Zero is returned if the element is not found.&nbsp; Note that
 equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The element equivalent to the passed value is located in the list.
</dl>
<h2 id="WCPtrSkipListXTypeY__forAllLR__WCPtrSkipListSetXTypeY__forAllLR"> forAll() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void forAll(</tt>
<br><tt> void (*user_fn)( Type *, void * ),</tt>
<br><tt>void * );</tt>
<dt><br>Semantics:
<dd>The<tt> forAll</tt> public member function causes the user supplied function to be invoked for every value in the list.&nbsp;
 The user function has the prototype
<br><tt>void user_func( Type * value, void * data );</tt>
<br><br>As the elements are visited, the user function is invoked with the element passed as the first.&nbsp; The second parameter
 of the<tt> forAll</tt> function is passed as the second parameter to the user function.&nbsp; This value can be used to pass
 any appropriate data from the main code to the user function.
<dt><br>Results:
<dd>The elements in the list are all visited, with the user function being invoked for each one.
<dt><br>See Also:
<dd><tt> find</tt>
</dl>
<h2 id="WCPtrSkipListXTypeY__insertLR__WCPtrSkipListSetXTypeY__insertLR"> insert() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function inserts a value into the list.&nbsp; If allocation of the node to store the value
 fails, then the<tt> out_of_memory</tt> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert
 will not be completed.
<br>With a<tt> WCPtrSkipListSet,</tt> there must be only one equivalent element in the set.&nbsp; If an element equivalent
 to the inserted element is already in the list set, the list set will remain unchanged, and the<tt> not_unique</tt> exception
 is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not be completed.
<dt><br>Results:
<dd>The<tt> insert</tt> public member function inserts a value into the list.&nbsp; If the insert is successful, a non-zero will
 returned.&nbsp; A zero will be returned if the insert fails.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCExcept::not_unique</tt>
</dl>
<h2 id="WCPtrSkipListXTypeY__isEmptyLR__WCPtrSkipListSetXTypeY__isEmptyLR"> isEmpty() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if the list is empty.
<dt><br>Results:
<dd>The<tt> isEmpty</tt> public member function returns zero if it contains at least one entry, non-zero if the list is empty.
<dt><br>See Also:
<dd><tt> entries</tt>
</dl>
<h2 id="WCPtrSkipListXTypeY__occurrencesOfLR"> occurrencesOf() &#91;WCPtrSkipList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned occurrencesOf( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> occurrencesOf</tt> public member function is used to return the current number of elements stored in the list which
 are equivalent to the passed value.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The<tt> occurrencesOf</tt> public member function returns the number of elements in the list which are equivalent to the passed
 value.
<dt><br>See Also:
<dd><tt> entries</tt>,<tt> find</tt>,<tt> isEmpty</tt>
</dl>
<h2 id="WCPtrSkipListXTypeY__operator_ELR__WCPtrSkipListSetXTypeY__operator_ELR"> operator =() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSkipList &amp; operator =( const WCPtrSkipList &amp; );</tt>
<br><tt> WCPtrSkipListSet &amp; operator =( const WCPtrSkipListSet &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the<tt> WCPtrSkipList&lt;Type&gt;</tt> and<tt>
 WCPtrSkipListSet&lt;Type&gt;</tt> classes.&nbsp; The left hand side list is first cleared using the<tt> clear</tt> member
 function, and then the right hand side list is copied.&nbsp; The list function, exception trap states, and all of the list
 elements are copied.&nbsp; If there is not enough memory to copy all of the values or pointers in the list, then only some
 will be copied, and the<tt> out_of_memory</tt> exception is thrown if it is enabled.&nbsp; The number of entries will correctly
 reflect the number copied.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the left hand side list to be a copy of the right hand side.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrSkipListXTypeY__operator_EELR__WCPtrSkipListSetXTypeY__operator_EELR"> operator ==() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ==( const WCPtrSkipList &amp; ) const;</tt>
<br><tt> int operator ==( const WCPtrSkipListSet &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the<tt> WCPtrSkipList&lt;Type&gt;</tt> and<tt>
 WCPtrSkipListSet&lt;Type&gt;</tt> classes.&nbsp; Two list objects are equivalent if they are the same object and share the
 same address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side and right hand side list are the same object.&nbsp; A FALSE (zero)
 value is returned otherwise.
</dl>
<h2 id="WCPtrSkipListXTypeY__removeLR__WCPtrSkipListSetXTypeY__removeLR"> remove() &#91;WCPtrSkipList&lt;Type&gt;,WCPtrSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * remove( const Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> remove</tt> public member function is used to remove the specified element from the list.&nbsp; If an equivalent element
 is found, the pointer value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; If the list is a<tt> WCPtrSkipList</tt>
 and there is more than one element equivalent to the specified element, then the last equivalent element added to the<tt>
 WCPtrSkipList</tt> is removed.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The element is removed from the list.
</dl>
<h2 id="WCPtrSkipListXTypeY__removeAllLR"> removeAll() &#91;WCPtrSkipList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned removeAll( const Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> removeAll</tt> public member function is used to remove all elements equivalent to the specified element from the
 list.&nbsp; Zero is returned if no equivalent elements are found.&nbsp; Note that equivalence is based on the equivalence
 operator of the element type.
<dt><br>Results:
<dd>All equivalent elements are removed from the list.
</dl>
<h2 id="WCValSkipListDictXKey_ValueY_Class_Description"> WCValSkipListDict&lt;Key,Value&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wcskip.h</tt>
<br>The<tt> WCValSkipListDict&lt;Key,Value&gt;</tt> class is a templated class used to store objects in a dictionary.&nbsp;
 Dictionaries store values with an associated key, which may be of any type.&nbsp; One example of a dictionary used in everyday
 life is the phone book.&nbsp; The phone numbers are the data values, and the customer name is the key.&nbsp; The equality
 operator of the key's type is used to locate the key-value pairs.
<br>In the description of each member function, the text<tt> Key</tt> is used to indicate the template parameter defining
 the type of the indices used to store data in the dictionary.&nbsp; The text<tt> Value</tt> is used to indicate the template
 parameter defining the type of the data stored in the dictionary.
<br><br>Values are copied into the dictionary, which could be undesirable if the stored objects are complicated and copying
 is expensive.&nbsp; Value dictionaries should not be used to store objects of a base class if any derived types of different
 sizes would be stored in the dictionary, or if the destructor for a derived class must be called.
<br><br>The iterator classes for skip lists have the same function and operator interface as the hash iterators classes.&nbsp;
 See the chapter on hash iterators for more information.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCValSkipListDict&lt;Key,Value&gt;</tt> class and provides
 the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can be thrown by the<tt>
 WCValSkipListDict&lt;Key,Value&gt;</tt> object.&nbsp; No exceptions are enabled unless they are set by the<tt> exceptions</tt>
 member function.
<br><br><b>Requirements of Key and Value</b>
<br><br>The<tt> WCValSkipListDict&lt;Key,Value&gt;</tt> class requires<tt> Key</tt> to have:
<br>A default constructor (<tt> Key::Key()</tt> ).
<br><br>A well defined copy constructor (<tt> Key::Key( const Key &amp; )</tt> ).
<br><br>A well defined assignment operator (<tt> Key &amp; operator =( const Key &amp; )</tt> ).
<br><br>A well defined equivalence operator with constant parameters
<br><br>(<tt> int operator ==( const Key &amp; ) const</tt> ).
<br>A well defined operator less than with constant parameters
<br><br>(<tt> int operator &lt;( const Key &amp; ) const</tt> ).
<br>The<tt> WCValSkipListDict&lt;Key,Value&gt;</tt> class requires<tt> Value</tt> to have:
<br><br>A default constructor (<tt> Value::Value()</tt> ).
<br><br>A well defined copy constructor (<tt> Value::Value( const Value &amp; )</tt> ).
<br><br>A well defined assignment operator (<tt> Value &amp; operator =( const Value &amp; )</tt> ).
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCValSkipListDict( unsigned = WCSkipListDict_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</tt>
<br><tt> WCValSkipListDict( unsigned = WCSkipListDict_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS, void * (*user_alloc)(
 size_t size ), void (*user_dealloc)( void *old, size_t size ) );</tt>
<br><tt> WCValSkipListDict( const WCValSkipListDict &amp; );</tt>
<br><tt> virtual ~WCValSkipListDict();</tt>
<br><tt> void clear();</tt>
<br><tt> int contains( const Key &amp; ) const;</tt>
<br><tt> unsigned entries() const;</tt>
<br><tt> int find( const Key &amp;, Value &amp; ) const;</tt>
<br><tt> int findKeyAndValue( const Key &amp;, Key &amp;, Value &amp; ) const;</tt>
<br><tt> void forAll( void (*user_fn)( Key, Value, void * ), void * );</tt>
<br><tt> int insert( const Key &amp;, const Value &amp; );</tt>
<br><tt> int isEmpty() const;</tt>
<br><tt> int remove( const Key &amp; );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>Value &amp; operator &#91;&#93;( const Key &amp; );</tt>
<br><tt> const Value &amp; operator &#91;&#93;( const Key &amp; ) const;</tt>
<br><tt> WCValSkipListDict &amp; operator =( const WCValSkipListDict &amp; );</tt>
<br><tt> int operator ==( const WCValSkipListDict &amp; ) const;</tt>
</dl>
<h2 id="WCValSkipListDictXKey_ValueY__WCValSkipListDictLR"> WCValSkipListDict() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSkipListDict( unsigned = WCSKIPLIST_PROB_QUARTER,</tt>
<br><tt> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCValSkipListDict&lt;Key,Value&gt;</tt> constructor creates an<tt> WCValSkipListDict&lt;Key,Value&gt;</tt>
 object with no entries.&nbsp; The first optional parameter, which defaults to the constant<tt> WCSKIPLIST_PROB_QUARTER,</tt>
 determines the probability of having a certain number of pointers in each skip list node.&nbsp; The second optional parameter,
 which defaults to the constant<tt> WCDEFAULT_SKIPLIST_MAX_PTRS,</tt> determines the maximum number of pointers that are allowed
 in any skip list node.<tt>&nbsp; WCDEFAULT_SKIPLIST_MAX_PTRS</tt> is the maximum effective value of the second parameter.
&nbsp; If an allocation failure occurs while creating the skip list, the<tt> out_of_memory</tt> exception is thrown if the<tt>
 out_of_memory</tt> exception is enabled.
<dt><br>Results:
<dd>The public<tt> WCValSkipListDict&lt;Key,Value&gt;</tt> constructor creates an initialized<tt> WCValSkipListDict&lt;Key,Value&gt;</tt>
 object.
<dt><br>See Also:
<dd><tt> ~WCValSkipListDict&lt;Key,Value&gt;</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSkipListDict( unsigned = WCSKIPLIST_PROB_QUARTER,</tt>
<br><tt> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS,</tt>
<br><tt>void * (*user_alloc)( size_t ),</tt>
<br><tt>void (*user_dealloc)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>Allocator and deallocator functions are specified for use when entries are inserted and removed from the list dictionary.
&nbsp; The semantics of this constructor are the same as the constructor without the memory management functions.
<br>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is passed
 the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic that the
 allocation function will always be called with the same size value for any particular instantiation of a list dictionary.
&nbsp; To determine the size of the objects that the memory management functions will be required to allocate and free, the
 following macro may be used:
<br><br><tt>WCValSkipListDictItemSize( Key, Value, num_of_pointers )</tt>
<dt><br>Results:
<dd>The public<tt> WCValSkipListDict&lt;Key,Value&gt;</tt> constructor creates an initialized<tt> WCValSkipListDict&lt;Key,Value&gt;</tt>
 object.
<dt><br>See Also:
<dd><tt> ~WCValSkipListDict&lt;Key,Value&gt;</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSkipListDict( const WCValSkipListDict &amp; );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCValSkipListDict&lt;Key,Value&gt;</tt> constructor is the copy constructor for the<tt> WCValSkipListDict&lt;Key,Value&gt;</tt>
 class.&nbsp; The new skip list is created with the same probability and maximum pointers, all values or pointers stored in
 the list, and the exception trap states.&nbsp; If there is not enough memory to copy all of the values, then only some will
 be copied, and the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied,
 then the<tt> out_of_memory</tt> exception is thrown if it is enabled.
<dt><br>Results:
<dd>The public<tt> WCValSkipListDict&lt;Key,Value&gt;</tt> constructor creates an<tt> WCValSkipListDict&lt;Key,Value&gt;</tt>
 object which is a copy of the passed dictionary.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValSkipListDictXKey_ValueY____WCValSkipListDictLR"> ~WCValSkipListDict() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCValSkipListDict();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCValSkipListDict&lt;Key,Value&gt;</tt> destructor is the destructor for the<tt> WCValSkipListDict&lt;Key,Value&gt;</tt>
 class.&nbsp; If the number of dictionary elements is not zero and the<tt> not_empty</tt> exception is enabled, the exception
 is thrown.&nbsp; Otherwise, the dictionary elements are cleared using the<tt> clear</tt> member function.&nbsp; The call
 to the public<tt> ~WCValSkipListDict&lt;Key,Value&gt;</tt> destructor is inserted implicitly by the compiler at the point
 where the<tt> WCValSkipListDict&lt;Key,Value&gt;</tt> object goes out of scope.
<dt><br>Results:
<dd>The public<tt> ~WCValSkipListDict&lt;Key,Value&gt;</tt> destructor destroys an<tt> WCValSkipListDict&lt;Key,Value&gt;</tt>
 object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCValSkipListDictXKey_ValueY__clearLR"> clear() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the dictionary so that it has no entries.&nbsp; Elements stored
 in the dictionary are destroyed using the destructors of<tt> Key</tt> and of<tt> Value.</tt>&nbsp; The dictionary object
 is not destroyed and re-created by this function, so the object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function clears the dictionary to have no elements.
<dt><br>See Also:
<dd><tt> ~WCValSkipListDict&lt;Key,Value&gt;</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCValSkipListDictXKey_ValueY__containsLR"> contains() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int contains( const Key &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> contains</tt> public member function returns non-zero if an element with the specified key is stored in the dictionary,
 or zero if there is no equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the<tt> Key</tt>
 type.
<dt><br>Results:
<dd>The<tt> contains</tt> public member function returns a non-zero value if the<tt> Key</tt> is found in the dictionary.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> findKeyAndValue</tt>
</dl>
<h2 id="WCValSkipListDictXKey_ValueY__entriesLR"> entries() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to return the current number of elements stored in the dictionary.
<dt><br>Results:
<dd>The<tt> entries</tt> public member function returns the number of elements in the dictionary.
<dt><br>See Also:
<dd><tt> isEmpty</tt>
</dl>
<h2 id="WCValSkipListDictXKey_ValueY__findLR"> find() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int find( const Key &amp;, Value &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> find</tt> public member function is used to find an element with an equivalent key in the dictionary.&nbsp; If an
 equivalent element is found, a non-zero value is returned.&nbsp; The reference to a<tt> Value</tt> passed as the second argument
 is assigned the found element's<tt> Value.</tt>&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence
 is based on the equivalence operator of the<tt> Key</tt> type.
<dt><br>Results:
<dd>The element equivalent to the passed key is located in the dictionary.
<dt><br>See Also:
<dd><tt> findKeyAndValue</tt>
</dl>
<h2 id="WCValSkipListDictXKey_ValueY__findKeyAndValueLR"> findKeyAndValue() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int findKeyAndValue( const Key &amp;,</tt>
<br><tt> Key &amp;, Value &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> findKeyAndValue</tt> public member function is used to find an element in the dictionary with an key equivalent to
 the first parameter.&nbsp; If an equivalent element is found, a non-zero value is returned.&nbsp; The reference to a<tt>
 Key</tt> passed as the second parameter is assigned the found element's key.&nbsp; The reference to a<tt> Value</tt> passed
 as the third argument is assigned the found element's<tt> Value.</tt>&nbsp; Zero is returned if the element is not found.
&nbsp; Note that equivalence is based on the equivalence operator of the<tt> Key</tt> type.
<dt><br>Results:
<dd>The element equivalent to the passed key is located in the dictionary.
<dt><br>See Also:
<dd><tt> findKeyAndValue</tt>
</dl>
<h2 id="WCValSkipListDictXKey_ValueY__forAllLR"> forAll() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void forAll(</tt>
<br><tt> void (*user_fn)( Key, Value, void * ),</tt>
<br><tt>void * );</tt>
<dt><br>Semantics:
<dd>The<tt> forAll</tt> public member function causes the user supplied function to be invoked for every key-value pair in the
 dictionary.&nbsp; The user function has the prototype
<br><tt>void user_func( Key key, Value value, void * data );</tt>
<br><br>As the elements are visited, the user function is invoked with the<tt> Key</tt> and<tt> Value</tt> components of the
 element passed as the first two parameters.&nbsp; The second parameter of the<tt> forAll</tt> function is passed as the third
 parameter to the user function.&nbsp; This value can be used to pass any appropriate data from the main code to the user
 function.
<dt><br>Results:
<dd>The elements in the dictionary are all visited, with the user function being invoked for each one.
<dt><br>See Also:
<dd><tt> find</tt>,<tt> findKeyAndValue</tt>
</dl>
<h2 id="WCValSkipListDictXKey_ValueY__insertLR"> insert() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( const Key &amp;, const Value &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function inserts a key and value into the dictionary.&nbsp; If allocation of the node to
 store the key-value pair fails, then the<tt> out_of_memory</tt> exception is thrown if it is enabled.&nbsp; If the exception
 is not enabled, the insert will not be completed.
<dt><br>Results:
<dd>The<tt> insert</tt> public member function inserts a key and value into the dictionary.&nbsp; If the insert is successful,
 a non-zero will returned.&nbsp; A zero will be returned if the insert fails.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValSkipListDictXKey_ValueY__isEmptyLR"> isEmpty() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if the dictionary is empty.
<dt><br>Results:
<dd>The<tt> isEmpty</tt> public member function returns zero if it contains at least one entry, non-zero if the dictionary is
 empty.
<dt><br>See Also:
<dd><tt> entries</tt>
</dl>
<h2 id="WCValSkipListDictXKey_ValueY__operator_UVLR"> operator &#91;&#93;() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Value &amp; operator&#91;&#93;( const Key &amp; );</tt>
<dt><br>Semantics:
<dd><tt> operator &#91;&#93;</tt> is the dictionary index operator.&nbsp; A reference to the object stored in the dictionary with
 the given<tt> Key</tt> is returned.&nbsp; If no equivalent element is found, then a new key-value pair is created with the
 specified<tt> Key</tt> value, and initialized with the default constructor.&nbsp; The returned reference can then be assigned
 to, so that insertions can be made with the operator.&nbsp; If an allocation error occurs while inserting a new key-value
 pair, then the<tt> out_of_memory</tt> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, then a
 reference to address zero will be returned.&nbsp; This will result in a run-time error on systems which trap address zero
 references.
<dt><br>Results:
<dd>The<tt> operator &#91;&#93;</tt> public member function returns a reference to the element at the given key value.&nbsp; If
 the key does not exist, a reference to a created element is returned.&nbsp; The result of the operator may be assigned to.
<dt><br>See Also:
<dd><tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>const Value &amp; operator&#91;&#93;( const Key &amp; ) const;</tt>
<dt><br>Semantics:
<dd><tt> operator &#91;&#93;</tt> is the dictionary index operator.&nbsp; A constant reference to the object stored in the dictionary
 with the given<tt> Key</tt> is returned.&nbsp; If no equivalent element is found, then the<tt> index_range</tt> exception
 is thrown if it is enabled.&nbsp; If the exception is not enabled, then a reference to address zero will be returned.&nbsp;
 This will result in a run-time error on systems which trap address zero references.
<dt><br>Results:
<dd>The<tt> operator &#91;&#93;</tt> public member function returns a constant reference to the element at the given key value.
&nbsp; The result of the operator may not be assigned to.
<dt><br>See Also:
<dd><tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCValSkipListDictXKey_ValueY__operator_ELR"> operator =() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSkipListDict &amp; operator =( const WCValSkipListDict &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the<tt> WCValSkipListDict&lt;Key,Value&gt;</tt>
 class.&nbsp; The left hand side dictionary is first cleared using the<tt> clear</tt> member function, and then the right
 hand side dictionary is copied.&nbsp; The new skip list is created with the same probability and maximum pointers, all values
 or pointers stored in the list, and the exception trap states.&nbsp; If there is not enough memory to copy all of the values
 or pointers in the dictionary, then only some will be copied, and the<tt> out_of_memory</tt> exception is thrown if it is
 enabled.&nbsp; The number of entries will correctly reflect the number copied.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the left hand side dictionary to be a copy of the right hand side.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValSkipListDictXKey_ValueY__operator_EELR"> operator ==() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ==( const WCValSkipListDict &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the<tt> WCValSkipListDict&lt;Key,Value&gt;</tt>
 class.&nbsp; Two dictionary objects are equivalent if they are the same object and share the same address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side and right hand side dictionary are the same object.&nbsp; A FALSE
 (zero) value is returned otherwise.
</dl>
<h2 id="WCValSkipListDictXKey_ValueY__removeLR"> remove() &#91;WCValSkipListDict&lt;Key,Value&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int remove( const Key &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> remove</tt> public member function is used to remove the specified element from the dictionary.&nbsp; If an equivalent
 element is found, a non-zero value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence
 is based on the equivalence operator of the<tt> Key</tt> type.
<dt><br>Results:
<dd>The element is removed from the dictionary if it found.
</dl>
<h2 id="WCValSkipListXTypeY__WCValSkipListSetXTypeY_Class_Description"> WCValSkipList&lt;Type&gt;, WCValSkipListSet&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wcskip.h</tt>
<br><tt>WCValSkipList&lt;Type&gt;</tt> and<tt> WCValSkipListSet&lt;Type&gt;</tt> classes are templated classes used to store
 objects in a skip list.&nbsp; A skip list is a probabilistic alternative to balanced trees, and provides a reasonable performance
 balance to insertion, search, and deletion.&nbsp; A skip list allows more than one copy of an element that is equivalent,
 while the skip list set allows only one copy.&nbsp; The equality operator of the element's type is used to locate the value.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the template parameter defining
 the type of the data to be stored in the list.
<br><br>Values are copied into the list, which could be undesirable if the stored objects are complicated and copying is expensive.
&nbsp; Value skip lists should not be used to store objects of a base class if any derived types of different sizes would
 be stored in the list, or if the destructor for a derived class must be called.
<br><br>The iterator classes for skip lists have the same function and operator interface as the hash iterators classes.&nbsp;
 See the chapter on hash iterators for more information.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCValSkipList&lt;Type&gt;</tt> and<tt> WCValSkipListSet&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCValSkipList&lt;Type&gt;</tt> and<tt> WCValSkipListSet&lt;Type&gt;</tt> objects.&nbsp; No exceptions
 are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Type</b>
<br><br>The<tt> WCValSkipList&lt;Type&gt;</tt> and<tt> WCValSkipListSet&lt;Type&gt;</tt> classes requires<tt> Type</tt> to
 have:
<br>A default constructor (<tt> Type::Type()</tt> ).
<br><br>A well defined copy constructor (<tt> Type::Type( const Type &amp; )</tt> ).
<br><br>A well defined equivalence operator
<br><br>(<tt> int operator ==( const Type &amp; ) const</tt> ).
<br>A well defined less than operator
<br><br>(<tt> int operator &lt;( const Type &amp; ) const</tt> ).
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCValSkipList( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</tt>
<br><tt> WCValSkipList( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS, void * (*user_alloc)(
 size_t size ), void (*user_dealloc)( void *old, size_t size ) );</tt>
<br><tt> WCValSkipList( const WCValSkipList &amp; );</tt>
<br><tt> virtual ~WCValSkipList();</tt>
<br><tt> WCValSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</tt>
<br><tt> WCValSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER, unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS, void * (*user_alloc)(
 size_t size ), void (*user_dealloc)( void *old, size_t size ) );</tt>
<br><tt> WCValSkipListSet( const WCValSkipListSet &amp; );</tt>
<br><tt> virtual ~WCValSkipListSet();</tt>
<br><tt> void clear();</tt>
<br><tt> int contains( const Type &amp; ) const;</tt>
<br><tt> unsigned entries() const;</tt>
<br><tt> int find( const Type &amp;, Type &amp; ) const;</tt>
<br><tt> void forAll( void (*user_fn)( Type, void * ), void * );</tt>
<br><tt> int insert( const Type &amp; );</tt>
<br><tt> int isEmpty() const;</tt>
<br><tt> int remove( const Type &amp; );</tt>
<br><br>The following public member functions are available for the<tt> WCValSkipList</tt> class only:
<br><br><tt>unsigned occurrencesOf( const Type &amp; ) const;</tt>
<br><tt> unsigned removeAll( const Type &amp; );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>WCValSkipList &amp; operator =( const WCValSkipList &amp; );</tt>
<br><tt> int operator ==( const WCValSkipList &amp; ) const;</tt>
<br><tt> WCValSkipListSet &amp; operator =( const WCValSkipListSet &amp; );</tt>
<br><tt> int operator ==( const WCValSkipListSet &amp; ) const;</tt>
</dl>
<h2 id="WCValSkipListSetXTypeY__WCValSkipListSetLR"> WCValSkipListSet() &#91;WCValSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER,</tt>
<br><tt> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSkipListSet&lt;Type&gt;</tt> constructor creates a<tt> WCValSkipListSet</tt> object with no entries.&nbsp; The
 first optional parameter, which defaults to the constant<tt> WCSKIPLIST_PROB_QUARTER,</tt> determines the probability of
 having a certain number of pointers in each skip list node.&nbsp; The second optional parameter, which defaults to the constant<tt>
 WCDEFAULT_SKIPLIST_MAX_PTRS,</tt> determines the maximum number of pointers that are allowed in any skip list node.<tt>&nbsp;
 WCDEFAULT_SKIPLIST_MAX_PTRS</tt> is the maximum effective value of the second parameter.&nbsp; If an allocation failure occurs
 while creating the skip list, the<tt> out_of_memory</tt> exception is thrown if the<tt> out_of_memory</tt> exception is enabled.
<dt><br>Results:
<dd>The<tt> WCValSkipListSet&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValSkipListSet</tt> object.
<dt><br>See Also:
<dd><tt> ~WCValSkipList&lt;Type&gt;</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSkipListSet( unsigned = WCSKIPLIST_PROB_QUARTER,</tt>
<br><tt> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS,</tt>
<br><tt>void * (*user_alloc)( size_t ),</tt>
<br><tt>void (*user_dealloc)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>Allocator and deallocator functions are specified for use when entries are inserted and removed from the list.&nbsp; The semantics
 of this constructor are the same as the constructor without the memory management functions.
<br>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is passed
 the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic that the
 allocation function will always be called with the same size value for any particular instantiation of a skip list.&nbsp;
 To determine the size of the objects that the memory management functions will be required to allocate and free, the following
 macro may be used:
<br><br><tt>WCValSkipListSetItemSize( Type, num_of_pointers )</tt>
<dt><br>Results:
<dd>The<tt> WCValSkipListSet&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValSkipListSet</tt> object.
<dt><br>See Also:
<dd><tt> ~WCValSkipList&lt;Type&gt;</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSkipListSet( const WCValSkipListSet &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSkipListSet&lt;Type&gt;</tt> constructor is the copy constructor for the<tt> WCValSkipListSet</tt> class.&nbsp;
 The new skip list is created with the same probability and maximum pointers, all values or pointers stored in the list, and
 the exception trap states.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied,
 and the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<tt>
 out_of_memory</tt> exception is thrown if it is enabled.
<dt><br>Results:
<dd>The<tt> WCValSkipListSet&lt;Type&gt;</tt> constructor creates a<tt> WCValSkipListSet</tt> object which is a copy of the passed
 list.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValSkipListSetXTypeY____WCValSkipListSetLR"> ~WCValSkipListSet() &#91;WCValSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCValSkipListSet();</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSkipListSet&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCValSkipListSet</tt> class.&nbsp; If the
 number of elements is not zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise,
 the list elements are cleared using the<tt> clear</tt> member function.&nbsp; The call to the<tt> WCValSkipListSet&lt;Type&gt;</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> WCValSkipListSet</tt> object goes out of scope.
<dt><br>Results:
<dd>The call to the<tt> WCValSkipListSet&lt;Type&gt;</tt> destructor destroys a<tt> WCValSkipListSet</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCValSkipListXTypeY__WCValSkipListLR"> WCValSkipList() &#91;WCValSkipList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSkipList( unsigned = WCSKIPLIST_PROB_QUARTER,</tt>
<br><tt> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSkipList&lt;Type&gt;</tt> constructor creates a<tt> WCValSkipList</tt> object with no entries.&nbsp; The first
 optional parameter, which defaults to the constant<tt> WCSKIPLIST_PROB_QUARTER,</tt> determines the probability of having
 a certain number of pointers in each skip list node.&nbsp; The second optional parameter, which defaults to the constant<tt>
 WCDEFAULT_SKIPLIST_MAX_PTRS,</tt> determines the maximum number of pointers that are allowed in any skip list node.<tt>&nbsp;
 WCDEFAULT_SKIPLIST_MAX_PTRS</tt> is the maximum effective value of the second parameter.&nbsp; If an allocation failure occurs
 while creating the skip list, the<tt> out_of_memory</tt> exception is thrown if the<tt> out_of_memory</tt> exception is enabled.
<dt><br>Results:
<dd>The<tt> WCValSkipList&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValSkipList</tt> object.
<dt><br>See Also:
<dd><tt> ~WCValSkipList&lt;Type&gt;</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSkipList( unsigned = WCSKIPLIST_PROB_QUARTER,</tt>
<br><tt> unsigned = WCDEFAULT_SKIPLIST_MAX_PTRS,</tt>
<br><tt>void * (*user_alloc)( size_t ),</tt>
<br><tt>void (*user_dealloc)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>Allocator and deallocator functions are specified for use when entries are inserted and removed from the list.&nbsp; The semantics
 of this constructor are the same as the constructor without the memory management functions.
<br>The allocation function must return a zero if it cannot perform the allocation.&nbsp; The deallocation function is passed
 the size as well as the pointer to the data.&nbsp; Your allocation system may take advantage of the characteristic that the
 allocation function will always be called with the same size value for any particular instantiation of a skip list.&nbsp;
 To determine the size of the objects that the memory management functions will be required to allocate and free, the following
 macro may be used:
<br><br><tt>WCValSkipListItemSize( Type, num_of_pointers )</tt>
<dt><br>Results:
<dd>The<tt> WCValSkipList&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValSkipList</tt> object.
<dt><br>See Also:
<dd><tt> ~WCValSkipList&lt;Type&gt;</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSkipList( const WCValSkipList &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSkipList&lt;Type&gt;</tt> constructor is the copy constructor for the<tt> WCValSkipList</tt> class.&nbsp; The
 new skip list is created with the same probability and maximum pointers, all values or pointers stored in the list, and the
 exception trap states.&nbsp; If there is not enough memory to copy all of the values, then only some will be copied, and
 the number of entries will correctly reflect the number copied.&nbsp; If all of the elements cannot be copied, then the<tt>
 out_of_memory</tt> exception is thrown if it is enabled.
<dt><br>Results:
<dd>The<tt> WCValSkipList&lt;Type&gt;</tt> constructor creates a<tt> WCValSkipList</tt> object which is a copy of the passed list.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValSkipListXTypeY____WCValSkipListLR"> ~WCValSkipList() &#91;WCValSkipList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCValSkipList();</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSkipList&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCValSkipList</tt> class.&nbsp; If the number
 of elements is not zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise, the list
 elements are cleared using the<tt> clear</tt> member function.&nbsp; The call to the<tt> WCValSkipList&lt;Type&gt;</tt> destructor
 is inserted implicitly by the compiler at the point where the<tt> WCValSkipList</tt> object goes out of scope.
<dt><br>Results:
<dd>The call to the<tt> WCValSkipList&lt;Type&gt;</tt> destructor destroys a<tt> WCValSkipList</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCValSkipListXTypeY__clearLR__WCValSkipListSetXTypeY__clearLR"> clear() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the list so that it has no entries.&nbsp; Elements stored in the
 list are destroyed using the destructors of<tt> Type.</tt>&nbsp; The list object is not destroyed and re-created by this
 function, so the object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function clears the list to have no elements.
<dt><br>See Also:
<dd><tt> ~WCValSkipList&lt;Type&gt;</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCValSkipListXTypeY__containsLR__WCValSkipListSetXTypeY__containsLR"> contains() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int contains( const Type &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> contains</tt> public member function returns non-zero if the element is stored in the list, or zero if there is no
 equivalent element.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The<tt> contains</tt> public member function returns a non-zero value if the element is found in the list.
<dt><br>See Also:
<dd><tt> find</tt>
</dl>
<h2 id="WCValSkipListXTypeY__entriesLR__WCValSkipListSetXTypeY__entriesLR"> entries() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to return the current number of elements stored in the list.
<dt><br>Results:
<dd>The<tt> entries</tt> public member function returns the number of elements in the list.
<dt><br>See Also:
<dd><tt> isEmpty</tt>
</dl>
<h2 id="WCValSkipListXTypeY__findLR__WCValSkipListSetXTypeY__findLR"> find() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int find( const Type &amp;, Type &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> find</tt> public member function is used to find an element with an equivalent value in the list.&nbsp; If an equivalent
 element is found, a non-zero value is returned.&nbsp; The reference to the element passed as the second argument is assigned
 the found element's value.&nbsp; Zero is returned if the element is not found.&nbsp; Note that equivalence is based on the
 equivalence operator of the element type.
<dt><br>Results:
<dd>The element equivalent to the passed value is located in the list.
</dl>
<h2 id="WCValSkipListXTypeY__forAllLR__WCValSkipListSetXTypeY__forAllLR"> forAll() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void forAll(</tt>
<br><tt> void (*user_fn)( Type, void * ),</tt>
<br><tt>void * );</tt>
<dt><br>Semantics:
<dd>The<tt> forAll</tt> public member function causes the user supplied function to be invoked for every value in the list.&nbsp;
 The user function has the prototype
<br><tt>void user_func( Type &amp; value, void * data );</tt>
<br><br>As the elements are visited, the user function is invoked with the element passed as the first.&nbsp; The second parameter
 of the<tt> forAll</tt> function is passed as the second parameter to the user function.&nbsp; This value can be used to pass
 any appropriate data from the main code to the user function.
<dt><br>Results:
<dd>The elements in the list are all visited, with the user function being invoked for each one.
<dt><br>See Also:
<dd><tt> find</tt>
</dl>
<h2 id="WCValSkipListXTypeY__insertLR__WCValSkipListSetXTypeY__insertLR"> insert() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function inserts a value into the list.&nbsp; If allocation of the node to store the value
 fails, then the<tt> out_of_memory</tt> exception is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert
 will not be completed.
<br>With a<tt> WCValSkipListSet,</tt> there must be only one equivalent element in the set.&nbsp; If an element equivalent
 to the inserted element is already in the list set, the list set will remain unchanged, and the<tt> not_unique</tt> exception
 is thrown if it is enabled.&nbsp; If the exception is not enabled, the insert will not be completed.
<dt><br>Results:
<dd>The<tt> insert</tt> public member function inserts a value into the list.&nbsp; If the insert is successful, a non-zero will
 returned.&nbsp; A zero will be returned if the insert fails.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCExcept::not_unique</tt>
</dl>
<h2 id="WCValSkipListXTypeY__isEmptyLR__WCValSkipListSetXTypeY__isEmptyLR"> isEmpty() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if the list is empty.
<dt><br>Results:
<dd>The<tt> isEmpty</tt> public member function returns zero if it contains at least one entry, non-zero if the list is empty.
<dt><br>See Also:
<dd><tt> entries</tt>
</dl>
<h2 id="WCValSkipListXTypeY__occurrencesOfLR"> occurrencesOf() &#91;WCValSkipList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned occurrencesOf( const Type &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> occurrencesOf</tt> public member function is used to return the current number of elements stored in the list which
 are equivalent to the passed value.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The<tt> occurrencesOf</tt> public member function returns the number of elements in the list which are equivalent to the passed
 value.
<dt><br>See Also:
<dd><tt> entries</tt>,<tt> find</tt>,<tt> isEmpty</tt>
</dl>
<h2 id="WCValSkipListXTypeY__operator_ELR__WCValSkipListSetXTypeY__operator_ELR"> operator =() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSkipList &amp; operator =( const WCValSkipList &amp; );</tt>
<br><tt> WCValSkipListSet &amp; operator =( const WCValSkipListSet &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the<tt> WCValSkipList&lt;Type&gt;</tt> and<tt>
 WCValSkipListSet&lt;Type&gt;</tt> classes.&nbsp; The left hand side list is first cleared using the<tt> clear</tt> member
 function, and then the right hand side list is copied.&nbsp; The list function, exception trap states, and all of the list
 elements are copied.&nbsp; If there is not enough memory to copy all of the values or pointers in the list, then only some
 will be copied, and the<tt> out_of_memory</tt> exception is thrown if it is enabled.&nbsp; The number of entries will correctly
 reflect the number copied.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the left hand side list to be a copy of the right hand side.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValSkipListXTypeY__operator_EELR__WCValSkipListSetXTypeY__operator_EELR"> operator ==() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ==( const WCValSkipList &amp; ) const;</tt>
<br><tt> int operator ==( const WCValSkipListSet &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the<tt> WCValSkipList&lt;Type&gt;</tt> and<tt>
 WCValSkipListSet&lt;Type&gt;</tt> classes.&nbsp; Two list objects are equivalent if they are the same object and share the
 same address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side and right hand side list are the same object.&nbsp; A FALSE (zero)
 value is returned otherwise.
</dl>
<h2 id="WCValSkipListXTypeY__removeLR__WCValSkipListSetXTypeY__removeLR"> remove() &#91;WCValSkipList&lt;Type&gt;,WCValSkipListSet&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int remove( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> remove</tt> public member function is used to remove the specified element from the list.&nbsp; If an equivalent element
 is found, a non-zero value is returned.&nbsp; Zero is returned if the element is not found.&nbsp; If the list is a<tt> WCValSkipList</tt>
 and there is more than one element equivalent to the specified element, then the last equivalent element added to the<tt>
 WCValSkipList</tt> is removed.&nbsp; Note that equivalence is based on the equivalence operator of the element type.
<dt><br>Results:
<dd>The element is removed from the list.
</dl>
<h2 id="WCValSkipListXTypeY__removeAllLR"> removeAll() &#91;WCValSkipList&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcskip.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned removeAll( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> removeAll</tt> public member function is used to remove all elements equivalent to the specified element from the
 list.&nbsp; Zero is returned if no equivalent elements are found.&nbsp; Note that equivalence is based on the equivalence
 operator of the element type.
<dt><br>Results:
<dd>All equivalent elements are removed from the list.
</dl>
<h1 id="Stack_Container"> Stack Container </h1>
<br>Stack containers maintain an ordered collection of data which is retrieved in the reverse order to which the data was
 entered into the stack.&nbsp; The stack class is implemented as a templated class, allowing the stacking of any data type.
<br><br>A second template parameter specifies the storage class used to implement the stack.&nbsp; The<tt> WCValSList, WCIsvSList</tt>
 and<tt> WCPtrSList</tt> classes are appropriate storage classes.
<h2 id="WCStackXType_FTypeY_Class_Description"> WCStack&lt;Type,FType&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wcstack.h</tt>
<br>The<tt> WCStack&lt;Type,FType&gt;</tt> class is a templated class used to create objects which maintain data in a stack.
<br>In the description of each member function, the text<tt> Type</tt> is used to indicate the template parameter defining
 the type of the elements stored in the stack.&nbsp; The text<tt> FType</tt> is used to indicate the template parameter defining
 the storage class used to maintain the stack.
<br><br>For example, to create a stack of integers, the<tt> WCStack&lt;int,WCValSList&lt;int&gt; &gt;</tt> class can be used.
&nbsp; The<tt> WCStack&lt;int *,WCPtrSList&lt;int&gt; &gt;</tt> class will create a stack of pointers to integers.&nbsp; To
 create an intrusive stack of objects of type<b> isv_link</b> (derived from the<tt> WCSLink</tt> class), the<tt> WCStack&lt;</tt><b>
 isv_link</b><tt> *,WCIsvSList&lt;</tt><b> isv_link</b><tt> &gt; &gt;</tt> class can be used.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCStack&lt;Type,FType&gt;</tt> class and provides the<tt> exceptions</tt>
 member function.&nbsp; This member function controls the exceptions which can be thrown by the<tt> WCStack&lt;Type,FType&gt;</tt>
 object.&nbsp; No exceptions are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Type</b>
<br><br><tt>Type</tt> must provide any constructors and/or operators required by the<tt> FType</tt> class.
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCStack();</tt>
<br><tt> WCStack( void *(*)( size_t ), void (*)( void *, size_t ) );</tt>
<br><tt> ~WCStack();</tt>
<br><tt> void clear();</tt>
<br><tt> int entries() const;</tt>
<br><tt> int isEmpty() const;</tt>
<br><tt> Type pop();</tt>
<br><tt> int push( const Type &amp; );</tt>
<br><tt> Type top() const;</tt>
<br><br><b>Sample Program Using a Stack</b>
<br><br><tt>#include &lt;wcstack.h&gt;</tt>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><br><tt>void main() {</tt>
<br><tt>&nbsp;&nbsp;&nbsp; WCStack&lt;int,WCValSList&lt;int&gt; &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stack;</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; stack.push( 7 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; stack.push( 8 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; stack.push( 9 );</tt>
<br><tt>&nbsp;&nbsp;&nbsp; stack.push( 10 );</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;\nNumber of stack entries: &quot; &lt;&lt; stack.entries() &lt;&lt; &quot;\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout &lt;&lt; &quot;Top entry = &#91;&quot; &lt;&lt; stack.top() &lt;&lt; &quot;&#93;\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; while( !stack.isEmpty() ) {</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; stack.pop() &lt;&lt; &quot;\n&quot;;</tt>
<br><tt>&nbsp;&nbsp;&nbsp; };</tt>
<br><tt>&nbsp;&nbsp;&nbsp; cout.flush();</tt>
<br><tt>}</tt>
</dl>
<h2 id="WCStackXType_FTypeY__WCStackLR"> WCStack() &#91;WCStack&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcstack.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCStack();</tt>
<dt><br>Semantics:
<dd>The public<tt> WCStack&lt;Type,FType&gt;</tt> constructor creates an empty<tt> WCStack&lt;Type,FType&gt;</tt> object.&nbsp;
 The<tt> FType</tt> storage class constructor performs the initialization.
<dt><br>Results:
<dd>The public<tt> WCStack&lt;Type,FType&gt;</tt> constructor creates an initialized<tt> WCStack&lt;Type,FType&gt;</tt> object.
<dt><br>See Also:
<dd><tt> ~WCStack&lt;Type,FType&gt;</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcstack.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCStack( void *(*allocator)( size_t ),</tt>
<br><tt> void (*deallocator)( void *, size_t ) );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCStack&lt;Type,FType&gt;</tt> constructor creates an empty<tt> WCStack&lt;Type,FType&gt;</tt> object.&nbsp;
 If<tt> FType</tt> is either the<tt> WCValSList</tt> or<tt> WCPtrSList</tt> class, then the<b> allocator</b> function is registered
 to perform all memory allocations of the stack elements, and the<b> deallocator</b> function to perform all freeing of the
 stack elements' memory.&nbsp; The<b> allocator</b> and<b> deallocator</b> functions are ignored if<tt> FType</tt> is the<tt>
 WCIsvSList</tt> class.&nbsp; These functions provide the ability to control how the allocation and freeing of memory is performed,
 allowing for more efficient memory handling than the general purpose global<tt> operator new()</tt> and<tt> operator delete()</tt>
 can provide.&nbsp; Memory management optimizations may potentially be made through the<b> allocator</b> and<b> deallocator</b>
 functions, but are not recommended before managing memory is understood and determined to be worth while.
<br>The<b> allocator</b> function shall return a pointer to allocated memory of size at least the argument, or zero(0) if
 the allocation cannot be performed.&nbsp; Initialization of the memory returned is performed by the<tt> WCStack&lt;Type,FType&gt;</tt>
 class.
<br><br>The<tt> WCStack&lt;Type,FType&gt;</tt> class calls the<b> deallocator</b> function only on memory allocated by the<b>
 allocator</b> function.&nbsp; The<b> deallocator</b> shall free the memory pointed to by the first argument which is of size
 the second argument.&nbsp; The size passed to the<b> deallocator</b> function is guaranteed to be the same size passed to
 the<b> allocator</b> function when the memory was allocated.
<br><br>The<b> allocator</b> and<b> deallocator</b> functions may assume that for a list object instance, the<b> allocator</b>
 is always called with the same first argument (the size of the memory to be allocated).&nbsp; If<tt> FType</tt> is the<tt>
 WCValSList&lt;Type&gt;</tt> class, then the<tt> WCValSListItemSize(Type)</tt> macro returns the size of the elements which
 are allocated by the<b> allocator</b> function.&nbsp; Similarly, the<tt> WCPtrSListItemSize( Type )</tt> macro returns the
 size of<tt> WCPtrSList&lt;Type&gt;</tt> elements.
<br><br>The<tt> FType</tt> storage class constructor performs the initialization of the stack.
<dt><br>Results:
<dd>The public<tt> WCStack&lt;Type,FType&gt;</tt> constructor creates an initialized<tt> WCStack&lt;Type,FType&gt;</tt> object
 and registers the<b> allocator</b> and<b> deallocator</b> functions.
<dt><br>See Also:
<dd><tt> WCStack&lt;Type,FType&gt;</tt>,<tt> ~WCStack&lt;Type,FType&gt;</tt>
</dl>
<h2 id="WCStackXType_FTypeY____WCStackLR"> ~WCStack() &#91;WCStack&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcstack.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCStack();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCStack&lt;Type,FType&gt;</tt> destructor destroys the<tt> WCStack&lt;Type,FType&gt;</tt> object.&nbsp; The<tt>
 FType</tt> storage class destructor performs the destruction.&nbsp; The call to the public<tt> ~WCStack&lt;Type,FType&gt;</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> WCStack&lt;Type,FType&gt;</tt> object goes out
 of scope.
<br>If the<tt> not_empty</tt> exception is enabled, the exception is thrown if the stack is not empty of stack elements.
<dt><br>Results:
<dd>The<tt> WCStack&lt;Type,FType&gt;</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> WCStack&lt;Type,FType&gt;</tt>,<tt> clear</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCStackXType_FTypeY__clearLR"> clear() &#91;WCStack&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcstack.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the stack object and set it to the state of the object just after
 the initial construction.&nbsp; The stack object is not destroyed and re-created by this operator, so the object destructor
 is not invoked.&nbsp; The stack elements are not cleared by the stack class.&nbsp; However, the class used to maintain the
 stack,<tt> FType,</tt> may clear the items as part of the<tt> clear</tt> member function for that class.&nbsp; If it does
 not clear the items, any stack items still in the list are lost unless pointed to by some pointer object in the program code.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function resets the stack object to the state of the object immediately after the initial
 construction.
<dt><br>See Also:
<dd><tt> ~WCStack&lt;Type,FType&gt;</tt>,<tt> isEmpty</tt>
</dl>
<h2 id="WCStackXType_FTypeY__entriesLR"> entries() &#91;WCStack&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcstack.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to determine the number of stack elements contained in the list object.
<dt><br>Results:
<dd>The number of elements on the stack is returned.&nbsp; Zero(0) is returned if there are no stack elements.
<dt><br>See Also:
<dd><tt> isEmpty</tt>
</dl>
<h2 id="WCStackXType_FTypeY__isEmptyLR"> isEmpty() &#91;WCStack&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcstack.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if a stack object has any stack elements contained in it.
<dt><br>Results:
<dd>A TRUE value (non-zero) is returned if the stack object does not have any stack elements contained within it.&nbsp; A FALSE
 (zero) result is returned if the stack contains at least one element.
<dt><br>See Also:
<dd><tt> entries</tt>
</dl>
<h2 id="WCStackXType_FTypeY__popLR"> pop() &#91;WCStack&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcstack.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type pop();</tt>
<dt><br>Semantics:
<dd>The<tt> pop</tt> public member function returns the top stack element from the stack object.&nbsp; The top stack element is
 the last element pushed onto the stack.&nbsp; The stack element is also removed from the stack.
<br>If the stack is empty, one of two exceptions can be thrown.&nbsp; If the<tt> empty_container</tt> exception is enabled,
 then it will be thrown.&nbsp; Otherwise, the<tt> index_range</tt> exception will be thrown, if enabled.
<dt><br>Results:
<dd>The top stack element is removed and returned.&nbsp; The return value is determined by the<tt> get</tt> member function of
 the<tt> FType</tt> class if there are no elements on the stack.
<dt><br>See Also:
<dd><tt> isEmpty</tt>,<tt> push</tt>,<tt> top</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>,<tt> FType::get</tt>
</dl>
<h2 id="WCStackXType_FTypeY__pushLR"> push() &#91;WCStack&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcstack.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int push( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> push</tt> public member function is used to push the data onto the top of the stack.&nbsp; It will be the first element
 on the stack to be popped.
<br>If the push fails, the<tt> out_of_memory</tt> exception will be thrown, if enabled, and the stack will remain unchanged.
<dt><br>Results:
<dd>The stack element is pushed onto the top of the stack.&nbsp; A TRUE value (non-zero) is returned if the push is successful.
&nbsp; A FALSE (zero) result is returned if the push fails.
<dt><br>See Also:
<dd><tt> pop</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCStackXType_FTypeY__topLR"> top() &#91;WCStack&lt;Type,FType&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcstack.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type top() const;</tt>
<dt><br>Semantics:
<dd>The<tt> top</tt> public member function returns the top stack element from the stack object.&nbsp; The top stack element is
 the last element pushed onto the stack.&nbsp; The stack element is not removed from the stack.
<br>If the stack is empty, one of two exceptions can be thrown.&nbsp; If the<tt> empty_container</tt> exception is enabled,
 then it will be thrown.&nbsp; Otherwise, the<tt> index_range</tt> exception will be thrown, if enabled.
<dt><br>Results:
<dd>The top stack element is returned.&nbsp; The return value is determined by the<tt> find</tt> member function of the<tt> FType</tt>
 class if there are no elements on the stack.
<dt><br>See Also:
<dd><tt> isEmpty</tt>,<tt> pop</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>,<tt> FType::find</tt>
</dl>
<h1 id="Vector_Containers"> Vector Containers </h1>
<br>This chapter describes vector containers.
<h2 id="WCPtrSortedVectorXTypeY__WCPtrOrderedVectorXTypeY_Class_Description"> WCPtrSortedVector&lt;Type&gt;, WCPtrOrderedVector&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wcvector.h</tt>
<br>The<tt> WCPtrSortedVector&lt;Type&gt;</tt> and<tt> WCPtrOrderedVector&lt;Type&gt;</tt> classes are templated classes used
 to store objects in a vector.&nbsp; Ordered and Sorted vectors are powerful arrays which can be resized and provide an abstract
 interface to insert, find and remove elements.&nbsp; An ordered vector maintains the order in which elements are added, and
 allows more than one copy of an element that is equivalent.&nbsp; The sorted vector allow only one copy of an equivalent
 element, and inserts them in a sorted order.&nbsp; The sorted vector is less efficient when inserting elements, but can provide
 a faster retrieval time.
<br>Elements cannot be inserted into these vectors by assigning to a vector index.&nbsp; Vectors automatically grow when necessary
 to insert an element if the<tt> resize_required</tt> exception is not enabled.
<br><br>In the description of each member function, the text<tt> Type</tt> is used to indicate the template parameter defining
 the type pointed to by the pointers stored in the vector.
<br><br>Note that lookups are performed on the types pointed to, not just by comparing pointers.&nbsp; Two pointer elements
 are equivalent if the values they point to are equivalent.&nbsp; The values pointed to do not need to be the same object.
<br><br>The<tt> WCPtrOrderedVector</tt> class stores elements in the order which they are inserted using the<tt> insert, append,
 prepend</tt> and<tt> insertAt</tt> member functions.&nbsp; Linear searches are performed to locate entries, and the less
 than operator is not required.
<br><br>The<tt> WCPtrSortedVector</tt> class stores elements in ascending order.&nbsp; This requires that<tt> Type</tt> provides
 a less than operator.&nbsp; Insertions are more expensive than inserting or appending into an ordered vector, since entries
 must be moved to make room for the new element.&nbsp; A binary search is used to locate elements in a sorted vector, making
 searches quicker than in the ordered vector.
<br><br>Care must be taken when using the<tt> WCPtrSortedVector</tt> class not to change the ordering of the vector elements.
&nbsp; An object pointed to by a vector element must not be changed so that it is not equivalent to the value when the pointer
 was inserted into the vector.&nbsp; The index operator and the member functions<tt> find, first,</tt> and<tt> last</tt> all
 return pointers the elements pointed to by the vector elements.&nbsp; Lookups assume elements are in sorted order, so you
 should not use the returned pointers to change the ordering of the value pointed to.
<br><br>The<tt> WCPtrVector</tt> class is also available.&nbsp; It provides a resizable and boundary safe vector similar to
 standard arrays.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCPtrSortedVector&lt;Type&gt;</tt> and<tt> WCPtrOrderedVector&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCPtrSortedVector&lt;Type&gt;</tt> and<tt> WCPtrOrderedVector&lt;Type&gt;</tt> objects.&nbsp; No exceptions
 are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Type</b>
<br><br>Both the<tt> WCPtrSortedVector&lt;Type&gt;</tt> and<tt> WCPtrOrderedVector&lt;Type&gt;</tt> classes require<tt> Type</tt>
 to have:
<br>A well defined equivalence operator with constant parameters
<br><br>(<tt> int operator ==( const Type &amp; ) const</tt> ).
<br>Additionally the<tt> WCPtrSortedVector</tt> class requires<tt> Type</tt> to have:
<br><br>A well defined less than operator with constant parameters
<br><br>(<tt> int operator &lt;( const Type &amp; ) const</tt> ).
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCPtrOrderedVector( size_t = WCDEFAULT_VECTOR_LENGTH, unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</tt>
<br><tt> WCPtrOrderedVector( const WCPtrOrderedVector &amp; );</tt>
<br><tt> virtual ~WCPtrOrderedVector();</tt>
<br><tt> WCPtrSortedVector( size_t = WCDEFAULT_VECTOR_LENGTH, unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</tt>
<br><tt> WCPtrSortedVector( const WCPtrSortedVector &amp; );</tt>
<br><tt> virtual ~WCPtrSortedVector();</tt>
<br><tt> void clear();</tt>
<br><tt> void clearAndDestroy();</tt>
<br><tt> int contains( const Type * ) const;</tt>
<br><tt> unsigned entries() const;</tt>
<br><tt> Type * find( const Type * ) const;</tt>
<br><tt> Type * first() const;</tt>
<br><tt> int index( const Type * ) const;</tt>
<br><tt> int insert( Type * );</tt>
<br><tt> int isEmpty() const;</tt>
<br><tt> Type * last() const;</tt>
<br><tt> int occurrencesOf( const Type * ) const;</tt>
<br><tt> Type * remove( const Type * );</tt>
<br><tt> unsigned removeAll( const Type * );</tt>
<br><tt> Type * removeAt( int );</tt>
<br><tt> Type * removeFirst();</tt>
<br><tt> Type * removeLast();</tt>
<br><tt> int resize( size_t );</tt>
<br><br>The following public member functions are available for the<tt> WCPtrOrderedVector</tt> class only:
<br><br><tt>int append( Type * );</tt>
<br><tt> int insertAt( int, Type * );</tt>
<br><tt> int prepend( Type * );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>Type * &amp; operator &#91;&#93;( int );</tt>
<br><tt> Type * const &amp; operator &#91;&#93;( int ) const;</tt>
<br><tt> WCPtrOrderedVector &amp; WCPtrOrderedVector::operator =( const WCPtrOrderedVector &amp; );</tt>
<br><tt> WCPtrSortedVector &amp; WCPtrSortedVector::operator =( const WCPtrSortedVector &amp; );</tt>
<br><tt> int WCPtrOrderedVector::operator ==( const WCPtrOrderedVector &amp; ) const;</tt>
<br><tt> int WCPtrSortedVector::operator ==( const WCPtrSortedVector &amp; ) const;</tt>
</dl>
<h2 id="WCPtrOrderedVectorXTypeY__WCPtrOrderedVectorLR"> WCPtrOrderedVector() &#91;WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrOrderedVector( size_t = WCDEFAULT_VECTOR_LENGTH,</tt>
<br><tt> unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrOrderedVector&lt;Type&gt;</tt> constructor creates an empty<tt> WCPtrOrderedVector</tt> object able to store
 the number of elements specified in the first optional parameter, which defaults to the constant<tt> WCDEFAULT_VECTOR_LENGTH</tt>
 (currently defined as 10).&nbsp; If the<tt> resize_required</tt> exception is not enabled, then the second optional parameter
 is used to specify the value to increase the vector size when an element is inserted into a full vector.&nbsp; If zero(0)
 is specified as the second parameter, any attempt to insert into a full vector fails.&nbsp; This parameter defaults to the
 constant<tt> WCDEFAULT_VECTOR_RESIZE_GROW</tt> (currently defined as 5).
<br>If the vector object cannot be fully initialized, the vector is created with length zero.
<dt><br>Results:
<dd>The<tt> WCPtrOrderedVector&lt;Type&gt;</tt> constructor creates an empty initialized<tt> WCPtrOrderedVector</tt> object.
<dt><br>See Also:
<dd><tt> WCExcept::resize_required</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrOrderedVector( const WCPtrOrderedVector &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrOrderedVector&lt;Type&gt;</tt> constructor is the copy constructor for the<tt> WCPtrOrderedVector</tt> class.
&nbsp; The new vector is created with the same length and resize value as the passed vector.&nbsp; All of the vector elements
 and exception trap states are copied.
<br>If the new vector cannot be fully created, it will have length zero.&nbsp; The<tt> out_of_memory</tt> exception is thrown
 if enabled in the vector being copied.
<dt><br>Results:
<dd>The<tt> WCPtrOrderedVector&lt;Type&gt;</tt> creates a<tt> WCPtrOrderedVector</tt> object which is a copy of the passed vector.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrOrderedVectorXTypeY____WCPtrOrderedVectorLR"> ~WCPtrOrderedVector() &#91;WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCPtrOrderedVector();</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrOrderedVector&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCPtrOrderedVector</tt> class.&nbsp;
 If the vector is not length zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise,
 the vector entries are cleared using the<tt> clear</tt> member function.&nbsp; The objects which the vector entries point
 to are not deleted unless the<tt> clearAndDestroy</tt> member function is explicitly called before the destructor is called.
&nbsp; The call to the<tt> WCPtrOrderedVector&lt;Type&gt;</tt> destructor is inserted implicitly by the compiler at the point
 where the<tt> WCPtrOrderedVector</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> WCPtrOrderedVector&lt;Type&gt;</tt> destructor destroys an<tt> WCPtrOrderedVector</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY__WCPtrSortedVectorLR"> WCPtrSortedVector() &#91;WCPtrSortedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSortedVector( size_t = WCDEFAULT_VECTOR_LENGTH,</tt>
<br><tt> unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSortedVector&lt;Type&gt;</tt> constructor creates an empty<tt> WCPtrSortedVector</tt> object able to store the
 number of elements specified in the first optional parameter, which defaults to the constant<tt> WCDEFAULT_VECTOR_LENGTH</tt>
 (currently defined as 10).&nbsp; If the<tt> resize_required</tt> exception is not enabled, then the second optional parameter
 is used to specify the value to increase the vector size when an element is inserted into a full vector.&nbsp; If zero(0)
 is specified as the second parameter, any attempt to insert into a full vector fails.&nbsp; This parameter defaults to the
 constant<tt> WCDEFAULT_VECTOR_RESIZE_GROW</tt> (currently defined as 5).
<br>If the vector object cannot be fully initialized, the vector is created with length zero.
<dt><br>Results:
<dd>The<tt> WCPtrSortedVector&lt;Type&gt;</tt> constructor creates an empty initialized<tt> WCPtrSortedVector</tt> object.
<dt><br>See Also:
<dd><tt> WCExcept::resize_required</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrSortedVector( const WCPtrSortedVector &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSortedVector&lt;Type&gt;</tt> constructor is the copy constructor for the<tt> WCPtrSortedVector</tt> class.&nbsp;
 The new vector is created with the same length and resize value as the passed vector.&nbsp; All of the vector elements and
 exception trap states are copied.
<br>If the new vector cannot be fully created, it will have length zero.&nbsp; The<tt> out_of_memory</tt> exception is thrown
 if enabled in the vector being copied.
<dt><br>Results:
<dd>The<tt> WCPtrSortedVector&lt;Type&gt;</tt> constructor creates a<tt> WCPtrSortedVector</tt> object which is a copy of the
 passed vector.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY____WCPtrSortedVectorLR"> ~WCPtrSortedVector() &#91;WCPtrSortedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCPtrSortedVector();</tt>
<dt><br>Semantics:
<dd>The<tt> WCPtrSortedVector&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCPtrSortedVector</tt> class.&nbsp; If
 the vector is not length zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise,
 the vector entries are cleared using the<tt> clear</tt> member function.&nbsp; The objects which the vector entries point
 to are not deleted unless the<tt> clearAndDestroy</tt> member function is explicitly called before the destructor is called.
&nbsp; The call to the<tt> WCPtrSortedVector&lt;Type&gt;</tt> destructor is inserted implicitly by the compiler at the point
 where the<tt> WCPtrSortedVector</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> WCPtrSortedVector&lt;Type&gt;</tt> destructor destroys an<tt> WCPtrSortedVector</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCPtrOrderedVectorXTypeY__appendLR"> append() &#91;WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int append( Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> append</tt> public member function appends the passed element to be the last element in the vector.&nbsp; This member
 function has the same semantics as the<tt> WCPtrOrderedVector::insert</tt> member function.
<br>This function is not provided by the<tt> WCPtrSortedVector</tt> class, since all elements must be inserted in sorted order
 by the<tt> insert</tt> member function.
<br><br>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<tt> resize_required</tt>
 exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the append fails if the amount the
 vector is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically
 grown by the number of elements specified to the constructor, using the<tt> resize</tt> member function.&nbsp; If<tt> resize</tt>
 fails, the element is not appended to the vector and the<tt> out_of_memory</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> append</tt> public member function appends an element to the<tt> WCPtrOrderedVector</tt> object.&nbsp; A TRUE (non-zero)
 value is returned if the append is successful.&nbsp; If the append fails, a FALSE (zero) value is returned.
<dt><br>See Also:
<dd><tt> insert</tt>,<tt> insertAt</tt>,<tt> prepend</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCExcept::resize_required</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY__clearLR__WCPtrOrderedVectorXTypeY__clearLR"> clear() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the vector so that it contains no entries, and is zero size.&nbsp;
 Objects pointed to by the vector elements are not deleted.&nbsp; The vector object is not destroyed and re-created by this
 function, so the object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function clears the vector to have zero length and no entries.
<dt><br>See Also:
<dd><tt> ~WCPtrOrderedVector</tt>,<tt> clearAndDestroy</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__clearAndDestroyLR"> clearAndDestroy() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clearAndDestroy();</tt>
<dt><br>Semantics:
<dd>The<tt> clearAndDestroy</tt> public member function is used to clear the vector to have zero length and delete the objects
 pointed to by the vector elements.&nbsp; The vector object is not destroyed and re-created by this function, so the vector
 object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clearAndDestroy</tt> public member function clears the vector by deleting the objects pointed to by the vector elements
 and makes the vector zero length.
<dt><br>See Also:
<dd><tt> clear</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__containsLR"> contains() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int contains( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> contains</tt> public member function is used to determine if a value is contained by a vector.&nbsp; Note that comparisons
 are done on the objects pointed to, not the pointers themselves.&nbsp; A linear search is used by the<tt> WCPtrOrderedVector</tt>
 class to find the value.&nbsp; The<tt> WCPtrSortedVector</tt> class uses a binary search.
<dt><br>Results:
<dd>The<tt> contains</tt> public member function returns a TRUE (non-zero) value if the element is found in the vector.&nbsp;
 A FALSE (zero) value is returned if the vector does not contain the element.
<dt><br>See Also:
<dd><tt> index</tt>,<tt> find</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY__entriesLR__WCPtrOrderedVectorXTypeY__entriesLR"> entries() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to find the number of elements which are stored in the vector.
<dt><br>Results:
<dd>The<tt> entries</tt> public member function returns the number of elements in the vector.
<dt><br>See Also:
<dd><tt> isEmpty</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY__findLR__WCPtrOrderedVectorXTypeY__findLR"> find() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * find( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> find</tt> public member function is used to find an element equivalent to the element passed.&nbsp; Note that comparisons
 are done on the objects pointed to, not the pointers themselves.&nbsp; The<tt> WCPtrOrderedVector</tt> class uses a linear
 search to find the element, and the<tt> WCPtrSortedVector</tt> class uses a binary search.
<dt><br>Results:
<dd>A pointer to the first equivalent element is returned.&nbsp; NULL(0) is returned if the element is not in the vector.
<dt><br>See Also:
<dd><tt> contains</tt>,<tt> first</tt>,<tt> index</tt>,<tt> last</tt>,<tt> occurrencesOf</tt>,<tt> remove</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY__firstLR__WCPtrOrderedVectorXTypeY__firstLR"> first() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * first() const;</tt>
<dt><br>Semantics:
<dd>The<tt> first</tt> public member function returns the first element in the vector.&nbsp; The element is not removed from the
 vector.
<br>If the vector is empty, one of two exceptions can be thrown.&nbsp; The<tt> empty_container</tt> exception is thrown if
 it is enabled.&nbsp; Otherwise, if the<tt> index_range</tt> exception is enabled, it is thrown.&nbsp; If neither exception
 is enabled, a first element of the vector is added with a NULL value.
<dt><br>Results:
<dd>The<tt> first</tt> public member function returns the value of the first element in the vector.
<dt><br>See Also:
<dd><tt> last</tt>,<tt> removeFirst</tt>,<tt> WCExcept::index_range</tt>,<tt> WCExcept::resize_required</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY__indexLR__WCPtrOrderedVectorXTypeY__indexLR"> index() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int index( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> index</tt> public member function is used find the index of the first element equivalent to the passed element.&nbsp;
 Note that comparisons are done on the objects pointed to, not the pointers themselves.&nbsp; A linear search is used by the<tt>
 WCPtrOrderedVector</tt> class to find the element.&nbsp; The<tt> WCPtrSortedVector</tt> class uses a binary search.
<dt><br>Results:
<dd>The<tt> index</tt> public member function returns the index of the first element equivalent to the parameter.&nbsp; If the
 passed value is not contained in the vector, negative one (-1) is returned.
<dt><br>See Also:
<dd><tt> contains</tt>,<tt> find</tt>,<tt> insertAt</tt>,<tt> operator &#91;&#93;</tt>,<tt> removeAt</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY__insertLR__WCPtrOrderedVectorXTypeY__insertLR"> insert() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function inserts the value into the vector.
<br>The<tt> WCPtrOrderedVector::insert</tt> function inserts the value as the last element of the vector, and has the same
 semantics as the<tt> WCPtrOrderedVector::append</tt> member function.
<br><br>A binary search is performed to determine where the value should be inserted for the<tt> WCPtrSortedVector::insert</tt>
 function.&nbsp; Note that comparisons are done on the objects pointed to, not the pointers themselves.&nbsp; Any elements
 greater than the inserted value are copied up one index so that the new element is after all elements with value less than
 or equal to it.
<br><br>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<tt> resize_required</tt>
 exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the insert fails if the amount the
 vector is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically
 grown by the number of elements specified to the constructor, using the<tt> resize</tt> member function.&nbsp; If<tt> resize</tt>
 fails, the element is not inserted to the vector and the<tt> out_of_memory</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> insert</tt> public member function inserts an element in to the vector.&nbsp; A TRUE (non-zero) value is returned
 if the insert is successful.&nbsp; If the insert fails, a FALSE (zero) value is returned.
<dt><br>See Also:
<dd><tt> append</tt>,<tt> insertAt</tt>,<tt> prepend</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCExcept::resize_required</tt>
</dl>
<h2 id="WCPtrOrderedVectorXTypeY__insertAtLR"> insertAt() &#91;WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insertAt( int, Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> insertAt</tt> public member function inserts the second argument into the vector before the element at index given
 by the first argument.&nbsp; If the passed index is equal to the number of entries in the vector, the new value is appended
 to the vector as the last element.&nbsp; All vector elements with indexes greater than or equal to the first parameter are
 copied up one index.
<br>This function is not provided by the<tt> WCPtrSortedVector</tt> class, since all elements must be inserted in sorted order
 by the<tt> insert</tt> member function.
<br><br>If the passed index is negative or greater than the number of entries in the vector and the<tt> index_range</tt> exception
 is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the new element is inserted as the first element
 when the index is negative, or as the last element when the index is too large.
<br><br>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<tt> resize_required</tt>
 exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the insert fails if the amount the
 vector is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically
 grown by the number of elements specified to the constructor, using the<tt> resize</tt> member function.&nbsp; If<tt> resize</tt>
 fails, the element is not inserted into the vector and the<tt> out_of_memory</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> insertAt</tt> public member function inserts an element into the<tt> WCPtrOrderedVector</tt> object before the element
 at the given index.&nbsp; A TRUE (non-zero) value is returned if the insert is successful.&nbsp; If the insert fails, a FALSE
 (zero) value is returned.
<dt><br>See Also:
<dd><tt> append</tt>,<tt> insert</tt>,<tt> prepend</tt>,<tt> operator &#91;&#93;</tt>,<tt> removeAt</tt>,<tt> WCExcept::index_range</tt>,<tt>
 WCExcept::out_of_memory</tt>,<tt> WCExcept::resize_required</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__isEmptyLR"> isEmpty() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if a vector object has any entries contained in it.
<dt><br>Results:
<dd>A TRUE value (non-zero) is returned if the vector object does not have any vector elements contained within it.&nbsp; A FALSE
 (zero) result is returned if the vector contains at least one element.
<dt><br>See Also:
<dd><tt> entries</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY__lastLR__WCPtrOrderedVectorXTypeY__lastLR"> last() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * last() const;</tt>
<dt><br>Semantics:
<dd>The<tt> last</tt> public member function returns the last element in the vector.&nbsp; The element is not removed from the
 vector.
<br>If the vector is empty, one of two exceptions can be thrown.&nbsp; The<tt> empty_container</tt> exception is thrown if
 it is enabled.&nbsp; Otherwise, if the<tt> index_range</tt> exception is enabled, it is thrown.&nbsp; If neither exception
 is enabled, a first element of the vector is added with a NULL value.
<dt><br>Results:
<dd>The<tt> last</tt> public member function returns the value of the last element in the vector.
<dt><br>See Also:
<dd><tt> first</tt>,<tt> removeLast</tt>,<tt> WCExcept::index_range</tt>,<tt> WCExcept::resize_required</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__occurrencesOfLR"> occurrencesOf() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int occurrencesOf( const Type * ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> occurrencesOf</tt> public member function returns the number of elements contained in the vector that are equivalent
 to the passed value.&nbsp; Note that comparisons are done on the objects pointed to, not the pointers themselves.&nbsp; A
 linear search is used by the<tt> WCPtrOrderedVector</tt> class to find the value.&nbsp; The<tt> WCPtrSortedVector</tt> class
 uses a binary search.
<dt><br>Results:
<dd>The<tt> occurrencesOf</tt> public member function returns the number of elements equivalent to the passed value.
<dt><br>See Also:
<dd><tt> contains</tt>,<tt> find</tt>,<tt> index</tt>,<tt> operator &#91;&#93;</tt>,<tt> removeAll</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__operator_UVLR"> operator &#91;&#93;() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * &amp; operator &#91;&#93;( int );</tt>
<br><tt> Type * const &amp; operator &#91;&#93;( int ) const;</tt>
<dt><br>Semantics:
<dd><tt> operator &#91;&#93;</tt> is the vector index operator.&nbsp; A reference to the object stored in the vector at the given
 index is returned.&nbsp; If a constant vector is indexed, a reference to a constant element is returned.
<br>The<tt> append, insert, insertAt</tt> and<tt> prepend</tt> member functions are used to insert a new element into a vector,
 and the<tt> remove, removeAll, removeAt, removeFirst</tt> and<tt> removeLast</tt> member functions remove elements.&nbsp;
 The index operator cannot be used to change the number of entries in the vector.&nbsp; Searches may be performed using the<tt>
 find</tt> and<tt> index</tt> member functions.
<br><br>If the vector is empty, one of two exceptions can be thrown.&nbsp; The<tt> empty_container</tt> exception is thrown
 if it is enabled.&nbsp; Otherwise, if the<tt> index_range</tt> exception is enabled, it is thrown.&nbsp; If neither exception
 is enabled, a first element of the vector is added with a NULL value.&nbsp; This element is added so that a reference to
 a valid vector element can be returned.
<br><br>If the index value is negative and the<tt> index_range</tt> exception is enabled, the exception is thrown.&nbsp; An
 attempt to index an element with index greater than or equal to the number of entries in the vector will also cause the<tt>
 index_range</tt> exception to be thrown if enabled.&nbsp; If the exception is not enabled, attempting to index a negative
 element will index the first element in the vector, and attempting to index an element after the last entry will index the
 last element.
<br><br>Care must be taken when using the<tt> WCPtrSortedVector</tt> class not to change the ordering of the vector elements.
&nbsp; The result returned by the index operator must not be assigned to or modified in such a way that it is no longer equivalent
 (by<tt> Type's</tt> equivalence operator) to the value inserted into the vector.&nbsp; Failure to comply may cause lookups
 to work incorrectly, since the binary search algorithm assumes elements are in sorted order.
<dt><br>Results:
<dd>The<tt> operator &#91;&#93;</tt> public member function returns a reference to the element at the given index.&nbsp; If the
 index is invalid, a reference to the closest valid element is returned.&nbsp; The result of the non-constant index operator
 may be assigned to.
<dt><br>See Also:
<dd><tt> append</tt>,<tt> find</tt>,<tt> first</tt>,<tt> index</tt>,<tt> insert</tt>,<tt> insertAt</tt>,<tt> isEmpty</tt>,<tt>
 last</tt>,<tt> prepend</tt>,<tt> remove</tt>,<tt> removeAt</tt>,<tt> removeAll</tt>,<tt> removeFirst</tt>,<tt> removeLast</tt>,<tt>
 WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__operator_ELR"> operator =() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrOrderedVector &amp; WCPtrOrderedVector::operator =( const WCPtrOrderedVector &amp; );</tt>
<br><tt> WCPtrSortedVector &amp; WCPtrSortedVector::operator =( const WCPtrSortedVector &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the class.&nbsp; The left hand side vector is
 first cleared using the<tt> clear</tt> member function, and then the right hand side vector is copied.&nbsp; The left hand
 side vector is made to have the same length and growth amount as the right hand side (the growth amount is the second argument
 passed to the right hand side vector constructor).&nbsp; All of the vector elements and exception trap states are copied.
<br>If the left hand side vector cannot be fully created, it will have zero length.&nbsp; The<tt> out_of_memory</tt> exception
 is thrown if enabled in the right hand side vector.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the left hand side vector to be a copy of the right hand side.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__operator_EELR"> operator ==() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int WCPtrOrderedVector::operator ==( const WCPtrOrderedVector &amp; ) const;</tt>
<br><tt> int WCPtrSortedVector::operator ==( const WCPtrSortedVector &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the class.&nbsp; Two vector objects are equivalent
 if they are the same object and share the same address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side and right hand side vectors are the same object.&nbsp; A FALSE (zero)
 value is returned otherwise.
</dl>
<h2 id="WCPtrOrderedVectorXTypeY__prependLR"> prepend() &#91;WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int prepend( Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> prepend</tt> public member function inserts the passed element to be the first element in the vector.&nbsp; All vector
 elements contained in the vector are copied up one index.
<br>This function is not provided by the<tt> WCPtrSortedVector</tt> class, since all elements must be inserted in sorted order
 by the<tt> insert</tt> member function.
<br><br>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<tt> resize_required</tt>
 exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the prepend fails if the amount the
 vector is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically
 grown by the number of elements specified to the constructor, using the<tt> resize</tt> member function.&nbsp; If<tt> resize</tt>
 fails, the element is not inserted to the vector and the<tt> out_of_memory</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> prepend</tt> public member function prepends an element to the<tt> WCPtrOrderedVector</tt> object.&nbsp; A TRUE (non-zero)
 value is returned if the insert is successful.&nbsp; If the insert fails, a FALSE (zero) value is returned.
<dt><br>See Also:
<dd><tt> append</tt>,<tt> insert</tt>,<tt> insertAt</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCExcept::resize_required</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY__removeLR__WCPtrOrderedVectorXTypeY__removeLR"> remove() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * remove( const Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> remove</tt> public member function removes the first element in the vector which is equivalent to the passed value.
&nbsp; Note that comparisons are done on the objects pointed to, not the pointers themselves.&nbsp; All vector elements stored
 after the removed elements are copied down one index.
<br>A linear search is used by the<tt> WCPtrOrderedVector</tt> class to find the element being removed.&nbsp; The<tt> WCPtrSortedVector</tt>
 class uses a binary search.
<dt><br>Results:
<dd>The<tt> remove</tt> public member function removes the first element in the vector which is equivalent to the passed value.
&nbsp; The removed pointer is returned.&nbsp; If the vector did not contain an equivalent value, NULL(0) is returned.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> find</tt>,<tt> removeAll</tt>,<tt> removeAt</tt>,<tt> removeFirst</tt>,<tt>
 removeLast</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeAllLR"> removeAll() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned removeAll( const Type * );</tt>
<dt><br>Semantics:
<dd>The<tt> removeAll</tt> public member function removes all elements in the vector which are equivalent to the passed value.
&nbsp; Note that comparisons are done on the objects pointed to, not the pointers themselves.&nbsp; All vector elements stored
 after the removed elements are copied down one or more indexes to take the place of the removed elements.
<br>A linear search is used by the<tt> WCPtrOrderedVector</tt> class to find the elements being removed.&nbsp; The<tt> WCPtrSortedVector</tt>
 class uses a binary search.
<dt><br>Results:
<dd>The<tt> removeAll</tt> public member function removes all elements in the vector which are equivalent to the passed value.
&nbsp; The number of elements removed is returned.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> find</tt>,<tt> occurrencesOf</tt>,<tt> remove</tt>,<tt> removeAt</tt>,<tt>
 removeFirst</tt>,<tt> removeLast</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeAtLR"> removeAt() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * removeAt( int );</tt>
<dt><br>Semantics:
<dd>The<tt> removeAt</tt> public member function removes the element at the given index.&nbsp; All vector elements stored after
 the removed elements are copied down one index.
<br>If the vector is empty and the<tt> empty_container</tt> exception is enabled, the exception is thrown.
<br><br>If an attempt to remove an element with a negative index is made and the<tt> index_range</tt> exception is enabled,
 the exception is thrown.&nbsp; If the exception is not enabled, the first element is removed from the vector.&nbsp; Attempting
 to remove an element with index greater or equal to the number of entries in the vector also causes the<tt> index_range</tt>
 exception to be thrown if enabled.&nbsp; The last element in the vector is removed if the exception is not enabled.
<dt><br>Results:
<dd>The<tt> removeAt</tt> public member function removes the element with the given index.&nbsp; If the index is invalid, the
 closest element to the given index is removed.&nbsp; The removed pointer is returned.&nbsp; If the vector was empty, NULL(0)
 is returned.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> insertAt</tt>,<tt> operator &#91;&#93;</tt>,<tt> remove</tt>,<tt> removeAll</tt>,<tt>
 removeFirst</tt>,<tt> removeLast</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeFirstLR"> removeFirst() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * removeFirst();</tt>
<dt><br>Semantics:
<dd>The<tt> removeFirst</tt> public member function removes the first element from a vector.&nbsp; All other vector elements are
 copied down one index.
<br>If the vector is empty and the<tt> empty_container</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>The<tt> removeFirst</tt> public member function removes the first element from the vector.&nbsp; The removed pointer is returned.
&nbsp; If the vector was empty, NULL(0) is returned.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> first</tt>,<tt> remove</tt>,<tt> removeAt</tt>,<tt> removeAll</tt>,<tt> removeLast</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY_WCPtrOrderedVectorXTypeY__removeLastLR"> removeLast() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * removeLast();</tt>
<dt><br>Semantics:
<dd>The<tt> removeLast</tt> public member function removes the last element from a vector.&nbsp; If the vector is empty and the<tt>
 empty_container</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>The<tt> removeLast</tt> public member function removes the last element from the vector.&nbsp; The removed pointer is returned.
&nbsp; If the vector was empty, NULL(0) is returned.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> last</tt>,<tt> remove</tt>,<tt> removeAt</tt>,<tt> removeAll</tt>,<tt> removeFirst</tt>
</dl>
<h2 id="WCPtrSortedVectorXTypeY__resizeLR__WCPtrOrderedVectorXTypeY__resizeLR"> resize() &#91;WCPtrSortedVector&lt;Type&gt;,WCPtrOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int resize( size_t new_size );</tt>
<dt><br>Semantics:
<dd>The<tt> resize</tt> public member function is used to change the vector size to be able to store<b> new_size</b> elements.
&nbsp; If<b> new_size</b> is larger than the previous vector size, all elements are copied into the newly sized vector, and
 new elements can be added using the<tt> append, insert, insertAt,</tt> and<tt> prepend</tt> member functions.&nbsp; If the
 vector is resized to a smaller size, the first<b> new_size</b> elements are copied (all vector elements if the vector contained<b>
 new_size</b> or fewer elements).&nbsp; The objects pointed to by the remaining elements are not deleted.
<br>If the resize cannot be performed and the<tt> out_of_memory</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>The vector is resized to<b> new_size</b>.&nbsp; A TRUE value (non-zero) is returned if the resize is successful.&nbsp; A FALSE
 (zero) result is returned if the resize fails.
<dt><br>See Also:
<dd><tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrVectorXTypeY_Class_Description"> WCPtrVector&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wcvector.h</tt>
<br>The<tt> WCPtrVector&lt;Type&gt;</tt> class is a templated class used to store objects in a vector.&nbsp; Vectors are similar
 to arrays, but vectors perform bounds checking and can be resized.&nbsp; Elements are inserted into the vector by assigning
 to a vector index.
<br>The<tt> WCPtrOrderedVector</tt> and<tt> WCPtrSortedVector</tt> classes are also available.&nbsp; They provide a more abstract
 view of the vector and additional functionality, including finding and removing elements.
<br><br>In the description of each member function, the text<tt> Type</tt> is used to indicate the template parameter defining
 the type pointed to by the pointers stored in the vector.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCPtrVector&lt;Type&gt;</tt> class and provides the<tt> exceptions</tt>
 member function.&nbsp; This member function controls the exceptions which can be thrown by the<tt> WCPtrVector&lt;Type&gt;</tt>
 object.&nbsp; No exceptions are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Type</b>
<br><br>The<tt> WCPtrVector&lt;Type&gt;</tt> class requires nothing from<tt> Type.</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCPtrVector( size_t = 0 );</tt>
<br><tt> WCPtrVector( size_t, const Type * );</tt>
<br><tt> WCPtrVector( const WCPtrVector &amp; );</tt>
<br><tt> virtual ~WCPtrVector();</tt>
<br><tt> void clear();</tt>
<br><tt> void clearAndDestroy();</tt>
<br><tt> size_t length() const;</tt>
<br><tt> int resize( size_t );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>Type * &amp; operator &#91;&#93;( int );</tt>
<br><tt> Type * const &amp; operator &#91;&#93;( int ) const;</tt>
<br><tt> WCPtrVector &amp; operator =( const WCPtrVector &amp; );</tt>
<br><tt> int operator ==( const WCPtrVector &amp; ) const;</tt>
</dl>
<h2 id="WCPtrVectorXTypeY__WCPtrVectorLR"> WCPtrVector() &#91;WCPtrVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrVector( size_t = 0 );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCPtrVector&lt;Type&gt;</tt> constructor creates a<tt> WCPtrVector&lt;Type&gt;</tt> object able to store the
 number of elements specified in the optional parameter, which defaults to zero.&nbsp; All vector elements are initialized
 to NULL(0).
<br>If the vector object cannot be fully initialized, the vector is created with length zero.
<dt><br>Results:
<dd>The public<tt> WCPtrVector&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrVector&lt;Type&gt;</tt> object with
 the specified length.
<dt><br>See Also:
<dd><tt> WCPtrVector&lt;Type&gt;</tt>,<tt> ~WCPtrVector&lt;Type&gt;</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrVector( size_t, const Type * );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCPtrVector&lt;Type&gt;</tt> constructor creates a<tt> WCPtrVector&lt;Type&gt;</tt> object able to store the
 number of elements specified by the first parameter.&nbsp; All vector elements are initialized to the pointer value given
 by the second parameter.
<br>If the vector object cannot be fully initialized, the vector is created with length zero.
<dt><br>Results:
<dd>The public<tt> WCPtrVector&lt;Type&gt;</tt> constructor creates an initialized<tt> WCPtrVector&lt;Type&gt;</tt> object with
 the specified length and elements set to the given value.
<dt><br>See Also:
<dd><tt> WCPtrVector&lt;Type&gt;</tt>,<tt> ~WCPtrVector&lt;Type&gt;</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrVector( const WCPtrVector &amp; );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCPtrVector&lt;Type&gt;</tt> constructor is the copy constructor for the<tt> WCPtrVector&lt;Type&gt;</tt> class.
&nbsp; The new vector is created with the same length as the given vector.&nbsp; All of the vector elements and exception
 trap states are copied.
<br>If the new vector cannot be fully created, it will have length zero.&nbsp; The<tt> out_of_memory</tt> exception is thrown
 if enabled in the vector being copied.
<dt><br>Results:
<dd>The public<tt> WCPtrVector&lt;Type&gt;</tt> constructor creates a<tt> WCPtrVector&lt;Type&gt;</tt> object which is a copy
 of the passed vector.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrVectorXTypeY____WCPtrVectorLR"> ~WCPtrVector() &#91;WCPtrVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCPtrVector();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCPtrVector&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCPtrVector&lt;Type&gt;</tt> class.
&nbsp; If the vector is not length zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise,
 the vector elements are cleared using the<tt> clear</tt> member function.&nbsp; The objects which the vector elements point
 to are not deleted unless the<tt> clearAndDestroy</tt> member function is explicitly called before the destructor is called.
&nbsp; The call to the public<tt> ~WCPtrVector&lt;Type&gt;</tt> destructor is inserted implicitly by the compiler at the point
 where the<tt> WCPtrVector&lt;Type&gt;</tt> object goes out of scope.
<dt><br>Results:
<dd>The public<tt> ~WCPtrVector&lt;Type&gt;</tt> destructor destroys an<tt> WCPtrVector&lt;Type&gt;</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCPtrVectorXTypeY__clearLR"> clear() &#91;WCPtrVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the vector so that it is of zero length.&nbsp; Objects pointed
 to by the vector elements are not deleted.&nbsp; The vector object is not destroyed and re-created by this function, so the
 object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function clears the vector to have zero length and no vector elements.
<dt><br>See Also:
<dd><tt> ~WCPtrVector&lt;Type&gt;</tt>,<tt> clearAndDestroy</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCPtrVectorXTypeY__clearAndDestroyLR"> clearAndDestroy() &#91;WCPtrVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clearAndDestroy();</tt>
<dt><br>Semantics:
<dd>The<tt> clearAndDestroy</tt> public member function is used to clear the vector to have zero length and delete the objects
 pointed to by the vector elements.&nbsp; The vector object is not destroyed and re-created by this function, so the vector
 object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clearAndDestroy</tt> public member function clears the vector by deleting the objects pointed to by the vector elements
 and makes the vector zero length.
<dt><br>See Also:
<dd><tt> clear</tt>
</dl>
<h2 id="WCPtrVectorXTypeY__lengthLR"> length() &#91;WCPtrVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>size_t length() const;</tt>
<dt><br>Semantics:
<dd>The<tt> length</tt> public member function is used to find the number of elements which can be stored in the<tt> WCPtrVector&lt;Type&gt;</tt>
 object.
<dt><br>Results:
<dd>The<tt> length</tt> public member function returns the length of the vector.
<dt><br>See Also:
<dd><tt> resize</tt>
</dl>
<h2 id="WCPtrVectorXTypeY__operator_UVLR"> operator &#91;&#93;() &#91;WCPtrVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type * &amp; operator &#91;&#93;( int );</tt>
<br><tt> Type * const &amp; operator &#91;&#93;( int ) const;</tt>
<dt><br>Semantics:
<dd><tt> operator &#91;&#93;</tt> is the vector index operator.&nbsp; A reference to the object stored in the vector at the given
 index is returned.&nbsp; If a constant vector is indexed, a reference to a constant element is returned.&nbsp; The index
 operator of a non-constant vector is the only way to insert an element into the vector.
<br>If an attempt to access an element with index greater than or equal to the length of a non-constant vector is made and
 the<tt> resize_required</tt> exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the vector
 is automatically resized using the<tt> resize</tt> member function to have length the index value plus one.&nbsp; New vector
 elements are initialized to NULL(0).&nbsp; If the resize failed, and the<tt> out_of_memory</tt> exception is enabled, the
 exception is thrown.&nbsp; If the exception is not enabled and the resize failed, the last element is indexed (a new element
 if the vector was zero length).&nbsp; If a negative value is used to index the non-constant vector and the<tt> index_range</tt>
 exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled and the vector is empty, the<tt> resize_required</tt>
 exception may be thrown.
<br><br>An attempt to index an empty constant vector may cause one of two exceptions to be thrown.&nbsp; If the<tt> empty_container</tt>
 exception is enabled, it is thrown.&nbsp; Otherwise, the<tt> index_range</tt> exception is thrown, if enabled.&nbsp; If neither
 exception is enabled, a first vector element is added and indexed (so that a reference to a valid element can be returned).
<br><br>Indexing with a negative value or a value greater than or equal to the length of a constant vector causes the<tt>
 index_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator &#91;&#93;</tt> public member function returns a reference to the element at the given index.&nbsp; If the
 index is invalid, a reference to the closest valid element is returned.&nbsp; The result of the non-constant index operator
 may be assigned to.
<dt><br>See Also:
<dd><tt> resize</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>,<tt> WCExcept::out_of_memory</tt>,<tt>
 WCExcept::resize_required</tt>
</dl>
<h2 id="WCPtrVectorXTypeY__operator_ELR"> operator =() &#91;WCPtrVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCPtrVector &amp; operator =( const WCPtrVector &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the<tt> WCPtrVector&lt;Type&gt;</tt> class.
&nbsp; The left hand side vector is first cleared using the<tt> clear</tt> member function, and then the right hand side vector
 is copied.&nbsp; The left hand side vector is made to have the same length as the right hand side.&nbsp; All of the vector
 elements and exception trap states are copied.
<br>If the left hand side vector cannot be fully created, it will have zero length.&nbsp; The<tt> out_of_memory</tt> exception
 is thrown if enabled in the right hand side vector.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the left hand side vector to be a copy of the right hand side.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> clearAndDestroy</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCPtrVectorXTypeY__operator_EELR"> operator ==() &#91;WCPtrVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ==( const WCPtrVector &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the<tt> WCPtrVector&lt;Type&gt;</tt> class.
&nbsp; Two vector objects are equivalent if they are the same object and share the same address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side and right hand side vectors are the same object.&nbsp; A FALSE (zero)
 value is returned otherwise.
</dl>
<h2 id="WCPtrVectorXTypeY__resizeLR"> resize() &#91;WCPtrVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int resize( size_t new_size );</tt>
<dt><br>Semantics:
<dd>The<tt> resize</tt> public member function is used to change the vector size to be able to store<b> new_size</b> elements.
&nbsp; If<b> new_size</b> is larger than the previous vector size, all elements will be copied into the newly sized vector,
 and new elements are initialized to NULL(0).&nbsp; If the vector is resized to a smaller size, the first<b> new_size</b>
 elements are copied.&nbsp; The objects pointed to by the remaining elements are not deleted.
<br>If the resize cannot be performed and the<tt> out_of_memory</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>The vector is resized to<b> new_size</b>.&nbsp; A TRUE value (non-zero) is returned if the resize is successful.&nbsp; A FALSE
 (zero) result is returned if the resize fails.
<dt><br>See Also:
<dd><tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY__WCValOrderedVectorXTypeY_Class_Description"> WCValSortedVector&lt;Type&gt;, WCValOrderedVector&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wcvector.h</tt>
<br>The<tt> WCValSortedVector&lt;Type&gt;</tt> and<tt> WCValOrderedVector&lt;Type&gt;</tt> classes are templated classes used
 to store objects in a vector.&nbsp; Ordered and Sorted vectors are powerful arrays which can be resized and provide an abstract
 interface to insert, find and remove elements.&nbsp; An ordered vector maintains the order in which elements are added, and
 allows more than one copy of an element that is equivalent.&nbsp; The sorted vector allow only one copy of an equivalent
 element, and inserts them in a sorted order.&nbsp; The sorted vector is less efficient when inserting elements, but can provide
 a faster retrieval time.
<br>Elements cannot be inserted into these vectors by assigning to a vector index.&nbsp; Vectors automatically grow when necessary
 to insert an element if the<tt> resize_required</tt> exception is not enabled.
<br><br>In the description of each member function, the text<tt> Type</tt> is used to indicate the template parameter defining
 the type of the elements stored in the vector.
<br><br>Values are copied into the vector, which could be undesirable if the stored objects are complicated and copying is
 expensive.&nbsp; Value vectors should not be used to store objects of a base class if any derived types of different sizes
 would be stored in the vector, or if the destructor for a derived class must be called.
<br><br>The<tt> WCValOrderedVector</tt> class stores elements in the order which they are inserted using the<tt> insert, append,
 prepend</tt> and<tt> insertAt</tt> member functions.&nbsp; Linear searches are performed to locate entries, and the less
 than operator is not required.
<br><br>The<tt> WCValSortedVector</tt> class stores elements in ascending order.&nbsp; This requires that<tt> Type</tt> provides
 a less than operator.&nbsp; Insertions are more expensive than inserting or appending into an ordered vector, since entries
 must be moved to make room for the new element.&nbsp; A binary search is used to locate elements in a sorted vector, making
 searches quicker than in the ordered vector.
<br><br>Care must be taken when using the<tt> WCValSortedVector</tt> class not to change the ordering of the vector elements.
&nbsp; The result returned by the index operator must not be assigned to or modified in such a way that it is no longer equivalent
 to the value inserted into the vector.&nbsp; Lookups assume elements are in sorted order.
<br><br>The<tt> WCValVector</tt> class is also available.&nbsp; It provides a resizable and boundary safe vector similar to
 standard arrays.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCValSortedVector&lt;Type&gt;</tt> and<tt> WCValOrderedVector&lt;Type&gt;</tt>
 classes and provides the<tt> exceptions</tt> member function.&nbsp; This member function controls the exceptions which can
 be thrown by the<tt> WCValSortedVector&lt;Type&gt;</tt> and<tt> WCValOrderedVector&lt;Type&gt;</tt> objects.&nbsp; No exceptions
 are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Type</b>
<br><br>Both the<tt> WCValSortedVector&lt;Type&gt;</tt> and<tt> WCValOrderedVector&lt;Type&gt;</tt> classes require<tt> Type</tt>
 to have:
<br>A default constructor (<tt> Type::Type()</tt> ).
<br><br>A well defined copy constructor (<tt> Type::Type( const Type &amp; )</tt> ).
<br><br>A well defined assignment operator
<br><br>(<tt> Type &amp; operator =( const Type &amp; )</tt> ).
<br>The following override of<tt> operator new()</tt> if<tt> Type</tt> overrides the global<tt> operator new():</tt>
<br><br><tt>void * operator new( size_t, void *ptr ) { return( ptr ); }</tt>
<br><br>A well defined equivalence operator with constant parameters
<br><br>(<tt> int operator ==( const Type &amp; ) const</tt> ).
<br>Additionally the<tt> WCValSortedVector</tt> class requires<tt> Type</tt> to have:
<br><br>A well defined less than operator with constant parameters
<br><br>(<tt> int operator &lt;( const Type &amp; ) const</tt> ).
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCValOrderedVector( size_t = WCDEFAULT_VECTOR_LENGTH, unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</tt>
<br><tt> WCValOrderedVector( const WCValOrderedVector &amp; );</tt>
<br><tt> virtual ~WCValOrderedVector();</tt>
<br><tt> WCValSortedVector( size_t = WCDEFAULT_VECTOR_LENGTH, unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</tt>
<br><tt> WCValSortedVector( const WCValSortedVector &amp; );</tt>
<br><tt> virtual ~WCValSortedVector();</tt>
<br><tt> void clear();</tt>
<br><tt> int contains( const Type &amp; ) const;</tt>
<br><tt> unsigned entries() const;</tt>
<br><tt> int find( const Type &amp;, Type &amp; ) const;</tt>
<br><tt> Type first() const;</tt>
<br><tt> int index( const Type &amp; ) const;</tt>
<br><tt> int insert( const Type &amp; );</tt>
<br><tt> int isEmpty() const;</tt>
<br><tt> Type last() const;</tt>
<br><tt> int occurrencesOf( const Type &amp; ) const;</tt>
<br><tt> int remove( const Type &amp; );</tt>
<br><tt> unsigned removeAll( const Type &amp; );</tt>
<br><tt> int removeAt( int );</tt>
<br><tt> int removeFirst();</tt>
<br><tt> int removeLast();</tt>
<br><tt> int resize( size_t );</tt>
<br><br>The following public member functions are available for the<tt> WCValOrderedVector</tt> class only:
<br><br><tt>int append( const Type &amp; );</tt>
<br><tt> int insertAt( int, const Type &amp; );</tt>
<br><tt> int prepend( const Type &amp; );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>Type &amp; operator &#91;&#93;( int );</tt>
<br><tt> const Type &amp; operator &#91;&#93;( int ) const;</tt>
<br><tt> WCValOrderedVector &amp; WCValOrderedVector::operator =( const WCValOrderedVector &amp; );</tt>
<br><tt> WCValSortedVector &amp; WCValSortedVector::operator =( const WCValSortedVector &amp; );</tt>
<br><tt> int WCValOrderedVector::operator ==( const WCValOrderedVector &amp; ) const;</tt>
<br><tt> int WCValSortedVector::operator ==( const WCValSortedVector &amp; ) const;</tt>
</dl>
<h2 id="WCValOrderedVectorXTypeY__WCValOrderedVectorLR"> WCValOrderedVector() &#91;WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValOrderedVector( size_t = WCDEFAULT_VECTOR_LENGTH,</tt>
<br><tt> unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValOrderedVector&lt;Type&gt;</tt> constructor creates an empty<tt> WCValOrderedVector</tt> object able to store
 the number of elements specified in the first optional parameter, which defaults to the constant<tt> WCDEFAULT_VECTOR_LENGTH</tt>
 (currently defined as 10).&nbsp; If the<tt> resize_required</tt> exception is not enabled, then the second optional parameter
 is used to specify the value to increase the vector size when an element is inserted into a full vector.&nbsp; If zero(0)
 is specified as the second parameter, any attempt to insert into a full vector fails.&nbsp; This parameter defaults to the
 constant<tt> WCDEFAULT_VECTOR_RESIZE_GROW</tt> (currently defined as 5).
<br>If the vector object cannot be fully initialized, the vector is created with length zero.
<dt><br>Results:
<dd>The<tt> WCValOrderedVector&lt;Type&gt;</tt> constructor creates an empty initialized<tt> WCValOrderedVector</tt> object.
<dt><br>See Also:
<dd><tt> WCExcept::resize_required</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValOrderedVector( const WCValOrderedVector &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValOrderedVector&lt;Type&gt;</tt> constructor is the copy constructor for the<tt> WCValOrderedVector</tt> class.
&nbsp; The new vector is created with the same length and resize value as the passed vector.&nbsp; All of the vector elements
 and exception trap states are copied.
<br>If the new vector cannot be fully created, it will have length zero.&nbsp; The<tt> out_of_memory</tt> exception is thrown
 if enabled in the vector being copied.
<dt><br>Results:
<dd>The<tt> WCValOrderedVector&lt;Type&gt;</tt> creates a<tt> WCValOrderedVector</tt> object which is a copy of the passed vector.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValOrderedVectorXTypeY____WCValOrderedVectorLR"> ~WCValOrderedVector() &#91;WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCValOrderedVector();</tt>
<dt><br>Semantics:
<dd>The<tt> WCValOrderedVector&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCValOrderedVector</tt> class.&nbsp;
 If the vector is not length zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise,
 the vector entries are cleared using the<tt> clear</tt> member function.&nbsp; The call to the<tt> WCValOrderedVector&lt;Type&gt;</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> WCValOrderedVector</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> WCValOrderedVector&lt;Type&gt;</tt> destructor destroys an<tt> WCValOrderedVector</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY__WCValSortedVectorLR"> WCValSortedVector() &#91;WCValSortedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSortedVector( size_t = WCDEFAULT_VECTOR_LENGTH,</tt>
<br><tt> unsigned = WCDEFAULT_VECTOR_RESIZE_GROW );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSortedVector&lt;Type&gt;</tt> constructor creates an empty<tt> WCValSortedVector</tt> object able to store the
 number of elements specified in the first optional parameter, which defaults to the constant<tt> WCDEFAULT_VECTOR_LENGTH</tt>
 (currently defined as 10).&nbsp; If the<tt> resize_required</tt> exception is not enabled, then the second optional parameter
 is used to specify the value to increase the vector size when an element is inserted into a full vector.&nbsp; If zero(0)
 is specified as the second parameter, any attempt to insert into a full vector fails.&nbsp; This parameter defaults to the
 constant<tt> WCDEFAULT_VECTOR_RESIZE_GROW</tt> (currently defined as 5).
<br>If the vector object cannot be fully initialized, the vector is created with length zero.
<dt><br>Results:
<dd>The<tt> WCValSortedVector&lt;Type&gt;</tt> constructor creates an empty initialized<tt> WCValSortedVector</tt> object.
<dt><br>See Also:
<dd><tt> WCExcept::resize_required</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValSortedVector( const WCValSortedVector &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSortedVector&lt;Type&gt;</tt> constructor is the copy constructor for the<tt> WCValSortedVector</tt> class.&nbsp;
 The new vector is created with the same length and resize value as the passed vector.&nbsp; All of the vector elements and
 exception trap states are copied.
<br>If the new vector cannot be fully created, it will have length zero.&nbsp; The<tt> out_of_memory</tt> exception is thrown
 if enabled in the vector being copied.
<dt><br>Results:
<dd>The<tt> WCValSortedVector&lt;Type&gt;</tt> constructor creates a<tt> WCValSortedVector</tt> object which is a copy of the
 passed vector.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY____WCValSortedVectorLR"> ~WCValSortedVector() &#91;WCValSortedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCValSortedVector();</tt>
<dt><br>Semantics:
<dd>The<tt> WCValSortedVector&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCValSortedVector</tt> class.&nbsp; If
 the vector is not length zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise,
 the vector entries are cleared using the<tt> clear</tt> member function.&nbsp; The call to the<tt> WCValSortedVector&lt;Type&gt;</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> WCValSortedVector</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> WCValSortedVector&lt;Type&gt;</tt> destructor destroys an<tt> WCValSortedVector</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCValOrderedVectorXTypeY__appendLR"> append() &#91;WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int append( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> append</tt> public member function appends the passed element to be the last element in the vector.&nbsp; The data
 stored in the vector is a copy of the data passed as a parameter.&nbsp; This member function has the same semantics as the<tt>
 WCValOrderedVector::insert</tt> member function.
<br>This function is not provided by the<tt> WCValSortedVector</tt> class, since all elements must be inserted in sorted order
 by the<tt> insert</tt> member function.
<br><br>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<tt> resize_required</tt>
 exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the append fails if the amount the
 vector is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically
 grown by the number of elements specified to the constructor, using the<tt> resize</tt> member function.&nbsp; If<tt> resize</tt>
 fails, the element is not appended to the vector and the<tt> out_of_memory</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> append</tt> public member function appends an element to the<tt> WCValOrderedVector</tt> object.&nbsp; A TRUE (non-zero)
 value is returned if the append is successful.&nbsp; If the append fails, a FALSE (zero) value is returned.
<dt><br>See Also:
<dd><tt> insert</tt>,<tt> insertAt</tt>,<tt> prepend</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCExcept::resize_required</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY__clearLR__WCValOrderedVectorXTypeY__clearLR"> clear() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the vector so that it contains no entries, and is zero size.&nbsp;
 Elements stored in the vector are destroyed using<tt> Type's</tt> destructor.&nbsp; The vector object is not destroyed and
 re-created by this function, so the object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function clears the vector to have zero length and no entries.
<dt><br>See Also:
<dd><tt> ~WCValOrderedVector</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__containsLR"> contains() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int contains( const Type &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> contains</tt> public member function is used to determine if a value is contained by a vector.&nbsp; A linear search
 is used by the<tt> WCValOrderedVector</tt> class to find the value.&nbsp; The<tt> WCValSortedVector</tt> class uses a binary
 search.
<dt><br>Results:
<dd>The<tt> contains</tt> public member function returns a TRUE (non-zero) value if the element is found in the vector.&nbsp;
 A FALSE (zero) value is returned if the vector does not contain the element.
<dt><br>See Also:
<dd><tt> index</tt>,<tt> find</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY__entriesLR__WCValOrderedVectorXTypeY__entriesLR"> entries() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned entries() const;</tt>
<dt><br>Semantics:
<dd>The<tt> entries</tt> public member function is used to find the number of elements which are stored in the vector.
<dt><br>Results:
<dd>The<tt> entries</tt> public member function returns the number of elements in the vector.
<dt><br>See Also:
<dd><tt> isEmpty</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY__findLR__WCValOrderedVectorXTypeY__findLR"> find() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int find( const Type &amp;, Type &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> find</tt> public member function is used to find an element equivalent to the first argument.&nbsp; The<tt> WCValOrderedVector</tt>
 class uses a linear search to find the element, and the<tt> WCValSortedVector</tt> class uses a binary search.
<dt><br>Results:
<dd>If an equivalent element is found, a TRUE (non-zero) value is returned, and the second parameter is assigned the first equivalent
 value.&nbsp; A FALSE (zero) value is returned and the second parameter is unchanged if the element is not in the vector.
<dt><br>See Also:
<dd><tt> contains</tt>,<tt> first</tt>,<tt> index</tt>,<tt> last</tt>,<tt> occurrencesOf</tt>,<tt> remove</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY__firstLR__WCValOrderedVectorXTypeY__firstLR"> first() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type first() const;</tt>
<dt><br>Semantics:
<dd>The<tt> first</tt> public member function returns the first element in the vector.&nbsp; The element is not removed from the
 vector.
<br>If the vector is empty, one of two exceptions can be thrown.&nbsp; The<tt> empty_container</tt> exception is thrown if
 it is enabled.&nbsp; Otherwise, if the<tt> index_range</tt> exception is enabled, it is thrown.&nbsp; If neither exception
 is enabled, a first element of the vector is added with a default value.
<dt><br>Results:
<dd>The<tt> first</tt> public member function returns the value of the first element in the vector.
<dt><br>See Also:
<dd><tt> last</tt>,<tt> removeFirst</tt>,<tt> WCExcept::index_range</tt>,<tt> WCExcept::resize_required</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY__indexLR__WCValOrderedVectorXTypeY__indexLR"> index() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int index( const Type &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> index</tt> public member function is used find the index of the first element equivalent to the passed element.&nbsp;
 A linear search is used by the<tt> WCValOrderedVector</tt> class to find the element.&nbsp; The<tt> WCValSortedVector</tt>
 class uses a binary search.
<dt><br>Results:
<dd>The<tt> index</tt> public member function returns the index of the first element equivalent to the parameter.&nbsp; If the
 passed value is not contained in the vector, negative one (-1) is returned.
<dt><br>See Also:
<dd><tt> contains</tt>,<tt> find</tt>,<tt> insertAt</tt>,<tt> operator &#91;&#93;</tt>,<tt> removeAt</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY__insertLR__WCValOrderedVectorXTypeY__insertLR"> insert() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insert( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> insert</tt> public member function inserts the value into the vector.&nbsp; The data stored in the vector is a copy
 of the data passed as a parameter.
<br>The<tt> WCValOrderedVector::insert</tt> function inserts the value as the last element of the vector, and has the same
 semantics as the<tt> WCValOrderedVector::append</tt> member function.
<br><br>A binary search is performed to determine where the value should be inserted for the<tt> WCValSortedVector::insert</tt>
 function.&nbsp; Any elements greater than the inserted value are copied up one index (using<tt> Type's</tt> assignment operator),
 so that the new element is after all elements with value less than or equal to it.
<br><br>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<tt> resize_required</tt>
 exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the insert fails if the amount the
 vector is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically
 grown by the number of elements specified to the constructor, using the<tt> resize</tt> member function.&nbsp; If<tt> resize</tt>
 fails, the element is not inserted to the vector and the<tt> out_of_memory</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> insert</tt> public member function inserts an element in to the vector.&nbsp; A TRUE (non-zero) value is returned
 if the insert is successful.&nbsp; If the insert fails, a FALSE (zero) value is returned.
<dt><br>See Also:
<dd><tt> append</tt>,<tt> insertAt</tt>,<tt> prepend</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCExcept::resize_required</tt>
</dl>
<h2 id="WCValOrderedVectorXTypeY__insertAtLR"> insertAt() &#91;WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int insertAt( int, const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> insertAt</tt> public member function inserts the second argument into the vector before the element at index given
 by the first argument.&nbsp; If the passed index is equal to the number of entries in the vector, the new value is appended
 to the vector as the last element.&nbsp; The data stored in the vector is a copy of the data passed as a parameter.&nbsp;
 All vector elements with indexes greater than or equal to the first parameter are copied (using<tt> Type's</tt> assignment
 operator) up one index.
<br>This function is not provided by the<tt> WCValSortedVector</tt> class, since all elements must be inserted in sorted order
 by the<tt> insert</tt> member function.
<br><br>If the passed index is negative or greater than the number of entries in the vector and the<tt> index_range</tt> exception
 is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the new element is inserted as the first element
 when the index is negative, or as the last element when the index is too large.
<br><br>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<tt> resize_required</tt>
 exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the insert fails if the amount the
 vector is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically
 grown by the number of elements specified to the constructor, using the<tt> resize</tt> member function.&nbsp; If<tt> resize</tt>
 fails, the element is not inserted into the vector and the<tt> out_of_memory</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> insertAt</tt> public member function inserts an element into the<tt> WCValOrderedVector</tt> object before the element
 at the given index.&nbsp; A TRUE (non-zero) value is returned if the insert is successful.&nbsp; If the insert fails, a FALSE
 (zero) value is returned.
<dt><br>See Also:
<dd><tt> append</tt>,<tt> insert</tt>,<tt> prepend</tt>,<tt> operator &#91;&#93;</tt>,<tt> removeAt</tt>,<tt> WCExcept::index_range</tt>,<tt>
 WCExcept::out_of_memory</tt>,<tt> WCExcept::resize_required</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__isEmptyLR"> isEmpty() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int isEmpty() const;</tt>
<dt><br>Semantics:
<dd>The<tt> isEmpty</tt> public member function is used to determine if a vector object has any entries contained in it.
<dt><br>Results:
<dd>A TRUE value (non-zero) is returned if the vector object does not have any vector elements contained within it.&nbsp; A FALSE
 (zero) result is returned if the vector contains at least one element.
<dt><br>See Also:
<dd><tt> entries</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY__lastLR__WCValOrderedVectorXTypeY__lastLR"> last() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type last() const;</tt>
<dt><br>Semantics:
<dd>The<tt> last</tt> public member function returns the last element in the vector.&nbsp; The element is not removed from the
 vector.
<br>If the vector is empty, one of two exceptions can be thrown.&nbsp; The<tt> empty_container</tt> exception is thrown if
 it is enabled.&nbsp; Otherwise, if the<tt> index_range</tt> exception is enabled, it is thrown.&nbsp; If neither exception
 is enabled, a first element of the vector is added with a default value.
<dt><br>Results:
<dd>The<tt> last</tt> public member function returns the value of the last element in the vector.
<dt><br>See Also:
<dd><tt> first</tt>,<tt> removeLast</tt>,<tt> WCExcept::index_range</tt>,<tt> WCExcept::resize_required</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__occurrencesOfLR"> occurrencesOf() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int occurrencesOf( const Type &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> occurrencesOf</tt> public member function returns the number of elements contained in the vector that are equivalent
 to the passed value.&nbsp; A linear search is used by the<tt> WCValOrderedVector</tt> class to find the value.&nbsp; The<tt>
 WCValSortedVector</tt> class uses a binary search.
<dt><br>Results:
<dd>The<tt> occurrencesOf</tt> public member function returns the number of elements equivalent to the passed value.
<dt><br>See Also:
<dd><tt> contains</tt>,<tt> find</tt>,<tt> index</tt>,<tt> operator &#91;&#93;</tt>,<tt> removeAll</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__operator_UVLR"> operator &#91;&#93;() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type &amp; operator &#91;&#93;( int );</tt>
<br><tt> const Type &amp; operator &#91;&#93;( int ) const;</tt>
<dt><br>Semantics:
<dd><tt> operator &#91;&#93;</tt> is the vector index operator.&nbsp; A reference to the object stored in the vector at the given
 index is returned.&nbsp; If a constant vector is indexed, a reference to a constant element is returned.
<br>The<tt> append, insert, insertAt</tt> and<tt> prepend</tt> member functions are used to insert a new element into a vector,
 and the<tt> remove, removeAll, removeAt, removeFirst</tt> and<tt> removeLast</tt> member functions remove elements.&nbsp;
 The index operator cannot be used to change the number of entries in the vector.&nbsp; Searches may be performed using the<tt>
 find</tt> and<tt> index</tt> member functions.
<br><br>If the vector is empty, one of two exceptions can be thrown.&nbsp; The<tt> empty_container</tt> exception is thrown
 if it is enabled.&nbsp; Otherwise, if the<tt> index_range</tt> exception is enabled, it is thrown.&nbsp; If neither exception
 is enabled, a first element of the vector is added with a default value.&nbsp; This element is added so that a reference
 to a valid vector element can be returned.
<br><br>If the index value is negative and the<tt> index_range</tt> exception is enabled, the exception is thrown.&nbsp; An
 attempt to index an element with index greater than or equal to the number of entries in the vector will also cause the<tt>
 index_range</tt> exception to be thrown if enabled.&nbsp; If the exception is not enabled, attempting to index a negative
 element will index the first element in the vector, and attempting to index an element after the last entry will index the
 last element.
<br><br>Care must be taken when using the<tt> WCValSortedVector</tt> class not to change the ordering of the vector elements.
&nbsp; The result returned by the index operator must not be assigned to or modified in such a way that it is no longer equivalent
 (by<tt> Type's</tt> equivalence operator) to the value inserted into the vector.&nbsp; Failure to comply may cause lookups
 to work incorrectly, since the binary search algorithm assumes elements are in sorted order.
<dt><br>Results:
<dd>The<tt> operator &#91;&#93;</tt> public member function returns a reference to the element at the given index.&nbsp; If the
 index is invalid, a reference to the closest valid element is returned.&nbsp; The result of the non-constant index operator
 may be assigned to.
<dt><br>See Also:
<dd><tt> append</tt>,<tt> find</tt>,<tt> first</tt>,<tt> index</tt>,<tt> insert</tt>,<tt> insertAt</tt>,<tt> isEmpty</tt>,<tt>
 last</tt>,<tt> prepend</tt>,<tt> remove</tt>,<tt> removeAt</tt>,<tt> removeAll</tt>,<tt> removeFirst</tt>,<tt> removeLast</tt>,<tt>
 WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__operator_ELR"> operator =() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValOrderedVector &amp; WCValOrderedVector::operator =( const WCValOrderedVector &amp; );</tt>
<br><tt> WCValSortedVector &amp; WCValSortedVector::operator =( const WCValSortedVector &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the class.&nbsp; The left hand side vector is
 first cleared using the<tt> clear</tt> member function, and then the right hand side vector is copied.&nbsp; The left hand
 side vector is made to have the same length and growth amount as the right hand side (the growth amount is the second argument
 passed to the right hand side vector constructor).&nbsp; All of the vector elements and exception trap states are copied.
<br>If the left hand side vector cannot be fully created, it will have zero length.&nbsp; The<tt> out_of_memory</tt> exception
 is thrown if enabled in the right hand side vector.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the left hand side vector to be a copy of the right hand side.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__operator_EELR"> operator ==() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int WCValOrderedVector::operator ==( const WCValOrderedVector &amp; ) const;</tt>
<br><tt> int WCValSortedVector::operator ==( const WCValSortedVector &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the class.&nbsp; Two vector objects are equivalent
 if they are the same object and share the same address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side and right hand side vectors are the same object.&nbsp; A FALSE (zero)
 value is returned otherwise.
</dl>
<h2 id="WCValOrderedVectorXTypeY__prependLR"> prepend() &#91;WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int prepend( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> prepend</tt> public member function inserts the passed element to be the first element in the vector.&nbsp; The data
 stored in the vector is a copy of the data passed as a parameter.&nbsp; All vector elements contained in the vector are copied
 (using<tt> Type's</tt> assignment operator) up one index.
<br>This function is not provided by the<tt> WCValSortedVector</tt> class, since all elements must be inserted in sorted order
 by the<tt> insert</tt> member function.
<br><br>Several different results can occur if the vector is not large enough for the new element.&nbsp; If the<tt> resize_required</tt>
 exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the prepend fails if the amount the
 vector is to be grown (the second parameter to the constructor) is zero(0).&nbsp; Otherwise, the vector is automatically
 grown by the number of elements specified to the constructor, using the<tt> resize</tt> member function.&nbsp; If<tt> resize</tt>
 fails, the element is not inserted to the vector and the<tt> out_of_memory</tt> exception is thrown, if enabled.
<dt><br>Results:
<dd>The<tt> prepend</tt> public member function prepends an element to the<tt> WCValOrderedVector</tt> object.&nbsp; A TRUE (non-zero)
 value is returned if the insert is successful.&nbsp; If the insert fails, a FALSE (zero) value is returned.
<dt><br>See Also:
<dd><tt> append</tt>,<tt> insert</tt>,<tt> insertAt</tt>,<tt> WCExcept::out_of_memory</tt>,<tt> WCExcept::resize_required</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY__removeLR__WCValOrderedVectorXTypeY__removeLR"> remove() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int remove( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> remove</tt> public member function removes the first element in the vector which is equivalent to the passed value.
&nbsp; All vector elements stored after the removed elements are copied (using<tt> Type's</tt> assignment operator) down one
 index.
<br>A linear search is used by the<tt> WCValOrderedVector</tt> class to find the element being removed.&nbsp; The<tt> WCValSortedVector</tt>
 class uses a binary search.
<dt><br>Results:
<dd>The<tt> remove</tt> public member function removes the first element in the vector which is equivalent to the passed value.
&nbsp; A TRUE (non-zero) value is returned if an equivalent element was contained in the vector and removed.&nbsp; If the
 vector did not contain an equivalent value, a FALSE (zero) value is returned.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> find</tt>,<tt> removeAll</tt>,<tt> removeAt</tt>,<tt> removeFirst</tt>,<tt> removeLast</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeAllLR"> removeAll() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>unsigned removeAll( const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> removeAll</tt> public member function removes all elements in the vector which are equivalent to the passed value.
&nbsp; All vector elements stored after the removed elements are copied (using<tt> Type's</tt> assignment operator) down one
 or more indexes to take the place of the removed elements.
<br>A linear search is used by the<tt> WCValOrderedVector</tt> class to find the elements being removed.&nbsp; The<tt> WCValSortedVector</tt>
 class uses a binary search.
<dt><br>Results:
<dd>The<tt> removeAll</tt> public member function removes all elements in the vector which are equivalent to the passed value.
&nbsp; The number of elements removed is returned.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> find</tt>,<tt> occurrencesOf</tt>,<tt> remove</tt>,<tt> removeAt</tt>,<tt> removeFirst</tt>,<tt> removeLast</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeAtLR"> removeAt() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int removeAt( int );</tt>
<dt><br>Semantics:
<dd>The<tt> removeAt</tt> public member function removes the element at the given index.&nbsp; All vector elements stored after
 the removed elements are copied (using<tt> Type's</tt> assignment operator) down one index.
<br>If the vector is empty and the<tt> empty_container</tt> exception is enabled, the exception is thrown.
<br><br>If an attempt to remove an element with a negative index is made and the<tt> index_range</tt> exception is enabled,
 the exception is thrown.&nbsp; If the exception is not enabled, the first element is removed from the vector.&nbsp; Attempting
 to remove an element with index greater or equal to the number of entries in the vector also causes the<tt> index_range</tt>
 exception to be thrown if enabled.&nbsp; The last element in the vector is removed if the exception is not enabled.
<dt><br>Results:
<dd>The<tt> removeAt</tt> public member function removes the element with the given index.&nbsp; If the index is invalid, the
 closest element to the given index is removed.&nbsp; A TRUE (non-zero) value is returned if an element was removed.&nbsp;
 If the vector was empty, FALSE (zero) value is returned.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> insertAt</tt>,<tt> operator &#91;&#93;</tt>,<tt> remove</tt>,<tt> removeAll</tt>,<tt> removeFirst</tt>,<tt>
 removeLast</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeFirstLR"> removeFirst() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int removeFirst();</tt>
<dt><br>Semantics:
<dd>The<tt> removeFirst</tt> public member function removes the first element from a vector.&nbsp; All other vector elements are
 copied (using<tt> Type's</tt> assignment operator) down one index.
<br>If the vector is empty and the<tt> empty_container</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>The<tt> removeFirst</tt> public member function removes the first element from the vector.&nbsp; A TRUE (non-zero) value is
 returned if an element was removed.&nbsp; If the vector was empty, FALSE (zero) value is returned.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> first</tt>,<tt> remove</tt>,<tt> removeAt</tt>,<tt> removeAll</tt>,<tt> removeLast</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY_WCValOrderedVectorXTypeY__removeLastLR"> removeLast() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int removeLast();</tt>
<dt><br>Semantics:
<dd>The<tt> removeLast</tt> public member function removes the last element from a vector.&nbsp; If the vector is empty and the<tt>
 empty_container</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>The<tt> removeLast</tt> public member function removes the last element from the vector.&nbsp; A TRUE (non-zero) value is
 returned if an element was removed.&nbsp; If the vector was empty, FALSE (zero) value is returned.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> last</tt>,<tt> remove</tt>,<tt> removeAt</tt>,<tt> removeAll</tt>,<tt> removeFirst</tt>
</dl>
<h2 id="WCValSortedVectorXTypeY__resizeLR__WCValOrderedVectorXTypeY__resizeLR"> resize() &#91;WCValSortedVector&lt;Type&gt;,WCValOrderedVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int resize( size_t new_size );</tt>
<dt><br>Semantics:
<dd>The<tt> resize</tt> public member function is used to change the vector size to be able to store<b> new_size</b> elements.
&nbsp; If<b> new_size</b> is larger than the previous vector size, all elements are copied (using<tt> Type's</tt> copy constructor)
 into the newly sized vector, and new elements can be added using the<tt> append, insert, insertAt,</tt> and<tt> prepend</tt>
 member functions.&nbsp; If the vector is resized to a smaller size, the first<b> new_size</b> elements are copied (all vector
 elements if the vector contained<b> new_size</b> or fewer elements).&nbsp; The remaining elements are destroyed using<tt>
 Type's</tt> destructor.
<br>If the resize cannot be performed and the<tt> out_of_memory</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>The vector is resized to<b> new_size</b>.&nbsp; A TRUE value (non-zero) is returned if the resize is successful.&nbsp; A FALSE
 (zero) result is returned if the resize fails.
<dt><br>See Also:
<dd><tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValVectorXTypeY_Class_Description"> WCValVector&lt;Type&gt; Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> wcvector.h</tt>
<br>The<tt> WCValVector&lt;Type&gt;</tt> class is a templated class used to store objects in a vector.&nbsp; Vectors are similar
 to arrays, but vectors perform bounds checking and can be resized.&nbsp; Elements are inserted into the vector by assigning
 to a vector index.
<br>The<tt> WCValOrderedVector</tt> and<tt> WCValSortedVector</tt> classes are also available.&nbsp; They provide a more abstract
 view of the vector and additional functionality, including finding and removing elements.
<br><br>Values are copied into the vector, which could be undesirable if the stored objects are complicated and copying is
 expensive.&nbsp; Value vectors should not be used to store objects of a base class if any derived types of different sizes
 would be stored in the vector, or if the destructor for a derived class must be called.
<br><br>In the description of each member function, the text<tt> Type</tt> is used to indicate the template parameter defining
 the type of the elements stored in the vector.
<br><br>The<tt> WCExcept</tt> class is a base class of the<tt> WCValVector&lt;Type&gt;</tt> class and provides the<tt> exceptions</tt>
 member function.&nbsp; This member function controls the exceptions which can be thrown by the<tt> WCValVector&lt;Type&gt;</tt>
 object.&nbsp; No exceptions are enabled unless they are set by the<tt> exceptions</tt> member function.
<br><br><b>Requirements of Type</b>
<br><br>The<tt> WCValVector&lt;Type&gt;</tt> class requires<tt> Type</tt> to have:
<br>A default constructor (<tt> Type::Type()</tt> ).
<br><br>A well defined copy constructor (<tt> Type::Type( const Type &amp; )</tt> ).
<br><br>The following override of<tt> operator new()</tt> only if<tt> Type</tt> overrides the global<tt> operator new():</tt>
<br><br><tt>void * operator new( size_t, void *ptr ) { return( ptr ); }</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>WCValVector( size_t = 0 );</tt>
<br><tt> WCValVector( size_t, const Type &amp; );</tt>
<br><tt> WCValVector( const WCValVector &amp; );</tt>
<br><tt> virtual ~WCValVector();</tt>
<br><tt> void clear();</tt>
<br><tt> size_t length() const;</tt>
<br><tt> int resize( size_t );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>Type &amp; operator &#91;&#93;( int );</tt>
<br><tt> const Type &amp; operator &#91;&#93;( int ) const;</tt>
<br><tt> WCValVector &amp; operator =( const WCValVector &amp; );</tt>
<br><tt> int operator ==( const WCValVector &amp; ) const;</tt>
</dl>
<h2 id="WCValVectorXTypeY__WCValVectorLR"> WCValVector() &#91;WCValVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValVector( size_t = 0 );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCValVector&lt;Type&gt;</tt> constructor creates a<tt> WCValVector&lt;Type&gt;</tt> object able to store the
 number of elements specified in the optional parameter, which defaults to zero.&nbsp; All vector elements are initialized
 with<tt> Type's</tt> default constructor.
<br>If the vector object cannot be fully initialized, the vector is created with length zero.
<dt><br>Results:
<dd>The public<tt> WCValVector&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValVector&lt;Type&gt;</tt> object with
 the specified length.
<dt><br>See Also:
<dd><tt> WCValVector&lt;Type&gt;</tt>,<tt> ~WCValVector&lt;Type&gt;</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValVector( size_t, const Type &amp; );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCValVector&lt;Type&gt;</tt> constructor creates a<tt> WCValVector&lt;Type&gt;</tt> object able to store the
 number of elements specified by the first parameter.&nbsp; All vector elements are initialized to the value of the second
 parameter using<tt> Type's</tt> copy constructor.
<br>If the vector object cannot be fully initialized, the vector is created with length zero.
<dt><br>Results:
<dd>The public<tt> WCValVector&lt;Type&gt;</tt> constructor creates an initialized<tt> WCValVector&lt;Type&gt;</tt> object with
 the specified length and elements set to the given value.
<dt><br>See Also:
<dd><tt> WCValVector&lt;Type&gt;</tt>,<tt> ~WCValVector&lt;Type&gt;</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValVector( const WCValVector &amp; );</tt>
<dt><br>Semantics:
<dd>The public<tt> WCValVector&lt;Type&gt;</tt> constructor is the copy constructor for the<tt> WCValVector&lt;Type&gt;</tt> class.
&nbsp; The new vector is created with the same length as the given vector.&nbsp; All of the vector elements and exception
 trap states are copied.
<br>If the new vector cannot be fully created, it will have length zero.&nbsp; The<tt> out_of_memory</tt> exception is thrown
 if enabled in the vector being copied.
<dt><br>Results:
<dd>The public<tt> WCValVector&lt;Type&gt;</tt> constructor creates a<tt> WCValVector&lt;Type&gt;</tt> object which is a copy
 of the passed vector.
<dt><br>See Also:
<dd><tt> operator =</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValVectorXTypeY____WCValVectorLR"> ~WCValVector() &#91;WCValVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ~WCValVector();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~WCValVector&lt;Type&gt;</tt> destructor is the destructor for the<tt> WCValVector&lt;Type&gt;</tt> class.
&nbsp; If the vector is not length zero and the<tt> not_empty</tt> exception is enabled, the exception is thrown.&nbsp; Otherwise,
 the vector elements are cleared using the<tt> clear</tt> member function.&nbsp; The call to the public<tt> ~WCValVector&lt;Type&gt;</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> WCValVector&lt;Type&gt;</tt> object goes out
 of scope.
<dt><br>Results:
<dd>The public<tt> ~WCValVector&lt;Type&gt;</tt> destructor destroys an<tt> WCValVector&lt;Type&gt;</tt> object.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::not_empty</tt>
</dl>
<h2 id="WCValVectorXTypeY__clearLR"> clear() &#91;WCValVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void clear();</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to clear the vector so that it is of zero length.&nbsp; Elements stored
 in the vector are destroyed using<tt> Type's</tt> destructor.&nbsp; The vector object is not destroyed and re-created by
 this function, so the object destructor is not invoked.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function clears the vector to have zero length and no vector elements.
<dt><br>See Also:
<dd><tt> ~WCValVector&lt;Type&gt;</tt>,<tt> operator =</tt>
</dl>
<h2 id="WCValVectorXTypeY__lengthLR"> length() &#91;WCValVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>size_t length() const;</tt>
<dt><br>Semantics:
<dd>The<tt> length</tt> public member function is used to find the number of elements which can be stored in the<tt> WCValVector&lt;Type&gt;</tt>
 object.
<dt><br>Results:
<dd>The<tt> length</tt> public member function returns the length of the vector.
<dt><br>See Also:
<dd><tt> resize</tt>
</dl>
<h2 id="WCValVectorXTypeY__operator_UVLR"> operator &#91;&#93;() &#91;WCValVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>Type &amp; operator &#91;&#93;( int );</tt>
<br><tt> const Type &amp; operator &#91;&#93;( int ) const;</tt>
<dt><br>Semantics:
<dd><tt> operator &#91;&#93;</tt> is the vector index operator.&nbsp; A reference to the object stored in the vector at the given
 index is returned.&nbsp; If a constant vector is indexed, a reference to a constant element is returned.&nbsp; The index
 operator of a non-constant vector is the only way to insert an element into the vector.
<br>If an attempt to access an element with index greater than or equal to the length of a non-constant vector is made and
 the<tt> resize_required</tt> exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled, the vector
 is automatically resized using the<tt> resize</tt> member function to have length the index value plus one.&nbsp; New vector
 elements are initialized using<tt> Type's</tt> default constructor.&nbsp; If the resize failed, and the<tt> out_of_memory</tt>
 exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled and the resize failed, the last element
 is indexed (a new element if the vector was zero length).&nbsp; If a negative value is used to index the non-constant vector
 and the<tt> index_range</tt> exception is enabled, the exception is thrown.&nbsp; If the exception is not enabled and the
 vector is empty, the<tt> resize_required</tt> exception may be thrown.
<br><br>An attempt to index an empty constant vector may cause one of two exceptions to be thrown.&nbsp; If the<tt> empty_container</tt>
 exception is enabled, it is thrown.&nbsp; Otherwise, the<tt> index_range</tt> exception is thrown, if enabled.&nbsp; If neither
 exception is enabled, a first vector element is added and indexed (so that a reference to a valid element can be returned).
<br><br>Indexing with a negative value or a value greater than or equal to the length of a constant vector causes the<tt>
 index_range</tt> exception to be thrown, if enabled.
<dt><br>Results:
<dd>The<tt> operator &#91;&#93;</tt> public member function returns a reference to the element at the given index.&nbsp; If the
 index is invalid, a reference to the closest valid element is returned.&nbsp; The result of the non-constant index operator
 may be assigned to.
<dt><br>See Also:
<dd><tt> resize</tt>,<tt> WCExcept::empty_container</tt>,<tt> WCExcept::index_range</tt>,<tt> WCExcept::out_of_memory</tt>,<tt>
 WCExcept::resize_required</tt>
</dl>
<h2 id="WCValVectorXTypeY__operator_ELR"> operator =() &#91;WCValVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>WCValVector &amp; operator =( const WCValVector &amp; );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function is the assignment operator for the<tt> WCValVector&lt;Type&gt;</tt> class.
&nbsp; The left hand side vector is first cleared using the<tt> clear</tt> member function, and then the right hand side vector
 is copied.&nbsp; The left hand side vector is made to have the same length as the right hand side.&nbsp; All of the vector
 elements and exception trap states are copied.
<br>If the left hand side vector cannot be fully created, it will have zero length.&nbsp; The<tt> out_of_memory</tt> exception
 is thrown if enabled in the right hand side vector.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function assigns the left hand side vector to be a copy of the right hand side.
<dt><br>See Also:
<dd><tt> clear</tt>,<tt> WCExcept::out_of_memory</tt>
</dl>
<h2 id="WCValVectorXTypeY__operator_EELR"> operator ==() &#91;WCValVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int operator ==( const WCValVector &amp; ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> public member function is the equivalence operator for the<tt> WCValVector&lt;Type&gt;</tt> class.
&nbsp; Two vector objects are equivalent if they are the same object and share the same address.
<dt><br>Results:
<dd>A TRUE (non-zero) value is returned if the left hand side and right hand side vectors are the same object.&nbsp; A FALSE (zero)
 value is returned otherwise.
</dl>
<h2 id="WCValVectorXTypeY__resizeLR"> resize() &#91;WCValVector&lt;Type&gt;&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;wcvector.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int resize( size_t new_size );</tt>
<dt><br>Semantics:
<dd>The<tt> resize</tt> public member function is used to change the vector size to be able to store<b> new_size</b> elements.
&nbsp; If<b> new_size</b> is larger than the previous vector size, all elements will be copied (using<tt> Type's</tt> copy
 constructor) into the newly sized vector, and new elements are initialized with<tt> Type's</tt> default constructor.&nbsp;
 If the vector is resized to a smaller size, the first<b> new_size</b> elements are copied.&nbsp; The remaining elements are
 destroyed using<tt> Type's</tt> destructor.
<br>If the resize cannot be performed and the<tt> out_of_memory</tt> exception is enabled, the exception is thrown.
<dt><br>Results:
<dd>The vector is resized to<b> new_size</b>.&nbsp; A TRUE value (non-zero) is returned if the resize is successful.&nbsp; A FALSE
 (zero) result is returned if the resize fails.
<dt><br>See Also:
<dd><tt> WCExcept::out_of_memory</tt>
</dl>
<h1 id="InputDOutput_Classes"> Input/Output Classes </h1>
<br>The input/output stream classes provide program access to the file system.&nbsp; In addition, various options for formatting
 of output and reading of input are provided.
<h2 id="filebuf_Class_Description"> filebuf Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> fstream.h</tt>
<dt><br>Derived from:
<dd><tt> streambuf</tt>
<br>The<tt> filebuf</tt> class is derived from the<tt> streambuf</tt> class, and provides additional functionality required
 to communicate with external files.&nbsp; Seek operations are supported when the underlying file supports seeking.&nbsp;
 Both input and output operations may be performed using a<tt> filebuf</tt> object, again when the underlying file supports
 read/write access.
<br><tt>filebuf</tt> objects are buffered by default, so the<b> reserve area</b> is allocated automatically unless one is
 specified when the<tt> filebuf</tt> object is created.&nbsp; The<b> get area</b> and<b> put area</b> pointers operate as
 if they were tied together.&nbsp; There is only one current position in a<tt> filebuf</tt> object.
<br><br>The<tt> filebuf</tt> class allows only the<b> get area</b> or the<b> put area</b>, but not both, to be active at a
 time.&nbsp; This follows from the capability of files opened for both reading and writing to have operations of each type
 performed at arbitrary locations in the file.&nbsp; When writing is occurring, the characters are buffered in the<b> put
 area</b>.&nbsp; If a seek or read operation is done, the<b> put area</b> must be flushed before the next operation in order
 to ensure that the characters are written to the proper location in the file.&nbsp; Similarly, if reading is occurring, characters
 are buffered in the<b> get area</b>.&nbsp; If a write operation is done, the<b> get area</b> must be flushed and synchronized
 before the write operation in order to ensure the write occurs at the proper location in the file.&nbsp; If a seek operation
 is done, the<b> get area</b> does not have to be synchronized, but is discarded.&nbsp; When the<b> get area</b> is empty
 and a read is done, the<tt> underflow</tt> virtual member function reads more characters and fills the<b> get area</b> again.
&nbsp; When the<b> put area</b> is full and a write is done, the<tt> overflow</tt> virtual member function writes the characters
 and makes the<b> put area</b> empty again.
<br><br>C++ programmers who wish to use files without deriving new objects do not need to explicitly create or use a<tt> filebuf</tt>
 object.
<br><br><b>Public Data Members</b>
<br><br>The following data member is declared in the public interface.&nbsp; Its value is the default file protection that
 is used when creating new files.&nbsp; It is primarily referenced as a default argument in member functions.
<br><br><tt>static int const openprot;</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>filebuf();</tt>
<br><tt> filebuf( filedesc );</tt>
<br><tt> filebuf( filedesc, char *, int );</tt>
<br><tt> ~filebuf();</tt>
<br><tt> int is_open() const;</tt>
<br><tt> filedesc fd() const;</tt>
<br><tt> filebuf *attach( filedesc );</tt>
<br><tt> filebuf *open( char const *,</tt>
<br><tt> ios::openmode,</tt>
<br><tt>int = filebuf::openprot );</tt>
<br><tt>filebuf *close();</tt>
<br><tt> virtual int pbackfail( int );</tt>
<br><tt> virtual int overflow( int = EOF );</tt>
<br><tt> virtual int underflow();</tt>
<br><tt> virtual streambuf *setbuf( char *, int );</tt>
<br><tt> virtual streampos seekoff( streamoff,</tt>
<br><tt> ios::seekdir,</tt>
<br><tt>ios::openmode );</tt>
<br><tt>virtual int sync();</tt>
<dt><br>See Also:
<dd><tt> fstreambase</tt>,<tt> streambuf</tt>
</dl>
<h2 id="filebuf__attachLR"> attach() &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>filebuf *filebuf::attach( filedesc hdl );</tt>
<dt><br>Semantics:
<dd>The<tt> attach</tt> public member function connects an existing<tt> filebuf</tt> object to an open file via the file's descriptor
 or handle specified by<b> hdl</b>.&nbsp; If the<tt> filebuf</tt> object is already connected to a file, the<tt> attach</tt>
 public member function fails.&nbsp; Otherwise, the<tt> attach</tt> public member function extracts information from the file
 system to determine the capabilities of the file and hence the<tt> filebuf</tt> object.
<dt><br>Results:
<dd>The<tt> attach</tt> public member function returns a pointer to the<tt> filebuf</tt> object on success, otherwise<tt> NULL</tt>
 is returned.
<dt><br>See Also:
<dd><tt> filebuf</tt>,<tt> fd</tt>,<tt> open</tt>
</dl>
<h2 id="filebuf__closeLR"> close() &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>filebuf *filebuf::close();</tt>
<dt><br>Semantics:
<dd>The<tt> close</tt> public member function disconnects the<tt> filebuf</tt> object from a connected file and closes the file.
&nbsp; Any buffered output is flushed before the file is closed.
<dt><br>Results:
<dd>The<tt> close</tt> public member function returns a pointer to the<tt> filebuf</tt> object on success, otherwise<tt> NULL</tt>
 is returned.
<dt><br>See Also:
<dd><tt> filebuf</tt>,<tt> fd</tt>,<tt> is_open</tt>
</dl>
<h2 id="filebuf__fdLR"> fd() &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>filedesc filebuf::fd() const;</tt>
<dt><br>Semantics:
<dd>The<tt> fd</tt> public member function queries the state of the<tt> filebuf</tt> object file handle.
<dt><br>Results:
<dd>The<tt> fd</tt> public member function returns the file descriptor or handle of the file to which the<tt> filebuf</tt> object
 is currently connected.&nbsp; If the<tt> filebuf</tt> object is not currently connected to a file,<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> filebuf::attach</tt>,<tt> is_open</tt>
</dl>
<h2 id="filebuf__filebufLR"> filebuf() &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>filebuf::filebuf();</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> filebuf</tt> constructor creates a<tt> filebuf</tt> object that is not currently connected to
 any file.&nbsp; A call to the<tt> fd</tt> member function for this created<tt> filebuf</tt> object returns<tt> EOF</tt>,
 unless a file is connected using the<tt> attach</tt> member function.
<dt><br>Results:
<dd>The public<tt> filebuf</tt> constructor produces a<tt> filebuf</tt> object that is not currently connected to any file.
<dt><br>See Also:
<dd><tt> ~filebuf</tt>,<tt> attach</tt>,<tt> open</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>filebuf::filebuf( filedesc hdl );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> filebuf</tt> constructor creates a<tt> filebuf</tt> object that is connected to an open file.
&nbsp; The file is specified via the<b> hdl</b> parameter, which is a file descriptor or handle.
<br>This form of the public<tt> filebuf</tt> constructor is similar to using the default constructor, and calling the<tt>
 attach</tt> member function.&nbsp; A call to the<tt> fd</tt> member function for this created<tt> filebuf</tt> object returns<b>
 hdl</b>.
<dt><br>Results:
<dd>The public<tt> filebuf</tt> constructor produces a<tt> filebuf</tt> object that is connected to<b> hdl</b>.
<dt><br>See Also:
<dd><tt> ~filebuf</tt>,<tt> attach</tt>,<tt> open</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>filebuf::filebuf( filedesc hdl, char *buf, int len );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> filebuf</tt> constructor creates a<tt> filebuf</tt> object that is connected to an open file and
 that uses the buffer specified by<b> buf</b> and<b> len</b>.&nbsp; The file is specified via the<b> hdl</b> parameter, which
 is a file descriptor or handle.&nbsp; If<b> buf</b> is<tt> NULL</tt> and/or<b> len</b> is less than or equal to zero, the<tt>
 filebuf</tt> object is unbuffered, so that reading and/or writing take place one character at a time.
<br>This form of the public<tt> filebuf</tt> constructor is similar to using the default constructor, and calling the<tt>
 attach</tt> and<tt> setbuf</tt> member functions.
<dt><br>Results:
<dd>The public<tt> filebuf</tt> constructor constructor produces a<tt> filebuf</tt> object that is connected to<b> hdl</b>.
<dt><br>See Also:
<dd><tt> ~filebuf</tt>,<tt> attach</tt>,<tt> open</tt>,<tt> setbuf</tt>
</dl>
<h2 id="filebuf____filebufLR"> ~filebuf() &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>filebuf::~filebuf();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~filebuf</tt> destructor closes the file if it was explicitly opened using the<tt> open</tt> member function.
&nbsp; Otherwise, the destructor takes no explicit action.&nbsp; The<tt> streambuf</tt> destructor is called to destroy that
 portion of the<tt> filebuf</tt> object.&nbsp; The call to the public<tt> ~filebuf</tt> destructor is inserted implicitly
 by the compiler at the point where the<tt> filebuf</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> filebuf</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> ~filebuf</tt>,<tt> close</tt>
</dl>
<h2 id="filebuf__is_openLR"> is_open() &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int filebuf::is_open();</tt>
<dt><br>Semantics:
<dd>The<tt> is_open</tt> public member function queries the<tt> filebuf</tt> object state.
<dt><br>Results:
<dd>The<tt> is_open</tt> public member function returns a non-zero value if the<tt> filebuf</tt> object is currently connected
 to a file.&nbsp; Otherwise, zero is returned.
<dt><br>See Also:
<dd><tt> filebuf::attach</tt>,<tt> close</tt>,<tt> fd</tt>,<tt> open</tt>
</dl>
<h2 id="filebuf__openLR"> open() &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>filebuf *filebuf::open( const char *name,</tt>
<br><tt> ios::openmode mode,</tt>
<br><tt>int prot = filebuf::openprot );</tt>
<dt><br>Semantics:
<dd>The<tt> open</tt> public member function is used to connect the<tt> filebuf</tt> object to a file specified by the<b> name</b>
 parameter.&nbsp; The file is opened using the specified<b> mode</b>.&nbsp; For details about the<b> mode</b> parameter, see
 the description of<tt> ios::openmode</tt>.&nbsp; The<b> prot</b> parameter specifies the file protection attributes to use
 when creating a file.
<dt><br>Results:
<dd>The<tt> open</tt> public member function returns a pointer to the<tt> filebuf</tt> object on success, otherwise<tt> NULL</tt>
 is returned.
<dt><br>See Also:
<dd><tt> filebuf</tt>,<tt> close</tt>,<tt> is_open</tt>,<tt> openprot</tt>
</dl>
<h2 id="filebuf__openprot"> openprot &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>static int const filebuf::openprot;</tt>
<dt><br>Semantics:
<dd>The<tt> openprot</tt> public member data is used to specify the default file protection to be used when creating new files.
&nbsp; This value is used as the default if no user specified value is provided.
<br>The default value is octal 0644.&nbsp; This is generally interpreted as follows:
<ul>
<li>Owner:&nbsp; read/write
<li>Group:&nbsp; read
<li>World:&nbsp; read
</ul>
<br>Note that not all operating systems support all bits.
<dt><br>See Also:
<dd><tt> filebuf</tt>,<tt> open</tt>
</dl>
<h2 id="filebuf__overflowLR"> overflow() &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int filebuf::overflow( int ch = EOF );</tt>
<dt><br>Semantics:
<dd>The<tt> overflow</tt> public virtual member function provides the output communication to the file to which the<tt> filebuf</tt>
 object is connected.&nbsp; Member functions in the<tt> streambuf</tt> class call the<tt> overflow</tt> public virtual member
 function for the derived class when the<b> put area</b> is full.
<br>The<tt> overflow</tt> public virtual member function performs the following steps:
<ol>
<li>If no buffer is present, a buffer is allocated with the<tt> streambuf::allocate</tt> member function, which may call the<tt>
 doallocate</tt> virtual member function.&nbsp; The<b> put area</b> is then set up.&nbsp; If, after calling<tt> streambuf::allocate</tt>,
 no buffer is present, the<tt> filebuf</tt> object is unbuffered and<b> ch</b> (if not<tt> EOF</tt>) is written directly to
 the file without buffering, and no further action is taken.
<li>If the<b> get area</b> is present, it is flushed with a call to the<tt> sync</tt> virtual member function.&nbsp; Note
 that the<b> get area</b> won't be present if a buffer was set up in step 1.
<li>If<b> ch</b> is not<tt> EOF</tt>, it is added to the<b> put area</b>, if possible.
<li>Any characters in the<b> put area</b> are written to the file.
<li>The<b> put area</b> pointers are updated to reflect the new state of the<b> put area</b>.&nbsp; If the write did not complete,
 the unwritten portion of the<b> put area</b> is still present.&nbsp; If the<b> put area</b> was full before the write,<b>
 ch</b> (if not<tt> EOF</tt>) is placed at the start of the<b> put area</b>.&nbsp; Otherwise, the<b> put area</b> is empty.
</ol>
<dt><br>Results:
<dd>The<tt> overflow</tt> public virtual member function returns<tt> __NOT_EOF</tt> on success, otherwise<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::overflow</tt>
<br><tt>filebuf::underflow</tt>
</dl>
<h2 id="filebuf__pbackfailLR"> pbackfail() &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int filebuf::pbackfail( int ch );</tt>
<dt><br>Semantics:
<dd>The<tt> pbackfail</tt> public virtual member function handles an attempt to put back a character when there is no room at
 the beginning of the<b> get area</b>.&nbsp; The<tt> pbackfail</tt> public virtual member function first calls the<tt> sync</tt>
 virtual member function to flush the<b> put area</b> and then it attempts to seek backwards over<b> ch</b> in the associated
 file.
<dt><br>Results:
<dd>The<tt> pbackfail</tt> public virtual member function returns<b> ch</b> on success, otherwise<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::pbackfail</tt>
</dl>
<h2 id="filebuf__seekoffLR"> seekoff() &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual streampos filebuf::seekoff( streamoff offset,</tt>
<br><tt> ios::seekdir dir,</tt>
<br><tt>ios::openmode mode );</tt>
<dt><br>Semantics:
<dd>The<tt> seekoff</tt> public virtual member function is used to position the<tt> filebuf</tt> object (and hence the file) to
 a particular offset so that subsequent input or output operations commence from that point.&nbsp; The offset is specified
 by the<b> offset</b> and<b> dir</b> parameters.
<br>Since the<b> get area</b> and<b> put area</b> pointers are tied together for the<tt> filebuf</tt> object, the<b> mode</b>
 parameter is ignored.
<br><br>Before the actual seek occurs, the<b> get area</b> and<b> put area</b> of the<tt> filebuf</tt> object are flushed
 via the<tt> sync</tt> virtual member function.&nbsp; Then, the new position in the file is calculated and the seek takes
 place.
<br><br>The<b> dir</b> parameter may be<tt> ios::beg</tt>,<tt> ios::cur</tt>, or<tt> ios::end</tt> and is interpreted in conjunction
 with the<b> offset</b> parameter as follows:
<br><br><tt>ios::beg</tt>&nbsp; the <b>offset</b> is relative to the start and should be a positive value.
<br><tt>ios::cur</tt>&nbsp; the <b>offset</b> is relative to the current position and may be positive
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (seek towards end) or negative (seek towards start).
<br><tt>ios::end</tt>&nbsp; the <b>offset</b> is relative to the end and should be a negative value.
<br><br>If the<b> dir</b> parameter has any other value, or the<b> offset</b> parameter does not have an appropriate sign,
 the<tt> seekoff</tt> public virtual member function fails.
<dt><br>Results:
<dd>The<tt> seekoff</tt> public virtual member function returns the new position in the file on success, otherwise<tt> EOF</tt>
 is returned.
<dt><br>See Also:
<dd><tt> streambuf::seekoff</tt>
</dl>
<h2 id="filebuf__setbufLR"> setbuf() &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual streambuf *filebuf::setbuf( char *buf, int len );</tt>
<dt><br>Semantics:
<dd>The<tt> setbuf</tt> public virtual member function is used to offer a buffer, specified by<b> buf</b> and<b> len</b> to the<tt>
 filebuf</tt> object.&nbsp; If the<b> buf</b> parameter is<tt> NULL</tt> or the<b> len</b> is less than or equal to zero,
 the request is to make the<tt> filebuf</tt> object unbuffered.
<br>If the<tt> filebuf</tt> object is already connected to a file and has a buffer, the offer is rejected.&nbsp; In other
 words, a call to the<tt> setbuf</tt> public virtual member function after the<tt> filebuf</tt> object has started to be used
 usually fails because the<tt> filebuf</tt> object has set up a buffer.
<br><br>If the request is to make the<tt> filebuf</tt> object unbuffered, the offer succeeds.
<br><br>If the<b> buf</b> is too small (less than five characters), the offer is rejected.&nbsp; Five characters are required
 to support the default putback area.
<br><br>Otherwise, the<b> buf</b> is acceptable and the offer succeeds.
<br><br>If the offer succeeds, the<tt> streambuf::setb</tt> member function is called to set up the pointers to the buffer.
&nbsp; The<tt> streambuf::setb</tt> member function releases the old buffer (if present), depending on how that buffer was
 allocated.
<br><br>Calls to the<tt> setbuf</tt> public virtual member function are usually made by a class derived from the<tt> fstream</tt>
 class, not directly by a user program.
<dt><br>Results:
<dd>The<tt> setbuf</tt> public virtual member function returns a pointer to the<tt> filebuf</tt> object on success, otherwise<tt>
 NULL</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::setbuf</tt>
</dl>
<h2 id="filebuf__syncLR"> sync() &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int filebuf::sync();</tt>
<dt><br>Semantics:
<dd>The<tt> sync</tt> public virtual member function synchronizes the<tt> filebuf</tt> object with the external file or device.
&nbsp; If the<b> put area</b> contains characters it is flushed.&nbsp; This leaves the file positioned after the last written
 character.&nbsp; If the<b> get area</b> contains buffered (unread) characters, file is backed up to be positioned after the
 last read character.
<br>Note that the<b> get area</b> and<b> put area</b> never both contain characters.
<dt><br>Results:
<dd>The<tt> sync</tt> public virtual member function returns<tt> __NOT_EOF</tt> on success, otherwise<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::sync</tt>
</dl>
<h2 id="filebuf__underflowLR"> underflow() &#91;filebuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int filebuf::underflow();</tt>
<dt><br>Semantics:
<dd>The<tt> underflow</tt> public virtual member function provides the input communication from the file to which the<tt> filebuf</tt>
 object is connected.&nbsp; Member functions in the<tt> streambuf</tt> class call the<tt> underflow</tt> public virtual member
 function for the derived class when the<b> get area</b> is empty.
<br>The<tt> underflow</tt> public virtual member function performs the following steps:
<ol>
<li>If no<b> reserve area</b> is present, a buffer is allocated with the<tt> streambuf::allocate</tt> member function, which
 may call the<tt> doallocate</tt> virtual member function.&nbsp; If, after calling<tt> allocate</tt>, no<b> reserve area</b>
 is present, the<tt> filebuf</tt> object is unbuffered and a one-character<b> reserve area</b> (plus putback area) is set
 up to do unbuffered input.&nbsp; This buffer is embedded in the<tt> filebuf</tt> object.&nbsp; The<b> get area</b> is set
 up as empty.
<li>If the<b> put area</b> is present, it is flushed using the<tt> sync</tt> virtual member function.
<li>The unused part of the<b> get area</b> is used to read characters from the file connected to the<tt> filebuf</tt> object.
&nbsp; The<b> get area</b> pointers are then set up to reflect the new<b> get area</b>.
</ol>
<dt><br>Results:
<dd>The<tt> underflow</tt> public virtual member function returns the first unread character of the<b> get area</b>, on success,
 otherwise<tt> EOF</tt> is returned.&nbsp; Note that the<b> get pointer</b> is not advanced on success.
<dt><br>See Also:
<dd><tt> streambuf::underflow</tt>
<br><tt>filebuf::overflow</tt>
</dl>
<h2 id="fstream_Class_Description"> fstream Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> fstream.h</tt>
<dt><br>Derived from:
<dd><tt> fstreambase</tt>,<tt> iostream</tt>
<br>The<tt> fstream</tt> class is used to access files for reading and writing.&nbsp; The file can be opened and closed, and
 read, write and seek operations can be performed.
<br>The<tt> fstream</tt> class provides very little of its own functionality.&nbsp; It is derived from both the<tt> fstreambase</tt>
 and<tt> iostream</tt> classes.&nbsp; The<tt> fstream</tt> constructors, destructor and member function provide simplified
 access to the appropriate equivalents in the base classes.
<br><br>Of the available I/O stream classes, creating an<tt> fstream</tt> object is the preferred method of accessing a file
 for both input and output.
<br><br><b>Public Member Functions</b>
<br><br>The following public member functions are declared:
<br><br><tt>fstream();</tt>
<br><tt> fstream( char const *,</tt>
<br><tt> ios::openmode = ios::in|ios::out,</tt>
<br><tt>int = filebuf::openprot );</tt>
<br><tt>fstream( filedesc );</tt>
<br><tt> fstream( filedesc, char *, int );</tt>
<br><tt> ~fstream();</tt>
<br><tt> void open( char const *,</tt>
<br><tt> ios::openmode = ios::in|ios::out,</tt>
<br><tt>int = filebuf::openprot );</tt>
<dt><br>See Also:
<dd><tt> fstreambase</tt>,<tt> ifstream</tt>,<tt> iostream</tt>,<tt> ofstream</tt>
</dl>
<h2 id="fstream__fstreamLR"> fstream() &#91;fstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>fstream::fstream();</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> fstream</tt> constructor creates an<tt> fstream</tt> object that is not connected to a file.&nbsp;
 The<tt> open</tt> or<tt> attach</tt> member functions should be used to connect the<tt> fstream</tt> object to a file.
<dt><br>Results:
<dd>The public<tt> fstream</tt> constructor produces an<tt> fstream</tt> object that is not connected to a file.
<dt><br>See Also:
<dd><tt> ~fstream</tt>,<tt> open</tt>,<tt> fstreambase::attach</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>fstream::fstream( const char *name,</tt>
<br><tt> ios::openmode mode = ios::in|ios::out,</tt>
<br><tt>int prot = filebuf::openprot );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> fstream</tt> constructor creates an<tt> fstream</tt> object that is connected to the file specified
 by the<b> name</b> parameter, using the specified<b> mode</b> and<b> prot</b> parameters.&nbsp; The connection is made via
 the C library<tt> open</tt> function.
<dt><br>Results:
<dd>The public<tt> fstream</tt> constructor produces an<tt> fstream</tt> object that is connected to the file specified by<b>
 name</b>.&nbsp; If the<tt> open</tt> fails,<tt> ios::failbit</tt> and<tt> ios::badbit</tt> are set in the error state in
 the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~fstream</tt>,<tt> open</tt>,<tt> openmode</tt>,<tt> openprot</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>fstream::fstream( filedesc hdl );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> fstream</tt> constructor creates an<tt> fstream</tt> object that is attached to the file specified
 by the<b> hdl</b> parameter.
<dt><br>Results:
<dd>The public<tt> fstream</tt> constructor produces an<tt> fstream</tt> object that is attached to<b> hdl</b>.&nbsp; If the attach
 fails,<tt> ios::failbit</tt> and<tt> ios::badbit</tt> are set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~fstream</tt>,<tt> fstreambase::attach</tt>,<tt> fstreambase::fd</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>fstream::fstream( filedesc hdl, char *buf, int len );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> fstream</tt> constructor creates an<tt> fstream</tt> object that is connected to the file specified
 by the<b> hdl</b> parameter.&nbsp; The buffer specified by the<b> buf</b> and<b> len</b> parameters is offered to the associated<tt>
 filebuf</tt> object via the<tt> setbuf</tt> member function.&nbsp; If the<b> buf</b> parameter is<tt> NULL</tt> or the<b>
 len</b> is less than or equal to zero, the<tt> filebuf</tt> is unbuffered, so that each read or write operation reads or
 writes a single character at a time.
<dt><br>Results:
<dd>The public<tt> fstream</tt> constructor produces an<tt> fstream</tt> object that is attached to<b> hdl</b>.&nbsp; If the connection
 to<b> hdl</b> fails,<tt> ios::failbit</tt> and<tt> ios::badbit</tt> are set in the error state in the inherited<tt> ios</tt>
 object.&nbsp; If the<tt> setbuf</tt> fails,<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt>
 object.
<dt><br>See Also:
<dd><tt> ~fstream</tt>,<tt> filebuf::setbuf</tt>,<tt> fstreambase::attach</tt>
</dl>
<h2 id="fstream____fstreamLR"> ~fstream() &#91;fstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>fstream::~fstream();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~fstream</tt> destructor does not do anything explicit.&nbsp; The call to the public<tt> ~fstream</tt> destructor
 is inserted implicitly by the compiler at the point where the<tt> fstream</tt> object goes out of scope.
<dt><br>Results:
<dd>The public<tt> ~fstream</tt> destructor destroys the<tt> fstream</tt> object.
<dt><br>See Also:
<dd><tt> fstream</tt>
</dl>
<h2 id="fstream__openLR"> open() &#91;fstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void fstream::open( const char *name,</tt>
<br><tt> ios::openmode mode = ios::in|ios::out,</tt>
<br><tt>int prot = filebuf::openprot );</tt>
<dt><br>Semantics:
<dd>The<tt> open</tt> public member function connects the<tt> fstream</tt> object to the file specified by the<b> name</b> parameter,
 using the specified<b> mode</b> and<b> prot</b> parameters.&nbsp; The<tt> mode</tt> parameter is optional and usually is
 not specified unless additional bits (such as<tt> ios::binary</tt> or<tt> ios::text</tt>) are to be specified.&nbsp; The
 connection is made via the C library<tt> open</tt> function.
<dt><br>Results:
<dd>If the open fails,<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> fstreambase::attach</tt>,<tt> fstreambase::close</tt>,<tt> fstreambase::fd</tt>,<tt> fstreambase::is_open</tt>
<br><tt>fstream::openmode</tt>,<tt> openprot</tt>
</dl>
<h2 id="fstreambase_Class_Description"> fstreambase Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> fstream.h</tt>
<dt><br>Derived from:
<dd><tt> ios</tt>
<dt><br>Derived by:
<dd><tt> ifstream</tt>,<tt> ofstream</tt>,<tt> fstream</tt>
<br>The<tt> fstreambase</tt> class is a base class that provides common functionality for the three file-based classes,<tt>
 ifstream</tt>,<tt> ofstream</tt> and<tt> fstream</tt>.&nbsp; The<tt> fstreambase</tt> class is derived from the<tt> ios</tt>
 class, providing the stream state information, plus it provides member functions for opening and closing files.&nbsp; The
 actual file manipulation work is performed by the<tt> filebuf</tt> class.
<br>It is not intended that<tt> fstreambase</tt> objects be created.&nbsp; Instead, the user should create an<tt> ifstream</tt>,<tt>
 ofstream</tt> or<tt> fstream</tt> object.
<br><br><b>Protected Member Functions</b>
<br><br>The following member functions are declared in the protected interface:
<br><br><tt>fstreambase();</tt>
<br><tt> fstreambase( char const *,</tt>
<br><tt> ios::openmode,</tt>
<br><tt>int = filebuf::openprot );</tt>
<br><tt>fstreambase( filedesc );</tt>
<br><tt> fstreambase( filedesc, char *, int );</tt>
<br><tt> ~fstreambase();</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>void attach( filedesc );</tt>
<br><tt> void close();</tt>
<br><tt> filedesc fd() const;</tt>
<br><tt> int is_open() const;</tt>
<br><tt> void open( char const *,</tt>
<br><tt> ios::openmode,</tt>
<br><tt>int = filebuf::openprot );</tt>
<br><tt>filebuf *rdbuf() const;</tt>
<br><tt> void setbuf( char *, int );</tt>
<dt><br>See Also:
<dd><tt> filebuf</tt>,<tt> fstream</tt>,<tt> ifstream</tt>,<tt> ofstream</tt>
</dl>
<h2 id="fstreambase__attachLR"> attach() &#91;fstreambase&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void fstreambase::attach( filedesc hdl );</tt>
<dt><br>Semantics:
<dd>The<tt> attach</tt> public member function connects the<tt> fstreambase</tt> object to the file specified by the<b> hdl</b>
 parameter.
<dt><br>Results:
<dd>If the<tt> attach</tt> public member function fails,<tt> ios::failbit</tt> bit is set in the error state in the inherited<tt>
 ios</tt> object.&nbsp; The error state in the inherited<tt> ios</tt> object is cleared on success.
<dt><br>See Also:
<dd><tt> fstreambase::fd</tt>,<tt> is_open</tt>,<tt> open</tt>
</dl>
<h2 id="fstreambase__closeLR"> close() &#91;fstreambase&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void fstreambase::close();</tt>
<dt><br>Semantics:
<dd>The<tt> close</tt> public member function disconnects the<tt> fstreambase</tt> object from the file with which it is associated.
&nbsp; If the<tt> fstreambase</tt> object is not associated with a file, the<tt> close</tt> public member function fails.
<dt><br>Results:
<dd>If the<tt> close</tt> public member function fails,<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt>
 object.
<dt><br>See Also:
<dd><tt> fstreambase::fd</tt>,<tt> is_open</tt>,<tt> open</tt>
</dl>
<h2 id="fstreambase__fstreambaseLR"> fstreambase() &#91;fstreambase&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>fstreambase::fstreambase();</tt>
<dt><br>Semantics:
<dd>The protected<tt> fstreambase</tt> constructor creates an<tt> fstreambase</tt> object that is initialized, but not connected
 to anything.&nbsp; The<tt> open</tt> or<tt> attach</tt> member function should be used to connect the<tt> fstreambase</tt>
 object to a file.
<dt><br>Results:
<dd>The protected<tt> fstreambase</tt> constructor produces an<tt> fstreambase</tt> object.
<dt><br>See Also:
<dd><tt> ~fstreambase</tt>,<tt> attach</tt>,<tt> open</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>fstreambase::fstreambase( char const *name,</tt>
<br><tt> ios::openmode mode,</tt>
<br><tt>int prot = filebuf::openprot );</tt>
<dt><br>Semantics:
<dd>This protected<tt> fstreambase</tt> constructor creates an<tt> fstreambase</tt> object that is initialized and connected to
 the file indicated by<b> name</b> using the specified<b> mode</b> and<b> prot</b>.&nbsp; The<tt> fstreambase</tt> object
 is connected to the specified file via the<tt> open</tt> C library function.
<dt><br>Results:
<dd>The protected<tt> fstreambase</tt> constructor produces an<tt> fstreambase</tt> object.&nbsp; If the call to<tt> open</tt>
 for the file fails,<tt> ios::failbit</tt> and<tt> ios::badbit</tt> are set in the error state in the inherited<tt> ios</tt>
 object.
<dt><br>See Also:
<dd><tt> ~fstreambase</tt>,<tt> open</tt>,<tt> openmode</tt>,<tt> openprot</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>fstreambase::fstreambase( filedesc hdl );</tt>
<dt><br>Semantics:
<dd>This protected<tt> fstreambase</tt> constructor creates an<tt> fstreambase</tt> object that is initialized and connected to
 the open file specified by the<b> hdl</b> parameter.
<dt><br>Results:
<dd>The protected<tt> fstreambase</tt> constructor produces an<tt> fstreambase</tt> object.&nbsp; If the attach to the file fails,<tt>
 ios::failbit</tt> and<tt> ios::badbit</tt> are set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~fstreambase</tt>,<tt> attach</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>fstreambase::fstreambase( filedesc hdl, char *buf, int len );</tt>
<dt><br>Semantics:
<dd>This protected<tt> fstreambase</tt> constructor creates an<tt> fstreambase</tt> object that is initialized and connected to
 the open file specified by the<b> hdl</b> parameter.&nbsp; The buffer, specified by the<b> buf</b> and<b> len</b> parameters,
 is offered via the<tt> setbuf</tt> virtual member function to be used as the<b> reserve area</b> for the<tt> filebuf</tt>
 associated with the<tt> fstreambase</tt> object.
<dt><br>Results:
<dd>The protected<tt> fstreambase</tt> constructor produces an<tt> fstreambase</tt> object.&nbsp; If the attach to the file fails,<tt>
 ios::failbit</tt> and<tt> ios::badbit</tt> are set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~fstreambase</tt>,<tt> attach</tt>,<tt> setbuf</tt>
</dl>
<h2 id="fstreambase____fstreambaseLR"> ~fstreambase() &#91;fstreambase&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>fstreambase::~fstreambase();</tt>
<dt><br>Semantics:
<dd>The protected<tt> ~fstreambase</tt> destructor does not do anything explicit.&nbsp; The<tt> filebuf</tt> object associated
 with the<tt> fstreambase</tt> object is embedded within the<tt> fstreambase</tt> object, so the<tt> filebuf</tt> destructor
 is called.&nbsp; The<tt> ios</tt> destructor is called for that portion of the<tt> fstreambase</tt> object.&nbsp; The call
 to the protected<tt> ~fstreambase</tt> destructor is inserted implicitly by the compiler at the point where the<tt> fstreambase</tt>
 object goes out of scope.
<dt><br>Results:
<dd>The<tt> fstreambase</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> fstreambase</tt>,<tt> close</tt>
</dl>
<h2 id="fstreambase__is_openLR"> is_open() &#91;fstreambase&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int fstreambase::is_open() const;</tt>
<dt><br>Semantics:
<dd>The<tt> is_open</tt> public member function queries the current state of the file associated with the<tt> fstreambase</tt>
 object.&nbsp; Calling the<tt> is_open</tt> public member function is equivalent to calling the<tt> fd</tt> member function
 and testing for<tt> EOF</tt>.
<dt><br>Results:
<dd>The<tt> is_open</tt> public member function returns a non-zero value if the<tt> fstreambase</tt> object is currently connected
 to a file, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> fstreambase::attach</tt>,<tt> fd</tt>,<tt> open</tt>
</dl>
<h2 id="fstreambase__fdLR"> fd() &#91;fstreambase&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>filedesc fstreambase::fd() const;</tt>
<dt><br>Semantics:
<dd>The<tt> fd</tt> public member function returns the file descriptor for the file to which the<tt> fstreambase</tt> object is
 connected.
<dt><br>Results:
<dd>The<tt> fd</tt> public member function returns the file descriptor for the file to which the<tt> fstreambase</tt> object is
 connected.&nbsp; If the<tt> fstreambase</tt> object is not currently connected to a file,<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> fstreambase::attach</tt>,<tt> is_open</tt>,<tt> open</tt>
</dl>
<h2 id="fstreambase__openLR"> open() &#91;fstreambase&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void fstreambase::open( const char *name,</tt>
<br><tt> ios::openmode mode,</tt>
<br><tt>int prot = filebuf::openprot );</tt>
<dt><br>Semantics:
<dd>The<tt> open</tt> public member function connects the<tt> fstreambase</tt> object to the file specified by<b> name</b>, using
 the specified<b> mode</b> and<b> prot</b>.&nbsp; The connection is made via the C library<tt> open</tt> function.
<dt><br>Results:
<dd>If the open fails,<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt> object.&nbsp; The error state
 in the inherited<tt> ios</tt> object is cleared on success.
<dt><br>See Also:
<dd><tt> fstreambase::attach</tt>,<tt> close</tt>,<tt> fd</tt>,<tt> is_open</tt>,<tt> openmode</tt>,<tt> openprot</tt>
</dl>
<h2 id="fstreambase__rdbufLR"> rdbuf() &#91;fstreambase&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>filebuf *fstreambase::rdbuf() const;</tt>
<dt><br>Semantics:
<dd>The<tt> rdbuf</tt> public member function returns the address of the<tt> filebuf</tt> object currently associated with the<tt>
 fstreambase</tt> object.
<dt><br>Results:
<dd>The<tt> rdbuf</tt> public member function returns a pointer to the<tt> filebuf</tt> object currently associated with the<tt>
 fstreambase</tt> object If there is no associated<tt> filebuf</tt>,<tt> NULL</tt> is returned.
<dt><br>See Also:
<dd><tt> ios::rdbuf</tt>
</dl>
<h2 id="fstreambase__setbufLR"> setbuf() &#91;fstreambase&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void fstreambase::setbuf( char *buf, int len );</tt>
<dt><br>Semantics:
<dd>The<tt> setbuf</tt> public member function offers the specified buffer to the<tt> filebuf</tt> object associated with the<tt>
 fstreambase</tt> object.&nbsp; The<tt> filebuf</tt> may or may not reject the offer, depending upon its state.
<dt><br>Results:
<dd>If the offer is rejected,<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> filebuf::setbuf</tt>
</dl>
<h2 id="ifstream_Class_Description"> ifstream Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> fstream.h</tt>
<dt><br>Derived from:
<dd><tt> fstreambase</tt>,<tt> istream</tt>
<br>The<tt> ifstream</tt> class is used to access existing files for reading.&nbsp; Such files can be opened and closed, and
 read and seek operations can be performed.
<br>The<tt> ifstream</tt> class provides very little of its own functionality.&nbsp; Derived from both the<tt> fstreambase</tt>
 and<tt> istream</tt> classes, its constructors, destructor and member functions provide simplified access to the appropriate
 equivalents in those base classes.
<br><br>Of the available I/O stream classes, creating an<tt> ifstream</tt> object is the preferred method of accessing a file
 for input only operations.
<br><br><b>Public Member Functions</b>
<br><br>The following public member functions are declared:
<br><br><tt>ifstream();</tt>
<br><tt> ifstream( char const *,</tt>
<br><tt> ios::openmode = ios::in,</tt>
<br><tt>int = filebuf::openprot );</tt>
<br><tt>ifstream( filedesc );</tt>
<br><tt> ifstream( filedesc, char *, int );</tt>
<br><tt> ~ifstream();</tt>
<br><tt> void open( char const *,</tt>
<br><tt> ios::openmode = ios::in,</tt>
<br><tt>int = filebuf::openprot );</tt>
<dt><br>See Also:
<dd><tt> fstream</tt>,<tt> fstreambase</tt>,<tt> istream</tt>,<tt> ofstream</tt>
</dl>
<h2 id="ifstream__ifstreamLR"> ifstream() &#91;ifstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ifstream::ifstream();</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> ifstream</tt> constructor creates an<tt> ifstream</tt> object that is not connected to a file.
&nbsp; The<tt> open</tt> or<tt> attach</tt> member functions should be used to connect the<tt> ifstream</tt> object to a file.
<dt><br>Results:
<dd>The public<tt> ifstream</tt> constructor produces an<tt> ifstream</tt> object that is not connected to a file.
<dt><br>See Also:
<dd><tt> ~ifstream</tt>,<tt> open</tt>,<tt> fstreambase::attach</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ifstream::ifstream( const char *name,</tt>
<br><tt> ios::openmode mode = ios::in,</tt>
<br><tt>int prot = filebuf::openprot );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> ifstream</tt> constructor creates an<tt> ifstream</tt> object that is connected to the file specified
 by the<b> name</b> parameter, using the specified<b> mode</b> and<b> prot</b> parameters.&nbsp; The connection is made via
 the C library<tt> open</tt> function.
<dt><br>Results:
<dd>The public<tt> ifstream</tt> constructor produces an<tt> ifstream</tt> object that is connected to the file specified by<b>
 name</b>.&nbsp; If the<tt> open</tt> fails,<tt> ios::failbit</tt> and<tt> ios::badbit</tt> are set in the error state in
 the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~ifstream</tt>,<tt> open</tt>,<tt> openmode</tt>,<tt> openprot</tt>,<tt> fstreambase::attach</tt>,<tt> fstreambase::fd</tt>,<tt>
 fstreambase::is_open</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ifstream::ifstream( filedesc hdl );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> ifstream</tt> constructor creates an<tt> ifstream</tt> object that is attached to the file specified
 by the<b> hdl</b> parameter.
<dt><br>Results:
<dd>The public<tt> ifstream</tt> constructor produces an<tt> ifstream</tt> object that is attached to<b> hdl</b>.&nbsp; If the
 attach fails,<tt> ios::failbit</tt> and<tt> ios::badbit</tt> are set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> fstreambase::attach</tt>
<br><tt>~ifstream</tt>,<tt> open</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ifstream::ifstream( filedesc hdl, char *buf, int len );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> ifstream</tt> constructor creates an<tt> ifstream</tt> object that is connected to the file specified
 by the<b> hdl</b> parameter.&nbsp; The buffer specified by the<b> buf</b> and<b> len</b> parameters is offered to the associated<tt>
 filebuf</tt> object via the<tt> setbuf</tt> member function.&nbsp; If the<b> buf</b> parameter is<tt> NULL</tt> or the<b>
 len</b> is less than or equal to zero, the<tt> filebuf</tt> is unbuffered, so that each read or write operation reads or
 writes a single character at a time.
<dt><br>Results:
<dd>The public<tt> ifstream</tt> constructor produces an<tt> ifstream</tt> object that is attached to<b> hdl</b>.&nbsp; If the
 connection to<b> hdl</b> fails,<tt> ios::failbit</tt> and<tt> ios::badbit</tt> are set in the error state in the inherited<tt>
 ios</tt> object.&nbsp; If the<tt> setbuf</tt> fails,<tt> ios::failbit</tt> is set in the error state in the inherited<tt>
 ios</tt> object.
<dt><br>See Also:
<dd><tt> fstreambase::attach</tt>,<tt> fstreambase::setbuf</tt>
<br><tt>~ifstream</tt>,<tt> open</tt>
</dl>
<h2 id="ifstream____ifstreamLR"> ~ifstream() &#91;ifstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ifstream::~ifstream();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~ifstream</tt> destructor does not do anything explicit.&nbsp; The call to the public<tt> ~ifstream</tt> destructor
 is inserted implicitly by the compiler at the point where the<tt> ifstream</tt> object goes out of scope.
<dt><br>Results:
<dd>The public<tt> ~ifstream</tt> destructor destroys the<tt> ifstream</tt> object.
<dt><br>See Also:
<dd><tt> ifstream</tt>
</dl>
<h2 id="ifstream__openLR"> open() &#91;ifstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void ifstream::open( const char *name,</tt>
<br><tt> ios::openmode mode = ios::in,</tt>
<br><tt>int prot = filebuf::openprot );</tt>
<dt><br>Semantics:
<dd>The<tt> open</tt> public member function connects the<tt> ifstream</tt> object to the file specified by the<b> name</b> parameter,
 using the specified<b> mode</b> and<b> prot</b> parameters.&nbsp; The<tt> mode</tt> parameter is optional and usually is
 not specified unless additional bits (such as<tt> ios::binary</tt> or<tt> ios::text</tt>) are to be specified.&nbsp; The
 connection is made via the C library<tt> open</tt> function.
<dt><br>Results:
<dd>If the open fails,<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> fstreambase::attach</tt>,<tt> fstreambase::close</tt>,<tt> fstreambase::fd</tt>,<tt> fstreambase::is_open</tt>
<br><tt>ifstream::openmode</tt>,<tt> openprot</tt>
</dl>
<h2 id="ios_Class_Description"> ios Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> iostream.h</tt>
<dt><br>Derived by:
<dd><tt> istream</tt>,<tt> ostream</tt>
<br>The<tt> ios</tt> class is used to group together common functionality needed for other derived stream classes.&nbsp; It
 is not intended that objects of type<tt> ios</tt> be created.
<br>This class maintains state information about the stream.&nbsp; (the<tt> ios</tt> name can be thought of as a short-form
 for I/O State).&nbsp; Error flags, formatting flags, and values and the connection to the buffers used for the input and
 output are all maintained by the<tt> ios</tt> class.&nbsp; No information about the buffer itself is stored in an<tt> ios</tt>
 object, merely the pointer to the buffer information.
<br><br><b>Protected Member Functions</b>
<br><br>The following member functions are declared in the protected interface:
<br><br><tt>ios();</tt>
<br><tt> void init( streambuf * );</tt>
<br><tt> void setstate( ios::iostate );</tt>
<br><br><b>Public Enumerations</b>
<br><br>The following enumeration typedefs are declared in the public interface:
<br><br><tt>typedef int&nbsp; iostate;</tt>
<br><tt>typedef long fmtflags;</tt>
<br><tt>typedef int&nbsp; openmode;</tt>
<br><tt>typedef int&nbsp; seekdir;</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>ios( streambuf * );</tt>
<br><tt> virtual ~ios();</tt>
<br><tt> ostream *tie() const;</tt>
<br><tt> ostream *tie( ostream * );</tt>
<br><tt> streambuf *rdbuf() const;</tt>
<br><tt> ios::iostate rdstate() const;</tt>
<br><tt> ios::iostate clear( ios::iostate = 0 );</tt>
<br><tt> int good() const;</tt>
<br><tt> int bad() const;</tt>
<br><tt> int fail() const;</tt>
<br><tt> int eof() const;</tt>
<br><tt> ios::iostate exceptions( ios::iostate );</tt>
<br><tt> ios::iostate exceptions() const;</tt>
<br><tt> ios::fmtflags setf( ios::fmtflags, ios::fmtflags );</tt>
<br><tt> ios::fmtflags setf( ios::fmtflags );</tt>
<br><tt> ios::fmtflags unsetf( ios::fmtflags );</tt>
<br><tt> ios::fmtflags flags( ios::fmtflags );</tt>
<br><tt> ios::fmtflags flags() const;</tt>
<br><tt> char fill( char );</tt>
<br><tt> char fill() const;</tt>
<br><tt> int precision( int );</tt>
<br><tt> int precision() const;</tt>
<br><tt> int width( int );</tt>
<br><tt> int width() const;</tt>
<br><tt> long &amp;iword( int );</tt>
<br><tt> void *&amp;pword( int );</tt>
<br><tt> static void sync_with_stdio();</tt>
<br><tt> static ios::fmtflags bitalloc();</tt>
<br><tt> static int xalloc();</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following member operators are declared in the public interface:
<br><br><tt>operator void *() const;</tt>
<br><tt> int operator !() const;</tt>
<dt><br>See Also:
<dd><tt> iostream</tt>,<tt> istream</tt>,<tt> ostream</tt>,<tt> streambuf</tt>
</dl>
<h2 id="ios__badLR"> bad() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int ios::bad() const;</tt>
<dt><br>Semantics:
<dd>The<tt> bad</tt> public member function queries the state of the<tt> ios</tt> object.
<dt><br>Results:
<dd>The<tt> bad</tt> public member function returns a non-zero value if<tt> ios::badbit</tt> is set in the error state in the
 inherited<tt> ios</tt> object, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> ios::clear</tt>,<tt> eof</tt>,<tt> fail</tt>,<tt> good</tt>,<tt> iostate</tt>,<tt> operator !</tt>,<tt> operator void
 *</tt>,<tt> rdstate</tt>,<tt> setstate</tt>
</dl>
<h2 id="ios__bitallocLR"> bitalloc() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>static ios::fmtflags ios::bitalloc();</tt>
<dt><br>Semantics:
<dd>The<tt> bitalloc</tt> public static member function is used to allocate a new<tt> ios::fmtflags</tt> bit for use by user derived
 classes.
<br>Because the<tt> bitalloc</tt> public static member function manipulates<tt> static</tt> member data, its behavior is not
 tied to any one object but affects the entire class of objects.&nbsp; The value that is returned by the<tt> bitalloc</tt>
 public static member function is valid for all objects of all classes derived from the<tt> ios</tt> class.&nbsp; No subsequent
 call to the<tt> bitalloc</tt> public static member function will return the same value as a previous call.
<br><br>The bit value allocated may be used with the member functions that query and affect<tt> ios::fmtflags</tt>.&nbsp;
 In particular, the bit can be set with the<tt> setf</tt> or<tt> flags</tt> member functions or the<tt> setiosflags</tt> manipulator,
 and reset with the<tt> unsetf</tt> or<tt> flags</tt> member functions or the<tt> resetiosflags</tt> manipulator.
<br><br>There are two constants defined in<tt> &lt;iostream.h&gt;</tt> which indicate the number of bits available when a
 program starts.<tt>&nbsp; _LAST_FORMAT_FLAG</tt> indicates the last bit used by the built-in format flags described by<tt>
 ios::fmtflags</tt>.<tt>&nbsp; _LAST_FLAG_BIT</tt> indicates the last bit that is available for the<tt> bitalloc</tt> public
 static member function to allocate.&nbsp; The difference between the bit positions indicates how many bits are available.
<dt><br>Results:
<dd>The<tt> bitalloc</tt> public static member function returns the next available<tt> ios::fmtflags</tt> bit for use by user
 derived classes.&nbsp; If no more bits are available, zero is returned.
<dt><br>See Also:
<dd><tt> ios::fmtflags</tt>
</dl>
<h2 id="ios__clearLR"> clear() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>iostate ios::clear( ios::iostate flags = 0 );</tt>
<dt><br>Semantics:
<dd>The<tt> clear</tt> public member function is used to change the current value of<tt> ios::iostate</tt> in the<tt> ios</tt>
 object.<tt>&nbsp; ios::iostate</tt> is cleared, all bits specified in<b> flags</b> are set.
<dt><br>Results:
<dd>The<tt> clear</tt> public member function returns the previous value of<tt> ios::iostate</tt>.
<dt><br>See Also:
<dd><tt> ios::bad</tt>,<tt> eof</tt>,<tt> fail</tt>,<tt> good</tt>,<tt> iostate</tt>,<tt> operator !</tt>,<tt> operator void *</tt>,<tt>
 rdstate</tt>,<tt> setstate</tt>
</dl>
<h2 id="ios__eofLR"> eof() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int ios::eof() const;</tt>
<dt><br>Semantics:
<dd>The<tt> eof</tt> public member function queries the state of the<tt> ios</tt> object.
<dt><br>Results:
<dd>The<tt> eof</tt> public member function returns a non-zero value if<tt> ios::eofbit</tt> is set in the error state in the
 inherited<tt> ios</tt> object, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> ios::bad</tt>,<tt> clear</tt>,<tt> fail</tt>,<tt> good</tt>,<tt> iostate</tt>,<tt> rdstate</tt>,<tt> setstate</tt>
</dl>
<h2 id="ios__exceptionsLR"> exceptions() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ios::iostate ios::exceptions() const;</tt>
<br><tt> ios::iostate ios::exceptions( int enable );</tt>
<dt><br>Semantics:
<dd>The<tt> exceptions</tt> public member function queries and/or sets the bits that control which exceptions are enabled.<tt>
&nbsp; ios::iostate</tt> within the<tt> ios</tt> object is used to enable and disable exceptions.
<br>When a condition arises that sets a bit in<tt> ios::iostate</tt>, a check is made to see if the same bit is also set in
 the exception bits.&nbsp; If so, an exception is thrown.&nbsp; Otherwise, no exception is thrown.
<br><br>The first form of the<tt> exceptions</tt> public member function looks up the current setting of the exception bits.
&nbsp; The bit values are those described by<tt> ios::iostate</tt>.
<br><br>The second form of the<tt> exceptions</tt> public member function sets the exceptions bits to those specified in the<b>
 enable</b> parameter, and returns the current settings.
<dt><br>Results:
<dd>The<tt> exceptions</tt> public member function returns the previous setting of the exception bits.
<dt><br>See Also:
<dd><tt> ios::clear</tt>,<tt> iostate</tt>,<tt> rdstate</tt>,<tt> setstate</tt>
</dl>
<h2 id="ios__failLR"> fail() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int ios::fail() const;</tt>
<dt><br>Semantics:
<dd>The<tt> fail</tt> public member function queries the state of the<tt> ios</tt> object.
<dt><br>Results:
<dd>The<tt> fail</tt> public member function returns a non-zero value if<tt> ios::failbit</tt> or<tt> ios::badbit</tt> is set
 in the error state in the inherited<tt> ios</tt> object, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> ios::bad</tt>,<tt> clear</tt>,<tt> eof</tt>,<tt> good</tt>,<tt> iostate</tt>,<tt> operator !</tt>,<tt> operator void
 *</tt>,<tt> rdstate</tt>,<tt> setstate</tt>
</dl>
<h2 id="ios__fillLR"> fill() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>char ios::fill() const;</tt>
<br><tt> char ios::fill( char fillchar );</tt>
<dt><br>Semantics:
<dd>The<tt> fill</tt> public member function queries and/or sets the<b> fill character</b> used when the size of a formatted object
 is smaller than the<b> format width</b> specified.
<br>The first form of the<tt> fill</tt> public member function looks up the current value of the<b> fill character</b>.
<br><br>The second form of the<tt> fill</tt> public member function sets the<b> fill character</b> to<b> fillchar</b>.
<br><br>By default, the<b> fill character</b> is a space.
<dt><br>Results:
<dd>The<tt> fill</tt> public member function returns the previous value of the<b> fill character</b>.
<dt><br>See Also:
<dd><tt> ios::fmtflags</tt>, manipulator<tt> setfill</tt>
</dl>
<h2 id="ios__flagsLR"> flags() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ios::fmtflags ios::flags() const;</tt>
<br><tt> ios::fmtflags ios::flags( ios::fmtflags setbits );</tt>
<dt><br>Semantics:
<dd>The<tt> flags</tt> public member function is used to query and/or set the value of<tt> ios::fmtflags</tt> in the<tt> ios</tt>
 object.
<br>The first form of the<tt> flags</tt> public member function looks up the current<tt> ios::fmtflags</tt> value.
<br><br>The second form of the<tt> flags</tt> public member function sets<tt> ios::fmtflags</tt> to the value specified in
 the<b> setbits</b> parameter.
<br><br>Note that the<tt> setf</tt> public member function only turns bits on, while the<tt> flags</tt> public member function
 turns some bits on and some bits off.
<dt><br>Results:
<dd>The<tt> flags</tt> public member function returns the previous<tt> ios::fmtflags</tt> value.
<dt><br>See Also:
<dd><tt> ios::fmtflags</tt>,<tt> setf</tt>,<tt> unsetf</tt>, manipulator<tt> dec</tt>, manipulator<tt> hex</tt>, manipulator<tt>
 oct</tt>, manipulator<tt> resetiosflags</tt>, manipulator<tt> setbase</tt>, manipulator<tt> setiosflags</tt>
</dl>
<h2 id="ios__fmtflags"> fmtflags &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>enum fmt_flags {</tt>
<br><tt>skipws = 0x0001, // skip whitespace</tt>
<br><tt> left = 0x0002, // align field to left edge</tt>
<br><tt> right = 0x0004, // align field to right edge</tt>
<br><tt> internal = 0x0008, // sign at left, value at right</tt>
<br><tt> dec = 0x0010, // decimal conversion for integers</tt>
<br><tt> oct = 0x0020, // octal conversion for integers</tt>
<br><tt> hex = 0x0040, // hexadecimal conversion for integers</tt>
<br><tt> showbase = 0x0080, // show dec/octal/hex base on output</tt>
<br><tt> showpoint = 0x0100, // show decimal and digits on output</tt>
<br><tt> uppercase = 0x0200, // use uppercase for format characters</tt>
<br><tt> showpos = 0x0400, // use + for output positive numbers</tt>
<br><tt> scientific = 0x0800, // use scientific notation for output</tt>
<br><tt> fixed = 0x1000, // use floating notation for output</tt>
<br><tt> unitbuf = 0x2000, // flush stream after output</tt>
<br><tt> stdio = 0x4000, // flush stdout/stderr after output</tt>
<br><br><tt>basefield = dec | oct | hex,</tt>
<br><tt> adjustfield= left | right | internal,</tt>
<br><tt> floatfield = scientific | fixed</tt>
<br><tt> };</tt>
<br><tt>typedef long fmtflags;</tt>
<dt><br>Semantics:
<dd>The type<tt> ios::fmt_flags</tt> is a set of bits representing methods of formatting objects written to the stream and interpreting
 objects read from the stream.&nbsp; The<tt> ios::fmtflags</tt> member typedef represents the same set of bits, but uses a<tt>
 long</tt> to represent the values, thereby avoiding problems made possible by the compiler's ability to use smaller types
 for enumerations.&nbsp; All uses of these bits should use the<tt> ios::fmtflags</tt> member typedef.
<br>The bit values defined by the<tt> ios::fmtflags</tt> member typedef are set and read by the member functions<tt> setf</tt>,<tt>
 unsetf</tt> and<tt> flags</tt>, as well as the manipulators<tt> setiosflags</tt> and<tt> resetiosflags</tt>.
<br><br>Because one field is used to store all of these bits, there are three special values used to mask various groups of
 bits.&nbsp; These values are named<tt> ios::basefield</tt>,<tt> ios::adjustfield</tt> and<tt> ios::floatfield</tt>, and are
 discussed with the bits that they are used to mask.
<br><br><tt>ios::skipws</tt> controls whether or not whitespace characters are automatically skipped when using an<tt> operator
 &gt;&gt;</tt> extractor.&nbsp; If<tt> ios::skipws</tt> is on, any use of the<tt> operator &gt;&gt;</tt> extractor skips whitespace
 characters before inputting the next item.&nbsp; Otherwise, skipping of whitespace characters must be handled by the program.
<br><br><tt>ios::left</tt>,<tt> ios::right</tt> and<tt> ios::internal</tt> control the alignment of items written using an<tt>
 operator &lt;&lt;</tt> inserter.&nbsp; These bits are usually used in conjunction with the<b> format width</b> and<b> fill
 character</b>.
<br><br><tt>ios::adjustfield</tt> can be used to mask the alignment bits returned by the<tt> setf</tt>,<tt> unsetf</tt> and<tt>
 flags</tt> member functions, and for setting new values to ensure that no other bits are accidentally affected.
<br><br>When the item to be written is smaller than the<b> format width</b> specified,<b> fill character</b>s are written
 to occupy the additional space.&nbsp; If<tt> ios::left</tt> is in effect, the item is written in the left portion of the
 available space, and<b> fill character</b>s are written in the right portion.&nbsp; If<tt> ios::right</tt> is in effect,
 the item is written in the right portion of the available space, and<b> fill character</b>s are written in the left portion.
&nbsp; If<tt> ios::internal</tt> is in effect, any sign character or base indicator is written in the left portion, the digits
 are written in the right portion, and<b> fill character</b>s are written in between.
<br><br>If no alignment is specified,<tt> ios::right</tt> is assumed.
<br><br>If the item to be written is as big as or bigger than the<b> format width</b> specified, no<b> fill character</b>s
 are written and the alignment is ignored.
<br><br><tt>ios::dec</tt>,<tt> ios::oct</tt> and<tt> ios::hex</tt> control the base used to format integers being written
 to the stream, and also control the interpretation of integers being read from the stream.
<br><br><tt>ios::basefield</tt> can be used to mask the base bits returned by the member functions<tt> setf</tt>,<tt> unsetf</tt>
 and<tt> flags</tt>, and for setting new values to ensure that no other bits are accidentally affected.
<br><br>When an integer is being read from the stream, these bits control the base used for the interpretation of the digits.
&nbsp; If none of these bits is set, a number that starts with<tt> 0x</tt> or<tt> 0X</tt> is interpreted as hexadecimal (digits<tt>
 0123456789</tt>, plus the letters<tt> abcdef</tt> or<tt> ABCDEF</tt>), a number that starts with<tt> 0</tt> (zero) is interpreted
 as octal (digits<tt> 01234567</tt>), otherwise the number is interpreted as decimal (digits<tt> 0123456789</tt>).&nbsp; If
 one of the bits is set, then the prefix is not necessary and the number is interpreted according to the bit.
<br><br>When any one of the integer types is being written to the stream, it can be written in decimal, octal or hexadecimal.
&nbsp; If none of these bits is set,<tt> ios::dec</tt> is assumed.
<br><br>If<tt> ios::dec</tt> is set (or assumed), the integer is written in decimal (digits<tt> 0123456789</tt>).&nbsp; No
 prefix is included.
<br><br>If<tt> ios::oct</tt> is set, the integer is written in octal (digits<tt> 01234567</tt>).&nbsp; No sign character is
 written, as the number is treated as an unsigned quantity upon conversion to octal.
<br><br>If<tt> ios::hex</tt> is set, the integer is written in hexadecimal (digits<tt> 0123456789</tt>, plus the letters<tt>
 abcdef</tt> or<tt> ABCDEF</tt>, depending on the setting of<tt> ios::uppercase</tt>).&nbsp; No sign character is written,
 as the number is treated as an unsigned quantity upon conversion to hexadecimal.
<br><br><tt>ios::showbase</tt> controls whether or not integers written to the stream in octal or hexadecimal form have a
 prefix that indicates the base of the number.&nbsp; If the bit is set, decimal numbers are written without a prefix, octal
 numbers are written with the prefix<tt> 0</tt> (zero) and hexadecimal numbers are written with the prefix<tt> 0x</tt> or<tt>
 0X</tt> depending on the setting of<tt> ios::uppercase</tt>.&nbsp; If the<tt> ios::showbase</tt> is not set, no prefixes
 are written.
<br><br><tt>ios::showpoint</tt> is used to control whether or not the decimal point and trailing zeroes are trimmed when floating-point
 numbers are written to the stream.&nbsp; If the bit is set, no trimming is done, causing the number to appear with the specified<b>
 format precision</b>.&nbsp; If the bit is not set, any trailing zeroes after the decimal point are trimmed, and if not followed
 by any digits, the decimal point is removed as well.
<br><br><tt>ios::uppercase</tt> is used to force to upper-case all letters used in formatting numbers, including the letter-digits<tt>
 abcdef</tt>, the<tt> x</tt> hexadecimal prefix, and the<tt> e</tt> used for the exponents in floating-point numbers.
<br><br><tt>ios::showpos</tt> controls whether or not a<tt> +</tt> is added to the front of positive integers being written
 to the stream.&nbsp; If the bit is set, the number is positive and the number is being written in decimal, a<tt> +</tt> is
 written before the first digit.
<br><br><tt>ios::scientific</tt> and<tt> ios::fixed</tt> controls the form used for writing floating-point numbers to the
 stream.&nbsp; Floating-point numbers can be written in scientific notation (also called exponential notation) or in fixed-point
 notation.
<br><br><tt>ios::floatfield</tt> can be used to mask the floating-format bits returned by the member functions<tt> setf</tt>,<tt>
 unsetf</tt> and<tt> flags</tt>, and for setting new values to ensure that no other bits are accidentally affected.
<br><br>If<tt> ios::scientific</tt> is set, the floating-point number is written with a leading<tt> -</tt> sign (for negative
 numbers), a digit, a decimal point, more digits, an<tt> e</tt> (or<tt> E</tt> if<tt> ios::uppercase</tt> is set), a<tt> +</tt>
 or<tt> -</tt> sign, and two or three digits representing the exponent.&nbsp; The digit before the decimal is not zero unless
 the number is zero.&nbsp; The total number of digits before and after the decimal is equal to the specified<b> format precision</b>.
&nbsp; If<tt> ios::showpoint</tt> is not set, trimming of the decimal and digits following the decimal may occur.
<br><br>If<tt> ios::fixed</tt> is set, the floating-point number is written with a<tt> -</tt> sign (for negative numbers),
 at least one digit, the decimal point, and as many digits following the decimal as specified by the<b> format precision</b>.
&nbsp; If<tt> ios::showpoint</tt> is not set, trimming of the decimal and digits following the decimal may occur.
<br><br>If neither<tt> ios::scientific</tt> nor<tt> ios::fixed</tt> is specified, the floating-point number is formatted using
 scientific notation provided one or both of the following conditions are met:
<ul>
<li>the exponent is less than -4, or,
<li>the exponent is greater than the<b> format precision</b>.
</ul>
<br>Otherwise, fixed-point notation is used.
<br><br><tt>ios::unitbuf</tt> controls whether or not the stream is flushed after each item is written.&nbsp; If the bit is
 set, every item that is written to the stream is followed by a flush operation, which ensures that the I/O stream buffer
 associated with the stream is kept empty, immediately transferring the data to its final destination.
<br><br><tt>ios::stdio</tt> controls whether or not the stream is synchronized after each item is written.&nbsp; If the bit
 is set, every item that is written to the stream causes the stream to be synchronized, which means any input or output buffers
 are flushed so that an I/O operation performed using C (not C++) I/O behaves in an understandable way.&nbsp; If the output
 buffer was not flushed, writing using C++ and then C I/O functions could cause the output from the C functions to appear
 before the output from the C++ functions, since the characters might be sitting in the C++ output buffer.&nbsp; Similarly,
 after the C output operations are done, a call should be made to the C library<tt> fflush</tt> function on the appropriate
 stream before resuming C++ output operations.
<dt><br>See Also:
<dd><tt> ios::flags</tt>,<tt> setf</tt>,<tt> unsetf</tt>, manipulator<tt> dec</tt>, manipulator<tt> hex</tt>, manipulator<tt>
 oct</tt>, manipulator<tt> resetiosflags</tt>, manipulator<tt> setbase</tt>, manipulator<tt> setiosflags</tt>
</dl>
<h2 id="ios__goodLR"> good() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int ios::good() const;</tt>
<dt><br>Semantics:
<dd>The<tt> good</tt> public member function queries the state of the<tt> ios</tt> object.
<dt><br>Results:
<dd>The<tt> good</tt> public member function returns a non-zero value if none of<tt> ios::iostate</tt> is clear, otherwise zero
 is returned.
<dt><br>See Also:
<dd><tt> ios::bad</tt>,<tt> clear</tt>,<tt> eof</tt>,<tt> fail</tt>,<tt> iostate</tt>,<tt> rdstate</tt>,<tt> setstate</tt>
</dl>
<h2 id="ios__initLR"> init() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>void ios::init( streambuf *sb );</tt>
<dt><br>Semantics:
<dd>The<tt> init</tt> public protected member function is used by derived classes to explicitly initialize the<tt> ios</tt> portion
 of the derived object, and to associate a<tt> streambuf</tt> with the<tt> ios</tt> object.&nbsp; The<tt> init</tt> public
 protected member function performs the following steps:
<ol>
<li>The default<b> fill character</b> is set to a space.
<li>The<b> format precision</b> is set to six.
<li>The<tt> streambuf</tt> pointer (returned by the<tt> rdbuf</tt> member function) is set to<b> sb</b>.
<li>The remaining fields of the<tt> ios</tt> object are initialized to zero.
</ol>
<dt><br>Results:
<dd>If<b> sb</b> is<tt> NULL</tt> the<tt> ios::badbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ios</tt>,<tt> rdbuf</tt>
</dl>
<h2 id="ios__iosLR"> ios() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>ios::ios();</tt>
<dt><br>Semantics:
<dd>This form of the protected<tt> ios</tt> constructor creates a default<tt> ios</tt> object that is initialized, but does not
 have an associated<tt> streambuf</tt>.&nbsp; Initialization of an<tt> ios</tt> object is handled by the<tt> init</tt> protected
 member function.
<dt><br>Results:
<dd>This protected<tt> ios</tt> constructor creates an<tt> ios</tt> object and sets<tt> ios::badbit</tt> in the error state in
 the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~ios</tt>,<tt> init</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ios::ios( streambuf *sb );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> ios</tt> constructor creates an<tt> ios</tt> object that is initialized and has an associated<tt>
 streambuf</tt>.&nbsp; Initialization of an<tt> ios</tt> object is handled by the<tt> init</tt> protected member function.
&nbsp; Once the<tt> init</tt> protected member function is completed, the<tt> ios</tt> object's<tt> streambuf</tt> pointer
 is set to<b> sb</b>.&nbsp; If<b> sb</b> is not<tt> NULL</tt>,<tt> ios::badbit</tt> is cleared from the error state in the
 inherited<tt> ios</tt> object.
<dt><br>Results:
<dd>This public<tt> ios</tt> constructor creates an<tt> ios</tt> object and, if<b> sb</b> is<tt> NULL</tt>, sets<tt> ios::badbit</tt>
 in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~ios</tt>,<tt> init</tt>
</dl>
<h2 id="ios____iosLR"> ~ios() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ios::~ios();</tt>
<dt><br>Semantics:
<dd>The public virtual<tt> ~ios</tt> destructor destroys an<tt> ios</tt> object.&nbsp; The call to the public virtual<tt> ~ios</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> ios</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> ios</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> ios</tt>
</dl>
<h2 id="ios__iostate"> iostate &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>enum io_state {</tt>
<br><tt>goodbit = 0x00, // no errors</tt>
<br><tt> badbit = 0x01, // operation failed, may not proceed</tt>
<br><tt> failbit = 0x02, // operation failed, may proceed</tt>
<br><tt> eofbit = 0x04 // end of file encountered</tt>
<br><tt> };</tt>
<br><tt>typedef int iostate;</tt>
<dt><br>Semantics:
<dd>The type<tt> ios::io_state</tt> is a set of bits representing the current state of the stream.&nbsp; The<tt> ios::iostate</tt>
 member typedef represents the same set of bits, but uses an<tt> int</tt> to represent the values, thereby avoiding problems
 made possible by the compiler's ability to use smaller types for enumerations.&nbsp; All uses of these bits should use the<tt>
 ios::iostate</tt> member typedef.
<br>The bit values defined by the<tt> ios::iostate</tt> member typedef can be read and set by the member functions<tt> rdstate</tt>
 and<tt> clear</tt>, and can be used to control exception handling with the member function<tt> exceptions</tt>.
<br><br><tt>ios::badbit</tt> represents the state where the stream is no longer usable because of some error condition.
<br><br><tt>ios::failbit</tt> represents the state where the previous operation on the stream failed, but the stream is still
 usable.&nbsp; Subsequent operations on the stream are possible, but the state must be cleared using the<tt> clear</tt> member
 function.
<br><br><tt>ios::eofbit</tt> represents the state where the end-of-file condition has been encountered.&nbsp; The stream may
 still be used, but the state must be cleared using the<tt> clear</tt> member function.
<br><br>Even though<tt> ios::goodbit</tt> is not a bit value (because its value is zero, which has no bits on), it is provided
 for completeness.
<dt><br>See Also:
<dd><tt> ios::bad</tt>,<tt> clear</tt>,<tt> eof</tt>,<tt> fail</tt>,<tt> good</tt>,<tt> operator !</tt>,<tt> operator void *</tt>,<tt>
 rdstate</tt>,<tt> setstate</tt>
</dl>
<h2 id="ios__iwordLR"> iword() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>long &amp;ios::iword( int index );</tt>
<dt><br>Semantics:
<dd>The<tt> iword</tt> public member function creates a reference to a<tt> long int</tt>, which may be used to store and retrieve
 any suitable integer value.&nbsp; The<b> index</b> parameter specifies which<tt> long int</tt> is to be referenced and must
 be obtained from a call to the<tt> xalloc</tt> static member function.
<br>Note that the<tt> iword</tt> and<tt> pword</tt> public member functions return references to the same storage with a different
 type.&nbsp; Therefore, each<b> index</b> obtained from the<tt> xalloc</tt> static member function can be used only for an
 integer or a pointer, not both.
<br><br>Since the<tt> iword</tt> public member function returns a reference and the<tt> ios</tt> class cannot predict how
 many such items will be required by a program, it should be assumed that each call to the<tt> xalloc</tt> static member function
 invalidates all previous references returned by the<tt> iword</tt> public member function.&nbsp; Therefore, the<tt> iword</tt>
 public member function should be called each time the reference is needed.
<dt><br>Results:
<dd>The<tt> iword</tt> public member function returns a reference to a<tt> long int</tt>.
<dt><br>See Also:
<dd><tt> ios::pword</tt>,<tt> xalloc</tt>
</dl>
<h2 id="ios__openmode"> openmode &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>enum open_mode {</tt>
<br><tt>in = 0x0001, // open for input</tt>
<br><tt> out = 0x0002, // open for output</tt>
<br><tt> atend = 0x0004, // seek to end after opening</tt>
<br><tt> append = 0x0008, // open for output, append to the end</tt>
<br><tt> truncate = 0x0010, // discard contents after opening</tt>
<br><tt> nocreate = 0x0020, // open only an existing file</tt>
<br><tt> noreplace = 0x0040, // open only a new file</tt>
<br><tt> text = 0x0080, // open as text file</tt>
<br><tt> binary = 0x0100, // open as binary file</tt>
<br><br><tt>app = append, // synonym</tt>
<br><tt> ate = atend, // synonym</tt>
<br><tt> trunc = truncate // synonym</tt>
<br><tt> };</tt>
<br><tt>typedef int openmode;</tt>
<dt><br>Semantics:
<dd>The type<tt> ios::open_mode</tt> is a set of bits representing ways of opening a stream.&nbsp; The<tt> ios::openmode</tt>
 member typedef represents the same set of bits, but uses an<tt> int</tt> to represent the values, thereby avoiding problems
 made possible by the compiler's ability to use smaller types for enumerations.&nbsp; All uses of these bits should use the<tt>
 ios::openmode</tt> member typedef.
<br>The bit values defined by<tt> ios::openmode</tt> member typedef can be specified in the constructors for stream objects,
 as well as in various member functions.
<br><br><tt>ios::in</tt> is specified in a stream for which input operations may be performed.<tt>&nbsp; ios::out</tt> is
 specified in a stream for which output operations may be performed.&nbsp; A stream for which only<tt> ios::in</tt> is specified
 is referred to as an<b> input</b> stream.&nbsp; A stream for which only<tt> ios::out</tt> is specified is referred to as
 an<b> output</b> stream.&nbsp; A stream where both<tt> ios::in</tt> and<tt> ios::out</tt> are specified is referred to as
 an<b> input/output</b> stream.
<br><br><tt>ios::atend</tt> and<tt> ios::ate</tt> are equivalent, and either one is specified for streams that are to be positioned
 to the end before the first operation takes place.<tt>&nbsp; ios:ate</tt> is provided for historical purposes and compatibility
 with other implementations of I/O streams.&nbsp; Note that this bit positions the stream to the end exactly once, when the
 stream is opened.
<br><br><tt>ios::append</tt> and<tt> ios::app</tt> are equivalent, and either one is specified for streams that are to be
 positioned to the end before any and all output operations take place.<tt>&nbsp; ios::app</tt> is provided for historical
 purposes and compatibility with other implementations of I/O streams.&nbsp; Note that this bit causes the stream to be positioned
 to the end before each output operation, while<tt> ios::atend</tt> causes the stream to be positioned to the end only when
 first opened.
<br><br><tt>ios::truncate</tt> and<tt> ios::trunc</tt> are equivalent, and either one is specified for streams that are to
 be truncated to zero length before the first operation takes place.<tt>&nbsp; ios::trunc</tt> is provided for historical
 purposes and compatibility with other implementations of I/O streams.
<br><br><tt>ios::nocreate</tt> is specified if the file must exist before it is opened.&nbsp; If the file does not exist,
 an error occurs.
<br><br><tt>ios::noreplace</tt> is specified if the file must not exist before it is opened.&nbsp; That is, the file must
 be a new file.&nbsp; If the file exists, an error occurs.
<br><br><tt>ios::text</tt> is specified if the file is to be treated as a<b> text</b> file.&nbsp; A text file is divided into
 records, and each record is terminated by a<b> new-line</b> character, usually represented as<tt> '\n'.</tt>&nbsp; The new-line
 character is translated into a form that is compatible with the underlying file system's concept of text files.&nbsp; This
 conversion happens automatically whenever the new-line is written to the file, and the inverse conversion (to the new-line
 character) happens automatically whenever the end of a record is read from the file system.
<br><br><tt>ios::binary</tt> is specified if the file is to be treated as a<b> binary</b> file.&nbsp; Binary files are streams
 of characters.&nbsp; No character has a special meaning.&nbsp; No grouping of characters into records is apparent to the
 program, although the underlying file system may cause such a grouping to occur.
<br><br>The following default behaviors are defined:
<br><br>If<tt> ios::out</tt> is specified and none of<tt> ios::in</tt>,<tt> ios::append</tt> or<tt> ios::atend</tt> are specified,<tt>
 ios::truncate</tt> is assumed.
<br><br>If<tt> ios::append</tt> is specified,<tt> ios::out</tt> is assumed.
<br><br>If<tt> ios::truncate</tt> is specified,<tt> ios::out</tt> is assumed.
<br><br>If neither<tt> ios::text</tt> nor<tt> ios::binary</tt> is specified,<tt> ios::text</tt> is assumed.
</dl>
<h2 id="ios__operator__LR"> operator !() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int ios::operator !() const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator !</tt>&nbsp; public member function tests the error state in the inherited<tt> ios</tt> object of the<tt>
 ios</tt> object.
<dt><br>Results:
<dd>The<tt> operator !</tt>&nbsp; public member function returns a non-zero value if either of<tt> ios::failbit</tt> or<tt> ios::badbit</tt>
 bits are set in the error state in the inherited<tt> ios</tt> object, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> ios::bad</tt>,<tt> clear</tt>,<tt> fail</tt>,<tt> good</tt>,<tt> iostate</tt>,<tt> operator void *</tt>,<tt> rdstate</tt>,<tt>
 setstate</tt>
</dl>
<h2 id="ios__operator_void_TLR"> operator void *() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ios::operator void *() const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator void *</tt> public member function converts the<tt> ios</tt> object into a pointer to<tt> void</tt>.&nbsp;
 The actual pointer value returned is meaningless and intended only for comparison with<tt> NULL</tt> to determine the error
 state in the inherited<tt> ios</tt> object of the<tt> ios</tt> object.
<dt><br>Results:
<dd>The<tt> operator void *</tt> public member function returns a<tt> NULL</tt> pointer if either of<tt> ios::failbit</tt> or<tt>
 ios::badbit</tt> bits are set in the error state in the inherited<tt> ios</tt> object, otherwise a non-<tt> NULL</tt> pointer
 is returned.
<dt><br>See Also:
<dd><tt> ios::bad</tt>,<tt> clear</tt>,<tt> fail</tt>,<tt> good</tt>,<tt> iostate</tt>,<tt> operator !</tt>,<tt> rdstate</tt>,<tt>
 setstate</tt>
</dl>
<h2 id="ios__precisionLR"> precision() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int ios::precision() const;</tt>
<br><tt> int ios::precision( int prec );</tt>
<dt><br>Semantics:
<dd>The<tt> precision</tt> public member function is used to query and/or set the<b> format precision</b>.&nbsp; The<b> format
 precision</b> is used to control the number of digits of precision used when formatting floating-point numbers.&nbsp; For
 scientific notation, the<b> format precision</b> describes the total number of digits before and after the decimal point,
 but not including the exponent.&nbsp; For fixed-point notation, the<b> format precision</b> describes the number of digits
 after the decimal point.
<br>The first form of the<tt> precision</tt> public member function looks up the current<b> format precision</b>.
<br><br>The second form of the<tt> precision</tt> public member function sets the<b> format precision</b> to<b> prec</b>.
<br><br>By default, the<b> format precision</b> is six.&nbsp; If<b> prec</b> is specified to be less than zero, the<b> format
 precision</b> is set to six.&nbsp; Otherwise, the specified<b> format precision</b> is used.&nbsp; For scientific notation,
 a<b> format precision</b> of zero is treated as a precision of one.
<dt><br>Results:
<dd>The<tt> precision</tt> public member function returns the previous<b> format precision</b> setting.
<dt><br>See Also:
<dd><tt> ios::fmtflags</tt>, manipulator<tt> setprec</tt>
</dl>
<h2 id="ios__pwordLR"> pword() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void * &amp;ios::pword( int index );</tt>
<dt><br>Semantics:
<dd>The<tt> pword</tt> public member function creates a reference to a<tt> void</tt> pointer, which may be used to store and retrieve
 any suitable pointer value.&nbsp; The<b> index</b> parameter specifies which<tt> void</tt> pointer is to be referenced and
 must be obtained from a call to the<tt> xalloc</tt> static member function.
<br>Note that the<tt> iword</tt> and<tt> pword</tt> public member functions return references to the same storage with a different
 type.&nbsp; Therefore, each<b> index</b> obtained from the<tt> xalloc</tt> static member function can be used only for an
 integer or a pointer, not both.
<br><br>Since the<tt> pword</tt> public member function returns a reference and the<tt> ios</tt> class cannot predict how
 many such items will be required by a program, it should be assumed that each call to the<tt> xalloc</tt> static member function
 invalidates all previous references returned by the<tt> pword</tt> public member function.&nbsp; Therefore, the<tt> pword</tt>
 public member function should be called each time the reference is needed.
<dt><br>Results:
<dd>The<tt> pword</tt> public member function returns a reference to a<tt> void</tt> pointer.
<dt><br>See Also:
<dd><tt> ios::iword</tt>,<tt> xalloc</tt>
</dl>
<h2 id="ios__rdbufLR"> rdbuf() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>streambuf *ios::rdbuf() const;</tt>
<dt><br>Semantics:
<dd>The<tt> rdbuf</tt> public member function looks up the pointer to the<tt> streambuf</tt> object which maintains the buffer
 associated with the<tt> ios</tt> object.
<dt><br>Results:
<dd>The<tt> rdbuf</tt> public member function returns the pointer to the<tt> streambuf</tt> object associated with the<tt> ios</tt>
 object.&nbsp; If there is no associated<tt> streambuf</tt> object,<tt> NULL</tt> is returned.
</dl>
<h2 id="ios__rdstateLR"> rdstate() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>iostate ios::rdstate() const;</tt>
<dt><br>Semantics:
<dd>The<tt> rdstate</tt> public member function is used to query the current value of<tt> ios::iostate</tt> in the<tt> ios</tt>
 object without modifying it.
<dt><br>Results:
<dd>The<tt> rdstate</tt> public member function returns the current value of<tt> ios::iostate</tt>.
<dt><br>See Also:
<dd><tt> ios::bad</tt>,<tt> clear</tt>,<tt> eof</tt>,<tt> fail</tt>,<tt> good</tt>,<tt> iostate</tt>,<tt> operator !</tt>,<tt>
 operator void *</tt>,<tt> setstate</tt>
</dl>
<h2 id="ios__seekdir"> seekdir &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>enum seek_dir {</tt>
<br><tt>beg, // seek from beginning</tt>
<br><tt> cur, // seek from current position</tt>
<br><tt> end // seek from end</tt>
<br><tt> };</tt>
<br><tt>typedef int seekdir;</tt>
<dt><br>Semantics:
<dd>The type<tt> ios::seek_dir</tt> is a set of bits representing different methods of seeking within a stream.&nbsp; The<tt>
 ios::seekdir</tt> member typedef represents the same set of bits, but uses an<tt> int</tt> to represent the values, thereby
 avoiding problems made possible by the compiler's ability to use smaller types for enumerations.&nbsp; All uses of these
 bits should use the<tt> ios::seekdir</tt> member typedef.
<br>The bit values defined by<tt> ios::seekdir</tt> member typedef are used by the member functions<tt> seekg</tt> and<tt>
 seekp</tt>, as well the<tt> seekoff</tt> and<tt> seekpos</tt> member functions in classes derived from the<tt> streambuf</tt>
 class.
<br><br><tt>ios::beg</tt> causes the seek offset to be interpreted as an offset from the beginning of the stream.&nbsp; The
 offset is specified as a positive value.
<br><br><tt>ios::cur</tt> causes the seek offset to be interpreted as an offset from the current position of the stream.&nbsp;
 If the offset is a negative value, the seek is towards the start of the stream.&nbsp; Otherwise, the seek is towards the
 end of the stream.
<br><br><tt>ios::end</tt> causes the seek offset to be interpreted as an offset from the end of the stream.&nbsp; The offset
 is specified as a negative value.
</dl>
<h2 id="ios__setfLR"> setf() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ios::fmtflags ios::setf( ios::fmtflags onbits );</tt>
<br><tt> ios::fmtflags ios::setf( ios::fmtflags setbits,</tt>
<br><tt> ios::fmtflags mask );</tt>
<dt><br>Semantics:
<dd>The<tt> setf</tt> public member function is used to set bits in<tt> ios::fmtflags</tt> in the<tt> ios</tt> object.
<br>The first form is used to turn on the bits that are on in the<b> onbits</b> parameter.&nbsp; (<b> onbits</b> is or'ed
 into<tt> ios::fmtflags</tt>).
<br><br>The second form is used to turn off the bits specified in the<b> mask</b> parameter and turn on the bits specified
 in the<b> setbits</b> parameter.&nbsp; This form is particularly useful for setting the bits described by the<tt> ios::basefield</tt>,<tt>
 ios::adjustfield</tt> and<tt> ios::floatfield</tt> values, where only one bit should be on at a time.
<dt><br>Results:
<dd>Both forms of the<tt> setf</tt> public member function return the previous<tt> ios::fmtflags</tt> value.
<dt><br>See Also:
<dd><tt> ios::fmtflags</tt>,<tt> setf</tt>,<tt> unsetf</tt>, manipulator<tt> dec</tt>, manipulator<tt> hex</tt>, manipulator<tt>
 oct</tt>, manipulator<tt> setbase</tt>, manipulator<tt> setiosflags</tt>, manipulator<tt> resetiosflags</tt>
</dl>
<h2 id="ios__setstateLR"> setstate() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>void ios::setstate( int or_bits );</tt>
<dt><br>Semantics:
<dd>The<tt> setstate</tt> protected member function is provided as a convenience for classes derived from the<tt> ios</tt> class.
&nbsp; It turns on the error state in the inherited<tt> ios</tt> object bits that are set in the<b> or_bits</b> parameter,
 and leaves the other error state in the inherited<tt> ios</tt> object bits unchanged.
<dt><br>Results:
<dd>The<tt> setstate</tt> protected member function sets the bits specified by<b> or_bits</b> in the error state in the inherited<tt>
 ios</tt> object.
<dt><br>See Also:
<dd><tt> ios::bad</tt>,<tt> clear</tt>,<tt> eof</tt>,<tt> fail</tt>,<tt> good</tt>,<tt> iostate</tt>,<tt> operator !</tt>,<tt>
 operator void *</tt>,<tt> rdstate</tt>
</dl>
<h2 id="ios__sync_with_stdioLR"> sync_with_stdio() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>static void ios::sync_with_stdio();</tt>
<dt><br>Semantics:
<dd>The<tt> sync_with_stdio</tt> public static member function is obsolete.&nbsp; It is provided for compatibility.
<dt><br>Results:
<dd>The<tt> sync_with_stdio</tt> public static member function has no return value.
</dl>
<h2 id="ios__tieLR"> tie() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream *ios::tie() const;</tt>
<br><tt> ostream *ios::tie( ostream *ostrm );</tt>
<dt><br>Semantics:
<dd>The<tt> tie</tt> public member function is used to query and/or set up a connection between the<tt> ios</tt> object and another
 stream.&nbsp; The connection causes the output stream specified by<b> ostrm</b> to be flushed whenever the<tt> ios</tt> object
 is about to read characters from a device or is about to write characters to an output buffer or device.
<br>The first form of the<tt> tie</tt> public member function is used to query the current tie.
<br><br>The second form of the<tt> tie</tt> public member function is used to set the tied stream to<b> ostrm</b>.
<br><br>Normally, the predefined streams<tt> cin</tt> and<tt> cerr</tt> set up ties to<tt> cout</tt> so that any input from
 the terminal flushes any buffered output, and any writes to<tt> cerr</tt> flush<tt> cout</tt> before the characters are written.<tt>
&nbsp; cout</tt> does not set up a tie to<tt> cerr</tt> because<tt> cerr</tt> has the flag<tt> ios::unitbuf</tt> set, so it
 flushes itself after every write operation.
<dt><br>Results:
<dd>Both forms of the<tt> tie</tt> public member function return the previous tie value.
<dt><br>See Also:
<dd><tt> ios::fmtflags</tt>
</dl>
<h2 id="ios__unsetfLR"> unsetf() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ios::fmtflags ios::unsetf( ios::fmtflags offbits );</tt>
<dt><br>Semantics:
<dd>The<tt> unsetf</tt> public member function is used to turn off bits in<tt> ios::fmtflags</tt> that are set in the<b> offbits</b>
 parameter.&nbsp; All other bits in<tt> ios::fmtflags</tt> are unchanged.
<dt><br>Results:
<dd>The<tt> unsetf</tt> public member function returns the old<tt> ios::fmtflags</tt> value.
<dt><br>See Also:
<dd><tt> ios::fmtflags</tt>,<tt> setf</tt>,<tt> unsetf</tt>, manipulator<tt> dec</tt>, manipulator<tt> hex</tt>, manipulator<tt>
 oct</tt>, manipulator<tt> setbase</tt>, manipulator<tt> setiosflags</tt>, manipulator<tt> resetiosflags</tt>
</dl>
<h2 id="ios__widthLR"> width() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int ios::width() const;</tt>
<br><tt> int ios::width( int wid );</tt>
<dt><br>Semantics:
<dd>The<tt> width</tt> public member function is used to query and/or set the<b> format width</b> used to format the next item.
&nbsp; A<b> format width</b> of zero indicates that the item is to be written using exactly the number of positions required.
&nbsp; Other values indicate that the item must occupy at least that many positions.&nbsp; If the formatted item is larger
 than the specified<b> format width</b>, the<b> format width</b> is ignored and the item is formatted using the required number
 of positions.
<br>The first form of the<tt> width</tt> public member function is used to query the<b> format width</b> that is to be used
 for the next item.
<br><br>The second form of the<tt> width</tt> public member function is used to set the<b> format width</b> to<b> wid</b>
 for the next item to be formatted.
<br><br>After an item has been formatted, the<b> format width</b> is reset to zero.&nbsp; Therefore, any non-zero<b> format
 width</b> must be set before each item that is to be formatted.
<dt><br>Results:
<dd>The<tt> width</tt> public member function returns the previous<b> format width</b>.
<dt><br>See Also:
<dd><tt> ios::fmtflags</tt>, manipulator<tt> setw</tt>, manipulator<tt> setwidth</tt>
</dl>
<h2 id="ios__xallocLR"> xalloc() &#91;ios&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>static int ios::xalloc();</tt>
<dt><br>Semantics:
<dd>The<tt> xalloc</tt> public static member function returns an index into an array of items that the program may use for any
 purpose.&nbsp; Each item can be either a<tt> long int</tt> or a pointer to<tt> void</tt>.&nbsp; The index can be used with
 the<tt> iword</tt> and<tt> pword</tt> member functions.
<br>Because the<tt> xalloc</tt> public static member function manipulates<tt> static</tt> member data, its behavior is not
 tied to any one object but affects the entire class of objects.&nbsp; The value that is returned by the<tt> xalloc</tt> public
 static member function is valid for all objects of all classes derived from the<tt> ios</tt> class.&nbsp; No subsequent call
 to the<tt> xalloc</tt> public static member function will return the same value as a previous call.
<dt><br>Results:
<dd>The<tt> xalloc</tt> public static member function returns an index for use with the<tt> iword</tt> and<tt> pword</tt> member
 functions.
<dt><br>See Also:
<dd><tt> ios::iword</tt>,<tt> pword</tt>
</dl>
<h2 id="iostream_Class_Description"> iostream Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> iostream.h</tt>
<dt><br>Derived from:
<dd><tt> istream</tt>,<tt> ostream</tt>
<dt><br>Derived by:
<dd><tt> fstream</tt>,<tt> strstream</tt>
<br>The<tt> iostream</tt> class supports reading and writing of characters from and to the standard input/output devices,
 usually the keyboard and screen.&nbsp; The<tt> iostream</tt> class provides formatted conversion of characters to and from
 other types (e.g.&nbsp; integers and floating-point numbers).&nbsp; The associated<tt> streambuf</tt> class provides the
 methods for communicating with the actual device, while the<tt> iostream</tt> class provides the interpretation of the characters.
<br>Generally, an<tt> iostream</tt> object won't be created by a program, since there is no mechanism at this level to &quot;open&quot;
 a device.&nbsp; No instance of an<tt> iostream</tt> object is created by default, since it is usually not possible to perform
 both input and output on the standard input/output devices.&nbsp; The<tt> iostream</tt> class is provided as a base class
 for other derived classes that can provide both input and output capabilities through the same object.&nbsp; The<tt> fstream</tt>
 and<tt> strstream</tt> classes are examples of classes derived from the<tt> iostream</tt> class.
<br><br><b>Protected Member Functions</b>
<br><br>The following protected member functions are declared:
<br><br><tt>iostream();</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following public member functions are declared:
<br><br><tt>iostream( ios const &amp; );</tt>
<br><tt> iostream( streambuf * );</tt>
<br><tt> virtual ~iostream();</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following public member operators are declared:
<br><br><tt>iostream &amp; operator =( streambuf * );</tt>
<br><tt> iostream &amp; operator =( ios const &amp; );</tt>
<dt><br>See Also:
<dd><tt> ios</tt>,<tt> istream</tt>,<tt> ostream</tt>
</dl>
<h2 id="iostream__iostreamLR"> iostream() &#91;iostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>iostream::iostream();</tt>
<dt><br>Semantics:
<dd>This form of the protected<tt> iostream</tt> constructor creates an<tt> iostream</tt> object without an attached<tt> streambuf</tt>
 object.
<br>This form of the protected<tt> iostream</tt> constructor is only used implicitly by the compiler when it generates a constructor
 for a derived class.
<dt><br>Results:
<dd>The protected<tt> iostream</tt> constructor produces an initialized<tt> iostream</tt> object.<tt>&nbsp; ios::badbit</tt> is
 set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~iostream</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>iostream::iostream( ios const &amp;strm );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> iostream</tt> constructor creates an<tt> iostream</tt> object associated with the<tt> streambuf</tt>
 object currently associated with the<b> strm</b> parameter.&nbsp; The<tt> iostream</tt> object is initialized and will use
 the<b> strm</b><tt> streambuf</tt> object for subsequent operations.<b>&nbsp; strm</b> will continue to use the<tt> streambuf</tt>
 object.
<dt><br>Results:
<dd>The public<tt> iostream</tt> constructor produces an initialized<tt> iostream</tt> object.&nbsp; If there is no<tt> streambuf</tt>
 object currently associated with the<b> strm</b> parameter,<tt> ios::badbit</tt> is set in the error state in the inherited<tt>
 ios</tt> object.
<dt><br>See Also:
<dd><tt> ~iostream</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>iostream::iostream( streambuf *sb );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> iostream</tt> constructor creates an<tt> iostream</tt> object with an attached<tt> streambuf</tt>
 object.
<br>Since a user program usually will not create an<tt> iostream</tt> object, this form of the public<tt> iostream</tt> constructor
 is unlikely to be explicitly used, except in the member initializer list for the constructor of a derived class.&nbsp; The<b>
 sb</b> parameter is a pointer to a<tt> streambuf</tt> object, which should be connected to the source and sink of characters
 for the stream.
<dt><br>Results:
<dd>The public<tt> iostream</tt> constructor produces an initialized<tt> iostream</tt> object.&nbsp; If the<b> sb</b> parameter
 is<tt> NULL</tt>,<tt> ios::badbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~iostream</tt>
</dl>
<h2 id="iostream____iostreamLR"> ~iostream() &#91;iostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual iostream::~iostream();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~iostream</tt> destructor does not do anything explicit.&nbsp; The<tt> ios</tt> destructor is called for that
 portion of the<tt> iostream</tt> object.&nbsp; The call to the public<tt> ~iostream</tt> destructor is inserted implicitly
 by the compiler at the point where the<tt> iostream</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> iostream</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> iostream</tt>
</dl>
<h2 id="iostream__operator_ELR"> operator =() &#91;iostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>iostream &amp;iostream::operator =( streambuf *sb );</tt>
<dt><br>Semantics:
<dd>This form of the<tt> operator =</tt> public member function initializes the target<tt> iostream</tt> object and sets up an
 association between the<tt> iostream</tt> object and the<tt> streambuf</tt> object specified by the<b> sb</b> parameter.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function returns a reference to the<tt> iostream</tt> object that is the target of the
 assignment.&nbsp; If the<b> sb</b> parameter is<tt> NULL</tt>,<tt> ios::badbit</tt> is set in the error state in the inherited<tt>
 ios</tt> object.
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>iostream &amp;iostream::operator =( const ios &amp;strm );</tt>
<dt><br>Semantics:
<dd>This form of the<tt> operator =</tt> public member function initializes the<tt> iostream</tt> object and sets up an association
 between the<tt> iostream</tt> object and the<tt> streambuf</tt> object currently associated with the<b> strm</b> parameter.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function returns a reference to the<tt> iostream</tt> object that is the target of the
 assignment.&nbsp; If there is no<tt> streambuf</tt> object currently associated with the<b> strm</b> parameter,<tt> ios::badbit</tt>
 is set in the error state in the inherited<tt> ios</tt> object.
</dl>
<h2 id="istream_Class_Description"> istream Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> iostream.h</tt>
<dt><br>Derived from:
<dd><tt> ios</tt>
<dt><br>Derived by:
<dd><tt> iostream</tt>,<tt> ifstream</tt>,<tt> istrstream</tt>
<br>The<tt> istream</tt> class supports reading characters from a class derived from<tt> streambuf</tt>, and provides formatted
 conversion of characters into other types (such as integers and floating-point numbers).&nbsp; The<tt> streambuf</tt> class
 provides the methods for communicating with the external device (keyboard, disk), while the<tt> istream</tt> class provides
 the interpretation of the resulting characters.
<br>Generally, an<tt> istream</tt> object won't be explicitly created by a program, since there is no mechanism at this level
 to open a device.&nbsp; The only default<tt> istream</tt> object in a program is<tt> cin</tt>, which reads from standard
 input (usually the keyboard).
<br><br>The<tt> istream</tt> class supports two basic concepts of input:&nbsp; formatted and unformatted.&nbsp; The overloaded<tt>
 operator &gt;&gt;</tt> member functions are called<b> extractors</b> and they provide the support for formatted input.&nbsp;
 The rest of the member functions deal with unformatted input, managing the state of the<tt> ios</tt> object and providing
 a friendlier interface to the associated<tt> streambuf</tt> object.
<br><br><b>Protected Member Functions</b>
<br><br>The following protected member functions are declared:
<br><br><tt>istream();</tt>
<br><tt> eatwhite();</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following public member functions are declared:
<br><br><tt>istream( istream const &amp; );</tt>
<br><tt> istream( streambuf * );</tt>
<br><tt> virtual ~istream();</tt>
<br><tt> int ipfx( int = 0 );</tt>
<br><tt> void isfx();</tt>
<br><tt> int get();</tt>
<br><tt> istream &amp;get( char *, int, char = '\n' );</tt>
<br><tt> istream &amp;get( signed char *, int, char = '\n' );</tt>
<br><tt> istream &amp;get( unsigned char *, int, char = '\n' );</tt>
<br><tt> istream &amp;get( char &amp; );</tt>
<br><tt> istream &amp;get( signed char &amp; );</tt>
<br><tt> istream &amp;get( unsigned char &amp; );</tt>
<br><tt> istream &amp;get( streambuf &amp;, char = '\n' );</tt>
<br><tt> istream &amp;getline( char *, int, char = '\n' );</tt>
<br><tt> istream &amp;getline( signed char *, int, char = '\n' );</tt>
<br><tt> istream &amp;getline( unsigned char *, int, char = '\n' );</tt>
<br><tt> istream &amp;ignore( int = 1, int = EOF );</tt>
<br><tt> istream &amp;read( char *, int );</tt>
<br><tt> istream &amp;read( signed char *, int );</tt>
<br><tt> istream &amp;read( unsigned char *, int );</tt>
<br><tt> istream &amp;seekg( streampos );</tt>
<br><tt> istream &amp;seekg( streamoff, ios::seekdir );</tt>
<br><tt> istream &amp;putback( char );</tt>
<br><tt> streampos tellg();</tt>
<br><tt> int gcount() const;</tt>
<br><tt> int peek();</tt>
<br><tt> int sync();</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following public member operators are declared:
<br><br><tt>istream &amp;operator =( streambuf * );</tt>
<br><tt> istream &amp;operator =( istream const &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( char * );</tt>
<br><tt> istream &amp;operator &gt;&gt;( signed char * );</tt>
<br><tt> istream &amp;operator &gt;&gt;( unsigned char * );</tt>
<br><tt> istream &amp;operator &gt;&gt;( char &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( signed char &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( unsigned char &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( signed short &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( unsigned short &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( signed int &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( unsigned int &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( signed long &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( unsigned long &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( float &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( double &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( long double &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( streambuf &amp; );</tt>
<br><tt> istream &amp;operator &gt;&gt;( istream &amp;(*)( istream &amp; ) );</tt>
<br><tt> istream &amp;operator &gt;&gt;( ios &amp;(*)( ios &amp; ) );</tt>
<dt><br>See Also:
<dd><tt> ios</tt>,<tt> iostream</tt>,<tt> ostream</tt>
</dl>
<h2 id="istream__eatwhiteLR"> eatwhite() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>void istream::eatwhite();</tt>
<dt><br>Semantics:
<dd>The<tt> eatwhite</tt> protected member function extracts and discards whitespace characters from the<tt> istream</tt> object,
 until a non-whitespace character is found.&nbsp; The non-whitespace character is not extracted.
<dt><br>Results:
<dd>The<tt> eatwhite</tt> protected member function sets<tt> ios::eofbit</tt> in the error state in the inherited<tt> ios</tt>
 object if end-of-file is encountered as the first character while extracting whitespace characters.
<dt><br>See Also:
<dd><tt> istream::ignore</tt>,<tt> ios::fmtflags</tt>
</dl>
<h2 id="istream__gcountLR"> gcount() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int istream::gcount() const;</tt>
<dt><br>Semantics:
<dd>The<tt> gcount</tt> public member function determines the number of characters extracted by the last unformatted input member
 function.
<dt><br>Results:
<dd>The<tt> gcount</tt> public member function returns the number of characters extracted by the last unformatted input member
 function.
<dt><br>See Also:
<dd><tt> istream::get</tt>,<tt> getline</tt>,<tt> read</tt>
</dl>
<h2 id="istream__getLR"> get() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int istream::get();</tt>
<dt><br>Semantics:
<dd>This form of the<tt> get</tt> public member function performs an unformatted read of a single character from the<tt> istream</tt>
 object.
<dt><br>Results:
<dd>This form of the<tt> get</tt> public member function returns the character read from the<tt> istream</tt> object.&nbsp; If
 the<tt> istream</tt> object is positioned at end-of-file before the read,<tt> EOF</tt> is returned and<tt> ios::eofbit</tt>
 bit is set in the error state in the inherited<tt> ios</tt> object.<tt>&nbsp; ios::failbit</tt> bit is not set by this form
 of the<tt> get</tt> public member function.
<dt><br>See Also:
<dd><tt> istream::putback</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::get( char &amp;ch );</tt>
<br><tt> istream &amp;istream::get( signed char &amp;ch );</tt>
<br><tt> istream &amp;istream::get( unsigned char &amp;ch );</tt>
<dt><br>Semantics:
<dd>These forms of the<tt> get</tt> public member function perform an unformatted read of a single character from the<tt> istream</tt>
 object and store the character in the<b> ch</b> parameter.
<dt><br>Results:
<dd>These forms of the<tt> get</tt> public member function return a reference to the<tt> istream</tt> object.<tt>&nbsp; ios::eofbit</tt>
 is set in the error state in the inherited<tt> ios</tt> object if the<tt> istream</tt> object is positioned at end-of-file
 before the attempt to read the character.<tt>&nbsp; ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt>
 object if no character is read.
<dt><br>See Also:
<dd><tt> istream::read</tt>,<tt> operator &gt;&gt;</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::get( char *buf, int len,</tt>
<br><tt> char delim = '\n' );</tt>
<br><tt>istream &amp;istream::get( signed char *buf, int len,</tt>
<br><tt> char delim = '\n' );</tt>
<br><tt>istream &amp;istream::get( unsigned char *buf, int len,</tt>
<br><tt> char delim = '\n' );</tt>
<dt><br>Semantics:
<dd>These forms of the<tt> get</tt> public member function perform an unformatted read of at most<b> len</b> -1 characters from
 the<tt> istream</tt> object and store them starting at the memory location specified by the<b> buf</b> parameter.&nbsp; If
 the character specified by the<b> delim</b> parameter is encountered in the<tt> istream</tt> object before<b> len</b> -1
 characters have been read, the read terminates without extracting the delimiting character.
<br>After the read terminates, whether or not an error occurred, a null character is stored in<b> buf</b> following the last
 character read from the<tt> istream</tt> object.
<br><br>If the<b> delim</b> parameter is not specified, the new-line character is assumed.
<dt><br>Results:
<dd>These forms of the<tt> get</tt> public member function return a reference to the<tt> istream</tt> object.&nbsp; If end-of-file
 is encountered as the first character,<tt> ios::eofbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
&nbsp; If no characters are stored into<b> buf,</b><tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt>
 object.
<dt><br>See Also:
<dd><tt> istream::getline</tt>,<tt> read</tt>,<tt> operator &gt;&gt;</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::get( streambuf &amp;sb, char delim = '\n' );</tt>
<dt><br>Semantics:
<dd>This form of the<tt> get</tt> public member function performs an unformatted read of characters from the<tt> istream</tt>
 object and transfers them to the<tt> streambuf</tt> object specified in the<b> sb</b> parameter.&nbsp; The transfer stops
 if end-of-file is encountered, the delimiting character specified in the<b> delim</b> parameter is found, or if the store
 into the<b> sb</b> parameter fails.&nbsp; If the<b> delim</b> character is found, it is not extracted from the<tt> istream</tt>
 object and is not transferred to the<b> sb</b> object.
<br>If the<b> delim</b> parameter is not specified, the new-line character is assumed.
<dt><br>Results:
<dd>The<tt> get</tt> public member function returns a reference to the<tt> istream</tt> object.<tt>&nbsp; ios::failbit</tt> is
 set in the error state in the inherited<tt> ios</tt> object if the store into the<tt> streambuf</tt> object fails.
<dt><br>See Also:
<dd><tt> istream::getline</tt>,<tt> read</tt>,<tt> operator &gt;&gt;</tt>
</dl>
<h2 id="istream__getlineLR"> getline() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::getline( char *buf, int len,</tt>
<br><tt> char delim = '\n' );</tt>
<br><tt>istream &amp;istream::getline( signed char *buf, int len,</tt>
<br><tt> char delim = '\n' );</tt>
<br><tt>istream &amp;istream::getline( unsigned char *buf, int len,</tt>
<br><tt> char delim = '\n' );</tt>
<dt><br>Semantics:
<dd>The<tt> getline</tt> public member function performs an unformatted read of at most<b> len</b> -1 characters from the<tt>
 istream</tt> object and stores them starting at the memory location specified by the<b> buf</b> parameter.&nbsp; If the delimiting
 character, specified by the<b> delim</b> parameter, is encountered in the<tt> istream</tt> object before<b> len</b> -1 characters
 have been read, the read terminates after extracting the<b> delim</b> character.
<br>If<b> len</b> -1 characters have been read and the next character is the<b> delim</b> character, it is not extracted.
<br><br>After the read terminates, whether or not an error occurred, a null character is stored in the buffer following the
 last character read from the<tt> istream</tt> object.
<br><br>If the<b> delim</b> parameter is not specified, the new-line character is assumed.
<dt><br>Results:
<dd>The<tt> getline</tt> public member function returns a reference to the<tt> istream</tt> object.&nbsp; If end-of-file is encountered
 as the first character,<tt> ios::eofbit</tt> is set in the error state in the inherited<tt> ios</tt> object.&nbsp; If end-of-file
 is encountered before<b> len</b> characters are transferred or the<b> delim</b> character is reached,<tt> ios::failbit</tt>
 is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> istream::get</tt>,<tt> read</tt>,<tt> operator &gt;&gt;</tt>
</dl>
<h2 id="istream__ignoreLR"> ignore() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::ignore( int num = 1, int delim = EOF );</tt>
<dt><br>Semantics:
<dd>The<tt> ignore</tt> public member function extracts and discards up to<b> num</b> characters from the<tt> istream</tt> object.
&nbsp; If the<b> num</b> parameter is not specified, the<tt> ignore</tt> public member function extracts and discards one
 character.&nbsp; If the<b> delim</b> parameter is not<tt> EOF</tt> and it is encountered before<b> num</b> characters have
 been extracted, the extraction ceases after discarding the delimiting character.&nbsp; The extraction stops if end-of-file
 is encountered.
<br>If the<b> num</b> parameter is specified as a negative number, no limit is imposed on the number of characters extracted
 and discarded.&nbsp; The operation continues until the delimiting character is found and discarded, or until end-of-file.
&nbsp; This behavior is a WATCOM extension.
<dt><br>Results:
<dd>The<tt> ignore</tt> public member function returns a reference to the<tt> istream</tt> object.&nbsp; If end-of-file is encountered
 as the first character,<tt> ios::eofbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> istream::eatwhite</tt>
</dl>
<h2 id="istream__ipfxLR"> ipfx() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int istream::ipfx( int noskipws = 0 );</tt>
<dt><br>Semantics:
<dd>The<tt> ipfx</tt> public member function is a prefix function executed before each of the formatted and unformatted read operations.
&nbsp; If any bits are set in<tt> ios::iostate</tt>, the<tt> ipfx</tt> public member function immediately returns 0, indicating
 that the prefix function failed.&nbsp; Failure in the prefix function causes the input operation to fail.
<br>If the<b> noskipws</b> parameter is 0 or unspecified and the<tt> ios::skipws</tt> bit is on in<tt> ios::fmtflags</tt>,
 whitespace characters are discarded and the<tt> istream</tt> object is positioned so that the next character read is the
 first character after the discarded whitespace.&nbsp; Otherwise, no whitespace skipping takes place.
<br><br>The formatted input functions that read specific types of objects (such as integers and floating-point numbers) call
 the<tt> ipfx</tt> public member function with the<b> noskipws</b> parameter set to zero, allowing leading whitespaces to
 be discarded if the<tt> ios::skipws</tt> bit is on in<tt> ios::fmtflags</tt>.&nbsp; The unformatted input functions that
 read characters without interpretation call the<tt> ipfx</tt> public member function with a the<b> noskipws</b> parameter
 set to 1 so that no whitespace characters are discarded.
<br><br>If the<tt> istream</tt> object is tied to an output stream, the output stream is flushed.
<dt><br>Results:
<dd>If the<tt> istream</tt> object is not in an error state in the inherited<tt> ios</tt> object when the above processing is
 completed, the<tt> ipfx</tt> public member function returns a non-zero value to indicate success.&nbsp; Otherwise, zero is
 returned to indicate failure.
<dt><br>See Also:
<dd><tt> istream::isfx</tt>
</dl>
<h2 id="istream__isfxLR"> isfx() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void istream::isfx();</tt>
<dt><br>Semantics:
<dd>The<tt> isfx</tt> public member function is a suffix function executed just before the end of each of the formatted and unformatted
 read operations.
<br>As currently implemented, the<tt> isfx</tt> public member function does not do anything.
<dt><br>See Also:
<dd><tt> istream::ipfx</tt>
</dl>
<h2 id="istream__istreamLR"> istream() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>istream::istream();</tt>
<dt><br>Semantics:
<dd>This form of the protected<tt> istream</tt> constructor creates an<tt> istream</tt> object without an associated<tt> streambuf</tt>
 object.
<br>This form of the protected<tt> istream</tt> constructor is only used implicitly by the compiler when it generates a constructor
 for a derived class.
<dt><br>Results:
<dd>This form of the protected<tt> istream</tt> constructor creates an initialized<tt> istream</tt> object.<tt>&nbsp; ios::badbit</tt>
 is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~istream</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream::istream( istream const &amp;istrm );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> istream</tt> constructor creates an<tt> istream</tt> object associated with the<tt> streambuf</tt>
 object currently associated with the<b> istrm</b> parameter.&nbsp; The<tt> istream</tt> object is initialized and will use
 the<b> istrm</b><tt> streambuf</tt> object for subsequent operations.<b>&nbsp; istrm</b> will continue to use the<tt> streambuf</tt>
 object.
<dt><br>Results:
<dd>This form of the public<tt> istream</tt> constructor creates an initialized<tt> istream</tt> object.&nbsp; If there is no<tt>
 streambuf</tt> object currently associated with the<b> istrm</b> parameter,<tt> ios::badbit</tt> is set in the error state
 in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~istream</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream::istream( streambuf *sb );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> istream</tt> constructor creates an<tt> istream</tt> object with an associated<tt> streambuf</tt>
 object specified by the<b> sb</b> parameter.
<br>This function is likely to be used for the creation of an<tt> istream</tt> object that is associated with the same<tt>
 streambuf</tt> object as another<tt> istream</tt> object.
<dt><br>Results:
<dd>This form of the public<tt> istream</tt> constructor creates an initialized<tt> istream</tt> object.&nbsp; If the<b> sb</b>
 parameter is<tt> NULL</tt>,<tt> ios::badbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~istream</tt>
</dl>
<h2 id="istream____istreamLR"> ~istream() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual istream::~istream();</tt>
<dt><br>Semantics:
<dd>The public virtual<tt> ~istream</tt> destructor does not do anything explicit.&nbsp; The<tt> ios</tt> destructor is called
 for that portion of the<tt> istream</tt> object.&nbsp; The call to the public virtual<tt> ~istream</tt> destructor is inserted
 implicitly by the compiler at the point where the<tt> istream</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> istream</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> istream</tt>
</dl>
<h2 id="istream__operator_ELR"> operator =() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::operator =( streambuf *sb );</tt>
<dt><br>Semantics:
<dd>This form of the<tt> operator =</tt> public member function is used to associate a<tt> streambuf</tt> object, specified by
 the<b> sb</b> parameter, with an existing<tt> istream</tt> object.&nbsp; The<tt> istream</tt> object is initialized and will
 use the specified<tt> streambuf</tt> object for subsequent operations.
<dt><br>Results:
<dd>This form of the<tt> operator =</tt> public member function returns a reference to the<tt> istream</tt> object that is the
 target of the assignment.&nbsp; If the<b> sb</b> parameter is<tt> NULL</tt>,<tt> ios::badbit</tt> is set in the error state
 in the inherited<tt> ios</tt> object.
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::operator =( istream const &amp;istrm );</tt>
<dt><br>Semantics:
<dd>This form of the<tt> operator =</tt> public member function is used to associate the<tt> istream</tt> object with the<tt>
 streambuf</tt> object currently associated with the<b> istrm</b> parameter.&nbsp; The<tt> istream</tt> object is initialized
 and will use the<b> istrm</b>'s<tt> streambuf</tt> object for subsequent operations.&nbsp; The<b> istrm</b> object will continue
 to use the<tt> streambuf</tt> object.
<dt><br>Results:
<dd>This form of the<tt> operator =</tt> public member function returns a reference to the<tt> istream</tt> object that is the
 target of the assignment.&nbsp; If there is no<tt> streambuf</tt> object currently associated with the<b> istrm</b> parameter,<tt>
 ios::badbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
</dl>
<h2 id="istream__operator_YYLR"> operator &gt;&gt;() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::operator &gt;&gt;( char *buf );</tt>
<br><tt> istream &amp;istream::operator &gt;&gt;( signed char *buf );</tt>
<br><tt> istream &amp;istream::operator &gt;&gt;( unsigned char *buf );</tt>
<dt><br>Semantics:
<dd>These forms of the<tt> operator &gt;&gt;</tt> public member function perform a formatted read of characters from the<tt> istream</tt>
 object and place them in the buffer specified by the<b> buf</b> parameter.&nbsp; Characters are read until a whitespace character
 is found or the maximum size has been read.&nbsp; If a whitespace character is found, it is not transferred to the buffer
 and remains in the<tt> istream</tt> object.
<br>If a non-zero<b> format width</b> has been specified, it is interpreted as the maximum number of characters that may be
 placed in<b> buf</b>.&nbsp; No more than<b> format width</b>-1 characters are read from the<tt> istream</tt> object and transferred
 to<b> buf</b>.&nbsp; If<b> format width</b> is zero, characters are transferred until a whitespace character is found.
<br><br>Since these forms of the<tt> operator &gt;&gt;</tt> public member function use<b> format width</b>, it is reset to
 zero after each use.&nbsp; It must be set before each input operation that requires a non-zero<b> format width</b>.
<br><br>A null character is added following the last transferred character, even if the transfer fails because of an error.
<dt><br>Results:
<dd>These forms of the<tt> operator &gt;&gt;</tt> public member function return a reference to the<tt> istream</tt> object so
 that further extraction operations may be specified in the same statement.&nbsp; If no characters are transferred to<b> buf</b>,<tt>
 ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt> object.&nbsp; If the first character read yielded
 end-of-file,<tt> ios::eofbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> istream::get</tt>,<tt> getline</tt>,<tt> read</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::operator &gt;&gt;( char &amp;ch );</tt>
<br><tt> istream &amp;istream::operator &gt;&gt;( signed char &amp;ch );</tt>
<br><tt> istream &amp;istream::operator &gt;&gt;( unsigned char &amp;ch );</tt>
<dt><br>Semantics:
<dd>These forms of the<tt> operator &gt;&gt;</tt> public member function perform a formatted read of a single character from the<tt>
 istream</tt> object and place it in the<b> ch</b> parameter.
<dt><br>Results:
<dd>These forms of the<tt> operator &gt;&gt;</tt> public member function return a reference to the<tt> istream</tt> object so
 that further extraction operations may be specified in the same statement.&nbsp; If the character read yielded end-of-file,<tt>
 ios::eofbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> istream::get</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::operator &gt;&gt;( signed int &amp;num );</tt>
<br><tt> istream &amp;istream::operator &gt;&gt;( unsigned int &amp;num );</tt>
<br><tt> istream &amp;istream::operator &gt;&gt;( signed long &amp;num );</tt>
<br><tt> istream &amp;istream::operator &gt;&gt;( unsigned long &amp;num );</tt>
<br><tt> istream &amp;istream::operator &gt;&gt;( signed short &amp;num );</tt>
<br><tt> istream &amp;istream::operator &gt;&gt;( unsigned short &amp;num );</tt>
<dt><br>Semantics:
<dd>These forms the<tt> operator &gt;&gt;</tt> public member function perform a formatted read of an integral value from the<tt>
 istream</tt> object and place it in the<b> num</b> parameter.
<br>The number may be preceded by a<tt> +</tt> or<tt> -</tt> sign.
<br><br>If<tt> ios::dec</tt> is the only bit set in the<tt> ios::basefield</tt> bits of<tt> ios::fmtflags</tt>, the number
 is interpreted as a decimal (base 10) integer, composed of the digits<tt> 0123456789</tt>.
<br><br>If<tt> ios::oct</tt> is the only bit set in the<tt> ios::basefield</tt> bits of<tt> ios::fmtflags</tt>, the number
 is interpreted as an octal (base 8) integer, composed of the digits<tt> 01234567</tt>.
<br><br>If<tt> ios::hex</tt> is the only bit set in the<tt> ios::basefield</tt> bits of<tt> ios::fmtflags</tt>, the number
 is interpreted as a hexadecimal (base 16) integer, composed of the digits<tt> 0123456789</tt> and the letters<tt> abcdef</tt>
 or<tt> ABCDEF</tt>.
<br><br>If no bits are set in the<tt> ios::basefield</tt> bits of<tt> ios::fmtflags</tt>, the operator looks for a prefix
 to determine the base of the number.&nbsp; If the first two characters are<tt> 0x</tt> or<tt> 0X</tt>, the number is interpreted
 as a hexadecimal number.&nbsp; If the first character is a<tt> 0</tt> (and the second is not an<tt> x</tt> or<tt> X</tt>),
 the number is interpreted as an octal integer.&nbsp; Otherwise, no prefix is expected and the number is interpreted as a
 decimal integer.
<br><br>If more than one bit is set in the<tt> ios::basefield</tt> bits of<tt> ios::fmtflags</tt>, the number is interpreted
 as a decimal integer.
<dt><br>Results:
<dd>These forms of the<tt> operator &gt;&gt;</tt> public member function return a reference to the<tt> istream</tt> object so
 that further extraction operations may be specified in the same statement.&nbsp; If end-of-file is encountered as the first
 character,<tt> ios::eofbit</tt> is set in the error state in the inherited<tt> ios</tt> object.&nbsp; If an overflow occurs
 while converting to the required integer type, the<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt>
 object.
<dt><br>See Also:
<dd><tt> ios::fmtflags</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::operator &gt;&gt;( float &amp;num );</tt>
<br><tt> istream &amp;istream::operator &gt;&gt;( double &amp;num );</tt>
<br><tt> istream &amp;istream::operator &gt;&gt;( long double &amp;num );</tt>
<dt><br>Semantics:
<dd>These forms of the<tt> operator &gt;&gt;</tt> public member function perform a formatted read of a floating-point value from
 the<tt> istream</tt> object and place it in the<b> num</b> parameter.
<br>The floating-point value may be specified in any form that is acceptable to the C++ compiler.
<dt><br>Results:
<dd>These forms of the<tt> operator &gt;&gt;</tt> public member function return a reference to the<tt> istream</tt> object so
 that further extraction operations may be specified in the same statement.&nbsp; If end-of-file is encountered as the first
 character,<tt> ios::eofbit</tt> is set in the error state in the inherited<tt> ios</tt> object.&nbsp; If an overflow occurs
 while converting to the required type, the<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt>
 object.
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::operator &gt;&gt;( streambuf &amp;sb );</tt>
<dt><br>Semantics:
<dd>This form of the<tt> operator &gt;&gt;</tt> public member function transfers all the characters from the<tt> istream</tt>
 object into the<b> sb</b> parameter.&nbsp; Reading continues until end-of-file is encountered.
<dt><br>Results:
<dd>This form of the<tt> operator &gt;&gt;</tt> public member function return a reference to the<tt> istream</tt> object so that
 further extraction operations may be specified in the same statement.
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::operator &gt;&gt;( istream &amp;(*fn)( istream &amp; ) );</tt>
<br><tt> istream &amp;istream::operator &gt;&gt;( ios &amp;(*fn)( ios &amp; ) );</tt>
<dt><br>Semantics:
<dd>These forms of the<tt> operator &gt;&gt;</tt> public member function are used to implement the non-parameterized manipulators
 for the<tt> istream</tt> class.&nbsp; The function specified by the<b> fn</b> parameter is called with the<tt> istream</tt>
 object as its parameter.
<dt><br>Results:
<dd>These forms of the<tt> operator &gt;&gt;</tt> public member function return a reference to the<tt> istream</tt> object so
 that further extraction operations may be specified in the same statement.
</dl>
<h2 id="istream__peekLR"> peek() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int istream::peek();</tt>
<dt><br>Semantics:
<dd>The<tt> peek</tt> public member function looks up the next character to be extracted from the<tt> istream</tt> object, without
 extracting the character.
<dt><br>Results:
<dd>The<tt> peek</tt> public member function returns the next character to be extracted from the<tt> istream</tt> object.&nbsp;
 If the<tt> istream</tt> object is positioned at end-of-file,<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> istream::get</tt>
</dl>
<h2 id="istream__putbackLR"> putback() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::putback( char ch );</tt>
<dt><br>Semantics:
<dd>The<tt> putback</tt> public member function attempts to put the extracted character specified by the<b> ch</b> parameter back
 into the<tt> istream</tt> object.&nbsp; The<b> ch</b> character must be the same as the character before the current position
 of the<tt> istream</tt> object, usually the last character extracted from the stream.&nbsp; If it is not the same character,
 the result of the next character extraction is undefined.
<br>The number of characters that can be put back is defined by the<tt> istream</tt> object, but is usually at least 4.&nbsp;
 Depending on the status of the buffers used for input, it may be possible to put back more than 4 characters.
<dt><br>Results:
<dd>The<tt> putback</tt> public member function returns a reference to the<tt> istream</tt> object.&nbsp; If the<tt> putback</tt>
 public member function is unable to put back the<b> ch</b> parameter,<tt> ios::failbit</tt> is set in the error state in
 the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> istream::get</tt>
</dl>
<h2 id="istream__readLR"> read() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::read( char *buf, int len );</tt>
<br><tt> istream &amp;istream::read( signed char *buf, int len );</tt>
<br><tt> istream &amp;istream::read( unsigned char *buf, int len );</tt>
<dt><br>Semantics:
<dd>The<tt> read</tt> public member function performs an unformatted read of at most<b> len</b> characters from the<tt> istream</tt>
 object and stores them in the memory locations starting at<b> buf</b>.&nbsp; If end-of-file is encountered before<b> len</b>
 characters have been transferred, the transfer stops and<tt> ios::failbit</tt> is set in the error state in the inherited<tt>
 ios</tt> object.
<br>The number of characters extracted can be determined with the<tt> gcount</tt> member function.
<dt><br>Results:
<dd>The<tt> read</tt> public member function returns a reference to the<tt> istream</tt> object.&nbsp; If end-of-file is encountered
 as the first character,<tt> ios::eofbit</tt> is set in the error state in the inherited<tt> ios</tt> object.&nbsp; If end-of-file
 is encountered before<b> len</b> characters are transferred,<tt> ios::failbit</tt> is set in the error state in the inherited<tt>
 ios</tt> object.
<dt><br>See Also:
<dd><tt> istream::gcount</tt>,<tt> get</tt>,<tt> getline</tt>
</dl>
<h2 id="istream__seekgLR"> seekg() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::seekg( streampos pos );</tt>
<dt><br>Semantics:
<dd>The<tt> seekg</tt> public member function positions the<tt> istream</tt> object to the position specified by the<b> pos</b>
 parameter so that the next input operation commences from that position.
<dt><br>Results:
<dd>The<tt> seekg</tt> public member function returns a reference to the<tt> istream</tt> object.&nbsp; If the seek operation
 fails,<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> istream::tellg</tt>,<tt> ostream::tellp</tt>,<tt> ostream::seekp</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istream &amp;istream::seekg( streamoff offset, ios::seekdir dir );</tt>
<dt><br>Semantics:
<dd>The<tt> seekg</tt> public member function positions the<tt> istream</tt> object to the specified position so that the next
 input operation commences from that position.
<br>The<b> dir</b> parameter may be<tt> ios::beg</tt>,<tt> ios::cur</tt>, or<tt> ios::end</tt> and is interpreted in conjunction
 with the<b> offset</b> parameter as follows:
<br><br><tt>ios::beg</tt>&nbsp; the <b>offset</b> is relative to the start and should be a positive value.
<br><tt>ios::cur</tt>&nbsp; the <b>offset</b> is relative to the current position and may be positive
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (seek towards end) or negative (seek towards start).
<br><tt>ios::end</tt>&nbsp; the <b>offset</b> is relative to the end and should be a negative value.
<br><br>If the<b> dir</b> parameter has any other value, or the<b> offset</b> parameter does not have an appropriate sign,
 the<tt> seekg</tt> public member function fails.
<dt><br>Results:
<dd>The<tt> seekg</tt> public member function returns a reference to the<tt> istream</tt> object.&nbsp; If the seek operation
 fails,<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ostream::tellp</tt>,<tt> ostream::seekp</tt>
<br><tt>istream::tellg</tt>
</dl>
<h2 id="istream__syncLR"> sync() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int istream::sync();</tt>
<dt><br>Semantics:
<dd>The<tt> sync</tt> public member function synchronizes the input buffer and the<tt> istream</tt> object with whatever source
 of characters is being used.&nbsp; The<tt> sync</tt> public member function uses the<tt> streambuf</tt> class's<tt> sync</tt>
 virtual member function to carry out the synchronization.&nbsp; The specific behavior is dependent on what type of<tt> streambuf</tt>
 derived object is associated with the<tt> istream</tt> object.
<dt><br>Results:
<dd>The<tt> sync</tt> public member function returns<tt> __NOT_EOF</tt> on success, otherwise<tt> EOF</tt> is returned.
</dl>
<h2 id="istream__tellgLR"> tellg() &#91;istream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>streampos istream::tellg();</tt>
<dt><br>Semantics:
<dd>The<tt> tellg</tt> public member function determines the position in the<tt> istream</tt> object of the next character available
 for reading.&nbsp; The first character in an<tt> istream</tt> object is at offset zero.
<dt><br>Results:
<dd>The<tt> tellg</tt> public member function returns the position of the next character available for reading.
<dt><br>See Also:
<dd><tt> ostream::tellp</tt>,<tt> ostream::seekp</tt>
<br><tt>istream::seekg</tt>
</dl>
<h2 id="istrstream_Class_Description"> istrstream Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> strstrea.h</tt>
<dt><br>Derived from:
<dd><tt> strstreambase</tt>,<tt> istream</tt>
<br>The<tt> istrstream</tt> class is used to create and read from string stream objects.
<br>The<tt> istrstream</tt> class provides little of its own functionality.&nbsp; Derived from the<tt> strstreambase</tt>
 and<tt> istream</tt> classes, its constructors and destructor provide simplified access to the appropriate equivalents in
 those base classes.
<br><br>Of the available I/O stream classes, creating an<tt> istrstream</tt> object is the preferred method of performing
 read operations from a string stream.
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>istrstream( char * );</tt>
<br><tt> istrstream( signed char * );</tt>
<br><tt> istrstream( unsigned char * );</tt>
<br><tt> istrstream( char *, int );</tt>
<br><tt> istrstream( signed char *, int );</tt>
<br><tt> istrstream( unsigned char *, int );</tt>
<br><tt> ~istrstream();</tt>
<dt><br>See Also:
<dd><tt> istream</tt>,<tt> ostrstream</tt>,<tt> strstream</tt>,<tt> strstreambase</tt>
</dl>
<h2 id="istrstream__istrstreamLR"> istrstream() &#91;istrstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istrstream::istrstream( char *str );</tt>
<br><tt> istrstream::istrstream( signed char *str );</tt>
<br><tt> istrstream::istrstream( unsigned char *str );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> istrstream</tt> constructor creates an<tt> istrstream</tt> object consisting of the null terminated
 C string specified by the<b> str</b> parameter.&nbsp; The inherited<tt> istream</tt> member functions can be used to read
 from the<tt> istrstream</tt> object.
<dt><br>Results:
<dd>This form of the public<tt> istrstream</tt> constructor creates an initialized<tt> istrstream</tt> object.
<dt><br>See Also:
<dd><tt> ~istrstream</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istrstream::istrstream( char *str, int len );</tt>
<br><tt> istrstream::istrstream( signed char *str, int len );</tt>
<br><tt> istrstream::istrstream( unsigned char *str, int len );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> istrstream</tt> constructor creates an<tt> istrstream</tt> object consisting of the characters
 starting at<b> str</b> and ending at<b> str</b> +<b> len</b> - 1.&nbsp; The inherited<tt> istream</tt> member functions can
 be used to read from the<tt> istrstream</tt> object.
<dt><br>Results:
<dd>This form of the public<tt> istrstream</tt> constructor creates an initialized<tt> istrstream</tt> object.
<dt><br>See Also:
<dd><tt> ~istrstream</tt>
</dl>
<h2 id="istrstream____istrstreamLR"> ~istrstream() &#91;istrstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>istrstream::~istrstream();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~istrstream</tt> destructor does not do anything explicit.&nbsp; The call to the public<tt> ~istrstream</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> istrstream</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> istrstream</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> istrstream</tt>
</dl>
<h2 id="Manipulators"> Manipulators &#91;manipulator&#93; </h2>
<dl>
<dt>Declared:
<dd><tt> iostream.h and iomanip.h</tt>
<br>Manipulators are designed to be inserted into or extracted from a stream.&nbsp; Manipulators come in two forms, non-parameterized
 and parameterized.&nbsp; The non-parameterized manipulators are simpler and are declared in<tt> &lt;iostream.h&gt;</tt>.
&nbsp; The parameterized manipulators require more complexity and are declared in<tt> &lt;iomanip.h&gt;</tt>.
<br><tt>&lt;iomanip.h&gt;</tt> defines two macros<tt> SMANIP_define</tt> and<tt> SMANIP_make</tt> to implement parameterized
 manipulators.&nbsp; The workings of the<tt> SMANIP_define</tt> and<tt> SMANIP_make</tt> macros are disclosed in the header
 file and are not discussed here.
<br><br><b>Non-parameterized Manipulators</b>
<br><br>The following non-parameterized manipulators are declared in<tt> &lt;iostream.h&gt;</tt>:
<br><br><tt>ios &amp;dec( ios &amp; );</tt>
<br><tt>ios &amp;hex( ios &amp; );</tt>
<br><tt>ios &amp;oct( ios &amp; );</tt>
<br><tt>istream &amp;ws( istream &amp; );</tt>
<br><tt>ostream &amp;endl( ostream &amp; );</tt>
<br><tt>ostream &amp;ends( ostream &amp; );</tt>
<br><tt>ostream &amp;flush( ostream &amp; );</tt>
<br><br><b>Parameterized Manipulators</b>
<br><br>The following parameterized manipulators are declared in<tt> &lt;iomanip.h&gt;</tt>:
<br><br><tt>SMANIP_define( long ) resetiosflags( long );</tt>
<br><tt>SMANIP_define( int )&nbsp; setbase( int );</tt>
<br><tt>SMANIP_define( int )&nbsp; setfill( int );</tt>
<br><tt>SMANIP_define( long ) setiosflags( long );</tt>
<br><tt>SMANIP_define( int )&nbsp; setprecision( int );</tt>
<br><tt>SMANIP_define( int )&nbsp; setw( int );</tt>
<br><tt>SMANIP_define( int )&nbsp; setwidth( int );</tt>
</dl>
<h2 id="manipulator_decLR"> manipulator dec() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>ios &amp;dec( ios &amp;strm );</tt>
<dt><br>Semantics:
<dd>The<tt> dec</tt> manipulator sets the<tt> ios::basefield</tt> bits for decimal formatting in<tt> ios::fmtflags</tt> in the<b>
 strm</b><tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ios::fmtflags</tt>
</dl>
<h2 id="manipulator_endlLR"> manipulator endl() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>ostream &amp;endl( ostream &amp;ostrm );</tt>
<dt><br>Semantics:
<dd>The<tt> endl</tt> manipulator writes a new-line character to the stream specified by the<b> ostrm</b> parameter and performs
 a flush.
<dt><br>See Also:
<dd><tt> ostream::flush</tt>
</dl>
<h2 id="manipulator_endsLR"> manipulator ends() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>ostream &amp;ends( ostream &amp;ostrm );</tt>
<dt><br>Semantics:
<dd>The<tt> ends</tt> manipulator writes a null character to the stream specified by the<b> ostrm</b> parameter.
</dl>
<h2 id="manipulator_flushLR"> manipulator flush() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>ostream &amp;flush( ostream &amp;ostrm );</tt>
<dt><br>Semantics:
<dd>The<tt> flush</tt> manipulator flushes the stream specified by the<b> ostrm</b> parameter.&nbsp; The flush is performed in
 the same manner as the<tt> flush</tt> member function.
<dt><br>See Also:
<dd><tt> ostream::flush</tt>
</dl>
<h2 id="manipulator_hexLR"> manipulator hex() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>ios &amp;hex( ios &amp;strm );</tt>
<dt><br>Semantics:
<dd>The<tt> hex</tt> manipulator sets the<tt> ios::basefield</tt> bits for hexadecimal formatting in<tt> ios::fmtflags</tt> in
 the<b> strm</b><tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ios::fmtflags</tt>
</dl>
<h2 id="manipulator_octLR"> manipulator oct() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>ios &amp;oct( ios &amp;strm );</tt>
<dt><br>Semantics:
<dd>The<tt> oct</tt> manipulator sets the<tt> ios::basefield</tt> bits for octal formatting in<tt> ios::fmtflags</tt> in the<b>
 strm</b><tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ios::fmtflags</tt>
</dl>
<h2 id="manipulator_resetiosflagsLR"> manipulator resetiosflags() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iomanip.h&gt;</tt>
<br><tt>SMANIP_define( long ) resetiosflags( long flags )</tt>
<dt><br>Semantics:
<dd>The<tt> resetiosflags</tt> manipulator turns off the bits in<tt> ios::fmtflags</tt> that correspond to the bits that are on
 in the<b> flags</b> parameter.&nbsp; No other bits are affected.
<dt><br>See Also:
<dd><tt> ios::flags</tt>,<tt> ios::fmtflags</tt>,<tt> ios::setf</tt>,<tt> ios::unsetf</tt>
</dl>
<h2 id="manipulator_setbaseLR"> manipulator setbase() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iomanip.h&gt;</tt>
<br><tt>SMANIP_define( int ) setbase( int base );</tt>
<dt><br>Semantics:
<dd>The<tt> setbase</tt> manipulator sets the<tt> ios::basefield</tt> bits in<tt> ios::fmtflags</tt> to the value specified by
 the<b> base</b> parameter within the stream that the<tt> setbase</tt> manipulator is operating upon.
<dt><br>See Also:
<dd><tt> ios::fmtflags</tt>
</dl>
<h2 id="manipulator_setfillLR"> manipulator setfill() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iomanip.h&gt;</tt>
<br><tt>SMANIP_define( int ) setfill( int fill )</tt>
<dt><br>Semantics:
<dd>The<tt> setfill</tt> manipulator sets the<b> fill character</b> to the value specified by the<b> fill</b> parameter within
 the stream that the<tt> setfill</tt> manipulator is operating upon.
<dt><br>See Also:
<dd><tt> ios::fill</tt>
</dl>
<h2 id="manipulator_setiosflagsLR"> manipulator setiosflags() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iomanip.h&gt;</tt>
<br><tt>SMANIP_define( long ) setiosflags( long flags );</tt>
<dt><br>Semantics:
<dd>The<tt> setiosflags</tt> manipulator turns on the bits in<tt> ios::fmtflags</tt> that correspond to the bits that are on in
 the<b> flags</b> parameter.&nbsp; No other bits are affected.
<dt><br>See Also:
<dd><tt> ios::flags</tt>,<tt> ios::fmtflags</tt>,<tt> ios::setf</tt>,<tt> ios::unsetf</tt>
</dl>
<h2 id="manipulator_setprecisionLR"> manipulator setprecision() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iomanip.h&gt;</tt>
<br><tt>SMANIP_define( int ) setprecision( int prec );</tt>
<dt><br>Semantics:
<dd>The<tt> setprecision</tt> manipulator sets the<b> format precision</b> to the value specified by the<b> prec</b> parameter
 within the stream that the<tt> setprecision</tt> manipulator is operating upon.
<dt><br>See Also:
<dd><tt> ios::precision</tt>
</dl>
<h2 id="manipulator_setwLR"> manipulator setw() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iomanip.h&gt;</tt>
<br><tt>SMANIP_define( int ) setw( int wid );</tt>
<dt><br>Semantics:
<dd>The<tt> setw</tt> manipulator sets the<b> format width</b> to the value specified by the<b> wid</b> parameter within the stream
 that the<tt> setw</tt> manipulator is operating upon.
<dt><br>See Also:
<dd><tt> ios::width</tt>, manipulator<tt> setwidth</tt>
</dl>
<h2 id="manipulator_setwidthLR"> manipulator setwidth() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iomanip.h&gt;</tt>
<br><tt>SMANIP_define( int ) setwidth( int wid );</tt>
<dt><br>Semantics:
<dd>The<tt> setwidth</tt> manipulator sets the<b> format width</b> to the value specified by the<b> wid</b> parameter within the
 stream that the<tt> setwidth</tt> manipulator is operating upon.
<br>This function is a WATCOM extension.
<dt><br>See Also:
<dd><tt> ios::width</tt>, manipulator<tt> setw</tt>
</dl>
<h2 id="manipulator_wsLR"> manipulator ws() &#91;manipulator&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>istream &amp;ws( istream &amp;istrm );</tt>
<dt><br>Semantics:
<dd>The<tt> ws</tt> manipulator extracts and discards whitespace characters from the<b> istrm</b> parameter, leaving the stream
 positioned at the next non-whitespace character.
<br>The<tt> ws</tt> manipulator is needed particularly when the<tt> ios::skipws</tt> bit is not set in<tt> ios::fmtflags</tt>
 in the<b> istrm</b> object.&nbsp; In this case, whitespace characters must be explicitly removed from the stream, since the
 formatted input operations will not automatically remove them.
<dt><br>See Also:
<dd><tt> istream::eatwhite</tt>,<tt> istream::ignore</tt>
</dl>
<h2 id="ofstream_Class_Description"> ofstream Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> fstream.h</tt>
<dt><br>Derived from:
<dd><tt> fstreambase</tt>,<tt> ostream</tt>
<br>The<tt> ofstream</tt> class is used to create new files or access existing files for writing.&nbsp; The file can be opened
 and closed, and write and seek operations can be performed.
<br>The<tt> ofstream</tt> class provides very little of its own functionality.&nbsp; Derived from both the<tt> fstreambase</tt>
 and<tt> ostream</tt> classes, its constructors, destructor and member function provide simplified access to the appropriate
 equivalents in those base classes.
<br><br>Of the available I/O stream classes, creating an<tt> ofstream</tt> object is the preferred method of accessing a file
 for output operations.
<br><br><b>Public Member Functions</b>
<br><br>The following public member functions are declared:
<br><br><tt>ofstream();</tt>
<br><tt> ofstream( char const *,</tt>
<br><tt> ios::openmode = ios::out,</tt>
<br><tt>int = filebuf::openprot );</tt>
<br><tt>ofstream( filedesc );</tt>
<br><tt> ofstream( filedesc, char *, int );</tt>
<br><tt> ~ofstream();</tt>
<br><tt> void open( char const *,</tt>
<br><tt> ios::openmode = ios::out,</tt>
<br><tt>int = filebuf::openprot );</tt>
<dt><br>See Also:
<dd><tt> fstream</tt>,<tt> fstreambase</tt>,<tt> ifstream</tt>,<tt> ostream</tt>
</dl>
<h2 id="ofstream__ofstreamLR"> ofstream() &#91;ofstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ofstream::ofstream();</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> ofstream</tt> constructor creates an<tt> ofstream</tt> object that is not connected to a file.
&nbsp; The<tt> open</tt> or<tt> attach</tt> member functions should be used to connect the<tt> ofstream</tt> object to a file.
<dt><br>Results:
<dd>The public<tt> ofstream</tt> constructor produces an<tt> ofstream</tt> object that is not connected to a file.
<dt><br>See Also:
<dd><tt> ~ofstream</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ofstream::ofstream( const char *name,</tt>
<br><tt> ios::openmode mode = ios::out,</tt>
<br><tt>int prot = filebuf::openprot );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> ofstream</tt> constructor creates an<tt> ofstream</tt> object that is connected to the file specified
 by the<b> name</b> parameter, using the specified<b> mode</b> and<b> prot</b> parameters.&nbsp; The connection is made via
 the C library<tt> open</tt> function.
<dt><br>Results:
<dd>The public<tt> ofstream</tt> constructor produces an<tt> ofstream</tt> object that is connected to the file specified by<b>
 name</b>.&nbsp; If the<tt> open</tt> fails,<tt> ios::failbit</tt> and<tt> ios::badbit</tt> are set in the error state in
 the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~ofstream</tt>,<tt> open</tt>,<tt> fstreambase::close</tt>,<tt> openmode</tt>,<tt> openprot</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ofstream::ofstream( filedesc hdl );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> ofstream</tt> constructor creates an<tt> ofstream</tt> object that is attached to the file specified
 by the<b> hdl</b> parameter.
<dt><br>Results:
<dd>The public<tt> ofstream</tt> constructor produces an<tt> ofstream</tt> object that is attached to<b> hdl</b>.&nbsp; If the
 attach fails,<tt> ios::failbit</tt> and<tt> ios::badbit</tt> are set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~ofstream</tt>,<tt> fstreambase::attach</tt>,<tt> fstreambase::fd</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ofstream::ofstream( filedesc hdl, char *buf, int len );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> ofstream</tt> constructor creates an<tt> ofstream</tt> object that is connected to the file specified
 by the<b> hdl</b> parameter.&nbsp; The buffer specified by the<b> buf</b> and<b> len</b> parameters is offered to the associated<tt>
 filebuf</tt> object via the<tt> setbuf</tt> member function.&nbsp; If the<b> buf</b> parameter is<tt> NULL</tt> or the<b>
 len</b> is less than or equal to zero, the<tt> filebuf</tt> is unbuffered, so that each read or write operation reads or
 writes a single character at a time.
<dt><br>Results:
<dd>The public<tt> ofstream</tt> constructor produces an<tt> ofstream</tt> object that is attached to<b> hdl</b>.&nbsp; If the
 connection to<b> hdl</b> fails,<tt> ios::failbit</tt> and<tt> ios::badbit</tt> are set in the error state in the inherited<tt>
 ios</tt> object.&nbsp; If the<tt> setbuf</tt> fails,<tt> ios::failbit</tt> is set in the error state in the inherited<tt>
 ios</tt> object.
<dt><br>See Also:
<dd><tt> ~ofstream</tt>,<tt> fstreambase::attach</tt>,<tt> fstreambase::fd</tt>,<tt> fstreambase::setbuf</tt>
</dl>
<h2 id="ofstream____ofstreamLR"> ~ofstream() &#91;ofstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ofstream::~ofstream();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~ofstream</tt> destructor does not do anything explicit.&nbsp; The call to the public<tt> ~ofstream</tt> destructor
 is inserted implicitly by the compiler at the point where the<tt> ofstream</tt> object goes out of scope.
<dt><br>Results:
<dd>The public<tt> ~ofstream</tt> destructor destroys the<tt> ofstream</tt> object.
<dt><br>See Also:
<dd><tt> ofstream</tt>
</dl>
<h2 id="ofstream__openLR"> open() &#91;ofstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;fstream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void ofstream::open( const char *name,</tt>
<br><tt> ios::openmode mode = ios::out,</tt>
<br><tt>int prot = filebuf::openprot );</tt>
<dt><br>Semantics:
<dd>The<tt> open</tt> public member function connects the<tt> ofstream</tt> object to the file specified by the<b> name</b> parameter,
 using the specified<b> mode</b> and<b> prot</b> parameters.&nbsp; The<tt> mode</tt> parameter is optional and usually is
 not specified unless additional bits (such as<tt> ios::binary</tt> or<tt> ios::text</tt>) are to be specified.&nbsp; The
 connection is made via the C library<tt> open</tt> function.
<dt><br>Results:
<dd>If the open fails,<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ofstream</tt>,<tt> openmode</tt>,<tt> openprot</tt>,<tt> fstreambase::attach</tt>,<tt> fstreambase::close</tt>,<tt> fstreambase::fd</tt>,<tt>
 fstreambase::is_open</tt>
</dl>
<h2 id="ostream_Class_Description"> ostream Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> iostream.h</tt>
<dt><br>Derived from:
<dd><tt> ios</tt>
<dt><br>Derived by:
<dd><tt> iostream</tt>,<tt> ofstream</tt>,<tt> ostrstream</tt>
<br>The<tt> ostream</tt> class supports writing characters to a class derived from the<tt> streambuf</tt> class, and provides
 formatted conversion of types (such as integers and floating-point numbers) into characters.&nbsp; The class derived from
 the<tt> streambuf</tt> class provides the methods for communicating with the external device (screen, disk), while the<tt>
 ostream</tt> class provides the conversion of the types into characters.
<br>Generally,<tt> ostream</tt> objects won't be explicitly created by a program, since there is no mechanism at this level
 to open a device.&nbsp; The only default<tt> ostream</tt> objects in a program are<tt> cout</tt>,<tt> cerr</tt>, and<tt>
 clog</tt> which write to the standard output and error devices (usually the screen).
<br><br>The<tt> ostream</tt> class supports two basic concepts of output:&nbsp; formatted and unformatted.&nbsp; The overloaded<tt>
 operator &lt;&lt;</tt> member functions are called<b> inserters</b> and they provide the support for formatted output.&nbsp;
 The rest of the member functions deal with unformatted output, managing the state of the<tt> ios</tt> object and providing
 a friendlier interface to the associated<tt> streambuf</tt> object.
<br><br><b>Protected Member Functions</b>
<br><br>The following protected member functions are declared:
<br><br><tt>ostream();</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following public member functions are declared:
<br><br><tt>ostream( ostream const &amp; );</tt>
<br><tt> ostream( streambuf * );</tt>
<br><tt> virtual ~ostream();</tt>
<br><tt> ostream &amp;flush();</tt>
<br><tt> int opfx();</tt>
<br><tt> void osfx();</tt>
<br><tt> ostream &amp;put( char );</tt>
<br><tt> ostream &amp;put( signed char );</tt>
<br><tt> ostream &amp;put( unsigned char );</tt>
<br><tt> ostream &amp;seekp( streampos );</tt>
<br><tt> ostream &amp;seekp( streamoff, ios::seekdir );</tt>
<br><tt> streampos tellp();</tt>
<br><tt> ostream &amp;write( char const *, int );</tt>
<br><tt> ostream &amp;write( signed char const *, int );</tt>
<br><tt> ostream &amp;write( unsigned char const *, int );</tt>
<br><br><b>Public Member Operators</b>
<br><br>The following public member operators are declared:
<br><br><tt>ostream &amp;operator =( streambuf * );</tt>
<br><tt> ostream &amp;operator =( ostream const &amp; );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( char );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( signed char );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( unsigned char );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( signed short );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( unsigned short );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( signed int );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( unsigned int );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( signed long );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( unsigned long );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( float );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( double );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( long double );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( void * );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( streambuf &amp; );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( char const * );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( signed char const * );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( unsigned char const * );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( ostream &amp;(*)( ostream &amp; ) );</tt>
<br><tt> ostream &amp;operator &lt;&lt;( ios &amp;(*)( ios &amp; ) );</tt>
<dt><br>See Also:
<dd><tt> ios</tt>,<tt> iostream</tt>,<tt> istream</tt>
</dl>
<h2 id="ostream__flushLR"> flush() &#91;ostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::flush();</tt>
<dt><br>Semantics:
<dd>The<tt> flush</tt> public member function causes the<tt> ostream</tt> object's buffers to be flushed, forcing the contents
 to be written to the actual device connected to the<tt> ostream</tt> object.
<dt><br>Results:
<dd>The<tt> flush</tt> public member function returns a reference to the<tt> ostream</tt> object.&nbsp; On failure,<tt> ios::failbit</tt>
 is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ostream::osfx</tt>
</dl>
<h2 id="ostream__operator_XXLR"> operator &lt;&lt;() &#91;ostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::operator &lt;&lt;( char ch );</tt>
<br><tt> ostream &amp;ostream::operator &lt;&lt;( signed char ch );</tt>
<br><tt> ostream &amp;ostream::operator &lt;&lt;( unsigned char ch );</tt>
<dt><br>Semantics:
<dd>These forms of the<tt> operator &lt;&lt;</tt> public member function write the<b> ch</b> character into the<tt> ostream</tt>
 object.
<dt><br>Results:
<dd>These forms of the<tt> operator &lt;&lt;</tt> public member function return a reference to the<tt> ostream</tt> object so
 that further insertion operations may be specified in the same statement.<tt>&nbsp; ios::failbit</tt> is set in the error
 state in the inherited<tt> ios</tt> object if an error occurs.
<dt><br>See Also:
<dd><tt> ostream::put</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::operator &lt;&lt;( char const *str );</tt>
<br><tt> ostream &amp;ostream::operator &lt;&lt;( signed char const *str );</tt>
<br><tt> ostream &amp;ostream::operator &lt;&lt;( unsigned char const *str );</tt>
<dt><br>Semantics:
<dd>These forms of the<tt> operator &lt;&lt;</tt> public member function perform a formatted write of the contents of the C string
 specified by the<b> str</b> parameter to the<tt> ostream</tt> object.&nbsp; The characters from<b> str</b> are transferred
 up to, but not including the terminating null character.
<dt><br>Results:
<dd>These forms of the<tt> operator &lt;&lt;</tt> public member function return a reference to the<tt> ostream</tt> object so
 that further insertion operations may be specified in the same statement.<tt>&nbsp; ios::failbit</tt> is set in the error
 state in the inherited<tt> ios</tt> object if an error occurs.
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::operator &lt;&lt;( signed int num );</tt>
<br><tt> ostream &amp;ostream::operator &lt;&lt;( unsigned int num );</tt>
<br><tt> ostream &amp;ostream::operator &lt;&lt;( signed long num );</tt>
<br><tt> ostream &amp;ostream::operator &lt;&lt;( unsigned long num );</tt>
<br><tt> ostream &amp;ostream::operator &lt;&lt;( signed short num );</tt>
<br><tt> ostream &amp;ostream::operator &lt;&lt;( unsigned short num );</tt>
<dt><br>Semantics:
<dd>These forms of the<tt> operator &lt;&lt;</tt> public member function perform a formatted write of the integral value specified
 by the<b> num</b> parameter to the<tt> ostream</tt> object.&nbsp; The integer value is converted to a string of characters
 which are written to the<tt> ostream</tt> object.<b>&nbsp; num</b> is converted to a base representation depending on the
 setting of the<tt> ios::basefield</tt> bits in<tt> ios::fmtflags</tt>.&nbsp; If the<tt> ios::oct</tt> bit is the only bit
 on, the conversion is to an octal (base 8) representation.&nbsp; If the<tt> ios::hex</tt> bit is the only bit on, the conversion
 is to a hexadecimal (base 16) representation.&nbsp; Otherwise, the conversion is to a decimal (base 10) representation.
<br>For decimal conversions only, a sign may be written in front of the number.&nbsp; If the number is negative, a<tt> -</tt>
 minus sign is written.&nbsp; If the number is positive and the<tt> ios::showpos</tt> bit is on in<tt> ios::fmtflags</tt>,
 a<tt> +</tt> plus sign is written.&nbsp; No sign is written for a value of zero.
<br><br>If the<tt> ios::showbase</tt> bit is on in<tt> ios::fmtflags</tt>, and the conversion is to octal or hexadecimal,
 the base indicator is written next.&nbsp; The base indicator for a conversion to octal is a zero.&nbsp; The base indicator
 for a conversion to hexadecimal is<tt> 0x</tt> or<tt> 0X</tt>, depending on the setting of the<tt> ios::uppercase</tt> bit
 in<tt> ios::fmtflags</tt>.
<br><br>If the value being written is zero, the conversion is to octal, and the<tt> ios::showbase</tt> bit is on, nothing
 further is written since a single zero is sufficient.
<br><br>The value of<b> num</b> is then converted to characters.&nbsp; For conversions to decimal, the magnitude of the number
 is converted to a string of decimal digits<tt> 0123456789</tt>.&nbsp; For conversions to octal, the number is treated as
 an unsigned quantity and converted to a string of octal digits<tt> 01234567</tt>.&nbsp; For conversions to hexadecimal, the
 number is treated as an unsigned quantity and converted to a string of hexadecimal digits<tt> 0123456789</tt> and the letters<tt>
 abcdef</tt> or<tt> ABCDEF</tt>, depending on the setting of the<tt> ios::uppercase</tt> in<tt> ios::fmtflags</tt>.&nbsp;
 The string resulting from the conversion is then written to the<tt> ostream</tt> object.
<br><br>If the<tt> ios::internal</tt> bit is set in<tt> ios::fmtflags</tt> and padding is required, the padding characters
 are written after the sign and/or base indicator (if present) and before the digits.
<dt><br>Results:
<dd>These forms of the<tt> operator &lt;&lt;</tt> public member function return a reference to the<tt> ostream</tt> object so
 that further insertion operations may be specified in the same statement.<tt>&nbsp; ios::failbit</tt> is set in the error
 state in the inherited<tt> ios</tt> object if an error occurs.
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::operator &lt;&lt;( float num );</tt>
<br><tt> ostream &amp;ostream::operator &lt;&lt;( double num );</tt>
<br><tt> ostream &amp;ostream::operator &lt;&lt;( long double num );</tt>
<dt><br>Semantics:
<dd>These forms of the<tt> operator &lt;&lt;</tt> public member function perform a formatted write of the floating-point value
 specified by the<b> num</b> parameter to the<tt> ostream</tt> object.&nbsp; The number is converted to either scientific
 (exponential) form or fixed-point form, depending on the setting of the<tt> ios::floatfield</tt> bits in<tt> ios::fmtflags</tt>.
&nbsp; If<tt> ios::scientific</tt> is the only bit set, the conversion is to scientific form.&nbsp; If<tt> ios::fixed</tt>
 is the only bit set, the conversion is to fixed-point form.&nbsp; Otherwise (neither or both bits set), the value of the
 number determines the conversion used.&nbsp; If the exponent is less than -4 or is greater than or equal to the<b> format
 precision</b>, the scientific form is used.&nbsp; Otherwise, the fixed-point form is used.
<br>Scientific form consists of a minus sign (for negative numbers), one digit, a decimal point,<b> format precision</b>-1
 digits, an<tt> e</tt> or<tt> E</tt> (depending on the setting of the<tt> ios::uppercase</tt> bit), a minus sign (for negative
 exponents) or a plus sign (for zero or positive exponents), and two or three digits for the exponent.&nbsp; The digit before
 the decimal is not zero, unless the number is zero.&nbsp; If the<b> format precision</b> is zero (or one), no digits are
 written following the decimal point.
<br><br>Fixed-point form consists of a minus sign (for negative numbers), one or more digits, a decimal point, and<b> format
 precision</b> digits.
<br><br>If the<tt> ios::showpoint</tt> bit is not set in<tt> ios::fmtflags</tt>, trailing zeroes are trimmed after the decimal
 point (and before the exponent for scientific form), and if no digits remain after the decimal point, the decimal point is
 discarded as well.
<br><br>If the<tt> ios::internal</tt> bit is set in<tt> ios::fmtflags</tt> and padding is required, the padding characters
 are written after the sign (if present) and before the digits.
<dt><br>Results:
<dd>These forms of the<tt> operator &lt;&lt;</tt> public member function return a reference to the<tt> ostream</tt> object so
 that further insertion operations may be specified in the same statement.<tt>&nbsp; ios::failbit</tt> is set in the error
 state in the inherited<tt> ios</tt> object if an error occurs.
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::operator &lt;&lt;( void *ptr );</tt>
<dt><br>Semantics:
<dd>This form of the<tt> operator &lt;&lt;</tt> public member function performs a formatted write of the pointer value specified
 by the<b> ptr</b> parameter to the<tt> ostream</tt> object.&nbsp; The<b> ptr</b> parameter is converted to an implementation-defined
 string of characters and written to the<tt> ostream</tt> object.&nbsp; With the Open Watcom C++ implementation, the string
 starts with<tt> 0x</tt> or<tt> 0X</tt> (depending on the setting of the<tt> ios::uppercase</tt> bit), followed by 4 hexadecimal
 digits for 16-bit pointers and 8 hexadecimal digits for 32-bit pointers.&nbsp; Leading zeroes are added to ensure the correct
 number of digits are written.&nbsp; For far pointers, 4 additional hexadecimal digits and a colon are inserted immediately
 after the<tt> 0x</tt> prefix.
<dt><br>Results:
<dd>This form of the<tt> operator &lt;&lt;</tt> public member function returns a reference to the<tt> ostream</tt> object so that
 further insertion operations may be specified in the same statement.<tt>&nbsp; ios::failbit</tt> is set in the error state
 in the inherited<tt> ios</tt> object if an error occurs during the write.
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::operator &lt;&lt;( streambuf &amp;sb );</tt>
<dt><br>Semantics:
<dd>This form of the<tt> operator &lt;&lt;</tt> public member function transfers the contents of the<b> sb</b><tt> streambuf</tt>
 object to the<tt> ostream</tt> object.&nbsp; Reading from the<tt> streambuf</tt> object stops when the read fails.&nbsp;
 No padding with the<b> fill character</b> takes place on output to the<tt> ostream</tt> object.
<dt><br>Results:
<dd>This form of the<tt> operator &lt;&lt;</tt> public member function returns a reference to the<tt> ostream</tt> object so that
 further insertion operations may be specified in the same statement.<tt>&nbsp; ios::failbit</tt> is set in the error state
 in the inherited<tt> ios</tt> object if an error occurs.
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::operator &lt;&lt;( ostream &amp;(*fn)( ostream &amp;) );</tt>
<br><tt> ostream &amp;ostream::operator &lt;&lt;( ios &amp;(*fn)( ios &amp; ) );</tt>
<dt><br>Semantics:
<dd>These forms of the<tt> operator &lt;&lt;</tt> public member function are used to implement the non-parameterized manipulators
 for the<tt> ostream</tt> class.&nbsp; The function specified by the<b> fn</b> parameter is called with the<tt> ostream</tt>
 object as its parameter.
<dt><br>Results:
<dd>These forms of the<tt> operator &lt;&lt;</tt> public member function return a reference to the<tt> ostream</tt> object so
 that further insertions operations may be specified in the same statement.
</dl>
<h2 id="ostream__operator_ELR"> operator =() &#91;ostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::operator =( streambuf *sb );</tt>
<dt><br>Semantics:
<dd>This form of the<tt> operator =</tt> public member function is used to associate a<tt> streambuf</tt> object, specified by
 the<b> sb</b> parameter, with an existing<tt> ostream</tt> object.&nbsp; The<tt> ostream</tt> object is initialized and will
 use the specified<tt> streambuf</tt> object for subsequent operations.
<dt><br>Results:
<dd>This form of the<tt> operator =</tt> public member function returns a reference to the<tt> ostream</tt> object that is the
 target of the assignment.&nbsp; If the<b> sb</b> parameter is<tt> NULL</tt>,<tt> ios::badbit</tt> is set in the error state
 in the inherited<tt> ios</tt> object.
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::operator =( const ostream &amp;ostrm );</tt>
<dt><br>Semantics:
<dd>This form of the<tt> operator =</tt> public member function is used to associate the<tt> ostream</tt> object with the<tt>
 streambuf</tt> object currently associated with the<b> ostrm</b> parameter.&nbsp; The<tt> ostream</tt> object is initialized
 and will use the<b> ostrm</b>'s<tt> streambuf</tt> object for subsequent operations.&nbsp; The<b> ostrm</b> object will continue
 to use the<tt> streambuf</tt> object.
<dt><br>Results:
<dd>This form of the<tt> operator =</tt> public member function returns a reference to the<tt> ostream</tt> object that is the
 target of the assignment.&nbsp; If there is no<tt> streambuf</tt> object currently associated with the<b> ostrm</b> parameter,<tt>
 ios::badbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
</dl>
<h2 id="ostream__opfxLR"> opfx() &#91;ostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int ostream::opfx();</tt>
<dt><br>Semantics:
<dd>If<tt> opfx</tt> public member function is a prefix function executed before each of the formatted and unformatted output
 operations.&nbsp; If any bits are set in<tt> ios::iostate</tt>, the<tt> opfx</tt> public member function immediately returns
 zero, indicating that the prefix function failed.&nbsp; Failure in the prefix function causes the output operation to fail.
<br>If the<tt> ostream</tt> object is tied to another<tt> ostream</tt> object, the other<tt> ostream</tt> object is flushed.
<dt><br>Results:
<dd>The<tt> opfx</tt> public member function returns a non-zero value on success, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> ostream::osfx</tt>,<tt> flush</tt>,<tt> ios::tie</tt>
</dl>
<h2 id="ostream__osfxLR"> osfx() &#91;ostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void ostream::osfx();</tt>
<dt><br>Semantics:
<dd>The<tt> osfx</tt> public member function is a suffix function executed at the end of each of the formatted and unformatted
 output operations.
<br>If the<tt> ios::unitbuf</tt> bit is set in<tt> ios::fmtflags</tt>, the<tt> flush</tt> member function is called.&nbsp;
 If the<tt> ios::stdio</tt> bit is set in<tt> ios::fmtflags</tt>, the C library<tt> fflush</tt> function is invoked on the<tt>
 stdout</tt> and<tt> stderr</tt> file streams.
<dt><br>See Also:
<dd><tt> ostream::osfx</tt>,<tt> flush</tt>
</dl>
<h2 id="ostream__ostreamLR"> ostream() &#91;ostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>ostream::ostream();</tt>
<dt><br>Semantics:
<dd>This form of the protected<tt> ostream</tt> constructor creates an<tt> ostream</tt> object without an attached<tt> streambuf</tt>
 object.
<br>This form of the protected<tt> ostream</tt> constructor is only used implicitly by the compiler when it generates a constructor
 for a derived class.
<dt><br>Results:
<dd>This form of the protected<tt> ostream</tt> constructor creates an initialized<tt> ostream</tt> object.<tt>&nbsp; ios::badbit</tt>
 is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~ostream</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream::ostream( ostream const &amp;ostrm );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> ostream</tt> constructor creates an<tt> ostream</tt> object associated with the<tt> streambuf</tt>
 object currently associated with the<b> ostrm</b> parameter.&nbsp; The<tt> ostream</tt> object is initialized and will use
 the<b> ostrm</b>'s<tt> streambuf</tt> object for subsequent operations.&nbsp; The<b> ostrm</b> object will continue to use
 the<tt> streambuf</tt> object.
<dt><br>Results:
<dd>This form of the public<tt> ostream</tt> constructor creates an initialized<tt> ostream</tt> object.&nbsp; If there is no<tt>
 streambuf</tt> object currently associated with the<b> ostrm</b> parameter,<tt> ios::badbit</tt> is set in the error state
 in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~ostream</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream::ostream( streambuf *sb );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> ostream</tt> constructor creates an<tt> ostream</tt> object with an associated<tt> streambuf</tt>
 object specified by the<b> sb</b> parameter.
<br>This function is likely to be used for the creation of an<tt> ostream</tt> object that is associated with the same<tt>
 streambuf</tt> object as another<tt> ostream</tt> object.
<dt><br>Results:
<dd>This form of the public<tt> ostream</tt> constructor creates an initialized<tt> ostream</tt> object.&nbsp; If the<b> sb</b>
 parameter is<tt> NULL</tt>,<tt> ios::badbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ~ostream</tt>
</dl>
<h2 id="ostream____ostreamLR"> ~ostream() &#91;ostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual ostream::~ostream();</tt>
<dt><br>Semantics:
<dd>The public virtual<tt> ~ostream</tt> destructor does not do anything explicit.&nbsp; The<tt> ios</tt> destructor is called
 for that portion of the<tt> ostream</tt> object.&nbsp; The call to the public virtual<tt> ~ostream</tt> destructor is inserted
 implicitly by the compiler at the point where the<tt> ostream</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> ostream</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> ostream</tt>
</dl>
<h2 id="ostream__putLR"> put() &#91;ostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::put( char ch );</tt>
<br><tt> ostream &amp;ostream::put( signed char ch );</tt>
<br><tt> ostream &amp;ostream::put( unsigned char ch );</tt>
<dt><br>Semantics:
<dd>These forms of the<tt> put</tt> public member function write the<b> ch</b> character to the<tt> ostream</tt> object.
<dt><br>Results:
<dd>These forms of the<tt> put</tt> public member function return a reference to the<tt> ostream</tt> object.&nbsp; If an error
 occurs,<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ostream::operator &lt;&lt;</tt>,<tt> write</tt>
</dl>
<h2 id="ostream__seekpLR"> seekp() &#91;ostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::seekp( streampos pos );</tt>
<dt><br>Semantics:
<dd>This from of the<tt> seekp</tt> public member function positions the<tt> ostream</tt> object to the position specified by
 the<b> pos</b> parameter so that the next output operation commences from that position.
<br>The<b> pos</b> value is an absolute position within the stream.&nbsp; It may be obtained via a call to the<tt> tellp</tt>
 member function.
<dt><br>Results:
<dd>This from of the<tt> seekp</tt> public member function returns a reference to the<tt> ostream</tt> object.&nbsp; If the seek
 operation fails,<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ostream::tellp</tt>,<tt> istream::tellg</tt>,<tt> istream::seekg</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::seekp( streamoff offset, ios::seekdir dir );</tt>
<dt><br>Semantics:
<dd>This from of the<tt> seekp</tt> public member function positions the<tt> ostream</tt> object to the specified position so
 that the next output operation commences from that position.
<br>The<b> dir</b> parameter may be<tt> ios::beg</tt>,<tt> ios::cur</tt>, or<tt> ios::end</tt> and is interpreted in conjunction
 with the<b> offset</b> parameter as follows:
<br><br><tt>ios::beg</tt>&nbsp; the <b>offset</b> is relative to the start and should be a positive value.
<br><tt>ios::cur</tt>&nbsp; the <b>offset</b> is relative to the current position and may be positive
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (seek towards end) or negative (seek towards start).
<br><tt>ios::end</tt>&nbsp; the <b>offset</b> is relative to the end and should be a negative value.
<br><br>If the<b> dir</b> parameter has any other value, or the<b> offset</b> parameter does not have an appropriate sign,
 the<tt> seekp</tt> public member function fails.
<dt><br>Results:
<dd>This from of the<tt> seekp</tt> public member function returns a reference to the<tt> ostream</tt> object.&nbsp; If the seek
 operation fails,<tt> ios::failbit</tt> is set in the error state in the inherited<tt> ios</tt> object.
<dt><br>See Also:
<dd><tt> ostream::tellp</tt>,<tt> istream::tellg</tt>,<tt> istream::seekg</tt>
</dl>
<h2 id="ostream__tellpLR"> tellp() &#91;ostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>streampos ostream::tellp();</tt>
<dt><br>Semantics:
<dd>The<tt> tellp</tt> public member function returns the position in the<tt> ostream</tt> object at which the next character
 will be written.&nbsp; The first character in an<tt> ostream</tt> object is at offset zero.
<dt><br>Results:
<dd>The<tt> tellp</tt> public member function returns the position in the<tt> ostream</tt> object at which the next character
 will be written.
<dt><br>See Also:
<dd><tt> ostream::seekp</tt>,<tt> istream::tellg</tt>,<tt> istream::seekg</tt>
</dl>
<h2 id="ostream__writeLR"> write() &#91;ostream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;iostream.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostream &amp;ostream::write( char const *buf, int len );</tt>
<br><tt> ostream &amp;ostream::write( signed char const *buf, int len );</tt>
<br><tt> ostream &amp;ostream::write( unsigned char const *buf, int len );</tt>
<dt><br>Semantics:
<dd>The<tt> write</tt> public member function performs an unformatted write of the characters specified by the<b> buf</b> and<b>
 len</b> parameters into the<tt> ostream</tt> object.
<dt><br>Results:
<dd>These member functions return a reference to the<tt> ostream</tt> object.&nbsp; If an error occurs,<tt> ios::failbit</tt>
 is set in the error state in the inherited<tt> ios</tt> object.
</dl>
<h2 id="ostrstream_Class_Description"> ostrstream Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> strstrea.h</tt>
<dt><br>Derived from:
<dd><tt> strstreambase</tt>,<tt> ostream</tt>
<br>The<tt> ostrstream</tt> class is used to create and write to string stream objects.
<br>The<tt> ostrstream</tt> class provides little of its own functionality.&nbsp; Derived from the<tt> strstreambase</tt>
 and<tt> ostream</tt> classes, its constructors and destructor provide simplified access to the appropriate equivalents in
 those base classes.&nbsp; The member functions provide specialized access to the string stream object.
<br><br>Of the available I/O stream classes, creating an<tt> ostrstream</tt> object is the preferred method of performing
 write operations to a string stream.
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>ostrstream();</tt>
<br><tt> ostrstream( char *, int, ios::openmode = ios::out );</tt>
<br><tt> ostrstream( signed char *, int, ios::openmode = ios::out );</tt>
<br><tt> ostrstream( unsigned char *, int, ios::openmode = ios::out );</tt>
<br><tt> ~ostrstream();</tt>
<br><tt> int pcount() const;</tt>
<br><tt> char *str();</tt>
<dt><br>See Also:
<dd><tt> istrstream</tt>,<tt> ostream</tt>,<tt> ostrstream</tt>,<tt> strstreambase</tt>
</dl>
<h2 id="ostrstream__ostrstreamLR"> ostrstream() &#91;ostrstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostrstream::ostrstream();</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> ostrstream</tt> constructor creates an empty<tt> ostrstream</tt> object.&nbsp; Dynamic allocation
 is used.&nbsp; The inherited stream member functions can be used to access the<tt> ostrstream</tt> object.
<dt><br>Results:
<dd>This form of the public<tt> ostrstream</tt> constructor creates an initialized, empty<tt> ostrstream</tt> object.
<dt><br>See Also:
<dd><tt> ~ostrstream</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostrstream::ostrstream( char *str,</tt>
<br><tt> int len,</tt>
<br><tt>ios::openmode mode = ios::out );</tt>
<br><tt>ostrstream::ostrstream( signed char *str,</tt>
<br><tt> int len,</tt>
<br><tt>ios::openmode mode = ios::out );</tt>
<br><tt>ostrstream::ostrstream( unsigned char *str,</tt>
<br><tt> int len,</tt>
<br><tt>ios::openmode mode = ios::out );</tt>
<dt><br>Semantics:
<dd>These forms of the public<tt> ostrstream</tt> constructor create an initialized<tt> ostrstream</tt> object.&nbsp; Dynamic
 allocation is not used.&nbsp; The buffer is specified by the<b> str</b> and<b> len</b> parameters.&nbsp; If the<tt> ios::append</tt>
 or<tt> ios::atend</tt> bits are set in the<b> mode</b> parameter, the<b> str</b> parameter is assumed to contain a C string
 terminated by a null character, and writing commences at the null character.&nbsp; Otherwise, writing commences at<b> str</b>.
<dt><br>Results:
<dd>This form of the public<tt> ostrstream</tt> constructor creates an initialized<tt> ostrstream</tt> object.
<dt><br>See Also:
<dd><tt> ~ostrstream</tt>
</dl>
<h2 id="ostrstream____ostrstreamLR"> ~ostrstream() &#91;ostrstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>ostrstream::~ostrstream();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~ostrstream</tt> destructor does not do anything explicit.&nbsp; The call to the public<tt> ~ostrstream</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> ostrstream</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> ostrstream</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> ostrstream</tt>
</dl>
<h2 id="ostrstream__pcountLR"> pcount() &#91;ostrstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int ostrstream::pcount() const;</tt>
<dt><br>Semantics:
<dd>The<tt> pcount</tt> public member function computes the number of characters that have been written to the<tt> ostrstream</tt>
 object.&nbsp; This value is particularly useful if the<tt> ostrstream</tt> object does not contain a C string (terminated
 by a null character), so that the number of characters cannot be determined with the C library<tt> strlen</tt> function.
&nbsp; If the<tt> ostrstream</tt> object was created by appending to a C string in a static buffer, the length of the original
 string is included in the character count.
<dt><br>Results:
<dd>The<tt> pcount</tt> public member function returns the number of characters contained in the<tt> ostrstream</tt> object.
</dl>
<h2 id="ostrstream__strLR"> str() &#91;ostrstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>char *ostrstream::str();</tt>
<dt><br>Semantics:
<dd>The<tt> str</tt> public member function creates a pointer to the buffer being used by the<tt> ostrstream</tt> object.&nbsp;
 If the<tt> ostrstream</tt> object was created without dynamic allocation (static mode), the pointer is the same as the buffer
 pointer passed in the constructor.
<br>For<tt> ostrstream</tt> objects using dynamic allocation, the<tt> str</tt> public member function makes an implicit call
 to the<tt> strstreambuf::freeze</tt> member function.&nbsp; If nothing has been written to the<tt> ostrstream</tt> object,
 the returned pointer will be<tt> NULL</tt>.
<br><br>Note that the buffer does not necessarily end with a null character.&nbsp; If the pointer returned by the<tt> str</tt>
 public member function is to be interpreted as a C string, it is the program's responsibility to ensure that the null character
 is present.
<dt><br>Results:
<dd>The<tt> str</tt> public member function returns a pointer to the buffer being used by the<tt> ostrstream</tt> object.
</dl>
<h2 id="stdiobuf_Class_Description"> stdiobuf Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> stdiobuf.h</tt>
<dt><br>Derived from:
<dd><tt> streambuf</tt>
<br>The<tt> stdiobuf</tt> class specializes the<tt> streambuf</tt> class and is used to implement the standard input/output
 buffering required for the<tt> cin</tt>,<tt> cout</tt>,<tt> cerr</tt> and<tt> clog</tt> predefined objects.
<br>The<tt> stdiobuf</tt> class behaves in a similar way to the<tt> filebuf</tt> class, but does not need to switch between
 the<b> get area</b> and<b> put area</b>, since no<tt> stdiobuf</tt> object can be created for both reading and writing.&nbsp;
 When the<b> get area</b> is empty and a read is done, the<tt> underflow</tt> virtual member function reads more characters
 and fills the<b> get area</b> again.&nbsp; When the<b> put area</b> is full and a write is done, the<tt> overflow</tt> virtual
 member function writes the characters and makes the<b> put area</b> empty again.
<br><br>C++ programmers who wish to use the standard input/output streams without deriving new objects do not need to explicitly
 create or use a<tt> stdiobuf</tt> object.
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>stdiobuf();</tt>
<br><tt> stdiobuf( FILE * );</tt>
<br><tt> ~stdiobuf();</tt>
<br><tt> virtual int overflow( int = EOF );</tt>
<br><tt> virtual int underflow();</tt>
<br><tt> virtual int sync();</tt>
<dt><br>See Also:
<dd><tt> streambuf</tt>,<tt> ios</tt>
</dl>
<h2 id="stdiobuf__overflowLR"> overflow() &#91;stdiobuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdiobuf.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int stdiobuf::overflow( int ch = EOF );</tt>
<dt><br>Semantics:
<dd>The<tt> overflow</tt> public virtual member function provides the output communication to the standard output and standard
 error devices to which the<tt> stdiobuf</tt> object is connected.&nbsp; Member functions in the<tt> streambuf</tt> class
 call the<tt> overflow</tt> public virtual member function for the derived class when the<b> put area</b> is full.
<br>The<tt> overflow</tt> public virtual member function performs the following steps:
<ol>
<li>If no buffer is present, a buffer is allocated with the<tt> streambuf::allocate</tt> member function, which may call the<tt>
 doallocate</tt> virtual member function.&nbsp; The<b> put area</b> is then set up.&nbsp; If, after calling<tt> streambuf::allocate</tt>,
 no buffer is present, the<tt> stdiobuf</tt> object is unbuffered and<b> ch</b> (if not<tt> EOF</tt>) is written directly
 to the file without buffering, and no further action is taken.
<li>If the<b> get area</b> is present, it is flushed with a call to the<tt> sync</tt> virtual member function.&nbsp; Note
 that the<b> get area</b> won't be present if a buffer was set up in step 1.
<li>If<b> ch</b> is not<tt> EOF</tt>, it is added to the<b> put area</b>, if possible.
<li>Any characters in the<b> put area</b> are written to the file.
<li>The<b> put area</b> pointers are updated to reflect the new state of the<b> put area</b>.&nbsp; If the write did not complete,
 the unwritten portion of the<b> put area</b> is still present.&nbsp; If the<b> put area</b> was full before the write,<b>
 ch</b> (if not<tt> EOF</tt>) is placed at the start of the<b> put area</b>.&nbsp; Otherwise, the<b> put area</b> is empty.
</ol>
<dt><br>Results:
<dd>The<tt> overflow</tt> public virtual member function returns<tt> __NOT_EOF</tt> on success, otherwise<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> stdiobuf::underflow</tt>,<tt> streambuf::overflow</tt>
</dl>
<h2 id="stdiobuf__stdiobufLR"> stdiobuf() &#91;stdiobuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdiobuf.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>stdiobuf::stdiobuf();</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> stdiobuf</tt> constructor creates a<tt> stdiobuf</tt> object that is initialized but not yet connected
 to a file.
<dt><br>Results:
<dd>This form of the public<tt> stdiobuf</tt> constructor creates a<tt> stdiobuf</tt> object.
<dt><br>See Also:
<dd><tt> ~stdiobuf</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdiobuf.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>stdiobuf::stdiobuf( FILE *fptr );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> stdiobuf</tt> constructor creates a<tt> stdiobuf</tt> object that is initialized and connected
 to a C library FILE stream.&nbsp; Usually, one of<tt> stdin</tt>,<tt> stdout</tt> or<tt> stderr</tt> is specified for the<b>
 fptr</b> parameter.
<dt><br>Results:
<dd>This form of the public<tt> stdiobuf</tt> constructor creates a<tt> stdiobuf</tt> object that is initialized and connected
 to a C library FILE stream.
<dt><br>See Also:
<dd><tt> ~stdiobuf</tt>
</dl>
<h2 id="stdiobuf____stdiobufLR"> ~stdiobuf() &#91;stdiobuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdiobuf.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>stdiobuf::~stdiobuf();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~stdiobuf</tt> destructor does not do anything explicit.&nbsp; The<tt> streambuf</tt> destructor is called
 for that portion of the<tt> stdiobuf</tt> object.&nbsp; The call to the public<tt> ~stdiobuf</tt> destructor is inserted
 implicitly by the compiler at the point where the<tt> stdiobuf</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> stdiobuf</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> stdiobuf</tt>
</dl>
<h2 id="stdiobuf__syncLR"> sync() &#91;stdiobuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdiobuf.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int stdiobuf::sync();</tt>
<dt><br>Semantics:
<dd>The<tt> sync</tt> public virtual member function synchronizes the<tt> stdiobuf</tt> object with the associated device.&nbsp;
 If the<b> put area</b> contains characters, it is flushed.&nbsp; If the<b> get area</b> contains buffered characters, the<tt>
 sync</tt> public virtual member function fails.
<dt><br>Results:
<dd>The<tt> sync</tt> public virtual member function returns<tt> __NOT_EOF</tt> on success, otherwise,<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::sync</tt>
</dl>
<h2 id="stdiobuf__underflowLR"> underflow() &#91;stdiobuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;stdiobuf.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int stdiobuf::underflow();</tt>
<dt><br>Semantics:
<dd>The<tt> underflow</tt> public virtual member function provides the input communication from the standard input device to which
 the<tt> stdiobuf</tt> object is connected.&nbsp; Member functions in the<tt> streambuf</tt> class call the<tt> underflow</tt>
 public virtual member function for the derived class when the<b> get area</b> is empty.
<br>The<tt> underflow</tt> public virtual member function performs the following steps:
<ol>
<li>If no<b> reserve area</b> is present, a buffer is allocated with the<tt> streambuf::allocate</tt> member function, which
 may call the<tt> doallocate</tt> virtual member function.&nbsp; If, after calling<tt> allocate</tt>, no<b> reserve area</b>
 is present, the<tt> stdiobuf</tt> object is unbuffered and a one-character<b> reserve area</b> (plus putback area) is set
 up to do unbuffered input.&nbsp; This buffer is embedded in the<tt> stdiobuf</tt> object.&nbsp; The<b> get area</b> is set
 up as empty.
<li>The unused part of the<b> get area</b> is used to read characters from the file connected to the<tt> stdiobuf</tt> object.
&nbsp; The<b> get area</b> pointers are then set up to reflect the new<b> get area</b>.
</ol>
<dt><br>Results:
<dd>The<tt> underflow</tt> public virtual member function returns the first unread character of the<b> get area</b>, on success,
 otherwise<tt> EOF</tt> is returned.&nbsp; Note that the<b> get pointer</b> is not advanced on success.
<dt><br>See Also:
<dd><tt> stdiobuf::overflow</tt>,<tt> streambuf::underflow</tt>
</dl>
<h2 id="streambuf_Class_Description"> streambuf Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> streambu.h</tt>
<dt><br>Derived by:
<dd><tt> filebuf</tt>,<tt> stdiobuf</tt>,<tt> strstreambuf</tt>
<br>The<tt> streambuf</tt> class is responsible for maintaining the buffer used to create an efficient implementation of the
 stream classes.&nbsp; Through its pure virtual functions, it is also responsible for the actual communication with the device
 associated with the stream.
<br>The<tt> streambuf</tt> class is abstract, due to the presence of pure virtual member functions.&nbsp; Abstract classes
 may not be instantiated, only inherited.&nbsp; Hence,<tt> streambuf</tt> objects will not be created by user programs.
<br><br>Stream objects maintain a pointer to an associated<tt> streambuf</tt> object and present the interface that the user
 deals with most often.&nbsp; Whenever a stream member function wishes to read or write characters, it uses the<tt> rdbuf</tt>
 member function to access the associated<tt> streambuf</tt> object and its member functions.&nbsp; Through judicious use
 of inline functions, most reads and writes of characters access the buffer directly without even doing a function call.&nbsp;
 Whenever the buffer gets filled (writing) or exhausted (reading), these inline functions invoke the function required to
 rectify the situation so that the proper action can take place.
<br><br>A<tt> streambuf</tt> object can be unbuffered, but most often has one buffer which can be used for both input and
 output operations.&nbsp; The buffer (called the<b> reserve area</b>) is divided into two areas, called the<b> get area</b>
 and the<b> put area</b>.&nbsp; For a<tt> streambuf</tt> object being used exclusively to write, the<b> get area</b> is empty
 or not present.&nbsp; Likewise, a<tt> streambuf</tt> object being used exclusively for reading has an empty or non-existent<b>
 put area</b>.
<br><br>The use of the<b> get area</b> and<b> put area</b> differs among the various classes derived from the<tt> streambuf</tt>
 class.
<br><br>The<tt> filebuf</tt> class allows only the<b> get area</b> or the<b> put area</b>, but not both, to be active at a
 time.&nbsp; This follows from the capability of files opened for both reading and writing to have operations of each type
 performed at arbitrary locations in the file.&nbsp; When writing is occurring, the characters are buffered in the<b> put
 area</b>.&nbsp; If a seek or read operation is done, the<b> put area</b> must be flushed before the next operation in order
 to ensure that the characters are written to the proper location in the file.&nbsp; Similarly, if reading is occurring, characters
 are buffered in the<b> get area</b>.&nbsp; If a write operation is done, the<b> get area</b> must be flushed and synchronized
 before the write operation in order to ensure the write occurs at the proper location in the file.&nbsp; If a seek operation
 is done, the<b> get area</b> does not have to be synchronized, but is discarded.&nbsp; When the<b> get area</b> is empty
 and a read is done, the<tt> underflow</tt> virtual member function reads more characters and fills the<b> get area</b> again.
&nbsp; When the<b> put area</b> is full and a write is done, the<tt> overflow</tt> virtual member function writes the characters
 and makes the<b> put area</b> empty again.
<br><br>The<tt> stdiobuf</tt> class behaves in a similar way to the<tt> filebuf</tt> class, but does not need to switch between
 the<b> get area</b> and<b> put area</b>, since no<tt> stdiobuf</tt> object can be created for both reading and writing.&nbsp;
 When the<b> get area</b> is empty and a read is done, the<tt> underflow</tt> virtual member function reads more characters
 and fills the<b> get area</b> again.&nbsp; When the<b> put area</b> is full and a write is done, the<tt> overflow</tt> virtual
 member function writes the characters and makes the<b> put area</b> empty again.
<br><br>The<tt> strstreambuf</tt> class differs quite markedly from the<tt> filebuf</tt> and<tt> stdiobuf</tt> classes.&nbsp;
 Since there is no actual source or destination for the characters in<tt> strstream</tt> objects, the buffer itself takes
 on that role.&nbsp; When writing is occurring and the<b> put area</b> is full, the<tt> overflow</tt> virtual member function
 reallocates the buffer to a larger size (if possible), the<b> put area</b> is extended and the writing continues.&nbsp; If
 reading is occurring and the<b> get area</b> is empty, the<tt> underflow</tt> virtual member function checks to see if the<b>
 put area</b> is present and not empty.&nbsp; If so, the<b> get area</b> is extended to overlap the<b> put area</b>.
<br><br>The<b> reserve area</b> is marked by two pointer values.&nbsp; The<tt> base</tt> member function returns the pointer
 to the start of the buffer.&nbsp; The<tt> ebuf</tt> member function returns the pointer to the end of the buffer (last character
 + 1).&nbsp; The<tt> setb</tt> protected member function is used to set both pointers.
<br><br>Within the<b> reserve area</b>, the<b> get area</b> is marked by three pointer values.&nbsp; The<tt> eback</tt> member
 function returns a pointer to the start of the<b> get area</b>.&nbsp; The<tt> egptr</tt> member function returns a pointer
 to the end of the<b> get area</b> (last character + 1).&nbsp; The<tt> gptr</tt> member function returns the<b> get pointer</b>.
&nbsp; The<b> get pointer</b> is a pointer to the next character to be extracted from the<b> get area</b>.&nbsp; Characters
 before the<b> get pointer</b> have already been consumed by the program, while characters at and after the<b> get pointer</b>
 have been read from their source and are buffered and waiting to be read by the program.&nbsp; The<tt> setg</tt> member function
 is used to set all three pointer values.&nbsp; If any of these pointers are<tt> NULL</tt>, there is no<b> get area</b>.
<br><br>Also within the<b> reserve area</b>, the<b> put area</b> is marked by three pointer values.&nbsp; The<tt> pbase</tt>
 member function returns a pointer to the start of the<b> put area</b>.&nbsp; The<tt> epptr</tt> member function returns a
 pointer to the end of the<b> put area</b> (last character + 1 ).&nbsp; The<tt> pptr</tt> member function returns the<b> put
 pointer</b>.&nbsp; The<b> put pointer</b> is a pointer to the next available position into which a character may be stored.
&nbsp; Characters before the<b> put pointer</b> are buffered and waiting to be written to their final destination, while character
 positions at and after the<b> put pointer</b> have yet to be written by the program.&nbsp; The<tt> setp</tt> member function
 is used to set all three pointer values.&nbsp; If any of these pointers are<tt> NULL</tt>, there is no<b> put area</b>.
<br><br>Unbuffered I/O is also possible.&nbsp; If unbuffered, the<tt> overflow</tt> virtual member function is used to write
 single characters directly to their final destination without using the<b> put area</b>.&nbsp; Similarly, the<tt> underflow</tt>
 virtual member function is used to read single characters directly from their source without using the<b> get area</b>.
<br><br><b>Protected Member Functions</b>
<br><br>The following member functions are declared in the protected interface:
<br><br><tt>streambuf();</tt>
<br><tt> streambuf( char *, int );</tt>
<br><tt> virtual ~streambuf();</tt>
<br><tt> int allocate();</tt>
<br><tt> char *base() const;</tt>
<br><tt> char *ebuf() const;</tt>
<br><tt> int blen() const;</tt>
<br><tt> void setb( char *, char *, int );</tt>
<br><tt> char *eback() const;</tt>
<br><tt> char *gptr() const;</tt>
<br><tt> char *egptr() const;</tt>
<br><tt> void gbump( streamoff );</tt>
<br><tt> void setg( char *, char *, char *);</tt>
<br><tt> char *pbase() const;</tt>
<br><tt> char *pptr() const;</tt>
<br><tt> char *epptr() const;</tt>
<br><tt> void pbump( streamoff );</tt>
<br><tt> void setp( char *, char *);</tt>
<br><tt> int unbuffered( int );</tt>
<br><tt> int unbuffered() const;</tt>
<br><tt> virtual int doallocate();</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>int in_avail() const;</tt>
<br><tt> int out_waiting() const;</tt>
<br><tt> int snextc();</tt>
<br><tt> int sgetn( char *, int );</tt>
<br><tt> int speekc();</tt>
<br><tt> int sgetc();</tt>
<br><tt> int sgetchar();</tt>
<br><tt> int sbumpc();</tt>
<br><tt> void stossc();</tt>
<br><tt> int sputbackc( char );</tt>
<br><tt> int sputc( int );</tt>
<br><tt> int sputn( char const *, int );</tt>
<br><tt> void dbp();</tt>
<br><br><tt>virtual int do_sgetn( char *, int );</tt>
<br><tt> virtual int do_sputn( char const *, int );</tt>
<br><tt> virtual int pbackfail( int );</tt>
<br><tt> virtual int overflow( int = EOF ) = 0;</tt>
<br><tt> virtual int underflow() = 0;</tt>
<br><tt> virtual streambuf *setbuf( char *, int );</tt>
<br><tt> virtual streampos seekoff( streamoff, ios::seekdir,</tt>
<br><tt> ios::openmode = ios::in|ios::out );</tt>
<br><tt>virtual streampos seekpos( streampos,</tt>
<br><tt> ios::openmode = ios::in|ios::out );</tt>
<br><tt>virtual int sync();</tt>
<dt><br>See Also:
<dd><tt> filebuf</tt>,<tt> stdiobuf</tt>,<tt> strstreambuf</tt>
</dl>
<h2 id="streambuf__allocateLR"> allocate() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>int streambuf::allocate();</tt>
<dt><br>Semantics:
<dd>The<tt> allocate</tt> protected member function works in tandem with the<tt> doallocate</tt> protected virtual member function
 to manage allocation of the<tt> streambuf</tt> object<b> reserve area</b>.&nbsp; Classes derived from the<tt> streambuf</tt>
 class should call the<tt> allocate</tt> protected member function, rather than the<tt> doallocate</tt> protected virtual
 member function.&nbsp; The<tt> allocate</tt> protected member function determines whether or not the<tt> streambuf</tt> object
 is allowed to allocate a buffer for use as the<b> reserve area</b>.&nbsp; If a<b> reserve area</b> already exists or if the<tt>
 streambuf</tt> object unbuffering state is non-zero, the<tt> allocate</tt> protected member function fails.&nbsp; Otherwise,
 it calls the<tt> doallocate</tt> protected virtual member function.
<dt><br>Results:
<dd>The<tt> allocate</tt> protected member function returns<tt> __NOT_EOF</tt> on success, otherwise<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::doallocate</tt>,<tt> underflow</tt>,<tt> overflow</tt>
</dl>
<h2 id="streambuf__baseLR"> base() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>char *streambuf::base() const;</tt>
<dt><br>Semantics:
<dd>The<tt> base</tt> protected member function returns a pointer to the start of the<b> reserve area</b> that the<tt> streambuf</tt>
 object is using.
<br>The<b> reserve area</b>,<b> get area</b>, and<b> put area</b> pointer functions return the following values:
<br><br><tt>base()</tt>&nbsp;&nbsp;&nbsp; start of the <b>reserve area</b>.
<br><tt>ebuf()</tt>&nbsp;&nbsp;&nbsp; end of the <b>reserve area</b>.
<br><tt>blen()</tt>&nbsp;&nbsp;&nbsp; length of the <b>reserve area</b>.
<br><br><tt>eback()</tt>&nbsp;&nbsp; start of the <b>get area</b>.
<br><tt>gptr()</tt>&nbsp;&nbsp;&nbsp; the <b>get pointer</b>.
<br><tt>egptr()</tt>&nbsp;&nbsp; end of the <b>get area</b>.
<br><br><tt>pbase()</tt>&nbsp;&nbsp; start of the <b>put area</b>.
<br><tt>pptr()</tt>&nbsp;&nbsp;&nbsp; the <b>put pointer</b>.
<br><tt>epptr()</tt>&nbsp;&nbsp; end of the <b>put area</b>.
<br><br>From<tt> eback</tt> to<tt> gptr</tt> are characters buffered and read.&nbsp; From<tt> gptr</tt> to<tt> egptr</tt>
 are characters buffered but not yet read.&nbsp; From<tt> pbase</tt> to<tt> pptr</tt> are characters buffered and not yet
 written.&nbsp; From<tt> pptr</tt> to<tt> epptr</tt> is unused buffer area.
<dt><br>Results:
<dd>The<tt> base</tt> protected member function returns a pointer to the start of the<b> reserve area</b> that the<tt> streambuf</tt>
 object is using.&nbsp; If the<tt> streambuf</tt> object currently does not have a<b> reserve area</b>,<tt> NULL</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::blen</tt>,<tt> ebuf</tt>,<tt> setb</tt>
</dl>
<h2 id="streambuf__blenLR"> blen() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>int streambuf::blen() const;</tt>
<dt><br>Semantics:
<dd>The<tt> blen</tt> protected member function reports the length of the<b> reserve area</b> that the<tt> streambuf</tt> object
 is using.
<br>The<b> reserve area</b>,<b> get area</b>, and<b> put area</b> pointer functions return the following values:
<br><br><tt>base()</tt>&nbsp;&nbsp;&nbsp; start of the <b>reserve area</b>.
<br><tt>ebuf()</tt>&nbsp;&nbsp;&nbsp; end of the <b>reserve area</b>.
<br><tt>blen()</tt>&nbsp;&nbsp;&nbsp; length of the <b>reserve area</b>.
<br><br><tt>eback()</tt>&nbsp;&nbsp; start of the <b>get area</b>.
<br><tt>gptr()</tt>&nbsp;&nbsp;&nbsp; the <b>get pointer</b>.
<br><tt>egptr()</tt>&nbsp;&nbsp; end of the <b>get area</b>.
<br><br><tt>pbase()</tt>&nbsp;&nbsp; start of the <b>put area</b>.
<br><tt>pptr()</tt>&nbsp;&nbsp;&nbsp; the <b>put pointer</b>.
<br><tt>epptr()</tt>&nbsp;&nbsp; end of the <b>put area</b>.
<br><br>From<tt> eback</tt> to<tt> gptr</tt> are characters buffered and read.&nbsp; From<tt> gptr</tt> to<tt> egptr</tt>
 are characters buffered but not yet read.&nbsp; From<tt> pbase</tt> to<tt> pptr</tt> are characters buffered and not yet
 written.&nbsp; From<tt> pptr</tt> to<tt> epptr</tt> is unused buffer area.
<dt><br>Results:
<dd>The<tt> blen</tt> protected member function returns the length of the<b> reserve area</b> that the<tt> streambuf</tt> object
 is using.&nbsp; If the<tt> streambuf</tt> object currently does not have a<b> reserve area</b>, zero is returned.
<dt><br>See Also:
<dd><tt> streambuf::base</tt>,<tt> ebuf</tt>,<tt> setb</tt>
</dl>
<h2 id="streambuf__dbpLR"> dbp() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void streambuf::dbp();</tt>
<dt><br>Semantics:
<dd>The<tt> dbp</tt> public member function dumps information about the<tt> streambuf</tt> object directly to<tt> stdout</tt>,
 and is used for debugging classes derived from the<tt> streambuf</tt> class.
<br>The following is an example of what the<tt> dbp</tt> public member function dumps:
</dl>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; STREAMBUF Debug Info:</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; this&nbsp; = 00030679, unbuffered = 0, delete_reserve = 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; base&nbsp; = 00070010, ebuf = 00070094</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; eback = 00000000, gptr = 00000000, egptr = 00000000</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; pbase = 00070010, pptr = 00070010, epptr = 00070094</tt>
<h2 id="streambuf__do_sgetnLR"> do_sgetn() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int do_sgetn( char *buf, int len );</tt>
<dt><br>Semantics:
<dd>The<tt> do_sgetn</tt> public virtual member function works in tandem with the<tt> sgetn</tt> member function to transfer<b>
 len</b> characters from the<b> get area</b> into<b> buf</b>.
<br>Classes derived from the<tt> streambuf</tt> class should call the<tt> sgetn</tt> member function, rather than the<tt>
 do_sgetn</tt> public virtual member function.
<dt><br>Derived Implementation Protocol:
<dd>Classes derived from the<tt> streambuf</tt> class that implement the<tt> do_sgetn</tt> public virtual member function should
 support copying up to<b> len</b> characters from the source through the<b> get area</b> and into<b> buf</b>.
<dt><br>Default Implementation:
<dd>The default<tt> do_sgetn</tt> public virtual member function provided with the<tt> streambuf</tt> class calls the<tt> underflow</tt>
 virtual member function to fetch more characters and then copies the characters from the<b> get area</b> into<b> buf</b>.
<dt><br>Results:
<dd>The<tt> do_sgetn</tt> public virtual member function returns the number of characters successfully transferred.
<dt><br>See Also:
<dd><tt> streambuf::sgetn</tt>
</dl>
<h2 id="streambuf__do_sputnLR"> do_sputn() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int do_sputn( char const *buf, int len );</tt>
<dt><br>Semantics:
<dd>The<tt> do_sputn</tt> public virtual member function works in tandem with the<tt> sputn</tt> member function to transfer<b>
 len</b> characters from<b> buf</b> to the end of the<b> put area</b> and advances the<b> put pointer</b>.
<br>Classes derived from the<tt> streambuf</tt> class should call the<tt> sputn</tt> member function, rather than the<tt>
 do_sputn</tt> public virtual member function.
<dt><br>Derived Implementation Protocol:
<dd>Classes derived from the<tt> streambuf</tt> class that implement the<tt> do_sputn</tt> public virtual member function should
 support copying up to<b> len</b> characters from<b> buf</b> through the<b> put area</b> and out to the destination device.
<dt><br>Default Implementation:
<dd>The default<tt> do_sputn</tt> public virtual member function provided with the<tt> streambuf</tt> class calls the<tt> overflow</tt>
 virtual member function to flush the<b> put area</b> and then copies the rest of the characters from<b> buf</b> into the<b>
 put area</b>.
<dt><br>Results:
<dd>The<tt> do_sputn</tt> public virtual member function returns the number of characters successfully written.&nbsp; If an error
 occurs, this number may be less than<b> len</b>.
<dt><br>See Also:
<dd><tt> streambuf::sputn</tt>
</dl>
<h2 id="streambuf__doallocateLR"> doallocate() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>virtual int streambuf::doallocate();</tt>
<dt><br>Semantics:
<dd>The<tt> doallocate</tt> protected virtual member function manages allocation of the<tt> streambuf</tt> object's<b> reserve
 area</b> in tandem with the<tt> allocate</tt> protected member function.
<br>Classes derived from the<tt> streambuf</tt> class should call the<tt> allocate</tt> protected member function rather than
 the<tt> doallocate</tt> protected virtual member function.
<br><br>The<tt> doallocate</tt> protected virtual member function does the actual memory allocation, and can be defined for
 each class derived from the<tt> streambuf</tt> class.
<dt><br>Derived Implementation Protocol:
<dd>Classes derived from the<tt> streambuf</tt> class should implement the<tt> doallocate</tt> protected virtual member function
 such that it does the following:
<ol>
<li>attempts to allocate an area of memory,
<li>calls the<tt> setb</tt> protected member function to initialize the<b> reserve area</b> pointers,
<li>performs any class specific operations required.
</ol>
<dt><br>Default Implementation:
<dd>The default<tt> doallocate</tt> protected virtual member function provided with the<tt> streambuf</tt> class attempts to allocate
 a buffer area with the<tt> operator new</tt> intrinsic function.&nbsp; It then calls the<tt> setb</tt> protected member function
 to set up the pointers to the<b> reserve area</b>.
<dt><br>Results:
<dd>The<tt> doallocate</tt> protected virtual member function returns<tt> __NOT_EOF</tt> on success, otherwise<tt> EOF</tt> is
 returned.
<dt><br>See Also:
<dd><tt> streambuf::allocate</tt>
</dl>
<h2 id="streambuf__ebackLR"> eback() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>char *streambuf::eback() const;</tt>
<dt><br>Semantics:
<dd>The<tt> eback</tt> protected member function returns a pointer to the start of the<b> get area</b> within the<b> reserve area</b>
 used by the<tt> streambuf</tt> object.
<br>The<b> reserve area</b>,<b> get area</b>, and<b> put area</b> pointer functions return the following values:
<br><br><tt>base()</tt>&nbsp;&nbsp;&nbsp; start of the <b>reserve area</b>.
<br><tt>ebuf()</tt>&nbsp;&nbsp;&nbsp; end of the <b>reserve area</b>.
<br><tt>blen()</tt>&nbsp;&nbsp;&nbsp; length of the <b>reserve area</b>.
<br><br><tt>eback()</tt>&nbsp;&nbsp; start of the <b>get area</b>.
<br><tt>gptr()</tt>&nbsp;&nbsp;&nbsp; the <b>get pointer</b>.
<br><tt>egptr()</tt>&nbsp;&nbsp; end of the <b>get area</b>.
<br><br><tt>pbase()</tt>&nbsp;&nbsp; start of the <b>put area</b>.
<br><tt>pptr()</tt>&nbsp;&nbsp;&nbsp; the <b>put pointer</b>.
<br><tt>epptr()</tt>&nbsp;&nbsp; end of the <b>put area</b>.
<br><br>From<tt> eback</tt> to<tt> gptr</tt> are characters buffered and read.&nbsp; From<tt> gptr</tt> to<tt> egptr</tt>
 are characters buffered but not yet read.&nbsp; From<tt> pbase</tt> to<tt> pptr</tt> are characters buffered and not yet
 written.&nbsp; From<tt> pptr</tt> to<tt> epptr</tt> is unused buffer area.
<dt><br>Results:
<dd>The<tt> eback</tt> protected member function returns a pointer to the start of the<b> get area</b>.&nbsp; If the<tt> streambuf</tt>
 object currently does not have a<b> get area</b>,<tt> NULL</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::egptr</tt>,<tt> gptr</tt>,<tt> setg</tt>
</dl>
<h2 id="streambuf__ebufLR"> ebuf() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>char *streambuf::ebuf() const;</tt>
<dt><br>Semantics:
<dd>The<tt> ebuf</tt> protected member function returns a pointer to the end of the<b> reserve area</b> that the<tt> streambuf</tt>
 object is using.&nbsp; The character pointed at is actually the first character past the end of the<b> reserve area</b>.
<br>The<b> reserve area</b>,<b> get area</b>, and<b> put area</b> pointer functions return the following values:
<br><br><tt>base()</tt>&nbsp;&nbsp;&nbsp; start of the <b>reserve area</b>.
<br><tt>ebuf()</tt>&nbsp;&nbsp;&nbsp; end of the <b>reserve area</b>.
<br><tt>blen()</tt>&nbsp;&nbsp;&nbsp; length of the <b>reserve area</b>.
<br><br><tt>eback()</tt>&nbsp;&nbsp; start of the <b>get area</b>.
<br><tt>gptr()</tt>&nbsp;&nbsp;&nbsp; the <b>get pointer</b>.
<br><tt>egptr()</tt>&nbsp;&nbsp; end of the <b>get area</b>.
<br><br><tt>pbase()</tt>&nbsp;&nbsp; start of the <b>put area</b>.
<br><tt>pptr()</tt>&nbsp;&nbsp;&nbsp; the <b>put pointer</b>.
<br><tt>epptr()</tt>&nbsp;&nbsp; end of the <b>put area</b>.
<br><br>From<tt> eback</tt> to<tt> gptr</tt> are characters buffered and read.&nbsp; From<tt> gptr</tt> to<tt> egptr</tt>
 are characters buffered but not yet read.&nbsp; From<tt> pbase</tt> to<tt> pptr</tt> are characters buffered and not yet
 written.&nbsp; From<tt> pptr</tt> to<tt> epptr</tt> is unused buffer area.
<dt><br>Results:
<dd>The<tt> ebuf</tt> protected member function returns a pointer to the end of the<b> reserve area</b>.&nbsp; If the<tt> streambuf</tt>
 object currently does not have a<b> reserve area</b>,<tt> NULL</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::base</tt>,<tt> blen</tt>,<tt> setb</tt>
</dl>
<h2 id="streambuf__egptrLR"> egptr() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>char *streambuf::egptr() const;</tt>
<dt><br>Semantics:
<dd>The<tt> egptr</tt> protected member function returns a pointer to the end of the<b> get area</b> within the<b> reserve area</b>
 used by the<tt> streambuf</tt> object.&nbsp; The character pointed at is actually the first character past the end of the<b>
 get area</b>.
<br>The<b> reserve area</b>,<b> get area</b>, and<b> put area</b> pointer functions return the following values:
<br><br><tt>base()</tt>&nbsp;&nbsp;&nbsp; start of the <b>reserve area</b>.
<br><tt>ebuf()</tt>&nbsp;&nbsp;&nbsp; end of the <b>reserve area</b>.
<br><tt>blen()</tt>&nbsp;&nbsp;&nbsp; length of the <b>reserve area</b>.
<br><br><tt>eback()</tt>&nbsp;&nbsp; start of the <b>get area</b>.
<br><tt>gptr()</tt>&nbsp;&nbsp;&nbsp; the <b>get pointer</b>.
<br><tt>egptr()</tt>&nbsp;&nbsp; end of the <b>get area</b>.
<br><br><tt>pbase()</tt>&nbsp;&nbsp; start of the <b>put area</b>.
<br><tt>pptr()</tt>&nbsp;&nbsp;&nbsp; the <b>put pointer</b>.
<br><tt>epptr()</tt>&nbsp;&nbsp; end of the <b>put area</b>.
<br><br>From<tt> eback</tt> to<tt> gptr</tt> are characters buffered and read.&nbsp; From<tt> gptr</tt> to<tt> egptr</tt>
 are characters buffered but not yet read.&nbsp; From<tt> pbase</tt> to<tt> pptr</tt> are characters buffered and not yet
 written.&nbsp; From<tt> pptr</tt> to<tt> epptr</tt> is unused buffer area.
<dt><br>Results:
<dd>The<tt> egptr</tt> protected member function returns a pointer to the end of the<b> get area</b>.&nbsp; If the<tt> streambuf</tt>
 object currently does not have a<b> get area</b>,<tt> NULL</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::eback</tt>,<tt> gptr</tt>,<tt> setg</tt>
</dl>
<h2 id="streambuf__epptrLR"> epptr() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>char *streambuf::epptr() const;</tt>
<dt><br>Semantics:
<dd>The<tt> epptr</tt> protected member function returns a pointer to the end of the<b> put area</b> within the<b> reserve area</b>
 used by the<tt> streambuf</tt> object.&nbsp; The character pointed at is actually the first character past the end of the<b>
 put area</b>.
<br>The<b> reserve area</b>,<b> get area</b>, and<b> put area</b> pointer functions return the following values:
<br><br><tt>base()</tt>&nbsp;&nbsp;&nbsp; start of the <b>reserve area</b>.
<br><tt>ebuf()</tt>&nbsp;&nbsp;&nbsp; end of the <b>reserve area</b>.
<br><tt>blen()</tt>&nbsp;&nbsp;&nbsp; length of the <b>reserve area</b>.
<br><br><tt>eback()</tt>&nbsp;&nbsp; start of the <b>get area</b>.
<br><tt>gptr()</tt>&nbsp;&nbsp;&nbsp; the <b>get pointer</b>.
<br><tt>egptr()</tt>&nbsp;&nbsp; end of the <b>get area</b>.
<br><br><tt>pbase()</tt>&nbsp;&nbsp; start of the <b>put area</b>.
<br><tt>pptr()</tt>&nbsp;&nbsp;&nbsp; the <b>put pointer</b>.
<br><tt>epptr()</tt>&nbsp;&nbsp; end of the <b>put area</b>.
<br><br>From<tt> eback</tt> to<tt> gptr</tt> are characters buffered and read.&nbsp; From<tt> gptr</tt> to<tt> egptr</tt>
 are characters buffered but not yet read.&nbsp; From<tt> pbase</tt> to<tt> pptr</tt> are characters buffered and not yet
 written.&nbsp; From<tt> pptr</tt> to<tt> epptr</tt> is unused buffer area.
<dt><br>Results:
<dd>The<tt> epptr</tt> protected member function returns a pointer to the end of the<b> put area</b>.&nbsp; If the<tt> streambuf</tt>
 object currently does not have a<b> put area</b>,<tt> NULL</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::pbase</tt>,<tt> pptr</tt>,<tt> setp</tt>
</dl>
<h2 id="streambuf__gbumpLR"> gbump() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>void streambuf::gbump( streamoff offset );</tt>
<dt><br>Semantics:
<dd>The<tt> gbump</tt> protected member function increments the<b> get pointer</b> by the specified<b> offset</b>, without regard
 for the boundaries of the<b> get area</b>.&nbsp; The<b> offset</b> parameter may be positive or negative.
<dt><br>Results:
<dd>The<tt> gbump</tt> protected member function returns nothing.
<dt><br>See Also:
<dd><tt> streambuf::gptr</tt>,<tt> pbump</tt>,<tt> sbumpc</tt>,<tt> sputbackc</tt>
</dl>
<h2 id="streambuf__gptrLR"> gptr() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>char *streambuf::gptr() const;</tt>
<dt><br>Semantics:
<dd>The<tt> gptr</tt> protected member function returns a pointer to the next available character in the<b> get area</b> within
 the<b> reserve area</b> used by the<tt> streambuf</tt> object.&nbsp; This pointer is called the<b> get pointer</b>.&nbsp;
 
<br>If the<b> get pointer</b> points beyond the end of the<b> get area</b>, all characters in the<b> get area</b> have been
 read by the program and a subsequent read causes the<tt> underflow</tt> virtual member function to be called to fetch more
 characters from the source to which the<tt> streambuf</tt> object is attached.
<br><br>The<b> reserve area</b>,<b> get area</b>, and<b> put area</b> pointer functions return the following values:
<br><br><tt>base()</tt>&nbsp;&nbsp;&nbsp; start of the <b>reserve area</b>.
<br><tt>ebuf()</tt>&nbsp;&nbsp;&nbsp; end of the <b>reserve area</b>.
<br><tt>blen()</tt>&nbsp;&nbsp;&nbsp; length of the <b>reserve area</b>.
<br><br><tt>eback()</tt>&nbsp;&nbsp; start of the <b>get area</b>.
<br><tt>gptr()</tt>&nbsp;&nbsp;&nbsp; the <b>get pointer</b>.
<br><tt>egptr()</tt>&nbsp;&nbsp; end of the <b>get area</b>.
<br><br><tt>pbase()</tt>&nbsp;&nbsp; start of the <b>put area</b>.
<br><tt>pptr()</tt>&nbsp;&nbsp;&nbsp; the <b>put pointer</b>.
<br><tt>epptr()</tt>&nbsp;&nbsp; end of the <b>put area</b>.
<br><br>From<tt> eback</tt> to<tt> gptr</tt> are characters buffered and read.&nbsp; From<tt> gptr</tt> to<tt> egptr</tt>
 are characters buffered but not yet read.&nbsp; From<tt> pbase</tt> to<tt> pptr</tt> are characters buffered and not yet
 written.&nbsp; From<tt> pptr</tt> to<tt> epptr</tt> is unused buffer area.
<dt><br>Results:
<dd>The<tt> gptr</tt> protected member function returns a pointer to the next available character in the<b> get area</b>.&nbsp;
 If the<tt> streambuf</tt> object currently does not have a<b> get area</b>,<tt> NULL</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::eback</tt>,<tt> egptr</tt>,<tt> setg</tt>
</dl>
<h2 id="streambuf__in_availLR"> in_avail() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int streambuf::in_avail() const;</tt>
<dt><br>Semantics:
<dd>The<tt> in_avail</tt> public member function computes the number of input characters buffered in the<b> get area</b> that
 have not yet been read by the program.&nbsp; These characters can be read with a guarantee that no errors will occur.
<dt><br>Results:
<dd>The<tt> in_avail</tt> public member function returns the number of buffered input characters.
<dt><br>See Also:
<dd><tt> streambuf::egptr</tt>,<tt> gptr</tt>
</dl>
<h2 id="streambuf__out_waitingLR"> out_waiting() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int streambuf::out_waiting() const;</tt>
<dt><br>Semantics:
<dd>The<tt> out_waiting</tt> public member function computes the number of characters that have been buffered in the<b> put area</b>
 and not yet been written to the output device.
<dt><br>Results:
<dd>The<tt> out_waiting</tt> public member function returns the number of buffered output characters.
<dt><br>See Also:
<dd><tt> streambuf::pbase</tt>,<tt> pptr</tt>
</dl>
<h2 id="streambuf__overflowLR"> overflow() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int streambuf::overflow( int ch = EOF ) = 0;</tt>
<dt><br>Semantics:
<dd>The<tt> overflow</tt> public virtual member function is used to flush the<b> put area</b> when it is full.
<dt><br>Derived Implementation Protocol:
<dd>Classes derived from the<tt> streambuf</tt> class should implement the<tt> overflow</tt> public virtual member function so
 that it performs the following:
<ol>
<li>if no<b> reserve area</b> is present and the<tt> streambuf</tt> object is not unbuffered, allocate a<b> reserve area</b>
 using the<tt> allocate</tt> member function and set up the<b> reserve area</b> pointers using the<tt> setb</tt> protected
 member function,
<li>flush any other uses of the<b> reserve area</b>,
<li>write any characters in the<b> put area</b> to the<tt> streambuf</tt> object's destination,
<li>set up the<b> put area</b> pointers to reflect the characters that were written,
<li>return<tt> __NOT_EOF</tt> on success, otherwise return<tt> EOF</tt>.
</ol>
<dt><br>Default Implementation:
<dd>There is no default<tt> streambuf</tt> class implementation of the<tt> overflow</tt> public virtual member function.&nbsp;
 The<tt> overflow</tt> public virtual member function must be defined for all classes derived from the<tt> streambuf</tt>
 class.
<dt><br>Results:
<dd>The<tt> overflow</tt> public virtual member function returns<tt> __NOT_EOF</tt> on success, otherwise<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> filebuf::overflow</tt>,<tt> stdiobuf::overflow</tt>,<tt> strstreambuf::overflow</tt>
</dl>
<h2 id="streambuf__pbackfailLR"> pbackfail() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int streambuf::pbackfail( int ch );</tt>
<dt><br>Semantics:
<dd>The<tt> pbackfail</tt> public virtual member function is called by the<tt> sputbackc</tt> member function when the<b> get
 pointer</b> is at the beginning of the<b> get area</b>, and so there is no place to put the<b> ch</b> parameter.
<dt><br>Derived Implementation Protocol:
<dd>Classes derived from the<tt> streambuf</tt> class should implement the<tt> pbackfail</tt> public virtual member function such
 that it attempts to put<b> ch</b> back into the source of the stream.
<dt><br>Default Implementation:
<dd>The default<tt> streambuf</tt> class implementation of the<tt> pbackfail</tt> public virtual member function is to return<tt>
 EOF</tt>.
<dt><br>Results:
<dd>If the<tt> pbackfail</tt> public virtual member function succeeds, it returns<b> ch</b>.&nbsp; Otherwise,<tt> EOF</tt> is
 returned.
</dl>
<h2 id="streambuf__pbaseLR"> pbase() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>char *streambuf::pbase() const;</tt>
<dt><br>Semantics:
<dd>The<tt> pbase</tt> protected member function returns a pointer to the start of the<b> put area</b> within the<b> reserve area</b>
 used by the<tt> streambuf</tt> object.
<br>The<b> reserve area</b>,<b> get area</b>, and<b> put area</b> pointer functions return the following values:
<br><br><tt>base()</tt>&nbsp;&nbsp;&nbsp; start of the <b>reserve area</b>.
<br><tt>ebuf()</tt>&nbsp;&nbsp;&nbsp; end of the <b>reserve area</b>.
<br><tt>blen()</tt>&nbsp;&nbsp;&nbsp; length of the <b>reserve area</b>.
<br><br><tt>eback()</tt>&nbsp;&nbsp; start of the <b>get area</b>.
<br><tt>gptr()</tt>&nbsp;&nbsp;&nbsp; the <b>get pointer</b>.
<br><tt>egptr()</tt>&nbsp;&nbsp; end of the <b>get area</b>.
<br><br><tt>pbase()</tt>&nbsp;&nbsp; start of the <b>put area</b>.
<br><tt>pptr()</tt>&nbsp;&nbsp;&nbsp; the <b>put pointer</b>.
<br><tt>epptr()</tt>&nbsp;&nbsp; end of the <b>put area</b>.
<br><br>From<tt> eback</tt> to<tt> gptr</tt> are characters buffered and read.&nbsp; From<tt> gptr</tt> to<tt> egptr</tt>
 are characters buffered but not yet read.&nbsp; From<tt> pbase</tt> to<tt> pptr</tt> are characters buffered and not yet
 written.&nbsp; From<tt> pptr</tt> to<tt> epptr</tt> is unused buffer area.
<dt><br>Results:
<dd>The<tt> pbase</tt> protected member function returns a pointer to the start of the<b> put area</b>.&nbsp; If the<tt> streambuf</tt>
 object currently does not have a<b> put area</b>,<tt> NULL</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::epptr</tt>,<tt> pptr</tt>,<tt> setp</tt>
</dl>
<h2 id="streambuf__pbumpLR"> pbump() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>void streambuf::pbump( streamoff offset );</tt>
<dt><br>Semantics:
<dd>The<tt> pbump</tt> protected member function increments the<b> put pointer</b> by the specified<b> offset</b>, without regard
 for the boundaries of the<b> put area</b>.&nbsp; The<b> offset</b> parameter may be positive or negative.
<dt><br>Results:
<dd>The<tt> pbump</tt> protected member function returns nothing.
<dt><br>See Also:
<dd><tt> streambuf::gbump</tt>,<tt> pbase</tt>,<tt> pptr</tt>
</dl>
<h2 id="streambuf__pptrLR"> pptr() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>char *streambuf::pptr() const;</tt>
<dt><br>Semantics:
<dd>The<tt> pptr</tt> protected member function returns a pointer to the next available space in the<b> put area</b> within the<b>
 reserve area</b> used by the<tt> streambuf</tt> object.&nbsp; This pointer is called the<b> put pointer</b>.&nbsp; 
<br>If the<b> put pointer</b> points beyond the end of the<b> put area</b>, the<b> put area</b> is full and a subsequent write
 causes the<tt> overflow</tt> virtual member function to be called to empty the<b> put area</b> to the device to which the<tt>
 streambuf</tt> object is attached.
<br><br>The<b> reserve area</b>,<b> get area</b>, and<b> put area</b> pointer functions return the following values:
<br><br><tt>base()</tt>&nbsp;&nbsp;&nbsp; start of the <b>reserve area</b>.
<br><tt>ebuf()</tt>&nbsp;&nbsp;&nbsp; end of the <b>reserve area</b>.
<br><tt>blen()</tt>&nbsp;&nbsp;&nbsp; length of the <b>reserve area</b>.
<br><br><tt>eback()</tt>&nbsp;&nbsp; start of the <b>get area</b>.
<br><tt>gptr()</tt>&nbsp;&nbsp;&nbsp; the <b>get pointer</b>.
<br><tt>egptr()</tt>&nbsp;&nbsp; end of the <b>get area</b>.
<br><br><tt>pbase()</tt>&nbsp;&nbsp; start of the <b>put area</b>.
<br><tt>pptr()</tt>&nbsp;&nbsp;&nbsp; the <b>put pointer</b>.
<br><tt>epptr()</tt>&nbsp;&nbsp; end of the <b>put area</b>.
<br><br>From<tt> eback</tt> to<tt> gptr</tt> are characters buffered and read.&nbsp; From<tt> gptr</tt> to<tt> egptr</tt>
 are characters buffered but not yet read.&nbsp; From<tt> pbase</tt> to<tt> pptr</tt> are characters buffered and not yet
 written.&nbsp; From<tt> pptr</tt> to<tt> epptr</tt> is unused buffer area.
<dt><br>Results:
<dd>The<tt> pptr</tt> protected member function returns a pointer to the next available space in the<b> put area</b>.&nbsp; If
 the<tt> streambuf</tt> object currently does not have a<b> put area</b>,<tt> NULL</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::epptr</tt>,<tt> pbase</tt>,<tt> setp</tt>
</dl>
<h2 id="streambuf__sbumpcLR"> sbumpc() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int streambuf::sbumpc();</tt>
<dt><br>Semantics:
<dd>The<tt> sbumpc</tt> public member function extracts the next available character from the<b> get area</b> and advances the<b>
 get pointer</b>.&nbsp; If no character is available, it calls the<tt> underflow</tt> virtual member function to fetch more
 characters from the source into the<b> get area</b>.
<br>Due to the<tt> sbumpc</tt> member functions's awkward name, the<tt> sgetchar</tt> member function was added to take its
 place in the WATCOM implementation.
<dt><br>Results:
<dd>The<tt> sbumpc</tt> public member function returns the next available character in the<b> get area</b>.&nbsp; If no character
 is available,<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::gbump</tt>,<tt> sgetc</tt>,<tt> sgetchar</tt>,<tt> sgetn</tt>,<tt> snextc</tt>,<tt> sputbackc</tt>
</dl>
<h2 id="streambuf__seekoffLR"> seekoff() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual streampos streambuf::seekoff( streamoff offset,</tt>
<br><tt> ios::seekdir dir,</tt>
<br><tt>ios::openmode mode );</tt>
<dt><br>Semantics:
<dd>The<tt> seekoff</tt> public virtual member function is used for positioning to a relative location within the<tt> streambuf</tt>
 object, and hence within the device that is connected to the<tt> streambuf</tt> object.&nbsp; The<b> offset</b> and<b> dir</b>
 parameters specify the relative change in position.&nbsp; The<b> mode</b> parameter controls whether the<b> get pointer</b>
 and/or the<b> put pointer</b> are repositioned.
<dt><br>Derived Implementation Protocol:
<dd>Classes derived from the<tt> streambuf</tt> class should implement the<tt> seekoff</tt> virtual member function so that it
 uses its parameters in the following way.
<br>The<b> mode</b> parameter may be<tt> ios::in</tt>,<tt> ios::out</tt>, or<tt> ios::in|ios::out</tt> and should be interpreted
 as follows, provided the interpretation is meaningful:
<br><br><tt>ios::in</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the <b>get pointer</b> should
 be moved.
<br><tt>ios::out</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the <b>put pointer</b> should be moved.
<br><tt>ios::in|ios::out</tt>&nbsp;&nbsp;&nbsp; both the <b>get pointer</b> and the <b>put pointer</b> should be moved.
<br><br>If<b> mode</b> has any other value, the<tt> seekoff</tt> public virtual member function fails.
<br>The<b> dir</b> parameter may be<tt> ios::beg</tt>,<tt> ios::cur</tt>, or<tt> ios::end</tt> and is interpreted in conjunction
 with the<b> offset</b> parameter as follows:
<br><br><tt>ios::beg</tt>&nbsp; the <b>offset</b> is relative to the start and should be a positive value.
<br><tt>ios::cur</tt>&nbsp; the <b>offset</b> is relative to the current position and may be positive
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (seek towards end) or negative (seek towards start).
<br><tt>ios::end</tt>&nbsp; the <b>offset</b> is relative to the end and should be a negative value.
<br><br>If the<b> dir</b> parameter has any other value, or the<b> offset</b> parameter does not have an appropriate sign,
 the<tt> seekoff</tt> public virtual member function fails.
<dt><br>Default Implementation:
<dd>The default implementation of the<tt> seekoff</tt> public virtual member function provided by the<tt> streambuf</tt> class
 returns<tt> EOF</tt>.
<dt><br>Results:
<dd>The<tt> seekoff</tt> public virtual member function returns the new position in the stream on success, otherwise<tt> EOF</tt>
 is returned.
<dt><br>See Also:
<dd><tt> streambuf::seekpos</tt>
</dl>
<h2 id="streambuf__seekposLR"> seekpos() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual streampos streambuf::seekpos( streampos pos,</tt>
<br><tt> ios::openmode mode = ios::in|ios::out );</tt>
<dt><br>Semantics:
<dd>The<tt> seekpos</tt> public virtual member function is used for positioning to an absolute location within the<tt> streambuf</tt>
 object, and hence within the device that is connected to the<tt> streambuf</tt> object.&nbsp; The<b> pos</b> parameter specifies
 the absolute position.&nbsp; The<b> mode</b> parameter controls whether the<b> get pointer</b> and/or the<b> put pointer</b>
 are repositioned.
<dt><br>Derived Implementation Protocol:
<dd>Classes derived from the<tt> streambuf</tt> class should implement the<tt> seekpos</tt> public virtual member function so
 that it uses its parameters in the following way.
<br>The<b> mode</b> parameter may be<tt> ios::in</tt>,<tt> ios::out</tt>, or<tt> ios::in|ios::out</tt> and should be interpreted
 as follows, provided the interpretation is meaningful:
<br><br><tt>ios::in</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the <b>get pointer</b> should
 be moved.
<br><tt>ios::out</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the <b>put pointer</b> should be moved.
<br><tt>ios::in|ios::out</tt>&nbsp;&nbsp;&nbsp; both the <b>get pointer</b> and the <b>put pointer</b> should be moved.
<br><br>If<b> mode</b> has any other value, the<tt> seekpos</tt> public virtual member function fails.
<br>In general the<tt> seekpos</tt> public virtual member function is equivalent to calling the<tt> seekoff</tt> virtual member
 function with the offset set to<b> pos</b>, the direction set to<tt> ios::beg</tt> and the mode set to<b> mode</b>.
<dt><br>Default Implementation:
<dd>The default implementation of the<tt> seekpos</tt> public virtual member function provided by the<tt> streambuf</tt> class
 calls the<tt> seekoff</tt> virtual member function with the offset set to<b> pos</b>, the direction set to<tt> ios::beg</tt>,
 and the mode set to<b> mode</b>.
<dt><br>Results:
<dd>The<tt> seekpos</tt> public virtual member function returns the new position in the stream on success, otherwise<tt> EOF</tt>
 is returned.
<dt><br>See Also:
<dd><tt> streambuf::seekoff</tt>
</dl>
<h2 id="streambuf__setbLR"> setb() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>void streambuf::setb( char *base, char *ebuf, int autodel );</tt>
<dt><br>Semantics:
<dd>The<tt> setb</tt> protected member function is used to set the pointers to the<b> reserve area</b> that the<tt> streambuf</tt>
 object is using.
<br>The<b> base</b> parameter is a pointer to the start of the<b> reserve area</b> and corresponds to the value that the<tt>
 base</tt> member function returns.
<br><br>The<b> ebuf</b> parameter is a pointer to the end of the<b> reserve area</b> and corresponds to the value that the<tt>
 ebuf</tt> member function returns.
<br><br>The<b> autodel</b> parameter indicates whether or not the<tt> streambuf</tt> object can free the<b> reserve area</b>
 when the<tt> streambuf</tt> object is destroyed or when a new<b> reserve area</b> is set up in a subsequent call to the<tt>
 setb</tt> protected member function.&nbsp; If the<b> autodel</b> parameter is non-zero, the<tt> streambuf</tt> object can
 delete the<b> reserve area</b>, using the<tt> operator delete</tt> intrinsic function.&nbsp; Otherwise, a zero value indicates
 that the buffer will be deleted elsewhere.
<br><br>If either of the<b> base</b> or<b> ebuf</b> parameters are<tt> NULL</tt> or if<b> ebuf</b> &lt;=<b> base</b>, the<tt>
 streambuf</tt> object does not have a buffer and input/output operations are unbuffered, unless another buffer is set up.
<br><br>Note that the<tt> setb</tt> protected member function is used to set the<b> reserve area</b> pointers, while the<tt>
 setbuf</tt> protected member function is used to offer a buffer to the<tt> streambuf</tt> object.
<dt><br>See Also:
<dd><tt> streambuf::base</tt>,<tt> blen</tt>,<tt> ebuf</tt>,<tt> setbuf</tt>
</dl>
<h2 id="streambuf__setbufLR"> setbuf() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual streambuf *streambuf::setbuf( char *buf, int len );</tt>
<dt><br>Semantics:
<dd>The<tt> setbuf</tt> public virtual member function is used to offer a buffer specified by the<b> buf</b> and<b> len</b> parameters
 to the<tt> streambuf</tt> object for use as its<b> reserve area</b>.&nbsp; Note that the<tt> setbuf</tt> public virtual member
 function is used to offer a buffer, while the<tt> setb</tt> protected member function is used to set the<b> reserve area</b>
 pointers once a buffer has been accepted.
<dt><br>Derived Implementation Protocol:
<dd>Classes derived from the<tt> streambuf</tt> class may implement the<tt> setbuf</tt> public virtual member function if the
 default behavior is not suitable.
<br>Derived classes that provide their own implementations of the<tt> setbuf</tt> public virtual member function may accept
 or reject the offered buffer.&nbsp; Often, if a buffer is already allocated, the offered buffer is rejected, as it may be
 difficult to transfer the information from the current buffer.
<dt><br>Default Implementation:
<dd>The default<tt> setbuf</tt> public virtual member function provided by the<tt> streambuf</tt> class rejects the buffer if
 one is already present.
<br>If no buffer is present and either<b> buf</b> is<tt> NULL</tt> or<b> len</b> is zero, the offer is accepted and the<tt>
 streambuf</tt> object is unbuffered.
<br><br>Otherwise, no buffer is present and one is specified.&nbsp; If<b> len</b> is less than five characters the buffer
 is too small and it is rejected.&nbsp; Otherwise, the buffer is accepted.
<dt><br>Results:
<dd>The<tt> setbuf</tt> public virtual member function returns the address of the<tt> streambuf</tt> object if the offered buffer
 is accepted, otherwise<tt> NULL</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::setb</tt>
</dl>
<h2 id="streambuf__setgLR"> setg() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>void streambuf::setg( char *eback, char *gptr, char *egptr );</tt>
<dt><br>Semantics:
<dd>The<tt> setg</tt> protected member function is used to set the three<b> get area</b> pointers.
<br>The<b> eback</b> parameter is a pointer to the start of the<b> get area</b> and corresponds to the value that the<tt>
 eback</tt> member function returns.
<br><br>The<b> gptr</b> parameter is a pointer to the first available character in the<b> get area</b>, that is, the<b> get
 pointer</b>, and usually is greater than the<tt> eback</tt> parameter in order to accommodate a putback area.&nbsp; The<b>
 gptr</b> parameter corresponds to the value that the<tt> gptr</tt> member function returns.
<br><br>The<b> egptr</b> parameter is a pointer to the end of the<b> get area</b> and corresponds to the value that the<tt>
 egptr</tt> member function returns.
<br><br>If any of the three parameters are<tt> NULL</tt>, there is no<b> get area</b>.
<dt><br>See Also:
<dd><tt> streambuf::eback</tt>,<tt> egptr</tt>,<tt> gptr</tt>
</dl>
<h2 id="streambuf__setpLR"> setp() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>void streambuf::setp( char *pbase, char *epptr );</tt>
<dt><br>Semantics:
<dd>The<tt> setp</tt> protected member function is used to set the three<b> put area</b> pointers.
<br>The<b> pbase</b> parameter is a pointer to the start of the<b> put area</b> and corresponds to the value that the<tt>
 pbase</tt> member function returns.
<br><br>The<b> epptr</b> parameter is a pointer to the end of the<b> put area</b> and corresponds to the value that the<tt>
 epptr</tt> member function returns.
<br><br>The<b> put pointer</b> is set to the<b> pbase</b> parameter value and corresponds to the value that the<tt> pptr</tt>
 member function returns.
<br><br>If either parameter is<tt> NULL</tt>, there is no<b> put area</b>.
<dt><br>See Also:
<dd><tt> streambuf::epptr</tt>,<tt> pbase</tt>,<tt> pptr</tt>
</dl>
<h2 id="streambuf__sgetcLR"> sgetc() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int streambuf::sgetc();</tt>
<dt><br>Semantics:
<dd>The<tt> sgetc</tt> public member function returns the next available character in the<b> get area</b>.&nbsp; The<b> get pointer</b>
 is not advanced.&nbsp; If the<b> get area</b> is empty, the<tt> underflow</tt> virtual member function is called to fetch
 more characters from the source into the<b> get area</b>.
<br>Due to the<tt> sgetc</tt> member function's confusing name (the C library<tt> getc</tt> function does advance the pointer),
 the<tt> speekc</tt> member function was added to take its place in the WATCOM implementation.
<dt><br>Results:
<dd>The<tt> sgetc</tt> public member function returns the next available character in the<b> get area</b>.&nbsp; If no character
 is available,<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::sbumpc</tt>,<tt> sgetchar</tt>,<tt> sgetn</tt>,<tt> snextc</tt>,<tt> speekc</tt>
</dl>
<h2 id="streambuf__sgetcharLR"> sgetchar() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int streambuf::sgetchar();</tt>
<dt><br>Semantics:
<dd>The<tt> sgetchar</tt> public member function extracts the next available character from the<b> get area</b> and advances the<b>
 get pointer</b>.&nbsp; If no character is available, it calls the<tt> underflow</tt> virtual member function to fetch more
 characters from the source into the<b> get area</b>.
<br>Due to the<tt> sbumpc</tt> member functions's awkward name, the<tt> sgetchar</tt> member function was added to take its
 place in the WATCOM implementation.
<dt><br>Results:
<dd>The<tt> sgetchar</tt> public member function returns the next available character in the<b> get area</b>.&nbsp; If no character
 is available,<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::gbump</tt>,<tt> sgetc</tt>,<tt> sgetchar</tt>,<tt> sgetn</tt>,<tt> snextc</tt>,<tt> speekc</tt>,<tt> sputbackc</tt>
</dl>
<h2 id="streambuf__sgetnLR"> sgetn() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int streambuf::sgetn( char *buf, int len );</tt>
<dt><br>Semantics:
<dd>The<tt> sgetn</tt> public member function transfers up to<b> len</b> characters from the<b> get area</b> into<b> buf</b>.
&nbsp; If there are not enough characters in the<b> get area</b>, the<tt> do_sgetn</tt> virtual member function is called
 to fetch more.
<br>Classes derived from the<tt> streambuf</tt> class should call the<tt> sgetn</tt> public member function, rather than the<tt>
 do_sgetn</tt> virtual member function.
<dt><br>Results:
<dd>The<tt> sgetn</tt> public member function returns the number of characters transferred from the<b> get area</b> into<b> buf</b>.
<dt><br>See Also:
<dd><tt> streambuf::do_sgetn</tt>,<tt> sbumpc</tt>,<tt> sgetc</tt>,<tt> sgetchar</tt>,<tt> speekc</tt>
</dl>
<h2 id="streambuf__snextcLR"> snextc() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int streambuf::snextc();</tt>
<dt><br>Semantics:
<dd>The<tt> snextc</tt> public member function advances the<b> get pointer</b> and then returns the character following the<b>
 get pointer</b>.&nbsp; The<b> get pointer</b> is left pointing at the returned character.
<br>If the<b> get pointer</b> cannot be advanced, the<tt> underflow</tt> virtual member function is called to fetch more characters
 from the source into the<b> get area</b>.
<dt><br>Results:
<dd>The<tt> snextc</tt> public member function advances the<b> get pointer</b> and returns the next available character in the<b>
 get area</b>.&nbsp; If there is no next available character,<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::sbumpc</tt>,<tt> sgetc</tt>,<tt> sgetchar</tt>,<tt> sgetn</tt>,<tt> speekc</tt>
</dl>
<h2 id="streambuf__speekcLR"> speekc() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int streambuf::speekc();</tt>
<dt><br>Semantics:
<dd>The<tt> speekc</tt> public member function returns the next available character in the<b> get area</b>.&nbsp; The<b> get pointer</b>
 is not advanced.&nbsp; If the<b> get area</b> is empty, the<tt> underflow</tt> virtual member function is called to fetch
 more characters from the source into the<b> get area</b>.
<br>Due to the<tt> sgetc</tt> member function's confusing name (the C library<tt> getc</tt> function does advance the pointer),
 the<tt> speekc</tt> member function was added to take its place in the WATCOM implementation.
<dt><br>Results:
<dd>The<tt> speekc</tt> public member function returns the next available character in the<b> get area</b>.&nbsp; If no character
 is available,<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::sbumpc</tt>,<tt> sgetc</tt>,<tt> sgetchar</tt>,<tt> sgetn</tt>,<tt> snextc</tt>
</dl>
<h2 id="streambuf__sputbackcLR"> sputbackc() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int streambuf::sputbackc( char ch );</tt>
<dt><br>Semantics:
<dd>The<tt> sputbackc</tt> public member function is used to put a character back into the<b> get area</b>.&nbsp; The<b> ch</b>
 character specified must be the same as the character before the<b> get pointer</b>, otherwise the behavior is undefined.
&nbsp; The<b> get pointer</b> is backed up by one position.&nbsp; At least four characters may be put back without any intervening
 reads.
<dt><br>Results:
<dd>The<tt> sputbackc</tt> public member function returns<b> ch</b> on success, otherwise<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::gbump</tt>,<tt> sbumpc</tt>,<tt> sgetchar</tt>
</dl>
<h2 id="streambuf__sputcLR"> sputc() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int streambuf::sputc( int ch );</tt>
<dt><br>Semantics:
<dd>The<tt> sputc</tt> public member function adds the character<b> ch</b> to the end of the<b> put area</b> and advances the<b>
 put pointer</b>.&nbsp; If the<b> put area</b> is full before the character is added, the<tt> overflow</tt> virtual member
 function is called to empty the<b> put area</b> and write the character.
<dt><br>Results:
<dd>The<tt> sputc</tt> public member function returns<b> ch</b> on success, otherwise<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::sgetc</tt>,<tt> sputn</tt>
</dl>
<h2 id="streambuf__sputnLR"> sputn() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int streambuf::sputn( char const *buf, int len );</tt>
<dt><br>Semantics:
<dd>The<tt> sputn</tt> public member function transfers up to<b> len</b> characters from<b> buf</b> to the end of the<b> put area</b>
 and advance the<b> put pointer</b>.&nbsp; If the<b> put area</b> is full or becomes full and more characters are to be written,
 the<tt> do_sputn</tt> virtual member function is called to empty the<b> put area</b> and finish writing the characters.
<br>Classes derived from the<tt> streambuf</tt> class should call the<tt> sputn</tt> public member function, rather than the<tt>
 do_sputn</tt> virtual member function.
<dt><br>Results:
<dd>The<tt> sputn</tt> public member function returns the number of characters successfully written.&nbsp; If an error occurs,
 this number may be less than<b> len</b>.
<dt><br>See Also:
<dd><tt> streambuf::do_sputn</tt>,<tt> sputc</tt>
</dl>
<h2 id="streambuf__stosscLR"> stossc() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void streambuf::stossc();</tt>
<dt><br>Semantics:
<dd>The<tt> stossc</tt> public member function advances the<b> get pointer</b> by one without returning a character.&nbsp; If
 the<b> get area</b> is empty, the<tt> underflow</tt> virtual member function is called to fetch more characters and then
 the<b> get pointer</b> is advanced.
<dt><br>See Also:
<dd><tt> streambuf::gbump</tt>,<tt> sbumpc</tt>,<tt> sgetchar</tt>,<tt> snextc</tt>
</dl>
<h2 id="streambuf__streambufLR"> streambuf() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>streambuf::streambuf();</tt>
<dt><br>Semantics:
<dd>This form of the protected<tt> streambuf</tt> constructor creates an empty<tt> streambuf</tt> object with all fields initialized
 to zero.&nbsp; No<b> reserve area</b> is yet allocated, but the<tt> streambuf</tt> object is buffered unless a subsequent
 call to the<tt> setbuf</tt> or<tt> unbuffered</tt> member functions dictate otherwise.
<dt><br>Results:
<dd>This form of the protected<tt> streambuf</tt> constructor creates an initialized<tt> streambuf</tt> object with no associated<b>
 reserve area</b>.
<dt><br>See Also:
<dd><tt> ~streambuf</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>streambuf::streambuf( char *buf, int len );</tt>
<dt><br>Semantics:
<dd>This form of the protected<tt> streambuf</tt> constructor creates an empty<tt> streambuf</tt> object with all fields initialized
 to zero.&nbsp; The<b> buf</b> and<b> len</b> parameters are passed to the<tt> setbuf</tt> member function, which sets up
 the buffer (if specified), or makes the<tt> streambuf</tt> object unbuffered (if the<b> buf</b> parameter is<tt> NULL</tt>
 or the<b> len</b> parameter is not positive).
<dt><br>Results:
<dd>This form of the protected<tt> streambuf</tt> constructor creates an initialized<tt> streambuf</tt> object with an associated<b>
 reserve area</b>.
<dt><br>See Also:
<dd><tt> ~streambuf</tt>,<tt> setbuf</tt>
</dl>
<h2 id="streambuf____streambufLR"> ~streambuf() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>virtual streambuf::~streambuf();</tt>
<dt><br>Semantics:
<dd>The<tt> streambuf</tt> object is destroyed.&nbsp; If the buffer was allocated by the<tt> streambuf</tt> object, it is freed.
&nbsp; Otherwise, the buffer is not freed and must be freed by the user of the<tt> streambuf</tt> object.&nbsp; The call to
 the protected<tt> ~streambuf</tt> destructor is inserted implicitly by the compiler at the point where the<tt> streambuf</tt>
 object goes out of scope.
<dt><br>Results:
<dd>The<tt> streambuf</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> streambuf</tt>
</dl>
<h2 id="streambuf__syncLR"> sync() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int streambuf::sync();</tt>
<dt><br>Semantics:
<dd>The<tt> sync</tt> public virtual member function is used to synchronize the<tt> streambuf</tt> object's<b> get area</b> and<b>
 put area</b> with the associated device.
<dt><br>Derived Implementation Protocol:
<dd>Classes derived from the<tt> streambuf</tt> class should implement the<tt> sync</tt> public virtual member function such that
 it attempts to perform the following:
<ol>
<li>flush the<b> put area</b>,
<li>discard the contents of the<b> get area</b> and reposition the stream device so that the discarded characters may be read
 again.
</ol>
<dt><br>Default Implementation:
<dd>The default implementation of the<tt> sync</tt> public virtual member function provided by the<tt> streambuf</tt> class takes
 no action.&nbsp; It succeeds if the<b> get area</b> and the<b> put area</b> are empty, otherwise it fails.
<dt><br>Results:
<dd>The<tt> sync</tt> public virtual member function returns<tt> __NOT_EOF</tt> on success, otherwise<tt> EOF</tt> is returned.
</dl>
<h2 id="streambuf__unbufferedLR"> unbuffered() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>int ios::unbuffered() const;</tt>
<br><tt> int ios::unbuffered( int unbuf );</tt>
<dt><br>Semantics:
<dd>The<tt> unbuffered</tt> protected member function is used to query and/or set the unbuffering state of the<tt> streambuf</tt>
 object.&nbsp; A non-zero unbuffered state indicates that the<tt> streambuf</tt> object is unbuffered.&nbsp; An unbuffered
 state of zero indicates that the<tt> streambuf</tt> object is buffered.
<br>The first form of the<tt> unbuffered</tt> protected member function is used to query the current unbuffering state.
<br><br>The second form of the<tt> unbuffered</tt> protected member function is used to set the unbuffering state to<b> unbuf</b>.
<br><br>Note that the unbuffering state only affects the<tt> allocate</tt> protected member function, which does nothing if
 the unbuffering state is non-zero.&nbsp; Setting the unbuffering state to a non-zero value does not mean that future I/O
 operations will be unbuffered.
<br><br>To determine if current I/O operations are unbuffered, use the<tt> base</tt> protected member function.&nbsp; A return
 value of<tt> NULL</tt> from the<tt> base</tt> protected member function indicates that unbuffered I/O operations will be
 used.
<dt><br>Results:
<dd>The<tt> unbuffered</tt> protected member function returns the previous unbuffered state.
<dt><br>See Also:
<dd><tt> streambuf::allocate</tt>,<tt> pbase</tt>,<tt> setbuf</tt>
</dl>
<h2 id="streambuf__underflowLR"> underflow() &#91;streambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;streambu.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int streambuf::underflow() = 0;</tt>
<dt><br>Semantics:
<dd>The<tt> underflow</tt> public virtual member function is used to fill the<b> get area</b> when it is empty.
<dt><br>Derived Implementation Protocol:
<dd>Classes derived from the<tt> streambuf</tt> class should implement the<tt> underflow</tt> public virtual member function so
 that it performs the following:
<ol>
<li>if no<b> reserve area</b> is present and the<tt> streambuf</tt> object is buffered, allocate the<b> reserve area</b> using
 the<tt> allocate</tt> member function and set up the<b> reserve area</b> pointers using the<tt> setb</tt> protected member
 function,
<li>flush any other uses of the<b> reserve area</b>,
<li>read some characters from the<tt> streambuf</tt> object's source into the<b> get area</b>,
<li>set up the<b> get area</b> pointers to reflect the characters that were read,
<li>return the first character of the<b> get area</b>, or<tt> EOF</tt> if no characters could be read.
</ol>
<dt><br>Default Implementation:
<dd>There is no default<tt> streambuf</tt> class implementation of the<tt> underflow</tt> public virtual member function.&nbsp;
 The<tt> underflow</tt> public virtual member function must be defined for all classes derived from the<tt> streambuf</tt>
 class.
<dt><br>Results:
<dd>The<tt> underflow</tt> public virtual member function returns the first character read into the<b> get area</b>, or<tt> EOF</tt>
 if no characters could be read.
<dt><br>See Also:
<dd><tt> filebuf::underflow</tt>,<tt> stdiobuf::underflow</tt>,<tt> strstreambuf::underflow</tt>
</dl>
<h2 id="strstream_Class_Description"> strstream Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> strstrea.h</tt>
<dt><br>Derived from:
<dd><tt> strstreambase</tt>,<tt> iostream</tt>
<br>The<tt> strstream</tt> class is used to create and write to string stream objects.
<br>The<tt> strstream</tt> class provides little of its own functionality.&nbsp; Derived from the<tt> strstreambase</tt> and<tt>
 iostream</tt> classes, its constructors and destructor provide simplified access to the appropriate equivalents in those
 base classes.&nbsp; The member functions provide specialized access to the string stream object.
<br><br>Of the available I/O stream classes, creating a<tt> strstream</tt> object is the preferred method of performing read
 and write operations on a string stream.
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>strstream();</tt>
<br><tt> strstream( char *,</tt>
<br><tt> int,</tt>
<br><tt>ios::openmode = ios::in|ios::out );</tt>
<br><tt>strstream( signed char *,</tt>
<br><tt> int,</tt>
<br><tt>ios::openmode = ios::in|ios::out );</tt>
<br><tt>strstream( unsigned char *,</tt>
<br><tt> int,</tt>
<br><tt>ios::openmode = ios::in|ios::out );</tt>
<br><tt>~strstream();</tt>
<br><tt> char *str();</tt>
<dt><br>See Also:
<dd><tt> istrstream</tt>,<tt> ostrstream</tt>,<tt> strstreambase</tt>
</dl>
<h2 id="strstream__strLR"> str() &#91;strstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>char *strstream::str();</tt>
<dt><br>Semantics:
<dd>The<tt> str</tt> public member function creates a pointer to the buffer being used by the<tt> strstream</tt> object.&nbsp;
 If the<tt> strstream</tt> object was created without dynamic allocation (static mode), the pointer is the same as the buffer
 pointer passed in the constructor.
<br>For<tt> strstream</tt> objects using dynamic allocation, the<tt> str</tt> public member function makes an implicit call
 to the<tt> strstreambuf::freeze</tt> member function.&nbsp; If nothing has been written to the<tt> strstream</tt> object,
 the returned pointer will be<tt> NULL</tt>.
<br><br>Note that the buffer does not necessarily end with a null character.&nbsp; If the pointer returned by the<tt> str</tt>
 public member function is to be interpreted as a C string, it is the program's responsibility to ensure that the null character
 is present.
<dt><br>Results:
<dd>The<tt> str</tt> public member function returns a pointer to the buffer being used by the<tt> strstream</tt> object.
<dt><br>See Also:
<dd><tt> strstreambuf::str</tt>,<tt> strstreambuf::freeze</tt>
</dl>
<h2 id="strstream__strstreamLR"> strstream() &#91;strstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>strstream::strstream();</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> strstream</tt> constructor creates an empty<tt> strstream</tt> object.&nbsp; Dynamic allocation
 is used.&nbsp; The inherited stream member functions can be used to access the<tt> strstream</tt> object.&nbsp; Note that
 the<b> get pointer</b> and<b> put pointer</b> are not necessarily pointing at the same location, so moving one pointer (e.g.
&nbsp; by doing a write) does not affect the location of the other pointer.
<dt><br>Results:
<dd>This form of the public<tt> strstream</tt> constructor creates an initialized, empty<tt> strstream</tt> object.
<dt><br>See Also:
<dd><tt> ~strstream</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>strstream::strstream( char *str,</tt>
<br><tt> int len,</tt>
<br><tt>ios::openmode mode );</tt>
<br><tt>strstream::strstream( signed char *str,</tt>
<br><tt> int len,</tt>
<br><tt>ios::openmode mode );</tt>
<br><tt>strstream::strstream( unsigned char *str,</tt>
<br><tt> int len,</tt>
<br><tt>ios::openmode mode );</tt>
<dt><br>Semantics:
<dd>These forms of the public<tt> strstream</tt> constructor create an initialized<tt> strstream</tt> object.&nbsp; Dynamic allocation
 is not used.&nbsp; The buffer is specified by the<b> str</b> and<b> len</b> parameters.&nbsp; If the<tt> ios::append</tt>
 or<tt> ios::atend</tt> bits are set in the<b> mode</b> parameter, the<b> str</b> parameter is assumed to contain a C string
 terminated by a null character, and writing commences at the null character.&nbsp; Otherwise, writing commences at<b> str</b>.
&nbsp; Reading commences at<b> str</b>.
<dt><br>Results:
<dd>This form of the public<tt> strstream</tt> constructor creates an initialized<tt> strstream</tt> object.
<dt><br>See Also:
<dd><tt> ~strstream</tt>
</dl>
<h2 id="strstream____strstreamLR"> ~strstream() &#91;strstream&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>strstream::~strstream();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~strstream</tt> destructor does not do anything explicit.&nbsp; The call to the public<tt> ~strstream</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> strstream</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> strstream</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> strstream</tt>
</dl>
<h2 id="strstreambase_Class_Description"> strstreambase Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> strstrea.h</tt>
<dt><br>Derived from:
<dd><tt> ios</tt>
<dt><br>Derived by:
<dd><tt> istrstream</tt>,<tt> ostrstream</tt>,<tt> strstream</tt>
<br>The<tt> strstreambase</tt> class is a base class that provides common functionality for the three string stream-based
 classes,<tt> istrstream</tt>,<tt> ostrstream</tt> and<tt> strstream</tt>.&nbsp; The<tt> strstreambase</tt> class is derived
 from the<tt> ios</tt> class which provides the stream state information.&nbsp; The<tt> strstreambase</tt> class provides
 constructors for string stream objects and one member function.
<br><br><b>Protected Member Functions</b>
<br><br>The following member functions are declared in the protected interface:
<br><br><tt>strstreambase();</tt>
<br><tt> strstreambase( char *, int, char * = 0 );</tt>
<br><tt> ~strstreambase();</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member function is declared in the public interface:
<br><br><tt>strstreambuf *rdbuf() const;</tt>
<dt><br>See Also:
<dd><tt> istrstream</tt>,<tt> ostrstream</tt>,<tt> strstream</tt>,<tt> strstreambuf</tt>
</dl>
<h2 id="strstreambase__rdbufLR"> rdbuf() &#91;strstreambase&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>strstreambuf *strstreambase::rdbuf() const;</tt>
<dt><br>Semantics:
<dd>The<tt> rdbuf</tt> public member function creates a pointer to the<tt> strstreambuf</tt> associated with the<tt> strstreambase</tt>
 object.&nbsp; Since the<tt> strstreambuf</tt> object is embedded within the<tt> strstreambase</tt> object, this function
 never returns<tt> NULL</tt>.
<dt><br>Results:
<dd>The<tt> rdbuf</tt> public member function returns a pointer to the<tt> strstreambuf</tt> associated with the<tt> strstreambase</tt>
 object.
</dl>
<h2 id="strstreambase__strstreambaseLR"> strstreambase() &#91;strstreambase&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>strstreambase::strstreambase();</tt>
<dt><br>Semantics:
<dd>This form of the protected<tt> strstreambase</tt> constructor creates a<tt> strstreambase</tt> object that is initialized,
 but empty.&nbsp; Dynamic allocation is used to store characters.&nbsp; No buffer is allocated.&nbsp; A buffer is be allocated
 when data is first written to the<tt> strstreambase</tt> object.
<br>This form of the protected<tt> strstreambase</tt> constructor is only used implicitly by the compiler when it generates
 a constructor for a derived class.
<dt><br>Results:
<dd>The protected<tt> strstreambase</tt> constructor creates an initialized<tt> strstreambase</tt> object.
<dt><br>See Also:
<dd><tt> ~strstreambase</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>strstreambase::strstreambase( char *str,</tt>
<br><tt> int len,</tt>
<br><tt>char *pstart );</tt>
<dt><br>Semantics:
<dd>This form of the protected<tt> strstreambase</tt> constructor creates a<tt> strstreambase</tt> object that is initialized
 and uses the buffer specified by the<b> str</b> and<b> len</b> parameters as its<b> reserve area</b> within the associated<tt>
 strstreambuf</tt> object.&nbsp; Dynamic allocation is not used.
<br>This form of the protected<tt> strstreambase</tt> constructor is unlikely to be explicitly used, except in the member
 initializer list for the constructor of a derived class.
<br><br>The<b> str</b>,<b> len</b> and<b> pstart</b> parameters are interpreted as follows:
<ol>
<li>The buffer starts at<b> str</b>.
<li>If<b> len</b> is positive, the buffer is<b> len</b> characters long.
<li>If<b> len</b> is zero,<b> str</b> is a pointer to a C string which is terminated by a null character, and the length of
 the buffer is the length of the string.
<li>If<b> len</b> is negative, the buffer is unbounded.&nbsp; This last form should be used with extreme caution, since no
 buffer is truly unlimited in size and it would be easy to write beyond the available space.
<li>If the<b> pstart</b> parameter is<tt> NULL</tt>, the<tt> strstreambase</tt> object is read-only.
<li>Otherwise,<b> pstart</b> divides the buffer into two regions.&nbsp; The<b> get area</b> starts at<b> str</b> and ends
 at<b> pstart</b>-1.&nbsp; The<b> put area</b> starts at<b> pstart</b> and goes to the end of the buffer.
</ol>
<dt><br>Results:
<dd>The protected<tt> strstreambase</tt> constructor creates an initialized<tt> strstreambase</tt> object.
<dt><br>See Also:
<dd><tt> ~strstreambase</tt>
</dl>
<h2 id="strstreambase____strstreambaseLR"> ~strstreambase() &#91;strstreambase&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>strstreambase::~strstreambase();</tt>
<dt><br>Semantics:
<dd>The protected<tt> ~strstreambase</tt> destructor does not do anything explicit.&nbsp; The call to the protected<tt> ~strstreambase</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> strstreambase</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> strstreambase</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> strstreambase</tt>
</dl>
<h2 id="strstreambuf_Class_Description"> strstreambuf Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> strstrea.h</tt>
<dt><br>Derived from:
<dd><tt> streambuf</tt>
<br>The<tt> strstreambuf</tt> class is derived from the<tt> streambuf</tt> class and provides additional functionality required
 to write characters to and read characters from a string buffer.&nbsp; Read and write operations can occur at different positions
 in the string buffer, since the<b> get pointer</b> and<b> put pointer</b> are not necessarily connected.&nbsp; Seek operations
 are also supported.
<br>The<b> reserve area</b> used by the<tt> strstreambuf</tt> object may be either fixed in size or dynamic.&nbsp; Generally,
 input strings are of a fixed size, while output streams are dynamic, since the final size may not be predictable.&nbsp; For
 dynamic buffers, the<tt> strstreambuf</tt> object automatically grows the buffer when necessary.
<br><br>The<tt> strstreambuf</tt> class differs quite markedly from the<tt> filebuf</tt> and<tt> stdiobuf</tt> classes.&nbsp;
 Since there is no actual source or destination for the characters in<tt> strstream</tt> objects, the buffer itself takes
 on that role.&nbsp; When writing is occurring and the<b> put area</b> is full, the<tt> overflow</tt> virtual member function
 reallocates the buffer to a larger size (if possible), the<b> put area</b> is extended and the writing continues.&nbsp; If
 reading is occurring and the<b> get area</b> is empty, the<tt> underflow</tt> virtual member function checks to see if the<b>
 put area</b> is present and not empty.&nbsp; If so, the<b> get area</b> is extended to overlap the<b> put area</b>.
<br><br>C++ programmers who wish to use string streams without deriving new objects will probably never explicitly create
 or use a<tt> strstreambuf</tt> object.
<br><br><b>Protected Member Functions</b>
<br><br>The following member function is declared in the protected interface:
<br><br><tt>virtual int doallocate();</tt>
<br><br><b>Public Member Functions</b>
<br><br>The following member functions are declared in the public interface:
<br><br><tt>strstreambuf();</tt>
<br><tt> strstreambuf( int );</tt>
<br><tt> strstreambuf( void *(*)( long ), void (*)( void * ) );</tt>
<br><tt> strstreambuf( char *, int, char * = 0 );</tt>
<br><tt> ~strstreambuf();</tt>
<br><tt> int alloc_size_increment( int );</tt>
<br><tt> void freeze( int = 1 );</tt>
<br><tt> char *str();</tt>
<br><tt> virtual int overflow( int = EOF );</tt>
<br><tt> virtual int underflow();</tt>
<br><tt> virtual streambuf *setbuf( char *, int );</tt>
<br><tt> virtual streampos seekoff( streamoff,</tt>
<br><tt> ios::seekdir,</tt>
<br><tt>ios::openmode );</tt>
<br><tt>virtual int sync();</tt>
<dt><br>See Also:
<dd><tt> streambuf</tt>,<tt> strstreambase</tt>
</dl>
<h2 id="strstreambuf__alloc_size_incrementLR"> alloc_size_increment() &#91;strstreambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>int strstreambuf::alloc_size_increment( int increment );</tt>
<dt><br>Semantics:
<dd>The<tt> alloc_size_increment</tt> public member function modifies the allocation size used when the buffer is first allocated
 or reallocated by dynamic allocation.&nbsp; The<b> increment</b> parameter is added to the previous allocation size for future
 use.
<br>This function is a WATCOM extension.
<dt><br>Results:
<dd>The<tt> alloc_size_increment</tt> public member function returns the previous value of the allocation size.
<dt><br>See Also:
<dd><tt> strstreambuf::doallocate</tt>,<tt> setbuf</tt>
</dl>
<h2 id="strstreambuf__doallocateLR"> doallocate() &#91;strstreambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>protected:</tt>
<br><tt>virtual int strstreambuf::doallocate();</tt>
<dt><br>Semantics:
<dd>The<tt> doallocate</tt> protected virtual member function is called by the<tt> allocate</tt> member function when it is determined
 that the<b> put area</b> is full and needs to be extended.
<br>The<tt> doallocate</tt> protected virtual member function performs the following steps:
<ol>
<li>If dynamic allocation is not being used, the<tt> doallocate</tt> protected virtual member function fails.
<li>A new size for the buffer is determined.&nbsp; If the allocation size is bigger than the current size, the allocation
 size is used.&nbsp; Otherwise, the buffer size is increased by<tt> DEFAULT_MAINBUF_SIZE</tt>, which is 512.
<li>A new buffer is allocated.&nbsp; If an allocation function was specified in the constructor for the<tt> strstreambuf</tt>
 object, that allocation function is used, otherwise the<tt> operator new</tt> intrinsic function is used.&nbsp; If the allocation
 fails, the<tt> doallocate</tt> protected virtual member function fails.
<li>If necessary, the contents of the<b> get area</b> are copied to the newly allocated buffer and the<b> get area</b> pointers
 are adjusted accordingly.
<li>The contents of the<b> put area</b> are copied to the newly allocated buffer and the<b> put area</b> pointers are adjusted
 accordingly, extending the<b> put area</b> to the end of the new buffer.
<li>The old buffer is freed.&nbsp; If a free function was specified in the constructor for the<tt> strstreambuf</tt> object,
 that free function is used, otherwise the<tt> operator delete</tt> intrinsic function is used.
</ol>
<dt><br>Results:
<dd>The<tt> doallocate</tt> protected virtual member function returns<tt> __NOT_EOF</tt> on success, otherwise<tt> EOF</tt> is
 returned.
<dt><br>See Also:
<dd><tt> strstreambuf::alloc_size_increment</tt>,<tt> setbuf</tt>
</dl>
<h2 id="strstreambuf__freezeLR"> freeze() &#91;strstreambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>void strstreambuf::freeze( int frozen = 1 );</tt>
<dt><br>Semantics:
<dd>The<tt> freeze</tt> public member function enables and disables automatic deletion of the<b> reserve area</b>.&nbsp; If the<tt>
 freeze</tt> public member function is called with no parameter or a non-zero parameter, the<tt> strstreambuf</tt> object
 is frozen.&nbsp; If the<tt> freeze</tt> public member function is called with a zero parameter, the<tt> strstreambuf</tt>
 object is unfrozen.
<br>A frozen<tt> strstreambuf</tt> object does not free the<b> reserve area</b> in the destructor.&nbsp; If the<tt> strstreambuf</tt>
 object is destroyed while it is frozen, it is the program's responsibility to also free the<b> reserve area</b>.
<br><br>If characters are written to the<tt> strstreambuf</tt> object while it is frozen, the effect is undefined since the<b>
 reserve area</b> may be reallocated and therefore may move.&nbsp; However, if the<tt> strstreambuf</tt> object is frozen
 and then unfrozen, characters may be written to it.
<dt><br>Results:
<dd>The<tt> freeze</tt> public member function returns the previous frozen state.
<dt><br>See Also:
<dd><tt> strstreambuf::str</tt>,<tt> ~strstreambuf</tt>
</dl>
<h2 id="strstreambuf__overflowLR"> overflow() &#91;strstreambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int strstreambuf::overflow( int ch = EOF );</tt>
<dt><br>Semantics:
<dd>The<tt> overflow</tt> public virtual member function provides the output communication between the<tt> streambuf</tt> member
 functions and the<tt> strstreambuf</tt> object.&nbsp; Member functions in the<tt> streambuf</tt> class call the<tt> overflow</tt>
 public virtual member function when the<b> put area</b> is full.&nbsp; The<tt> overflow</tt> public virtual member function
 attempts to grow the<b> put area</b> so that writing may continue.
<br>The<tt> overflow</tt> public virtual member function performs the following steps:
<ol>
<li>If dynamic allocation is not being used, the<b> put area</b> cannot be extended, so the<tt> overflow</tt> public virtual
 member function fails.
<li>If dynamic allocation is being used, a new buffer is allocated using the<tt> doallocate</tt> member function.&nbsp; It
 handles copying the contents of the old buffer to the new buffer and discarding the old buffer.
<li>If the<b> ch</b> parameter is not<tt> EOF</tt>, it is added to the end of the extended<b> put area</b> and the<b> put
 pointer</b> is advanced.
</ol>
<dt><br>Results:
<dd>The<tt> overflow</tt> public virtual member function returns<tt> __NOT_EOF</tt> when it successfully extends the<b> put area</b>,
 otherwise<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::overflow</tt>
<br><tt>strstreambuf::underflow</tt>
</dl>
<h2 id="strstreambuf__seekoffLR"> seekoff() &#91;strstreambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual streampos strstreambuf::seekoff( streamoff offset,</tt>
<br><tt> ios::seekdir dir,</tt>
<br><tt>ios::openmode mode );</tt>
<dt><br>Semantics:
<dd>The<tt> seekoff</tt> public virtual member function positions the<b> get pointer</b> and/or<b> put pointer</b> to the specified
 position in the<b> reserve area</b>.&nbsp; If the<b> get pointer</b> is moved, it is moved to a position relative to the
 start of the<b> reserve area</b> (which is also the start of the<b> get area</b>).&nbsp; If a position is specified that
 is beyond the end of the<b> get area</b> but is in the<b> put area</b>, the<b> get area</b> is extended to include the<b>
 put area</b>.&nbsp; If the<b> put pointer</b> is moved, it is moved to a position relative to the start of the<b> put area</b>,<b>
 not</b> relative to the start of the<b> reserve area</b>.
<br>The<tt> seekoff</tt> public virtual member function seeks<b> offset</b> bytes from the position specified by the<b> dir</b>
 parameter.
<br><br>The<b> mode</b> parameter may be<tt> ios::in</tt>,<tt> ios::out</tt>, or<tt> ios::in|ios::out</tt> and should be interpreted
 as follows, provided the interpretation is meaningful:
<br><br><tt>ios::in</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the <b>get pointer</b> should
 be moved.
<br><tt>ios::out</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the <b>put pointer</b> should be moved.
<br><tt>ios::in|ios::out</tt>&nbsp;&nbsp;&nbsp; both the <b>get pointer</b> and the <b>put pointer</b> should be moved.
<br><br>If<b> mode</b> has any other value, the<tt> seekoff</tt> public virtual member function fails.<tt>&nbsp; ios::in|ios::out</tt>
 is not valid if the<b> dir</b> parameter is<tt> ios::cur</tt>.
<br>The<b> dir</b> parameter may be<tt> ios::beg</tt>,<tt> ios::cur</tt>, or<tt> ios::end</tt> and is interpreted in conjunction
 with the<b> offset</b> parameter as follows:
<br><br><tt>ios::beg</tt>&nbsp; the <b>offset</b> is relative to the start and should be a positive value.
<br><tt>ios::cur</tt>&nbsp; the <b>offset</b> is relative to the current position and may be positive
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (seek towards end) or negative (seek towards start).
<br><tt>ios::end</tt>&nbsp; the <b>offset</b> is relative to the end and should be a negative value.
<br><br>If the<b> dir</b> parameter has any other value, or the<b> offset</b> parameter does not have an appropriate sign,
 the<tt> seekoff</tt> public virtual member function fails.
<dt><br>Results:
<dd>The<tt> seekoff</tt> public virtual member function returns the new position in the file on success, otherwise<tt> EOF</tt>
 is returned.&nbsp; If both or<tt> ios::in|ios::out</tt> are specified and the<b> dir</b> parameter is<tt> ios::cur</tt> the
 returned position refers to the<b> put pointer</b>.
</dl>
<h2 id="strstreambuf__setbufLR"> setbuf() &#91;strstreambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual streambuf *strstreambuf::setbuf( char *, int size );</tt>
<dt><br>Semantics:
<dd>The<tt> setbuf</tt> public virtual member function is used to control the size of the allocations when the<tt> strstreambuf</tt>
 object is using dynamic allocation.&nbsp; The first parameter is ignored.&nbsp; The next time an allocation is required,
 at least the number of characters specified in the<b> size</b> parameter is allocated.&nbsp; If the specified size is not
 sufficient, the allocation reverts to its default behavior, which is to extend the buffer by<tt> DEFAULT_MAINBUF_SIZE</tt>,
 which is 512 characters.
<br>If a program is going to write a large number of characters to the<tt> strstreambuf</tt> object, it should call the<tt>
 setbuf</tt> public virtual member function to indicate the size of the next allocation, to prevent multiple allocations as
 the buffer gets larger.
<dt><br>Results:
<dd>The<tt> setbuf</tt> public virtual member function returns a pointer to the<tt> strstreambuf</tt> object.
<dt><br>See Also:
<dd><tt> strstreambuf::alloc_size_increment</tt>,<tt> doallocate</tt>
</dl>
<h2 id="strstreambuf__strLR"> str() &#91;strstreambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>char *strstreambuf::str();</tt>
<dt><br>Semantics:
<dd>The<tt> str</tt> public member function freezes the<tt> strstreambuf</tt> object and returns a pointer to the<b> reserve area</b>.
&nbsp; This pointer remains valid after the<tt> strstreambuf</tt> object is destroyed provided the<tt> strstreambuf</tt> object
 remains frozen, since the destructor does not free the<b> reserve area</b> if it is frozen.
<br>The returned pointer may be<tt> NULL</tt> if the<tt> strstreambuf</tt> object is using dynamic allocation but has not
 yet had anything written to it.
<br><br>If the<tt> strstreambuf</tt> object is not using dynamic allocation, the pointer returned by the<tt> str</tt> public
 member function is the same buffer pointer provided to the constructor.&nbsp; For a<tt> strstreambuf</tt> object using dynamic
 allocation, the pointer points to a dynamically allocated area.
<br><br>Note that the<b> reserve area</b> does not necessarily end with a null character.&nbsp; If the pointer returned by
 the<tt> str</tt> public member function is to be interpreted as a C string, it is the program's responsibility to ensure
 that the null character is present.
<dt><br>Results:
<dd>The<tt> str</tt> public member function returns a pointer to the<b> reserve area</b> and freezes the<tt> strstreambuf</tt>
 object.
<dt><br>See Also:
<dd><tt> strstreambuf::freeze</tt>
</dl>
<h2 id="strstreambuf__strstreambufLR"> strstreambuf() &#91;strstreambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>strstreambuf::strstreambuf();</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> strstreambuf</tt> constructor creates an empty<tt> strstreambuf</tt> object that uses dynamic
 allocation.&nbsp; No<b> reserve area</b> is allocated to start.&nbsp; Whenever characters are written to extend the<tt> strstreambuf</tt>
 object, the<b> reserve area</b> is reallocated and copied as required.&nbsp; The size of allocation is determined by the<tt>
 strstreambuf</tt> object unless the<tt> setbuf</tt> or<tt> alloc_size_increment</tt> member functions are called to change
 the allocation size.&nbsp; The default allocation size is determined by the constant<tt> DEFAULT_MAINBUF_SIZE</tt>, which
 is 512.
<dt><br>Results:
<dd>This form of the public<tt> strstreambuf</tt> constructor creates a<tt> strstreambuf</tt> object.
<dt><br>See Also:
<dd><tt> strstreambuf::doallocate</tt>,<tt> ~strstreambuf</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>strstreambuf::strstreambuf( int alloc_size );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> strstreambuf</tt> constructor creates an empty<tt> strstreambuf</tt> object that uses dynamic
 allocation.&nbsp; No buffer is allocated to start.&nbsp; Whenever characters are written to extend the<tt> strstreambuf</tt>
 object, the<b> reserve area</b> is reallocated and copied as required.&nbsp; The size of the first allocation is determined
 by the<b> alloc_size</b> parameter, unless changed by a call to the<tt> setbuf</tt> or<tt> alloc_size_increment</tt> member
 functions.
<br>Note that the<b> alloc_size</b> parameter is the starting<b> reserve area</b> size.&nbsp; When the<b> reserve area</b>
 is reallocated, the<tt> strstreambuf</tt> object uses<tt> DEFAULT_MAINBUF_SIZE</tt> to increase the<b> reserve area</b> size,
 unless the<tt> setbuf</tt> or<tt> alloc_size_increment</tt> member functions have been called to specify a new allocation
 size.
<dt><br>Results:
<dd>This form of the public<tt> strstreambuf</tt> constructor creates a<tt> strstreambuf</tt> object.
<dt><br>See Also:
<dd><tt> strstreambuf::alloc_size_increment</tt>,<tt> doallocate</tt>,<tt> setbuf</tt>,<tt> ~strstreambuf</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>strstreambuf::strstreambuf( void * (*alloc_fn)( long ),</tt>
<br><tt> void (*free_fn)( void * ) );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> strstreambuf</tt> constructor creates an empty<tt> strstreambuf</tt> object that uses dynamic
 allocation.&nbsp; No buffer is allocated to start.&nbsp; Whenever characters are written to extend the<tt> strstreambuf</tt>
 object, the<b> reserve area</b> is reallocated and copied as required, using the specified<b> alloc_fn</b> and<b> free_fn</b>
 functions.&nbsp; The size of allocation is determined by the class unless the<tt> setbuf</tt> or<tt> alloc_size_increment</tt>
 member functions are called to change the allocation size.&nbsp; The default allocation size is determined by the constant<tt>
 DEFAULT_MAINBUF_SIZE</tt>, which is 512.
<br>When a new<b> reserve area</b> is allocated, the function specified by the<b> alloc_fn</b> parameter is called with a<tt>
 long integer</tt> value indicating the number of bytes to allocate.&nbsp; If<b> alloc_fn</b> is<tt> NULL</tt>, the<tt> operator
 new</tt> intrinsic function is used.&nbsp; Likewise, when the<b> reserve area</b> is freed, the function specified by the<b>
 free_fn</b> parameter is called with the pointer returned by the<b> alloc_fn</b> function as the parameter.&nbsp; If<b> free_fn</b>
 is<tt> NULL</tt>, the<tt> operator delete</tt> intrinsic function is used.
<dt><br>Results:
<dd>This form of the public<tt> strstreambuf</tt> constructor creates a<tt> strstreambuf</tt> object.
<dt><br>See Also:
<dd><tt> strstreambuf::alloc_size_increment</tt>,<tt> doallocate</tt>,<tt> setbuf</tt>,<tt> ~strstreambuf</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>strstreambuf::strstreambuf( char *str,</tt>
<br><tt> int len,</tt>
<br><tt>char *pstart = NULL );</tt>
<br><tt>strstreambuf::strstreambuf( signed char *str,</tt>
<br><tt> int len,</tt>
<br><tt>signed char *pstart = NULL );</tt>
<br><tt>strstreambuf::strstreambuf( unsigned char *str,</tt>
<br><tt> int len,</tt>
<br><tt>unsigned char *pstart = NULL );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> strstreambuf</tt> constructor creates a<tt> strstreambuf</tt> object that does not use dynamic
 allocation (unless<b> str</b> is<tt> NULL</tt>).&nbsp; The<tt> strstreambuf</tt> object is said to be using static allocation.
&nbsp; The<b> str</b> and<b> len</b> parameters specify the bounds of the<b> reserve area</b>.
<br>The<b> str</b>,<b> len</b> and<b> pstart</b> parameters are interpreted as follows:
<ol>
<li>The buffer starts at<b> str</b>.
<li>If<b> len</b> is positive, the buffer is<b> len</b> characters long.
<li>If<b> len</b> is zero,<b> str</b> is a pointer to a C string which is terminated by a null character, and the length of
 the buffer is the length of the string.
<li>If<b> len</b> is negative, the buffer is unbounded.&nbsp; This last form should be used with extreme caution, since no
 buffer is truly unlimited in size and it would be easy to write beyond the available space.
<li>If the<b> pstart</b> parameter is<tt> NULL</tt>, the<tt> strstreambuf</tt> object is read-only.
<li>Otherwise,<b> pstart</b> divides the buffer into two regions.&nbsp; The<b> get area</b> starts at<b> str</b> and ends
 at<b> pstart</b>-1.&nbsp; The<b> put area</b> starts at<b> pstart</b> and goes to the end of the buffer.
</ol>
<br>If the<b> get area</b> is exhausted and characters have been written to the<b> put area</b>, the<b> get area</b> is extended
 to include the<b> put area</b>.
<br><br>The<b> get pointer</b> and<b> put pointer</b> do not necessarily point at the same position in the<b> reserve area</b>,
 so a read followed by a write does not imply that the write stores following the last character read.&nbsp; The<b> get pointer</b>
 is positioned following the last read operation, and the<b> put pointer</b> is positioned following the last write operation,
 unless the<tt> seekoff</tt> member function has been used to reposition the pointer(s).
<br><br>Note that if<b> str</b> is<tt> NULL</tt> the effect is to create an empty dynamic<tt> strstreambuf</tt> object.
<dt><br>Results:
<dd>This form of the public<tt> strstreambuf</tt> constructor creates a<tt> strstreambuf</tt> object.
<dt><br>See Also:
<dd><tt> ~strstreambuf</tt>
</dl>
<h2 id="strstreambuf____strstreambufLR"> ~strstreambuf() &#91;strstreambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>strstreambuf::~strstreambuf();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~strstreambuf</tt> destructor destroys the<tt> strstreambuf</tt> object after discarding the<b> reserve area</b>.
&nbsp; The<b> reserve area</b> is discarded only if the<tt> strstreambuf</tt> object is using dynamic allocation and is not
 frozen.&nbsp; The<b> reserve area</b> is freed using the free function specified by the form of the constructor that allows
 specification of the allocate and free functions, or using the<tt> operator delete</tt> intrinsic function.&nbsp; If the<tt>
 strstreambuf</tt> object is frozen or using static allocation, the user of the<tt> strstreambuf</tt> object must have a pointer
 to the<b> reserve area</b> and is responsible for freeing it.&nbsp; The call to the public<tt> ~strstreambuf</tt> destructor
 is inserted implicitly by the compiler at the point where the<tt> strstreambuf</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> strstreambuf</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> strstreambuf</tt>
</dl>
<h2 id="strstreambuf__syncLR"> sync() &#91;strstreambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int strstreambuf::sync();</tt>
<dt><br>Semantics:
<dd>The<tt> sync</tt> public virtual member function does nothing because there is no external device with which to synchronize.
<dt><br>Results:
<dd>The<tt> sync</tt> public virtual member function returns<tt> __NOT_EOF</tt>.
</dl>
<h2 id="strstreambuf__underflowLR"> underflow() &#91;strstreambuf&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;strstrea.h&gt;</tt>
<br><tt>public:</tt>
<br><tt>virtual int strstreambuf::underflow();</tt>
<dt><br>Semantics:
<dd>The<tt> underflow</tt> public virtual member function provides the input communication between the<tt> streambuf</tt> member
 functions and the<tt> strstreambuf</tt> object.&nbsp; Member functions in the<tt> streambuf</tt> class call the<tt> underflow</tt>
 public virtual member function when the<b> get area</b> is empty.
<br>If there is a non-empty<b> put area</b> present following the<b> get area</b>, the<b> get area</b> is extended to include
 the<b> put area</b>, allowing the input operation to continue using the<b> put area</b>.&nbsp; Otherwise the<b> get area</b>
 cannot be extended.
<dt><br>Results:
<dd>The<tt> underflow</tt> public virtual member function returns the first available character in the<b> get area</b> on successful
 extension, otherwise<tt> EOF</tt> is returned.
<dt><br>See Also:
<dd><tt> streambuf::underflow</tt>
<br><tt>strstreambuf::overflow</tt>
</dl>
<h1 id="String_Class"> String Class </h1>
<br>This class is used to store arbitrarily long sequences of characters in memory.&nbsp; Objects of this type may be concatenated,
 substringed, compared and searched without the need for memory management by the user.&nbsp; Unlike a C string, this object
 has no delimiting character, so any character in the collating sequence, or character set, may be stored in an object.
<br><br>The class documented here is the Open Watcom legacy string class.&nbsp; It is not related to the<tt> std::basic_string</tt>
 class template nor to its corresponding specialization<tt> std::string.</tt>
<h2 id="String_Class_Description"> String Class Description </h2>
<dl>
<dt>Declared:
<dd><tt> string.hpp</tt>
<br>The<tt> String</tt> class is used to store arbitrarily long sequences of characters in memory.&nbsp; Objects of this type
 may be concatenated, substringed, compared and searched without the need for memory management by the user.&nbsp; Unlike
 a C string, a<tt> String</tt> object has no delimiting character, so any character in the collating sequence, or character
 set, may be stored in a<tt> String</tt> object.
<br><br><b>Public Functions</b>
<br><br>The following constructors and destructors are declared:
<br><br><tt>String();</tt>
<br><tt> String( size_t, capacity );</tt>
<br><tt> String( String const &amp;, size_t = 0, size_t = NPOS );</tt>
<br><tt> String( char const *, size_t = NPOS );</tt>
<br><tt> String( char, size_t = 1 );</tt>
<br><tt> ~String();</tt>
<br><br>The following member functions are declared:
<br><br><tt>operator char const *();</tt>
<br><tt> operator char() const;</tt>
<br><tt> String &amp;operator =( String const &amp; );</tt>
<br><tt> String &amp;operator =( char const * );</tt>
<br><tt> String &amp;operator +=( String const &amp; );</tt>
<br><tt> String &amp;operator +=( char const * );</tt>
<br><tt> String operator ()( size_t, size_t ) const;</tt>
<br><tt> char &amp;operator ()( size_t );</tt>
<br><tt> char const &amp;operator &#91;&#93;( size_t ) const;</tt>
<br><tt> char &amp;operator &#91;&#93;( size_t );</tt>
<br><tt> int operator !() const;</tt>
<br><tt> size_t length() const;</tt>
<br><tt> char const &amp;get_at( size_t ) const;</tt>
<br><tt> void put_at( size_t, char );</tt>
<br><tt> int match( String const &amp; ) const;</tt>
<br><tt> int match( char const * ) const;</tt>
<br><tt> int index( String const &amp;, size_t = 0 ) const;</tt>
<br><tt> int index( char const *, size_t = 0 ) const;</tt>
<br><tt> String upper() const;</tt>
<br><tt> String lower() const;</tt>
<br><tt> int valid() const;</tt>
<br><tt> int alloc_mult_size() const;</tt>
<br><tt> int alloc_mult_size( int );</tt>
<br><br>The following friend functions are declared:
<br><br><tt>friend int&nbsp;&nbsp;&nbsp; operator ==( String const &amp;, String const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator ==( String const &amp;,&nbsp;&nbsp; char const * );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator ==(&nbsp;&nbsp; char const *, String const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator ==( String const &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator ==(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String const
 &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator !=( String const &amp;, String const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator !=( String const &amp;,&nbsp;&nbsp; char const * );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator !=(&nbsp;&nbsp; char const *, String const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator !=( String const &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator !=(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String const
 &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &lt;( String const &amp;, String const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &lt;( String const &amp;,&nbsp;&nbsp; char const * );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &lt;(&nbsp;&nbsp; char const *, String const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &lt;( String const &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &lt;(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String
 const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator &lt;=( String const &amp;, String const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator &lt;=( String const &amp;,&nbsp;&nbsp; char const * );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator &lt;=(&nbsp;&nbsp; char const *, String const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator &lt;=( String const &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator &lt;=(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String const
 &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &gt;( String const &amp;, String const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &gt;( String const &amp;,&nbsp;&nbsp; char const * );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &gt;(&nbsp;&nbsp; char const *, String const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &gt;( String const &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator&nbsp; &gt;(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String
 const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator &gt;=( String const &amp;, String const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator &gt;=( String const &amp;,&nbsp;&nbsp; char const * );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator &gt;=(&nbsp;&nbsp; char const *, String const &amp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator &gt;=( String const &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; );</tt>
<br><tt>friend int&nbsp;&nbsp;&nbsp; operator &gt;=(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String const
 &amp; );</tt>
<br><tt>friend String operator&nbsp; +(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String &amp;, String const &amp; );</tt>
<br><tt>friend String operator&nbsp; +(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String &amp;,&nbsp;&nbsp; char const * );</tt>
<br><tt>friend String operator&nbsp; +(&nbsp;&nbsp; char const *, String const &amp; );</tt>
<br><tt>friend String operator&nbsp; +(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String &amp;,&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</tt>
<br><tt>friend String operator&nbsp; +(&nbsp;&nbsp; char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , String const &amp; );</tt>
<br><tt>friend int valid( String const &amp; );</tt>
<br><br>The following I/O Stream inserter and extractor functions are declared:
<br><br><tt>friend istream &amp;operator &gt;&gt;( istream &amp;, String &amp; );</tt>
<br><tt>friend ostream &amp;operator &lt;&lt;( ostream &amp;, String const &amp; );</tt>
</dl>
<h2 id="String__alloc_mult_sizeLR"> alloc_mult_size() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>int String::alloc_mult_size() const;</tt>
<br><tt> int String::alloc_mult_size( int mult );</tt>
<dt><br>Semantics:
<dd>The<tt> alloc_mult_size</tt> public member function is used to query and/or change the allocation multiple size.
<br>The first form of the<tt> alloc_mult_size</tt> public member function queries the current setting.
<br><br>The second form of the<tt> alloc_mult_size</tt> public member function sets the value to a multiple of 8 based on
 the<b> mult</b> parameter.&nbsp; The value of<b> mult</b> is rounded down to a multiple of 8 characters.&nbsp; If<b> mult</b>
 is less than 8, the new multiple size is 1 and allocation sizes are exact.
<br><br>The scheme used to store a<tt> String</tt> object allocates the memory for the characters in multiples of some size.
&nbsp; By default, this size is 8 characters.&nbsp; A<tt> String</tt> object with a length of 10 actually has 16 characters
 of storage allocated for it.&nbsp; Concatenating more characters on the end of the<tt> String</tt> object only allocates
 a new storage block if more than 6 (16-10) characters are appended.&nbsp; This scheme tries to find a balance between reallocating
 frequently (multiples of a small value) and creating a large amount of unused space (multiples of a large value).
<dt><br>Results:
<dd>The<tt> alloc_mult_size</tt> public member function returns the previous allocation multiple size.
</dl>
<h2 id="String__get_atLR"> get_at() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>char const &amp;String::get_at( size_t pos );</tt>
<dt><br>Semantics:
<dd>The<tt> get_at</tt> public member function creates a const reference to the character at offset<b> pos</b> within the<tt>
 String</tt> object.&nbsp; This reference may not be used to modify that character.&nbsp; The first character of a<tt> String</tt>
 object is at position zero.
<br>If<b> pos</b> is greater than or equal to the length of the<tt> String</tt> object, and the resulting reference is used,
 the behavior is undefined.
<br><br>The reference is associated with the<tt> String</tt> object, and therefore has meaning only as long as the<tt> String</tt>
 object is not modified (or destroyed).&nbsp; If the<tt> String</tt> object has been modified and an old reference is used,
 the behavior is undefined.
<dt><br>Results:
<dd>The<tt> get_at</tt> public member function returns a const reference to a character.
<dt><br>See Also:
<dd><tt> String::put_at</tt>,<tt> operator &#91;&#93;</tt>,<tt> operator ()</tt>
</dl>
<h2 id="String__indexLR"> index() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>int String::index( String const &amp;str, size_t pos = 0 ) const;</tt>
<br><tt> int String::index( char const *pch, size_t pos = 0 ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> index</tt> public member function computes the offset at which a sequence of characters in the<tt> String</tt> object
 is found.
<br>The first form searches the<tt> String</tt> object for the contents of the<b> str</b><tt> String</tt> object.
<br><br>The second form searches the<tt> String</tt> object for the sequence of characters pointed at by<b> pch</b>.
<br><br>If<b> pos</b> is specified, the search begins at that offset from the start of the<tt> String</tt> object.&nbsp; Otherwise,
 the search begins at offset zero (the first character).
<br><br>The<tt> index</tt> public member function treats upper and lower case letters as not equal.
<dt><br>Results:
<dd>The<tt> index</tt> public member function returns the offset at which the sequence of characters is found.&nbsp; If the substring
 is not found, -1 is returned.
<dt><br>See Also:
<dd><tt> String::lower</tt>,<tt> operator !=</tt>,<tt> operator ==</tt>,<tt> match</tt>,<tt> upper</tt>
</dl>
<h2 id="String__lengthLR"> length() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>size_t String::length() const;</tt>
<dt><br>Semantics:
<dd>The<tt> length</tt> public member function computes the number of characters contained in the<tt> String</tt> object.
<dt><br>Results:
<dd>The<tt> length</tt> public member function returns the number of characters contained in the<tt> String</tt> object.
</dl>
<h2 id="String__lowerLR"> lower() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>String String::lower() const;</tt>
<dt><br>Semantics:
<dd>The<tt> lower</tt> public member function creates a<tt> String</tt> object whose value is the same as the original object's
 value, except that all upper-case letters have been converted to lower-case.
<dt><br>Results:
<dd>The<tt> lower</tt> public member function returns a lower-case<tt> String</tt> object.
<dt><br>See Also:
<dd><tt> String::upper</tt>
</dl>
<h2 id="String__matchLR"> match() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>int String::match( String const &amp;str ) const;</tt>
<br><tt> int String::match( char const *pch ) const;</tt>
<dt><br>Semantics:
<dd>The<tt> match</tt> public member function compares two character sequences to find the offset where they differ.
<br>The first form compares the<tt> String</tt> object to the<b> str</b><tt> String</tt> object.
<br><br>The second form compares the<tt> String</tt> object to the<b> pch</b> C string.
<br><br>The first character is at offset zero.&nbsp; The<tt> match</tt> public member function treats upper and lower case
 letters as not equal.
<dt><br>Results:
<dd>The<tt> match</tt> public member function returns the offset at which the two character sequences differ.&nbsp; If the character
 sequences are equal, -1 is returned.
<dt><br>See Also:
<dd><tt> String::index</tt>,<tt> lower</tt>,<tt> operator !=</tt>,<tt> operator ==</tt>,<tt> upper</tt>
</dl>
<h2 id="String__operator__LR"> operator !() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>int String::operator !() const;</tt>
<dt><br>Semantics:
<dd>The<tt> operator !</tt>&nbsp; public member function tests the validity of the<tt> String</tt> object.
<dt><br>Results:
<dd>The<tt> operator !</tt>&nbsp; public member function returns a non-zero value if the<tt> String</tt> object is invalid, otherwise
 zero is returned.
<dt><br>See Also:
<dd><tt> String::valid</tt>,<tt> valid</tt>
</dl>
<h2 id="String_operator__ELR"> String operator !=() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>friend int operator !=( String const &amp;lft, String const &amp;rht );</tt>
<br><tt>friend int operator !=( String const &amp;lft, char const *rht );</tt>
<br><tt>friend int operator !=( char const *lft, String const &amp;rht );</tt>
<br><tt>friend int operator !=( String const &amp;lft, char rht );</tt>
<br><tt>friend int operator !=( char lft, String const &amp;rht );</tt>
<dt><br>Semantics:
<dd>The<tt> operator !=</tt> function compares two sequences of characters in terms of an<b> inequality</b> relationship.
<br>A<tt> String</tt> object is different from another<tt> String</tt> object if the lengths are different or they contain
 different sequences of characters.&nbsp; A<tt> String</tt> object and a C string are different if their lengths are different
 or they contain a different sequence of characters.&nbsp; A C string is terminated by a null character.&nbsp; A<tt> String</tt>
 object and a character are different if the<tt> String</tt> object does not contain only the character.&nbsp; Upper-case
 and lower-case characters are considered different.
<dt><br>Results:
<dd>The<tt> operator !=</tt> function returns a non-zero value if the lengths or sequences of characters in the<b> lft</b> and<b>
 rht</b> parameter are different, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> String::operator ==</tt>,<tt> operator &lt;</tt>,<tt> operator &lt;=</tt>,<tt> operator &gt;</tt>,<tt> operator &gt;=</tt>
</dl>
<h2 id="String__operator_LRLR"> operator ()() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>char &amp;String::operator ()( size_t pos );</tt>
<dt><br>Semantics:
<dd>The<tt> operator ()</tt> public member function creates a reference to the character at offset<b> pos</b> within the<tt> String</tt>
 object.&nbsp; This reference may be used to modify that character.&nbsp; The first character of a<tt> String</tt> object
 is at position zero.
<br>If<b> pos</b> is greater than or equal to the length of the<tt> String</tt> object, and the resulting reference is used,
 the behavior is undefined.
<br><br>If the reference is used to modify other characters within the<tt> String</tt> object, the behavior is undefined.
<br><br>The reference is associated with the<tt> String</tt> object, and therefore has meaning only as long as the<tt> String</tt>
 object is not modified (or destroyed).&nbsp; If the<tt> String</tt> object has been modified and an old reference is used,
 the behavior is undefined.
<dt><br>Results:
<dd>The<tt> operator ()</tt> public member function returns a reference to a character.
<dt><br>See Also:
<dd><tt> String::operator &#91;&#93;</tt>,<tt> operator char</tt>,<tt> operator char const *</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>String String::operator ()( size_t pos, size_t len ) const;</tt>
<dt><br>Semantics:
<dd>This form of the<tt> operator ()</tt> public member function extracts a sub-sequence of characters from the<tt> String</tt>
 object.&nbsp; A new<tt> String</tt> object is created that contains the sub-sequence of characters.&nbsp; The sub-sequence
 begins at offset<b> pos</b> within the<tt> String</tt> object and continues for<b> len</b> characters.&nbsp; The first character
 of a<tt> String</tt> object is at position zero.
<br>If<b> pos</b> is greater than or equal to the length of the<tt> String</tt> object, the result is empty.
<br><br>If<b> len</b> is such that<b> pos</b> +<b> len</b> exceeds the length of the object, the result is the sub-sequence
 of characters from the<tt> String</tt> object starting at offset<b> pos</b> and running to the end of the<tt> String</tt>
 object.
<dt><br>Results:
<dd>The<tt> operator ()</tt> public member function returns a<tt> String</tt> object.
<dt><br>See Also:
<dd><tt> String::operator &#91;&#93;</tt>,<tt> operator char</tt>,<tt> operator char const *</tt>
</dl>
<h2 id="String_operator_PLR"> String operator +() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>friend String operator +( String &amp;lft, String const &amp;rht );</tt>
<br><tt>friend String operator +( String &amp;lft, char const *rht );</tt>
<br><tt>friend String operator +( char const *lft, String const &amp;rht );</tt>
<br><tt>friend String operator +( String &amp;lft, char rht );</tt>
<br><tt>friend String operator +( char lft, String const &amp;rht );</tt>
<dt><br>Semantics:
<dd>The<tt> operator +</tt> function concatenates two sequences of characters into a new<tt> String</tt> object.&nbsp; The new<tt>
 String</tt> object contains the sequence of characters from the<b> lft</b> parameter followed by the sequence of characters
 from the<b> rht</b> parameter.
<br>A<tt> NULL</tt> pointer to a C string is treated as a pointer to an empty C string.
<dt><br>Results:
<dd>The<tt> operator +</tt> function returns a new<tt> String</tt> object that contains the characters from the<b> lft</b> parameter
 followed by the characters from the<b> rht</b> parameter.
<dt><br>See Also:
<dd><tt> String::operator +=</tt>
</dl>
<h2 id="String__operator_PELR"> operator +=() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>String &amp;String::operator +=( String const &amp;str );</tt>
<br><tt> String &amp;String::operator +=( char const *pch );</tt>
<dt><br>Semantics:
<dd>The<tt> operator +=</tt> public member function appends the contents of the parameter to the end of the<tt> String</tt> object.
<br>The first form of the<tt> operator +=</tt> public member function appends the contents of the<b> str</b><tt> String</tt>
 object to the<tt> String</tt> object.
<br><br>The second form appends the null-terminated sequence of characters stored at<b> pch</b> to the<tt> String</tt> object.
&nbsp; If the<b> pch</b> parameter is<tt> NULL</tt>, nothing is appended.
<dt><br>Results:
<dd>The<tt> operator +=</tt> public member function returns a reference to the<tt> String</tt> object that was the target of the
 assignment.
<dt><br>See Also:
<dd><tt> String::operator =</tt>
</dl>
<h2 id="String_operator_XLR"> String operator &lt;() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>friend int operator &lt;( String const &amp;lft, String const &amp;rht );</tt>
<br><tt>friend int operator &lt;( String const &amp;lft, char const *rht );</tt>
<br><tt>friend int operator &lt;( char const *lft, String const &amp;rht );</tt>
<br><tt>friend int operator &lt;( String const &amp;lft, char rht );</tt>
<br><tt>friend int operator &lt;( char lft, String const &amp;rht );</tt>
<dt><br>Semantics:
<dd>The<tt> operator &lt;</tt> function compares two sequences of characters in terms of a<b> less-than</b> relationship.
<br><b>lft</b> is less-than<b> rht</b> if<b> lft</b> if the characters of<b> lft</b> occur before the characters of<b> rht</b>
 in the collating sequence.&nbsp; Upper-case and lower-case characters are considered different.
<dt><br>Results:
<dd>The<tt> operator &lt;</tt> function returns a non-zero value if the<b> lft</b> sequence of characters is less than the<b>
 rht</b> sequence, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> String::operator !=</tt>,<tt> operator ==</tt>,<tt> operator &lt;=</tt>,<tt> operator &gt;</tt>,<tt> operator &gt;=</tt>
</dl>
<h2 id="String_operator_XXLR"> String operator &lt;&lt;() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>friend ostream &amp;operator &lt;&lt;( ostream &amp;strm, String const &amp;str );</tt>
<dt><br>Semantics:
<dd>The<tt> operator &lt;&lt;</tt> function is used to write the sequence of characters in the<b> str</b><tt> String</tt> object
 to the<b> strm</b><tt> ostream</tt> object.&nbsp; Like C strings, the value of the<b> str</b><tt> String</tt> object is written
 to<b> strm</b> without the addition of any characters.&nbsp; No special processing occurs for any characters in the<tt> String</tt>
 object that have special meaning for the<b> strm</b> object, such as carriage-returns.
<br>The underlying implementation of the<tt> operator &lt;&lt;</tt> function uses the ostream write method, which writes unformatted
 characters to the output stream.&nbsp; If formatted output is required, then the programmer should make use of the classes
 accessor methods, such as c_str(), and pass the resulting data item to the stream using the appropriate insert operator.
<dt><br>Results:
<dd>The<tt> operator &lt;&lt;</tt> function returns a reference to the<b> strm</b> parameter.
<dt><br>See Also:
<dd><tt> ostream</tt>
</dl>
<h2 id="String_operator_XELR"> String operator &lt;=() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>friend int operator &lt;=( String const &amp;lft, String const &amp;rht );</tt>
<br><tt>friend int operator &lt;=( String const &amp;lft, char const *rht );</tt>
<br><tt>friend int operator &lt;=( char const *lft, String const &amp;rht );</tt>
<br><tt>friend int operator &lt;=( String const &amp;lft, char rht );</tt>
<br><tt>friend int operator &lt;=( char lft, String const &amp;rht );</tt>
<dt><br>Semantics:
<dd>The<tt> operator &lt;=</tt> function compares two sequences of characters in terms of a<b> less-than or equal</b> relationship.
<br><b>lft</b> is less-than or equal to<b> rht</b> if the characters of<b> lft</b> are equal to or occur before the characters
 of<b> rht</b> in the collating sequence.&nbsp; Upper-case and lower-case characters are considered different.
<dt><br>Results:
<dd>The<tt> operator &lt;=</tt> function returns a non-zero value if the<b> lft</b> sequence of characters is less than or equal
 to the<b> rht</b> sequence, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> String::operator !=</tt>,<tt> operator ==</tt>,<tt> operator &lt;</tt>,<tt> operator &gt;</tt>,<tt> operator &gt;=</tt>
</dl>
<h2 id="String__operator_ELR"> operator =() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>String &amp;String::operator =( String const &amp;str );</tt>
<br><tt> String &amp;String::operator =( char const *pch );</tt>
<dt><br>Semantics:
<dd>The<tt> operator =</tt> public member function sets the contents of the<tt> String</tt> object to be the same as the parameter.
<br>The first form of the<tt> operator =</tt> public member function sets the value of the<tt> String</tt> object to be the
 same as the value of the<b> str</b><tt> String</tt> object.
<br><br>The second form sets the value of the<tt> String</tt> object to the null-terminated sequence of characters stored
 at<b> pch</b>.&nbsp; If the<b> pch</b> parameter is<tt> NULL</tt>, the<tt> String</tt> object is empty.
<dt><br>Results:
<dd>The<tt> operator =</tt> public member function returns a reference to the<tt> String</tt> object that was the target of the
 assignment.
<dt><br>See Also:
<dd><tt> String::operator +=</tt>,<tt> String</tt>
</dl>
<h2 id="String_operator_EELR"> String operator ==() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>friend int operator ==( String const &amp;lft, String const &amp;rht );</tt>
<br><tt>friend int operator ==( String const &amp;lft, char const *rht );</tt>
<br><tt>friend int operator ==( char const *lft, String const &amp;rht );</tt>
<br><tt>friend int operator ==( String const &amp;lft, char rht );</tt>
<br><tt>friend int operator ==( char lft, String const &amp;rht );</tt>
<dt><br>Semantics:
<dd>The<tt> operator ==</tt> function compares two sequences of characters in terms of an<b> equality</b> relationship.
<br>A<tt> String</tt> object is equal to another<tt> String</tt> object if they have the same length and they contain the
 same sequence of characters.&nbsp; A<tt> String</tt> object and a C string are equal if their lengths are the same and they
 contain the same sequence of characters.&nbsp; The C string is terminated by a null character.&nbsp; A<tt> String</tt> object
 and a character are equal if the<tt> String</tt> object contains only that character.&nbsp; Upper-case and lower-case characters
 are considered different.
<dt><br>Results:
<dd>The<tt> operator ==</tt> function returns a non-zero value if the lengths and sequences of characters in the<b> lft</b> and<b>
 rht</b> parameter are identical, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> String::operator !=</tt>,<tt> operator &lt;</tt>,<tt> operator &lt;=</tt>,<tt> operator &gt;</tt>,<tt> operator &gt;=</tt>
</dl>
<h2 id="String_operator_YLR"> String operator &gt;() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>friend int operator &gt;( String const &amp;lft, String const &amp;rht );</tt>
<br><tt>friend int operator &gt;( String const &amp;lft, char const *rht );</tt>
<br><tt>friend int operator &gt;( char const *lft, String const &amp;rht );</tt>
<br><tt>friend int operator &gt;( String const &amp;lft, char rht );</tt>
<br><tt>friend int operator &gt;( char lft, String const &amp;rht );</tt>
<dt><br>Semantics:
<dd>The<tt> operator &gt;</tt> function compares two sequences of characters in terms of a<b> greater-than</b> relationship.
<br><b>lft</b> is greater-than<b> rht</b> if the characters of<b> lft</b> occur after the characters of<b> rht</b> in the
 collating sequence.&nbsp; Upper-case and lower-case characters are considered different.
<dt><br>Results:
<dd>The<tt> operator &gt;</tt> function returns a non-zero value if the<b> lft</b> sequence of characters is greater than the<b>
 rht</b> sequence, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> String::operator !=</tt>,<tt> operator ==</tt>,<tt> operator &lt;</tt>,<tt> operator &lt;=</tt>,<tt> operator &gt;=</tt>
</dl>
<h2 id="String_operator_YELR"> String operator &gt;=() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>friend int operator &gt;=( String const &amp;lft, String const &amp;rht );</tt>
<br><tt>friend int operator &gt;=( String const &amp;lft, char const *rht );</tt>
<br><tt>friend int operator &gt;=( char const *lft, String const &amp;rht );</tt>
<br><tt>friend int operator &gt;=( String const &amp;lft, char rht );</tt>
<br><tt>friend int operator &gt;=( char lft, String const &amp;rht );</tt>
<dt><br>Semantics:
<dd>The<tt> operator &gt;=</tt> function compares two sequences of characters in terms of a<b> greater-than or equal</b> relationship.
<br><b>lft</b> is greater-than or equal to<b> rht</b> if the characters of<b> lft</b> are equal to or occur after the characters
 of<b> rht</b> in the collating sequence.&nbsp; Upper-case and lower-case characters are considered different.
<dt><br>Results:
<dd>The<tt> operator &gt;=</tt> function returns a non-zero value if the<b> lft</b> sequence of characters is greater than or
 equal to the<b> rht</b> sequence, otherwise zero is returned.
<dt><br>See Also:
<dd><tt> String::operator !=</tt>,<tt> operator ==</tt>,<tt> operator &lt;</tt>,<tt> operator &lt;=</tt>,<tt> operator &gt;</tt>
</dl>
<h2 id="String_operator_YYLR"> String operator &gt;&gt;() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>friend istream &amp;operator &gt;&gt;( istream &amp;strm, String &amp;str );</tt>
<dt><br>Semantics:
<dd>The<tt> operator &gt;&gt;</tt> function is used to read a sequence of characters from the<b> strm</b><tt> istream</tt> object
 into the<b> str</b><tt> String</tt> object.&nbsp; Like C strings, the gathering of characters for a<b> str</b><tt> String</tt>
 object ends at the first whitespace encountered, so that the last character placed in<b> str</b> is the character before
 the whitespace.
<dt><br>Results:
<dd>The<tt> operator &gt;&gt;</tt> function returns a reference to the<b> strm</b> parameter.
<dt><br>See Also:
<dd><tt> istream</tt>
</dl>
<h2 id="String__operator_UVLR"> operator &#91;&#93;() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>char const &amp;String::operator &#91;&#93;( size_t pos ) const;</tt>
<br><tt> char &amp;String::operator &#91;&#93;( size_t pos );</tt>
<dt><br>Semantics:
<dd>The<tt> operator &#91;&#93;</tt> public member function creates either a const or a non-const reference to the character at
 offset<b> pos</b> within the<tt> String</tt> object.&nbsp; The non-const reference may be used to modify that character.
&nbsp; The first character of a<tt> String</tt> object is at position zero.
<br>If<b> pos</b> is greater than or equal to the length of the<tt> String</tt> object, and the resulting reference is used,
 the behavior is undefined.
<br><br>If the non-const reference is used to modify other characters within the<tt> String</tt> object, the behavior is undefined.
<br><br>The reference is associated with the<tt> String</tt> object, and therefore has meaning only as long as the<tt> String</tt>
 object is not modified (or destroyed).&nbsp; If the<tt> String</tt> object has been modified and an old reference is used,
 the behavior is undefined.
<dt><br>Results:
<dd>The<tt> operator &#91;&#93;</tt> public member function returns either a const or a non-const reference to a character.
<dt><br>See Also:
<dd><tt> String::operator ()</tt>,<tt> operator char</tt>,<tt> operator char const *</tt>
</dl>
<h2 id="String__operator_charLR"> operator char() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>String::operator char();</tt>
<dt><br>Semantics:
<dd>The<tt> operator char</tt> public member function converts a<tt> String</tt> object into the first character it contains.
&nbsp; If the<tt> String</tt> object is empty, the result is the null character.
<dt><br>Results:
<dd>The<tt> operator char</tt> public member function returns the first character contained in the<tt> String</tt> object.&nbsp;
 If the<tt> String</tt> object is empty, the null character is returned.
<dt><br>See Also:
<dd><tt> String::operator ()</tt>,<tt> operator &#91;&#93;</tt>,<tt> operator char const *</tt>
</dl>
<h2 id="String__operator_char_const_TLR"> operator char const *() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>String::operator char const *();</tt>
<dt><br>Semantics:
<dd>The<tt> operator char const *</tt> public member function converts a<tt> String</tt> object into a C string containing the
 same length and sequence of characters, terminated by a null character.&nbsp; If the<tt> String</tt> object contains a null
 character the resulting C string is terminated by that null character.
<br>The returned pointer is associated with the<tt> String</tt> object, and therefore has meaning only as long as the<tt>
 String</tt> object is not modified.&nbsp; If the intention is to be able to refer to the C string after the<tt> String</tt>
 object has been modified, a copy of the string should be made, perhaps by using the C library<tt> strdup</tt> function.
<br><br>The returned pointer is a pointer to a constant C string.&nbsp; If the pointer is used in some way to modify the C
 string, the behavior is undefined.
<dt><br>Results:
<dd>The<tt> operator char const *</tt> public member function returns a pointer to a null-terminated constant C string that contains
 the same characters as the<tt> String</tt> object.
<dt><br>See Also:
<dd><tt> String::operator ()</tt>,<tt> operator &#91;&#93;</tt>,<tt> operator char</tt>
</dl>
<h2 id="String__put_atLR"> put_at() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>void String::put_at( size_t pos, char chr );</tt>
<dt><br>Semantics:
<dd>The<tt> put_at</tt> public member function modifies the character at offset<b> pos</b> within the<tt> String</tt> object.
&nbsp; The character at the specified offset is set to the value of<b> chr</b>.&nbsp; If<b> pos</b> is greater than the number
 of characters within the<tt> String</tt> object,<b> chr</b> is appended to the<tt> String</tt> object.
<dt><br>Results:
<dd>The<tt> put_at</tt> public member function has no return value.
<dt><br>See Also:
<dd><tt> String::get_at</tt>,<tt> operator &#91;&#93;</tt>,<tt> operator ()</tt>,<tt> operator +=</tt>,<tt> operator +</tt>
</dl>
<h2 id="String__StringLR"> String() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>String::String();</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> String</tt> constructor creates a default<tt> String</tt> object containing no characters.&nbsp;
 The created<tt> String</tt> object has length zero.
<dt><br>Results:
<dd>This form of the public<tt> String</tt> constructor produces a<tt> String</tt> object.
<dt><br>See Also:
<dd><tt> String::operator =</tt>,<tt> operator +=</tt>,<tt> ~String</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>String::String( size_t size, String::capacity cap );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> String</tt> constructor creates a<tt> String</tt> object.&nbsp; The function constructs a<tt>
 String</tt> object of length<b> size</b> if<b> cap</b> is equal to the enumerated<b> default_size</b>.&nbsp; The function
 reserves<b> size</b> bytes of memory and sets the length of the<tt> String</tt> object to be zero if<b> cap</b> is equal
 to the enumerated<b> reserve</b>.
<dt><br>Results:
<dd>This form of the public<tt> String</tt> constructor produces a<tt> String</tt> object of size<b> size</b>.
<dt><br>See Also:
<dd><tt> String::operator =</tt>,<tt> ~String</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>String::String( String const &amp;str, size_t pos = 0, size_t num = NPOS );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> String</tt> constructor creates a<tt> String</tt> object which contains a sub-string of the<b>
 str</b> parameter.&nbsp; The sub-string starts at position<b> pos</b> within<b> str</b> and continues for<b> num</b> characters
 or until the end of the<b> str</b> parameter, whichever comes first.
<dt><br>Results:
<dd>This form of the public<tt> String</tt> constructor produces a sub-string or duplicate of the<b> str</b> parameter.
<dt><br>See Also:
<dd><tt> String::operator =</tt>,<tt> operator ()</tt>,<tt> operator &#91;&#93;</tt>,<tt> ~String</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>String::String( char const *pch, size_t num = NPOS );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> String</tt> constructor creates a<tt> String</tt> object from a C string.&nbsp; The<tt> String</tt>
 object contains the sequence of characters located at the<b> pch</b> parameter.&nbsp; Characters are included up to<b> num</b>
 or the end of the C string pointed at by<b> pch</b>.&nbsp; Note that C strings are terminated by a null character and that
 the value of the created<tt> String</tt> object does not contain that character, nor any following it.
<dt><br>Results:
<dd>This form of the public<tt> String</tt> constructor produces a<tt> String</tt> object of at most length<b> n</b> containing
 the characters in the C string starting at the<b> pch</b> parameter.
<dt><br>See Also:
<dd><tt> String::operator =</tt>,<tt> operator char const *</tt>,<tt> operator ()</tt>,<tt> operator &#91;&#93;</tt>,<tt> ~String</tt>
</dl>
<br><b>Member function</b>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>String::String( char ch, size_t rep = 1 );</tt>
<dt><br>Semantics:
<dd>This form of the public<tt> String</tt> constructor creates a<tt> String</tt> object containing<b> rep</b> copies of the<b>
 ch</b> parameter.
<dt><br>Results:
<dd>This form of the public<tt> String</tt> constructor produces a<tt> String</tt> object of length<b> rep</b> containing only
 the character specified by the<b> ch</b> parameter.
<dt><br>See Also:
<dd><tt> String::operator =</tt>,<tt> operator char</tt>,<tt> ~String</tt>
</dl>
<h2 id="String____StringLR"> ~String() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>String::~String();</tt>
<dt><br>Semantics:
<dd>The public<tt> ~String</tt> destructor destroys the<tt> String</tt> object.&nbsp; The call to the public<tt> ~String</tt>
 destructor is inserted implicitly by the compiler at the point where the<tt> String</tt> object goes out of scope.
<dt><br>Results:
<dd>The<tt> String</tt> object is destroyed.
<dt><br>See Also:
<dd><tt> String</tt>
</dl>
<h2 id="String__upperLR"> upper() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>String String::upper() const;</tt>
<dt><br>Semantics:
<dd>The<tt> upper</tt> public member function creates a new<tt> String</tt> object whose value is the same as the original<tt>
 String</tt> object, except that all lower-case letters have been converted to upper-case.
<dt><br>Results:
<dd>The<tt> upper</tt> public member function returns a new upper-case<tt> String</tt> object.
<dt><br>See Also:
<dd><tt> String::lower</tt>
</dl>
<h2 id="String_validLR"> String valid() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>friend int valid( String const &amp;str );</tt>
<dt><br>Semantics:
<dd>The<tt> valid</tt> function tests the validity of the<b> str</b><tt> String</tt> object.
<dt><br>Results:
<dd>The<tt> valid</tt> function returns a non-zero value if the<b> str</b><tt> String</tt> object is valid, otherwise zero is
 returned.
<dt><br>See Also:
<dd><tt> String::operator !</tt>,<tt> valid</tt>
</dl>
<h2 id="String__validLR"> valid() &#91;String&#93; </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>#include &lt;string.hpp&gt;</tt>
<br><tt>public:</tt>
<br><tt>int String::valid() const;</tt>
<dt><br>Semantics:
<dd>The<tt> valid</tt> public member function tests the validity of the<tt> String</tt> object.
<dt><br>Results:
<dd>The<tt> valid</tt> public member function returns a non-zero value if the<tt> String</tt> object is valid, otherwise zero
 is returned.
<dt><br>See Also:
<dd><tt> String::operator !</tt>,<tt> valid</tt>
</dl>
</body>
