<head>
<title> Open Watcom 1.9 FORTRAN 77 Graphics Library Reference </title>
</head>
<body>
<h1 id="Index_of_Topics"> Index of Topics </h1>
<dl>
<dt>- A -
<dd><a href="#Analyze_Routines">Analyze Routines</a>
<br><a href="#_arc">_arc, _arc_w, _arc_wxy</a>
<br><a href="#Attribute_Routines">Attribute Routines</a>
<dt><br>- C -
<dd><a href="#Classes_of_Graphics_Routines">Classes of Graphics Routines</a>
<br><a href="#_clearscreen">_clearscreen</a>
<br><a href="#Coordinate_System_Routines">Coordinate System Routines</a>
<dt><br>- D -
<dd><a href="#Display_Routines">Display Routines</a>
<br><a href="#_displaycursor">_displaycursor</a>
<br><a href="#Drawing_Routines">Drawing Routines</a>
<dt><br>- E -
<dd><a href="#_ellipse">_ellipse, _ellipse_w, _ellipse_wxy</a>
<br><a href="#Environment_Routines">Environment Routines</a>
<dt><br>- F -
<dd><a href="#_floodfill">_floodfill, _floodfill_w</a>
<br><a href="#Font_Manipulation_Routines">Font Manipulation Routines</a>
<dt><br>- G -
<dd><a href="#_getactivepage">_getactivepage</a>
<br><a href="#_getarcinfo">_getarcinfo</a>
<br><a href="#_getbkcolor">_getbkcolor</a>
<br><a href="#_getcliprgn">_getcliprgn</a>
<br><a href="#_getcolor">_getcolor</a>
<br><a href="#_getcurrentposition">_getcurrentposition, _getcurrentposition_w</a>
<br><a href="#_getfillmask">_getfillmask</a>
<br><a href="#_getfontinfo">_getfontinfo</a>
<br><a href="#_getgtextextent">_getgtextextent</a>
<br><a href="#_getgtextvector">_getgtextvector</a>
<br><a href="#_getimage">_getimage, _getimage_w, _getimage_wxy</a>
<br><a href="#_getlinestyle">_getlinestyle</a>
<br><a href="#_getphyscoord">_getphyscoord</a>
<br><a href="#_getpixel">_getpixel, _getpixel_w</a>
<br><a href="#_getplotaction">_getplotaction</a>
<br><a href="#_gettextcolor">_gettextcolor</a>
<br><a href="#_gettextcursor">_gettextcursor</a>
<br><a href="#_gettextextent">_gettextextent</a>
<br><a href="#_gettextposition">_gettextposition</a>
<br><a href="#_gettextsettings">_gettextsettings</a>
<br><a href="#_gettextwindow">_gettextwindow</a>
<br><a href="#_getvideoconfig">_getvideoconfig</a>
<br><a href="#_getviewcoord">_getviewcoord, _getviewcoord_w, _getviewcoord_wxy</a>
<br><a href="#_getvisualpage">_getvisualpage</a>
<br><a href="#_getwindowcoord">_getwindowcoord</a>
<br><a href="#Graphics_Adapters">Graphics Adapters</a>
<br><a href="#Graphics_Library">Graphics Library</a>
<br><a href="#Graphics_Library_Routines">Graphics Library Routines</a>
<br><a href="#Graphics_Routines">Graphics Routines</a>
<br><a href="#Graphics_Text_Routines">Graphics Text Routines</a>
<br><a href="#_grstatus">_grstatus</a>
<br><a href="#_grtext">_grtext, _grtext_w</a>
<dt><br>- I -
<dd><a href="#Image_Manipulation_Routines">Image Manipulation Routines</a>
<br><a href="#_imagesize">_imagesize, _imagesize_w, _imagesize_wxy</a>
<br><a href="#Include_Files">Include Files</a>
<dt><br>- L -
<dd><a href="#_lineto">_lineto, _lineto_w</a>
<dt><br>- M -
<dd><a href="#_moveto">_moveto, _moveto_w</a>
<dt><br>- O -
<dd><a href="#_outgtext">_outgtext</a>
<br><a href="#_outmem">_outmem</a>
<br><a href="#_outtext">_outtext</a>
<dt><br>- P -
<dd><a href="#_pg_analyzechart">_pg_analyzechart, _pg_analyzechartms</a>
<br><a href="#_pg_analyzepie">_pg_analyzepie</a>
<br><a href="#_pg_analyzescatter">_pg_analyzescatter, _pg_analyzescatterms</a>
<br><a href="#_pg_chart">_pg_chart, _pg_chartms</a>
<br><a href="#_pg_chartpie">_pg_chartpie</a>
<br><a href="#_pg_chartscatter">_pg_chartscatter, _pg_chartscatterms</a>
<br><a href="#_pg_defaultchart">_pg_defaultchart</a>
<br><a href="#_pg_getchardef">_pg_getchardef</a>
<br><a href="#_pg_getpalette">_pg_getpalette</a>
<br><a href="#_pg_getstyleset">_pg_getstyleset</a>
<br><a href="#_pg_hlabelchart">_pg_hlabelchart</a>
<br><a href="#_pg_initchart">_pg_initchart</a>
<br><a href="#_pg_resetpalette">_pg_resetpalette</a>
<br><a href="#_pg_resetstyleset">_pg_resetstyleset</a>
<br><a href="#_pg_setchardef">_pg_setchardef</a>
<br><a href="#_pg_setpalette">_pg_setpalette</a>
<br><a href="#_pg_setstyleset">_pg_setstyleset</a>
<br><a href="#_pg_vlabelchart">_pg_vlabelchart</a>
<br><a href="#_pie">_pie, _pie_w, _pie_wxy</a>
<br><a href="#_polygon">_polygon, _polygon_w, _polygon_wxy</a>
<br><a href="#Presentation_Graphics_Routines">Presentation Graphics Routines</a>
<br><a href="#_putimage">_putimage, _putimage_w</a>
<dt><br>- R -
<dd><a href="#_rectangle">_rectangle, _rectangle_w, _rectangle_wxy</a>
<br><a href="#_registerfonts">_registerfonts</a>
<br><a href="#_remapallpalette">_remapallpalette</a>
<br><a href="#_remappalette">_remappalette</a>
<dt><br>- S -
<dd><a href="#_scrolltextwindow">_scrolltextwindow</a>
<br><a href="#_selectpalette">_selectpalette</a>
<br><a href="#_setactivepage">_setactivepage</a>
<br><a href="#_setbkcolor">_setbkcolor</a>
<br><a href="#_setcharsize">_setcharsize, _setcharsize_w</a>
<br><a href="#_setcharspacing">_setcharspacing, _setcharspacing_w</a>
<br><a href="#_setcliprgn">_setcliprgn</a>
<br><a href="#_setcolor">_setcolor</a>
<br><a href="#_setfillmask">_setfillmask</a>
<br><a href="#_setfont">_setfont</a>
<br><a href="#_setgtextvector">_setgtextvector</a>
<br><a href="#_setlinestyle">_setlinestyle</a>
<br><a href="#_setpixel">_setpixel, _setpixel_w</a>
<br><a href="#_setplotaction">_setplotaction</a>
<br><a href="#_settextalign">_settextalign</a>
<br><a href="#_settextcolor">_settextcolor</a>
<br><a href="#_settextcursor">_settextcursor</a>
<br><a href="#_settextorient">_settextorient</a>
<br><a href="#_settextpath">_settextpath</a>
<br><a href="#_settextposition">_settextposition</a>
<br><a href="#_settextrows">_settextrows</a>
<br><a href="#_settextwindow">_settextwindow</a>
<br><a href="#_setvideomode">_setvideomode</a>
<br><a href="#_setvideomoderows">_setvideomoderows</a>
<br><a href="#_setvieworg">_setvieworg</a>
<br><a href="#_setviewport">_setviewport</a>
<br><a href="#_setvisualpage">_setvisualpage</a>
<br><a href="#_setwindow">_setwindow</a>
<dt><br>- T -
<dd><a href="#Text_Routines">Text Routines</a>
<dt><br>- U -
<dd><a href="#_unregisterfonts">_unregisterfonts</a>
<br><a href="#Utility_Routines">Utility Routines</a>
<dt><br>- W -
<dd><a href="#_wrapon">_wrapon</a>
</dl>
<h1 id="Graphics_Library"> Graphics Library </h1>
<br>The &amp;company FORTRAN 77 Graphics Library consists of a large number of routines that provide graphical image support
 under DOS and QNX.&nbsp; This chapter provides an overview of this support.&nbsp; The following topics are discussed.
<ul>
<li>Graphics Routines
<li>Graphics Adapters
<li>Classes of Graphics Routines
<ol>
<li>Environment Routines
<li>Coordinate System Routines
<li>Attribute Routines
<li>Drawing Routines
<li>Text Routines
<li>Graphics Text Routines
<li>Image Manipulation Routines
<li>Font Manipulation Routines
<li>Presentation Graphics Routines
<br><br>&nbsp;&nbsp;&nbsp;&nbsp; Display Routines
<br>&nbsp;&nbsp;&nbsp;&nbsp; Analyze Routines
<br>&nbsp;&nbsp;&nbsp;&nbsp; Utility Routines
</ol>
<li>Include Files
</ul>
<h2 id="Graphics_Routines"> Graphics Routines </h2>
<br>Graphics routines are used to display graphical images such as lines and circles upon the computer screen.&nbsp; Routines
 are also provided for displaying text along with the graphics output.
<h2 id="Graphics_Adapters"> Graphics Adapters </h2>
<br>Support is provided for both color and monochrome screens which are connected to the computer using any of the following
 graphics adapters:
<ul>
<li>IBM Monochrome Display/Printer Adapter (MDPA)
<li>IBM Color Graphics Adapter (CGA)
<li>IBM Enhanced Graphics Adapter (EGA)
<li>IBM Multi-Color Graphics Array (MCGA)
<li>IBM Video Graphics Array (VGA)
<li>Hercules Monochrome Adapter
<li>SuperVGA adapters (SVGA) supplied by various manufacturers
</ul>
<h2 id="Classes_of_Graphics_Routines"> Classes of Graphics Routines </h2>
<br>The routines in the &amp;company FORTRAN 77 Graphics Library can be organized into a number of classes:
<dl>
<dt>Environment Routines
<dd>
<br>These routines deal with the hardware environment.
<dt><br>Coordinate System Routines
<dd>
<br>These routines deal with coordinate systems and mapping coordinates from one system to another.
<dt><br>Attribute Routines
<dd>
<br>These routines control the display of graphical images.
<dt><br>Drawing Routines
<dd>
<br>These routines display graphical images such as lines and ellipses.
<dt><br>Text Routines
<dd>
<br>These routines deal with displaying text in both graphics and text modes.
<dt><br>Graphics Text Routines
<dd>
<br>These routines deal with displaying graphics text.
<dt><br>Image Manipulation Routines
<dd>
<br>These routines store and retrieve screen images.
<dt><br>Font Manipulation Routines
<dd>
<br>These routines deal with displaying font based text.
<dt><br>Presentation Graphics Routines
<dd>
<br>These routines deal with displaying presentation graphics elements such as bar charts and pie charts.
</dl>
<br>The following subsections describe these routine classes in more detail.&nbsp; Each routine in the class is noted with
 a brief description of its purpose.
<h3 id="Environment_Routines"> Environment Routines </h3>
<br>These routines deal with the hardware environment.&nbsp; The <tt> _getvideoconfig</tt> routine returns information about
 the current video mode and the hardware configuration.&nbsp; The <tt> _setvideomode</tt> routine selects a new video mode.
<br><br>Some video modes support multiple pages of screen memory.&nbsp; The visual page (the one displayed on the screen)
 may be different than the active page (the one to which objects are being written).
<br><br>The following routines are defined:
<dl>
<dt><a href="#_getactivepage">_getactivepage</a>
<dd>get the number of the current active graphics page
<dt><br><a href="#_getvideoconfig">_getvideoconfig</a>
<dd>get information about the graphics configuration
<dt><br><a href="#_getvisualpage">_getvisualpage</a>
<dd>get the number of the current visual graphics page
<dt><br><a href="#_grstatus">_grstatus</a>
<dd>get the status of the most recently called graphics library routine
<dt><br><a href="#_setactivepage">_setactivepage</a>
<dd>set the active graphics page (the page to which graphics objects are drawn)
<dt><br><a href="#_settextrows">_settextrows</a>
<dd>set the number of rows of text displayed on the screen
<dt><br><a href="#_setvideomode">_setvideomode</a>
<dd>select the video mode to be used
<dt><br><a href="#_setvideomoderows">_setvideomoderows</a>
<dd>select the video mode and the number of text rows to be used
<dt><br><a href="#_setvisualpage">_setvisualpage</a>
<dd>set the visual graphics page (the page displayed on the screen)
</dl>
<h3 id="Coordinate_System_Routines"> Coordinate System Routines </h3>
<br>These routines deal with coordinate systems and mapping coordinates from one system to another.&nbsp; The &amp;company
 FORTRAN 77 Graphics Library supports three coordinate systems:&nbsp; 
<ol>
<li>Physical coordinates
<li>View coordinates
<li>Window coordinates
</ol>
<br>Physical coordinates match the physical dimensions of the screen.&nbsp; The physical origin, denoted (0,0), is located
 at the top left corner of the screen.&nbsp; A pixel to the right of the origin has a positive x-coordinate and a pixel below
 the origin will have a positive y-coordinate.&nbsp; The x- and y-coordinates will never be negative values.
<br><br>The view coordinate system can be defined upon the physical coordinate system by moving the origin from the top left
 corner of the screen to any physical coordinate (see the <tt> _setvieworg</tt> routine).&nbsp; In the view coordinate system,
 negative x- and y-coordinates are allowed.&nbsp; The scale of the view and physical coordinate systems is identical (both
 are in terms of pixels).
<br><br>The window coordinate system is defined in terms of a range of user-specified values (see the <tt> _setwindow</tt>
 routine).&nbsp; These values are scaled to map onto the physical coordinates of the screen.&nbsp; This allows for consistent
 pictures regardless of the resolution (number of pixels) of the screen.
<br><br>The following routines are defined:
<dl>
<dt><a href="#_getcliprgn">_getcliprgn</a>
<dd>get the boundary of the current clipping region
<dt><br><a href="#_getphyscoord">_getphyscoord</a>
<dd>get the physical coordinates of a point in view coordinates
<dt><br><a href="#_getviewcoord">_getviewcoord</a>
<dd>get the view coordinates of a point in physical coordinates
<dt><br>_getviewcoord_w (see <a href="#_getviewcoord">_getviewcoord</a>)
<dd>get the view coordinates of a point in window coordinates
<dt><br>_getviewcoord_wxy (see <a href="#_getviewcoord">_getviewcoord</a>)
<dd>get the view coordinates of a point in window coordinates
<dt><br><a href="#_getwindowcoord">_getwindowcoord</a>
<dd>get the window coordinates of a point in view coordinates
<dt><br><a href="#_setcliprgn">_setcliprgn</a>
<dd>set the boundary of the clipping region
<dt><br><a href="#_setvieworg">_setvieworg</a>
<dd>set the position to be used as the origin of the view coordinate system
<dt><br><a href="#_setviewport">_setviewport</a>
<dd>set the boundary of the clipping region and the origin of the view coordinate system
<dt><br><a href="#_setwindow">_setwindow</a>
<dd>define the boundary of the window coordinate system
</dl>
<h3 id="Attribute_Routines"> Attribute Routines </h3>
<br>These routines control the display of graphical images such as lines and circles.&nbsp; Lines and figures are drawn using
 the current color (see the <tt> _setcolor</tt> routine), the current line style (see the <tt> _setlinestyle</tt> routine),
 the current fill mask (see the <tt> _setfillmask</tt> routine), and the current plotting action (see the <tt> _setplotaction</tt>
 routine).
<br><br>The following routines are defined:
<dl>
<dt><a href="#_getarcinfo">_getarcinfo</a>
<dd>get the endpoints of the most recently drawn arc
<dt><br><a href="#_getbkcolor">_getbkcolor</a>
<dd>get the background color
<dt><br><a href="#_getcolor">_getcolor</a>
<dd>get the current color
<dt><br><a href="#_getfillmask">_getfillmask</a>
<dd>get the current fill mask
<dt><br><a href="#_getlinestyle">_getlinestyle</a>
<dd>get the current line style
<dt><br><a href="#_getplotaction">_getplotaction</a>
<dd>get the current plotting action
<dt><br><a href="#_remapallpalette">_remapallpalette</a>
<dd>assign colors for all pixel values
<dt><br><a href="#_remappalette">_remappalette</a>
<dd>assign color for one pixel value
<dt><br><a href="#_selectpalette">_selectpalette</a>
<dd>select a palette
<dt><br><a href="#_setbkcolor">_setbkcolor</a>
<dd>set the background color
<dt><br><a href="#_setcolor">_setcolor</a>
<dd>set the current color
<dt><br><a href="#_setfillmask">_setfillmask</a>
<dd>set the current fill mask
<dt><br><a href="#_setlinestyle">_setlinestyle</a>
<dd>set the current line style
<dt><br><a href="#_setplotaction">_setplotaction</a>
<dd>set the current plotting action
</dl>
<h3 id="Drawing_Routines"> Drawing Routines </h3>
<br>These routines display graphical images such as lines and ellipses.&nbsp; Routines exist to draw straight lines (see the
 <tt> _lineto</tt> routines), rectangles (see the <tt> _rectangle</tt> routines), polygons (see the <tt> _polygon</tt> routines),
 ellipses (see the <tt> _ellipse</tt> routines), elliptical arcs (see the <tt> _arc</tt> routines) and pie-shaped wedges from
 ellipses (see the <tt> _pie</tt> routines).
<br><br>These figures are drawn using the attributes described in the previous section.&nbsp; The routines ending with<tt>
 _w</tt> or<tt> _wxy</tt> use the window coordinate system; the others use the view coordinate system.
<br><br>The following routines are defined:
<dl>
<dt><a href="#_arc">_arc</a>
<dd>draw an arc
<dt><br>_arc_w (see <a href="#_arc">_arc</a>)
<dd>draw an arc using window coordinates
<dt><br>_arc_wxy (see <a href="#_arc">_arc</a>)
<dd>draw an arc using window coordinates
<dt><br><a href="#_clearscreen">_clearscreen</a>
<dd>clear the screen and fill with the background color
<dt><br><a href="#_ellipse">_ellipse</a>
<dd>draw an ellipse
<dt><br>_ellipse_w (see <a href="#_ellipse">_ellipse</a>)
<dd>draw an ellipse using window coordinates
<dt><br>_ellipse_wxy (see <a href="#_ellipse">_ellipse</a>)
<dd>draw an ellipse using window coordinates
<dt><br><a href="#_floodfill">_floodfill</a>
<dd>fill an area of the screen with the current color
<dt><br>_floodfill_w (see <a href="#_floodfill">_floodfill</a>)
<dd>fill an area of the screen in window coordinates with the current color
<dt><br><a href="#_getcurrentposition">_getcurrentposition</a>
<dd>get the coordinates of the current output position
<dt><br>_getcurrentposition_w (see <a href="#_getcurrentposition">_getcurrentposition</a>)
<dd>get the window coordinates of the current output position
<dt><br><a href="#_getpixel">_getpixel</a>
<dd>get the color of the pixel at the specified position
<dt><br>_getpixel_w (see <a href="#_getpixel">_getpixel</a>)
<dd>get the color of the pixel at the specified position in window coordinates
<dt><br><a href="#_lineto">_lineto</a>
<dd>draw a line from the current position to a specified position
<dt><br>_lineto_w (see <a href="#_lineto">_lineto</a>)
<dd>draw a line from the current position to a specified position in window coordinates
<dt><br><a href="#_moveto">_moveto</a>
<dd>set the current output position
<dt><br>_moveto_w (see <a href="#_moveto">_moveto</a>)
<dd>set the current output position using window coordinates
<dt><br><a href="#_pie">_pie</a>
<dd>draw a wedge of a &quot;pie&quot;
<dt><br>_pie_w (see <a href="#_pie">_pie</a>)
<dd>draw a wedge of a &quot;pie&quot; using window coordinates
<dt><br>_pie_wxy (see <a href="#_pie">_pie</a>)
<dd>draw a wedge of a &quot;pie&quot; using window coordinates
<dt><br><a href="#_polygon">_polygon</a>
<dd>draw a polygon
<dt><br>_polygon_w (see <a href="#_polygon">_polygon</a>)
<dd>draw a polygon using window coordinates
<dt><br>_polygon_wxy (see <a href="#_polygon">_polygon</a>)
<dd>draw a polygon using window coordinates
<dt><br><a href="#_rectangle">_rectangle</a>
<dd>draw a rectangle
<dt><br>_rectangle_w (see <a href="#_rectangle">_rectangle</a>)
<dd>draw a rectangle using window coordinates
<dt><br>_rectangle_wxy (see <a href="#_rectangle">_rectangle</a>)
<dd>draw a rectangle using window coordinates
<dt><br><a href="#_setpixel">_setpixel</a>
<dd>set the color of the pixel at the specified position
<dt><br>_setpixel_w (see <a href="#_setpixel">_setpixel</a>)
<dd>set the color of the pixel at the specified position in window coordinates
</dl>
<h3 id="Text_Routines"> Text Routines </h3>
<br>These routines deal with displaying text in both graphics and text modes.&nbsp; This type of text output can be displayed
 in only one size.
<br><br>This text is displayed using the <tt> _outtext</tt> and <tt> _outmem</tt> routines.&nbsp; The output position for
 text follows the last text that was displayed or can be reset (see the <tt> _settextposition</tt> routine).&nbsp; Text windows
 can be created (see the <tt> _settextwindow</tt> routine) in which the text will scroll.&nbsp; Text is displayed with the
 current text color (see the <tt> _settextcolor</tt> routine).
<br><br>The following routines are defined:
<dl>
<dt><a href="#_clearscreen">_clearscreen</a>
<dd>clear the screen and fill with the background color
<dt><br><a href="#_displaycursor">_displaycursor</a>
<dd>determine whether the cursor is to be displayed after a graphics routine completes execution
<dt><br><a href="#_getbkcolor">_getbkcolor</a>
<dd>get the background color
<dt><br><a href="#_gettextcolor">_gettextcolor</a>
<dd>get the color used to display text
<dt><br><a href="#_gettextcursor">_gettextcursor</a>
<dd>get the shape of the text cursor
<dt><br><a href="#_gettextposition">_gettextposition</a>
<dd>get the current output position for text
<dt><br><a href="#_gettextwindow">_gettextwindow</a>
<dd>get the boundary of the current text window
<dt><br><a href="#_outmem">_outmem</a>
<dd>display a text string of a specified length
<dt><br><a href="#_outtext">_outtext</a>
<dd>display a text string
<dt><br><a href="#_scrolltextwindow">_scrolltextwindow</a>
<dd>scroll the contents of the text window
<dt><br><a href="#_setbkcolor">_setbkcolor</a>
<dd>set the background color
<dt><br><a href="#_settextcolor">_settextcolor</a>
<dd>set the color used to display text
<dt><br><a href="#_settextcursor">_settextcursor</a>
<dd>set the shape of the text cursor
<dt><br><a href="#_settextposition">_settextposition</a>
<dd>set the output position for text
<dt><br><a href="#_settextwindow">_settextwindow</a>
<dd>set the boundary of the region used to display text
<dt><br><a href="#_wrapon">_wrapon</a>
<dd>permit or disallow wrap-around of text in a text window
</dl>
<h3 id="Graphics_Text_Routines"> Graphics Text Routines </h3>
<br>These routines deal with displaying graphics text.&nbsp; Graphics text is displayed as a sequence of line segments, and
 can be drawn in different sizes (see the <tt> _setcharsize</tt> routine), with different orientations (see the <tt> _settextorient</tt>
 routine) and alignments (see the <tt> _settextalign</tt> routine).&nbsp; The routines ending with<tt> _w</tt> use the window
 coordinate system; the others use the view coordinate system.
<br><br>The following routines are defined:
<dl>
<dt><a href="#_gettextextent">_gettextextent</a>
<dd>get the bounding rectangle for a graphics text string
<dt><br><a href="#_gettextsettings">_gettextsettings</a>
<dd>get information about the current settings used to display graphics text
<dt><br><a href="#_grtext">_grtext</a>
<dd>display graphics text
<dt><br>_grtext_w (see <a href="#_grtext">_grtext</a>)
<dd>display graphics text using window coordinates
<dt><br><a href="#_setcharsize">_setcharsize</a>
<dd>set the character size used to display graphics text
<dt><br>_setcharsize_w (see <a href="#_setcharsize">_setcharsize</a>)
<dd>set the character size in window coordinates used to display graphics text
<dt><br><a href="#_setcharspacing">_setcharspacing</a>
<dd>set the character spacing used to display graphics text
<dt><br>_setcharspacing_w (see <a href="#_setcharspacing">_setcharspacing</a>)
<dd>set the character spacing in window coordinates used to display graphics text
<dt><br><a href="#_settextalign">_settextalign</a>
<dd>set the alignment used to display graphics text
<dt><br><a href="#_settextorient">_settextorient</a>
<dd>set the orientation used to display graphics text
<dt><br><a href="#_settextpath">_settextpath</a>
<dd>set the path used to display graphics text
</dl>
<h3 id="Image_Manipulation_Routines"> Image Manipulation Routines </h3>
<br>These routines are used to transfer screen images.&nbsp; The <tt> _getimage</tt> routine transfers a rectangular image
 from the screen into memory.&nbsp; The <tt> _putimage</tt> routine transfers an image from memory back onto the screen.&nbsp;
 The routines ending with<tt> _w</tt> or<tt> _wxy</tt> use the window coordinate system; the others use the view coordinate
 system.
<br><br>The following routines are defined:
<dl>
<dt><a href="#_getimage">_getimage</a>
<dd>store an image of an area of the screen into memory
<dt><br>_getimage_w (see <a href="#_getimage">_getimage</a>)
<dd>store an image of an area of the screen in window coordinates into memory
<dt><br>_getimage_wxy (see <a href="#_getimage">_getimage</a>)
<dd>store an image of an area of the screen in window coordinates into memory
<dt><br><a href="#_imagesize">_imagesize</a>
<dd>get the size of a screen area
<dt><br>_imagesize_w (see <a href="#_imagesize">_imagesize</a>)
<dd>get the size of a screen area in window coordinates
<dt><br>_imagesize_wxy (see <a href="#_imagesize">_imagesize</a>)
<dd>get the size of a screen area in window coordinates
<dt><br><a href="#_putimage">_putimage</a>
<dd>display an image from memory on the screen
<dt><br>_putimage_w (see <a href="#_putimage">_putimage</a>)
<dd>display an image from memory on the screen using window coordinates
</dl>
<h3 id="Font_Manipulation_Routines"> Font Manipulation Routines </h3>
<br>These routines are for the display of fonts compatible with Microsoft Windows.&nbsp; Fonts are contained in files with
 an extension of<tt> .FON.</tt>&nbsp; Before font based text can be displayed, the fonts must be registered with the <tt>
 _registerfonts</tt> routine, and a font must be selected with the <tt> _setfont</tt> routine.
<br><br>The following routines are defined:
<dl>
<dt><a href="#_getfontinfo">_getfontinfo</a>
<dd>get information about the currently selected font
<dt><br><a href="#_getgtextextent">_getgtextextent</a>
<dd>get the length in pixels of a text string
<dt><br><a href="#_getgtextvector">_getgtextvector</a>
<dd>get the current value of the font text orientation vector
<dt><br><a href="#_outgtext">_outgtext</a>
<dd>display a string of text in the current font
<dt><br><a href="#_registerfonts">_registerfonts</a>
<dd>initialize the font graphics system
<dt><br><a href="#_setfont">_setfont</a>
<dd>select a font from among the registered fonts
<dt><br><a href="#_setgtextvector">_setgtextvector</a>
<dd>set the font text orientation vector
<dt><br><a href="#_unregisterfonts">_unregisterfonts</a>
<dd>frees memory allocated by the font graphics system
</dl>
<h3 id="Presentation_Graphics_Routines"> Presentation Graphics Routines </h3>
<br>These routines provide a system for displaying and manipulating presentation graphics elements such as bar charts and
 pie charts.&nbsp; The presentation graphics routines can be further divided into three classes:
<dl>
<dt>Display Routines
<dd>
<br>These routines are for the initialization of the presentation graphics system and the displaying of charts.
<dt><br>Analyze Routines
<dd>
<br>These routines calculate default values for chart elements without actually displaying the chart.
<dt><br>Utility Routines
<dd>
<br>These routines provide additional support to control the appearance of presentation graphics elements.
</dl>
<br>The following subsections describe these routine classes in more detail.&nbsp; Each routine in the class is noted with
 a brief description of its purpose.
<h4 id="Display_Routines"> Display Routines </h4>
<br>These routines are for the initialization of the presentation graphics system and the displaying of charts.&nbsp; The
 <tt> _pg_initchart</tt> routine initializes the system and should be the first presentation graphics routine called.&nbsp;
 The single-series routines display a single set of data on a chart; the multi-series routines (those ending with<tt> ms)</tt>
 display several sets of data on the same chart.
<br><br>The following routines are defined:
<dl>
<dt><a href="#_pg_chart">_pg_chart</a>
<dd>display a bar, column or line chart
<dt><br>_pg_chartms (see <a href="#_pg_chart">_pg_chart</a>)
<dd>display a multi-series bar, column or line chart
<dt><br><a href="#_pg_chartpie">_pg_chartpie</a>
<dd>display a pie chart
<dt><br><a href="#_pg_chartscatter">_pg_chartscatter</a>
<dd>display a scatter chart
<dt><br>_pg_chartscatterms (see <a href="#_pg_chartscatter">_pg_chartscatter</a>)
<dd>display a multi-series scatter chart
<dt><br><a href="#_pg_defaultchart">_pg_defaultchart</a>
<dd>initialize the chart environment for a specific chart type
<dt><br><a href="#_pg_initchart">_pg_initchart</a>
<dd>initialize the presentation graphics system
</dl>
<h4 id="Analyze_Routines"> Analyze Routines </h4>
<br>These routines calculate default values for chart elements without actually displaying the chart.&nbsp; The routines ending
 with<tt> ms</tt> analyze multi-series charts; the others analyze single-series charts.
<br><br>The following routines are defined:
<dl>
<dt><a href="#_pg_analyzechart">_pg_analyzechart</a>
<dd>analyze a bar, column or line chart
<dt><br>_pg_analyzechartms (see <a href="#_pg_analyzechart">_pg_analyzechart</a>)
<dd>analyze a multi-series bar, column or line chart
<dt><br><a href="#_pg_analyzepie">_pg_analyzepie</a>
<dd>analyze a pie chart
<dt><br><a href="#_pg_analyzescatter">_pg_analyzescatter</a>
<dd>analyze a scatter chart
<dt><br>_pg_analyzescatterms (see <a href="#_pg_analyzescatter">_pg_analyzescatter</a>)
<dd>analyze a multi-series scatter chart
</dl>
<h4 id="Utility_Routines"> Utility Routines </h4>
<br>These routines provide additional support to control the appearance of presentation graphics elements.
<br><br>The following routines are defined:
<dl>
<dt><a href="#_pg_getchardef">_pg_getchardef</a>
<dd>get bit-map definition for a specific character
<dt><br><a href="#_pg_getpalette">_pg_getpalette</a>
<dd>get presentation graphics palette (colors, line styles, fill patterns and plot characters)
<dt><br><a href="#_pg_getstyleset">_pg_getstyleset</a>
<dd>get presentation graphics style-set (line styles for window borders and grid lines)
<dt><br><a href="#_pg_hlabelchart">_pg_hlabelchart</a>
<dd>display text horizontally on a chart
<dt><br><a href="#_pg_resetpalette">_pg_resetpalette</a>
<dd>reset presentation graphics palette to default values
<dt><br><a href="#_pg_resetstyleset">_pg_resetstyleset</a>
<dd>reset presentation graphics style-set to default values
<dt><br><a href="#_pg_setchardef">_pg_setchardef</a>
<dd>set bit-map definition for a specific character
<dt><br><a href="#_pg_setpalette">_pg_setpalette</a>
<dd>set presentation graphics palette (colors, line styles, fill patterns and plot characters)
<dt><br><a href="#_pg_setstyleset">_pg_setstyleset</a>
<dd>set presentation graphics style-set (line styles for window borders and grid lines)
<dt><br><a href="#_pg_vlabelchart">_pg_vlabelchart</a>
<dd>display text vertically on a chart
</dl>
<h2 id="Include_Files"> Include Files </h2>
<br>All program modules which use the Graphics Library should include the file<tt> graphapi.fi.</tt>&nbsp; This file contains
 definitions of all the routines in the library.&nbsp; As well, each routine should include<tt> graph.fi</tt> which contains
 all the structure and constant definitions.
<br><br>Modules using the presentation graphics routines should also include the file<tt> pgapi.fi.</tt>&nbsp; As well, each
 routine should include<tt> pg.fi.</tt>
<h1 id="Graphics_Library_Routines"> Graphics Library Routines </h1>
<br>This chapter contains, in alphabetical order, descriptions of the routines which comprise the graphics library.&nbsp;
 Each description consists of a number of subsections:
<dl>
<dt>Synopsis:
<dd>
<br>This subsection gives an example of a declaration for the routine, showing the types of the routine and its arguments.
<dt><br>Description:
<dd>
<br>This subsection is a description of the routine.
<dt><br>Returns:
<dd>
<br>This subsection describes the return value (if any) for the routine.
<dt><br>See Also:
<dd>
<br>This subsection provides a list of related routines.
<dt><br>Example:
<dd>
<br>This subsection consists of an example program demonstrating the use of the routine.&nbsp; In some cases the output from
 the program is also displayed.
<dt><br>Classification:
<dd>
<br>This subsection provides an indication of where the routine is commonly found.&nbsp; The following notation is used:
<dl>
<dt>PC Graphics
<dd>These &amp;routiness are part of the PC graphics library.
</dl>
<dt><br>Systems:
<dd>This subsection provides an indication of where the routine is supported.&nbsp; The following notation is used:
<dl>
<dt>DOS
<dd>This routine is available on both 16-bit DOS and 32-bit extended DOS.
<dt><br>QNX
<dd>This routine is available on QNX Software Systems' 16 or 32-bit operating systems.
</dl>
</dl>
<h2 id="_arc"> _arc, _arc_w, _arc_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _arc( x1, y1, x2, y2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x3, y3, x4, y4 )</tt>
<br><tt>integer*2 x1, y1</tt>
<br><tt>integer*2 x2, y2</tt>
<br><tt>integer*2 x3, y3</tt>
<br><tt>integer*2 x4, y4</tt>
<br><br><tt>integer*2 function _arc_w( x1, y1, x2, y2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x3, y3, x4, y4 )</tt>
<br><tt>double precision x1, y1</tt>
<br><tt>double precision x2, y2</tt>
<br><tt>double precision x3, y3</tt>
<br><tt>double precision x4, y4</tt>
<br><br><tt>integer*2 function _arc_wxy( p1, p2, p3, p4 )</tt>
<br><tt>record /_wxycoord/ p1</tt>
<br><tt>record /_wxycoord/ p2</tt>
<br><tt>record /_wxycoord/ p3</tt>
<br><tt>record /_wxycoord/ p4</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _arc</tt> routines draw elliptical arcs.&nbsp; The<tt> _arc</tt> routine uses the view coordinate system.&nbsp; The<tt>
 _arc_w</tt> and<tt> _arc_wxy</tt> routines use the window coordinate system.
<br>The center of the arc is the center of the rectangle established by the points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>
&nbsp; The arc is a segment of the ellipse drawn within this bounding rectangle.&nbsp; The arc starts at the point on this
 ellipse that intersects the vector from the centre of the ellipse to the point<tt> (x3,y3).</tt>&nbsp; The arc ends at the
 point on this ellipse that intersects the vector from the centre of the ellipse to the point<tt> (x4,y4).</tt>&nbsp; The
 arc is drawn in a counter-clockwise direction with the current plot action using the current color and the current line style.
<br><br>The following picture illustrates the way in which the bounding rectangle and the vectors specifying the start and
 end points are defined.
<br><br><img src="pic1.bmp" style="vertical-align:middle">
<br>When the coordinates<tt> (x1,y1)</tt> and<tt> (x2,y2)</tt> establish a line or a point (this happens when one or more
 of the x-coordinates or y-coordinates are equal), nothing is drawn.
<br><br>The current output position for graphics output is set to be the point at the end of the arc that was drawn.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _arc</tt> routines return a non-zero value when the arc was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_ellipse">_ellipse</a>, <a href="#_pie">_pie</a>, <a href="#_rectangle">_rectangle</a>, <a href="#_getarcinfo">_getarcinfo</a>,
 <a href="#_setcolor">_setcolor</a>, <a href="#_setlinestyle">_setlinestyle</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _arc( 120, 90, 520, 390, 500, 20, 450, 460 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_arc.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _arc - DOS, QNX</tt>
<br><tt>_arc_w - DOS, QNX</tt>
<br><tt>_arc_wxy - DOS, QNX</tt>
</dl>
<h2 id="_clearscreen"> _clearscreen </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _clearscreen( area )</tt>
<br><tt>integer*2 area</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _clearscreen</tt> routine clears the indicated<b> area</b> and fills it with the background color.&nbsp; The<b> area</b>
 argument must be one of the following values:
<dl>
<dt>_GCLEARSCREEN
<dd>area is entire screen
<dt><br>_GVIEWPORT
<dd>area is current viewport or clip region
<dt><br>_GWINDOW
<dd>area is current text window
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setbkcolor">_setbkcolor</a>, <a href="#_setviewport">_setviewport</a>, <a href="#_setcliprgn">_setcliprgn</a>,
 <a href="#_settextwindow">_settextwindow</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 100, 100, 540, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setviewport( 200, 200, 440, 280 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GVIEWPORT )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_displaycursor"> _displaycursor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _displaycursor( mode )</tt>
<br><tt>integer*2 mode</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _displaycursor</tt> routine is used to establish whether the text cursor is to be displayed when graphics routines
 complete.&nbsp; On entry to a graphics routine, the text cursor is turned off.&nbsp; When the routine completes, the<b> mode</b>
 setting determines whether the cursor is turned back on.&nbsp; The<b> mode</b> argument can have one of the following values:
<dl>
<dt>_GCURSORON
<dd>the cursor will be displayed
<dt><br>_GCURSOROFF
<dd>the cursor will not be displayed
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _displaycursor</tt> routine returns the previous setting for<b> mode</b>.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_gettextcursor">_gettextcursor</a>, <a href="#_settextcursor">_settextcursor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*30 name</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 2, 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _displaycursor( _GCURSORON )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( 'Cursor ON'//char(10)//char(10)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; //'Enter your name &gt;'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read( *, '(a30)' ) name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _displaycursor( _GCURSOROFF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 6, 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( 'Cursor OFF'//char(10)//char(10)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; //'Enter your name &gt;'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read( *, '(a30)' ) name</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_ellipse"> _ellipse, _ellipse_w, _ellipse_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _ellipse( fill, x1, y1, x2, y2 )</tt>
<br><tt>integer*2 fill</tt>
<br><tt>integer*2 x1, y1</tt>
<br><tt>integer*2 x2, y2</tt>
<br><br><tt>integer*2 function _ellipse_w( fill, x1, y1, x2, y2 )</tt>
<br><tt>integer*2 fill,</tt>
<br><tt>double precision x1, y1</tt>
<br><tt>double precision x2, y2</tt>
<br><br><tt>integer*2 function _ellipse_wxy( fill, p1, p2 )</tt>
<br><tt>integer*2 fill,</tt>
<br><tt>record /_wxycoord/ p1, p2</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _ellipse</tt> routines draw ellipses.&nbsp; The<tt> _ellipse</tt> routine uses the view coordinate system.&nbsp; The<tt>
 _ellipse_w</tt> and<tt> _ellipse_wxy</tt> routines use the window coordinate system.
<br>The center of the ellipse is the center of the rectangle established by the points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>
<br><br>The argument<b> fill</b> determines whether the ellipse is filled in or has only its outline drawn.&nbsp; The argument
 can have one of two values:
<dl>
<dt>_GFILLINTERIOR
<dd>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<dt><br>_GBORDER
<dd>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
 style
</dl>
<br>When the coordinates<tt> (x1,y1)</tt> and<tt> (x2,y2)</tt> establish a line or a point (this happens when one or more
 of the x-coordinates or y-coordinates are equal), nothing is drawn.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _ellipse</tt> routines return a non-zero value when the ellipse was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_arc">_arc</a>, <a href="#_rectangle">_rectangle</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_setfillmask">_setfillmask</a>,
 <a href="#_setlinestyle">_setlinestyle</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GBORDER, 120, 90, 520, 390 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_ellip.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _ellipse - DOS, QNX</tt>
<br><tt>_ellipse_w - DOS, QNX</tt>
<br><tt>_ellipse_wxy - DOS, QNX</tt>
</dl>
<h2 id="_floodfill"> _floodfill, _floodfill_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _floodfill( x, y, stop_color )</tt>
<br><tt>integer*2 x, y</tt>
<br><tt>integer*2 stop_color</tt>
<br><br><tt>integer*2 function _floodfill_w( x, y, stop_color )</tt>
<br><tt>double precision x, y</tt>
<br><tt>integer*2 stop_color</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _floodfill</tt> routines fill an area of the screen.&nbsp; The<tt> _floodfill</tt> routine uses the view coordinate
 system.&nbsp; The<tt> _floodfill_w</tt> routine uses the window coordinate system.
<br>The filling starts at the point<tt> (x,y)</tt> and continues in all directions:&nbsp; when a pixel is filled, the neighbouring
 pixels (horizontally and vertically) are then considered for filling.&nbsp; Filling is done using the current color and fill
 mask.&nbsp; No filling will occur if the point<tt> (x,y)</tt> lies outside the clipping region.
<br><br>If the argument<b> stop_color</b> is a valid pixel value, filling will occur in each direction until a pixel is encountered
 with a pixel value of<b> stop_color</b>.&nbsp; The filled area will be the area around<tt> (x,y),</tt> bordered by<b> stop_color</b>.
&nbsp; No filling will occur if the point<tt> (x,y)</tt> has the pixel value<b> stop_color</b>.
<br><br>If<b> stop_color</b> has the value (-1), filling occurs until a pixel is encountered with a pixel value different
 from the pixel value of the starting point<tt> (x,y).</tt>&nbsp; No filling will occur if the pixel value of the point<tt>
 (x,y)</tt> is the current color.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _floodfill</tt> routines return zero when no filling takes place; a non-zero value is returned to indicate that filling
 has occurred.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setcliprgn">_setcliprgn</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_setfillmask">_setfillmask</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GBORDER, 120, 90, 520, 390 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( 2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _floodfill( 320, 240, 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _floodfill - DOS, QNX</tt>
<br><tt>_floodfill_w - DOS, QNX</tt>
</dl>
<h2 id="_getactivepage"> _getactivepage </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _getactivepage()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getactivepage</tt> routine returns the number of the currently selected active graphics page.
<br>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple pages
 are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
 what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
 can be constructed without affecting the screen by setting the active page to be different than the visual page.
<br><br>The number of available video pages can be determined by using the <tt> _getvideoconfig</tt> routine.&nbsp; The default
 video page is 0.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getactivepage</tt> routine returns the number of the currently selected active graphics page.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setactivepage">_setactivepage</a>, <a href="#_setvisualpage">_setvisualpage</a>, <a href="#_getvisualpage">_getvisualpage</a>,
 <a href="#_getvideoconfig">_getvideoconfig</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_apage, old_vpage</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _HRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_apage = _getactivepage()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw an ellipse on page 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR, 100, 50,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw a rectangle on page 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 50,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150
 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! display page 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( old_apage )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( old_vpage )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getarcinfo"> _getarcinfo </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _getarcinfo( start_pt, end_pt,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inside_pt )</tt>
<br><tt>record /xycoord/ start_pt</tt>
<br><tt>record /xycoord/ end_pt</tt>
<br><tt>record /xycoord/ inside_pt</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getarcinfo</tt> routine returns information about the arc most recently drawn by the <tt> _arc</tt> or <tt> _pie</tt>
 routines.&nbsp; The arguments<b> start_pt</b> and<b> end_pt</b> are set to contain the endpoints of the arc.&nbsp; The argument<b>
 inside_pt</b> will contain the coordinates of a point within the pie.&nbsp; The points are all specified in the view coordinate
 system.
<br>The endpoints of the arc can be used to connect other lines to the arc.&nbsp; The interior point can be used to fill the
 pie.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getarcinfo</tt> routine returns a non-zero value when successful.&nbsp; If the previous arc or pie was not successfully
 drawn, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_arc">_arc</a>, <a href="#_pie">_pie</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ start_pt, end_pt, inside_pt</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _arc( 120, 90, 520, 390, 520, 90, 120, 390 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getarcinfo( start_pt, end_pt, inside_pt )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( start_pt.xcoord, start_pt.ycoord )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( end_pt.xcoord, end_pt.ycoord )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_getai.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getbkcolor"> _getbkcolor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*4 function _getbkcolor()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getbkcolor</tt> routine returns the current background color.&nbsp; In text modes, the background color controls
 the area behind each individual character.&nbsp; In graphics modes, the background refers to the entire screen.&nbsp; The
 default background color is 0.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getbkcolor</tt> routine returns the current background color.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setbkcolor">_setbkcolor</a>, <a href="#_remappalette">_remappalette</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer bk, old_bk</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer colors(16)/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BLACK, _BLUE, _GREEN,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _CYAN, _RED, _MAGENTA,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BROWN, _WHITE, _GRAY, _LIGHTBLUE,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTGREEN, _LIGHTCYAN, _LIGHTRED,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTMAGENTA, _YELLOW, _BRIGHTWHITE/</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do bk = 1, 16</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( colors( bk ) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( old_bk )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getcliprgn"> _getcliprgn </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _getcliprgn( x1, y1, x2, y2 )</tt>
<br><tt>integer*2 x1, y1</tt>
<br><tt>integer*2 x2, y2</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getcliprgn</tt> routine returns the location of the current clipping region.&nbsp; A clipping region is defined with
 the <tt> _setcliprgn</tt> or <tt> _setviewport</tt> routines.&nbsp; By default, the clipping region is the entire screen.
<br>The current clipping region is a rectangular area of the screen to which graphics output is restricted.&nbsp; The top
 left corner of the clipping region is placed in the arguments<tt> (x1,y1).</tt>&nbsp; The bottom right corner of the clipping
 region is placed in<tt> (x2,y2).</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setcliprgn">_setcliprgn</a>, <a href="#_setviewport">_setviewport</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 x1, y1, x2, y2</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getcliprgn( x1, y1, x2, y2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcliprgn( 130, 100, 510, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GBORDER, 120, 90, 520, 390 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcliprgn( x1, y1, x2, y2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getcolor"> _getcolor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _getcolor()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getcolor</tt> routine returns the pixel value for the current color.&nbsp; This is the color used for displaying
 graphics output.&nbsp; The default color value is one less than the maximum number of colors in the current video mode.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getcolor</tt> routine returns the pixel value for the current color.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setcolor">_setcolor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer col, old_col</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_col = _getcolor()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do col = 0, 15</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( col )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100, 100, 540, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( old_col )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getcurrentposition"> _getcurrentposition, _getcurrentposition_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>record /xycoord/ function _getcurrentposition()</tt>
<br><br><tt>record /_wxycoord/ function _getcurrentposition_w()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getcurrentposition</tt> routines return the current output position for graphics.&nbsp; The<tt> _getcurrentposition</tt>
 routine returns the point in view coordinates.&nbsp; The<tt> _getcurrentposition_w</tt> routine returns the point in window
 coordinates.
<br>The current position defaults to the origin,<tt> (0,0),</tt> when a new video mode is selected.&nbsp; It is changed by
 successful calls to the <tt> _arc</tt>, <tt> _moveto</tt> and <tt> _lineto</tt> routines as well as the <tt> _setviewport</tt>
 routine.
<br><br>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
 text output can be set by use of the <tt> _settextposition</tt> routine.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getcurrentposition</tt> routines return the current output position for graphics.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_moveto">_moveto</a>, <a href="#_settextposition">_settextposition</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ old_pos</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_pos = _getcurrentposition()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 540, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 320, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( old_pos.xcoord, old_pos.ycoord )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _getcurrentposition - DOS, QNX</tt>
<br><tt>_getcurrentposition_w - DOS, QNX</tt>
</dl>
<h2 id="_getfillmask"> _getfillmask </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _getfillmask( mask )</tt>
<br><tt>integer*1 mask(8)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getfillmask</tt> routine copies the current fill mask into the area located by the argument<b> mask</b>.&nbsp; The
 fill mask is used by the <tt> _ellipse</tt>, <tt> _floodfill</tt>, <tt> _pie</tt>, <tt> _polygon</tt> and <tt> _rectangle</tt>
 routines that fill an area of the screen.
<br>The fill mask is an eight-byte array which is interpreted as a square pattern (8 by 8) of 64 bits.&nbsp; Each bit in the
 mask corresponds to a pixel.&nbsp; When a region is filled, each point in the region is mapped onto the fill mask.&nbsp;
 When a bit from the mask is one, the pixel value of the corresponding point is set using the current plotting action with
 the current color; when the bit is zero, the pixel value of that point is not affected.
<br><br>When the fill mask is not set, a fill operation will set all points in the fill region to have a pixel value of the
 current color.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_floodfill">_floodfill</a>, <a href="#_setfillmask">_setfillmask</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 old_mask(8)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 new_mask(8)/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 '81'x, '42'x, '24'x, '18'x,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 '18'x, '24'x, '42'x, '81'x/</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getfillmask( old_mask )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfillmask( new_mask )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 100, 100, 540, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfillmask( old_mask )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getfontinfo"> _getfontinfo </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _getfontinfo( info )</tt>
<br><tt>record /_fontinfo/ info</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getfontinfo</tt> routine returns information about the currently selected font.&nbsp; Fonts are selected with the
 <tt> _setfont</tt> routine.&nbsp; The font information is returned in the<tt> _fontinfo</tt> structure indicated by the argument<b>
 info</b>.&nbsp; The structure contains the following fields:
<dl>
<dt>type
<dd>1 for a vector font, 0 for a bit-mapped font
<dt><br>ascent
<dd>distance from top of character to baseline in pixels
<dt><br>pixwidth
<dd>character width in pixels (0 for a proportional font)
<dt><br>pixheight
<dd>character height in pixels
<dt><br>avgwidth
<dd>average character width in pixels
<dt><br>filename
<dd>name of the file containing the current font
<dt><br>facename
<dd>name of the current font
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getfontinfo</tt> routine returns zero if the font information is returned successfully; otherwise a negative value
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_setfont">_setfont</a>,
 <a href="#_outgtext">_outgtext</a>, <a href="#_getgtextextent">_getgtextextent</a>, <a href="#_setgtextvector">_setgtextvector</a>,
 <a href="#_getgtextvector">_getgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /_fontinfo/ info</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer width</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getfontinfo( info )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width = _getgtextextent( 'WATCOM Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 100 + width, 100 + info.pixheight )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getgtextextent"> _getgtextextent </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _getgtextextent( text )</tt>
<br><tt>character*(*) text</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getgtextextent</tt> routine returns the length in pixels of the argument<b> text</b> as it would be displayed in
 the current font by the routine <tt> _outgtext</tt>.&nbsp; Note that the text is not displayed on the screen, only its length
 is determined.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getgtextextent</tt> routine returns the length in pixels of a string.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_setfont">_setfont</a>,
 <a href="#_getfontinfo">_getfontinfo</a>, <a href="#_outgtext">_outgtext</a>, <a href="#_setgtextvector">_setgtextvector</a>,
 <a href="#_getgtextvector">_getgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /_fontinfo/ info</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer width</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getfontinfo( info )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width = _getgtextextent( 'WATCOM Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 100 + width, 100 + info.pixheight )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getgtextvector"> _getgtextvector </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>record /xycoord/ function _getgtextvector()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getgtextvector</tt> routine returns the current value of the text orientation vector.&nbsp; This is the direction
 used when text is displayed by the <tt> _outgtext</tt> routine.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getgtextvector</tt> routine returns, as an<tt> xycoord</tt> structure, the current value of the text orientation
 vector.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_setfont">_setfont</a>,
 <a href="#_getfontinfo">_getfontinfo</a>, <a href="#_outgtext">_outgtext</a>, <a href="#_getgtextextent">_getgtextextent</a>,
 <a href="#_setgtextvector">_setgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ old_vec</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_vec = _getgtextvector()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setgtextvector( 0, -1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setgtextvector( old_vec.xcoord, old_vec.ycoord )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getimage"> _getimage, _getimage_w, _getimage_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _getimage( x1, y1, x2, y2, image )</tt>
<br><tt>integer*2 x1, y1</tt>
<br><tt>integer*2 x2, y2</tt>
<br><tt>integer*1 image(*)</tt>
<br><br><tt>subroutine _getimage_w( x1, y1, x2, y2, image )</tt>
<br><tt>double precision x1, y1</tt>
<br><tt>double precision x2, y2</tt>
<br><tt>integer*1 image(*)</tt>
<br><br><tt>subroutine _getimage_wxy( p1, p2, image )</tt>
<br><tt>record /_wxycoord/ p1, p2</tt>
<br><tt>integer*1 image(*)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getimage</tt> routines store a copy of an area of the screen into the buffer indicated by the<b> image</b> argument.
&nbsp; The<tt> _getimage</tt> routine uses the view coordinate system.&nbsp; The<tt> _getimage_w</tt> and<tt> _getimage_wxy</tt>
 routines use the window coordinate system.
<br>The screen image is the rectangular area defined by the points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>&nbsp; The buffer<b>
 image</b> must be large enough to contain the image (the size of the image can be determined by using the <tt> _imagesize</tt>
 routine).&nbsp; The image may be displayed upon the screen at some later time by using the <tt> _putimage</tt> routines.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_imagesize">_imagesize</a>, <a href="#_putimage">_putimage</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 image(:)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer y, image_size, istat</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 100, 100, 200, 200 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image_size = _imagesize( 100, 100, 201, 201 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate( image(image_size), stat = istat )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( istat .eq. 0 )then</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getimage( 100, 100, 201, 201, image )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 260, 200, image, _GPSET )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, 100, image, _GPSET )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do y = 100, 280, 20</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, y,
 image, _GXOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, y+20,
 image, _GXOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deallocate( image )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _getimage - DOS, QNX</tt>
<br><tt>_getimage_w - DOS, QNX</tt>
<br><tt>_getimage_wxy - DOS, QNX</tt>
</dl>
<h2 id="_getlinestyle"> _getlinestyle </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _getlinestyle()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getlinestyle</tt> routine returns the current line-style mask.
<br>The line-style mask determines the style by which lines and arcs are drawn.&nbsp; The mask is treated as an array of 16
 bits.&nbsp; As a line is drawn, a pixel at a time, the bits in this array are cyclically tested.&nbsp; When a bit in the
 array is 1, the pixel value for the current point is set using the current color according to the current plotting action;
 otherwise, the pixel value for the point is left unchanged.&nbsp; A solid line would result from a value of<tt> 'FFFF'x</tt>
 and a dashed line would result from a value of<tt> 'F0F0'x.</tt>
<br><br>The default line style mask is<tt> 'FFFF'x.</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getlinestyle</tt> routine returns the current line-style mask.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_lineto">_lineto</a>, <a href="#_pie">_pie</a>, <a href="#_rectangle">_rectangle</a>, <a href="#_polygon">_polygon</a>,
 <a href="#_setlinestyle">_setlinestyle</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer DASHED</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (DASHED='f0f0'x)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_style</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_style = _getlinestyle()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setlinestyle( DASHED )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100, 540, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setlinestyle( old_style )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getphyscoord"> _getphyscoord </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>record /xycoord/ function _getphyscoord( x, y )</tt>
<br><tt>integer*2 x, y</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getphyscoord</tt> routine returns the physical coordinates of the position with view coordinates<tt> (x,y).</tt>
&nbsp; View coordinates are defined by the <tt> _setvieworg</tt> and <tt> _setviewport</tt> routines.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getphyscoord</tt> routine returns the physical coordinates, as an<tt> xycoord</tt> structure, of the given point.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getviewcoord">_getviewcoord</a>, <a href="#_setvieworg">_setvieworg</a>, <a href="#_setviewport">_setviewport</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ pos</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real urand</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer seed</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed = 75347</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvieworg(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod( int( urand( seed )*32767 ), 640 ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod( int( urand( seed )*32767 ), 480 ) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos = _getphyscoord( 0, 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - pos.xcoord, - pos.ycoord,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 639 - pos.xcoord, 479 - pos.ycoord
 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getpixel"> _getpixel, _getpixel_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _getpixel( x, y )</tt>
<br><tt>integer*2 x, y</tt>
<br><br><tt>integer*2 function _getpixel_w( x, y )</tt>
<br><tt>double precision x, y</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getpixel</tt> routines return the pixel value for the point with coordinates<tt> (x,y).</tt>&nbsp; The<tt> _getpixel</tt>
 routine uses the view coordinate system.&nbsp; The<tt> _getpixel_w</tt> routine uses the window coordinate system.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getpixel</tt> routines return the pixel value for the given point when the point lies within the clipping region;
 otherwise, (-1) is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setpixel">_setpixel</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer x, y, i</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real urand</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer seed</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed = 75347</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100, 540, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, 60000</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 101 + mod( int( urand( seed )*32767 ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 439 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 101 + mod( int( urand( seed )*32767 ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 279 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( _getpixel( x, y ) + 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setpixel( x, y )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _getpixel - DOS, QNX</tt>
<br><tt>_getpixel_w - DOS, QNX</tt>
</dl>
<h2 id="_getplotaction"> _getplotaction </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _getplotaction()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getplotaction</tt> routine returns the current plotting action.
<br>The drawing routines cause pixels to be set with a pixel value.&nbsp; By default, the value to be set is obtained by replacing
 the original pixel value with the supplied pixel value.&nbsp; Alternatively, the replaced value may be computed as a function
 of the original and the supplied pixel values.
<br><br>The plotting action can have one of the following values:
<dl>
<dt>_GPSET
<dd>replace the original screen pixel value with the supplied pixel value
<dt><br>_GAND
<dd>replace the original screen pixel value with the<b> bitwise and</b> of the original pixel value and the supplied pixel value
<dt><br>_GOR
<dd>replace the original screen pixel value with the<b> bitwise or</b> of the original pixel value and the supplied pixel value
<dt><br>_GXOR
<dd>replace the original screen pixel value with the<b> bitwise exclusive-or</b> of the original pixel value and the supplied
 pixel value.&nbsp; Performing this operation twice will restore the original screen contents, providing an efficient method
 to produce animated effects.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getplotaction</tt> routine returns the current plotting action.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_act</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_act = _getplotaction()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setplotaction( _GPSET )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 100,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 380
 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setplotaction( _GXOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 100,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 380
 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setplotaction( old_act )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_gettextcolor"> _gettextcolor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _gettextcolor()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _gettextcolor</tt> routine returns the pixel value of the current text color.&nbsp; This is the color used for displaying
 text with the <tt> _outtext</tt> and <tt> _outmem</tt> routines.&nbsp; The default text color value is set to 7 whenever
 a new video mode is selected.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _gettextcolor</tt> routine returns the pixel value of the current text color.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextcolor">_settextcolor</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_col</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_bk</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_col = _gettextcolor()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcolor( 7 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( _BLUE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( ' WATCOM '//char(10)//</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 'Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcolor( old_col )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( old_bk )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_gettextcursor"> _gettextcursor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _gettextcursor()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _gettextcursor</tt> routine returns the current cursor attribute, or shape.&nbsp; The cursor shape is set with the
 <tt> _settextcursor</tt> routine.&nbsp; See the <tt> _settextcursor</tt> routine for a description of the value returned
 by the<tt> _gettextcursor</tt> routine.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _gettextcursor</tt> routine returns the current cursor shape when successful; otherwise, (-1) is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextcursor">_settextcursor</a>, <a href="#_displaycursor">_displaycursor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 old_shape</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_shape = _gettextcursor()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcursor( '0007'x )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(10)//'Block cursor'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcursor( '0407'x )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(10)//'Half height cursor'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcursor( '2000'x )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(10)//'No cursor'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_gettextextent"> _gettextextent </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _gettextextent( x, y, text, concat, extent )</tt>
<br><tt>integer*2 x, y</tt>
<br><tt>character*(*) text</tt>
<br><tt>record /xycoord/ concat</tt>
<br><tt>record /xycoord/ extent(4)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _gettextextent</tt> routine simulates the effect of using the <tt> _grtext</tt> routine to display the text string<b>
 text</b> at the position<tt> (x,y),</tt> using the current text settings.&nbsp; The concatenation point is returned in the
 argument<b> concat</b>.&nbsp; The text extent parallelogram is returned in the array<b> extent</b>.
<br>The concatenation point is the position to use to output text after the given string.&nbsp; The text extent parallelogram
 outlines the area where the text string would be displayed.&nbsp; The four points are returned in counter-clockwise order,
 starting at the upper-left corner.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_gettextsettings">_gettextsettings</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ concat, extent(4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 100, 'hot'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _gettextextent( 100, 100, 'hot'c,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; concat, extent )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _polygon( _GBORDER, 4, extent )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( concat.xcoord, concat.ycoord,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 'dog'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_gette.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_gettextposition"> _gettextposition </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>record /rccoord/ function _gettextposition()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _gettextposition</tt> routine returns the current output position for text.&nbsp; This position is in terms of characters,
 not pixels.
<br>The current position defaults to the top left corner of the screen,<tt> (1,1),</tt> when a new video mode is selected.
&nbsp; It is changed by successful calls to the <tt> _outtext</tt>, <tt> _outmem</tt>, <tt> _settextposition</tt> and <tt>
 _settextwindow</tt> routines.
<br><br>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
 graphics output can be set by use of the <tt> _moveto</tt> routine.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _gettextposition</tt> routine returns, as an<tt> rccoord</tt> structure, the current output position for text.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_settextposition">_settextposition</a>, <a href="#_settextwindow">_settextwindow</a>,
 <a href="#_moveto">_moveto</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /rccoord/ old_pos</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_pos = _gettextposition()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 10, 40 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( 'WATCOM Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( old_pos.row, old_pos.col )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_gettextsettings"> _gettextsettings </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _gettextsettings( settings )</tt>
<br><tt>record /textsettings/ settings</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _gettextsettings</tt> routine returns information about the current text settings used when text is displayed by the
 <tt> _grtext</tt> routine.&nbsp; The information is stored in the<tt> textsettings</tt> structure indicated by the argument<b>
 settings</b>.&nbsp; The structure contains the following fields (all are<tt> integer*2</tt> fields):
<dl>
<dt>basevectorx
<dd>x-component of the current base vector
<dt><br>basevectory
<dd>y-component of the current base vector
<dt><br>path
<dd>current text path
<dt><br>height
<dd>current text height (in pixels)
<dt><br>width
<dd>current text width (in pixels)
<dt><br>spacing
<dd>current text spacing (in pixels)
<dt><br>horizalign
<dd>horizontal component of the current text alignment
<dt><br>vertalign
<dd>vertical component of the current text alignment
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_setcharsize">_setcharsize</a>, <a href="#_setcharspacing">_setcharspacing</a>,
 <a href="#_settextalign">_settextalign</a>, <a href="#_settextpath">_settextpath</a>, <a href="#_settextorient">_settextorient</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /textsettings/ ts</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _gettextsettings( ts )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 100, 'WATCOM'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcharsize( 2 * ts.height, 2 * ts.width )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 300, 'Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcharsize( ts.height, ts.width )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_gettextwindow"> _gettextwindow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _gettextwindow( row1, col1, row2, col2 )</tt>
<br><tt>integer*2 row1, col1</tt>
<br><tt>integer*2 row2, col2</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _gettextwindow</tt> routine returns the location of the current text window.&nbsp; A text window is defined with the
 <tt> _settextwindow</tt> routine.&nbsp; By default, the text window is the entire screen.
<br>The current text window is a rectangular area of the screen.&nbsp; Text display is restricted to be within this window.
&nbsp; The top left corner of the text window is placed in the arguments<tt> (row1,col1).</tt>&nbsp; The bottom right corner
 of the text window is placed in<tt> (row2,col2).</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextwindow">_settextwindow</a>, <a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_settextposition">_settextposition</a>,
 <a href="#_scrolltextwindow">_scrolltextwindow</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 r1, c1, r2, c2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _gettextwindow( r1, c1, r2, c2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextwindow( 5, 20, 20, 40 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 20</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''Line '', i2, a1, a1 )' )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, char(10), char(0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextwindow( r1, c1, r2, c2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getvideoconfig"> _getvideoconfig </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _getvideoconfig( config )</tt>
<br><tt>record /videoconfig/ config</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getvideoconfig</tt> routine returns information about the current video mode and the hardware configuration.&nbsp;
 The information is returned in the<tt> videoconfig</tt> structure indicated by the argument<b> config</b>.&nbsp; The structure
 contains the following fields (all are<tt> integer*2</tt> fields):
<dl>
<dt>numxpixels
<dd>number of pixels in x-axis
<dt><br>numypixels
<dd>number of pixels in y-axis
<dt><br>numtextcols
<dd>number of text columns
<dt><br>numtextrows
<dd>number of text rows
<dt><br>numcolors
<dd>number of actual colors
<dt><br>bitsperpixel
<dd>number of bits in a pixel value
<dt><br>numvideopages
<dd>number of video pages
<dt><br>mode
<dd>current video mode
<dt><br>adapter
<dd>adapter type
<dt><br>monitor
<dd>monitor type
<dt><br>memory
<dd>number of kilobytes (1024 characters) of video memory
</dl>
<br>The<tt> adapter</tt> field will contain one of the following values:
<dl>
<dt>_NODISPLAY
<dd>no display adapter attached
<dt><br>_UNKNOWN
<dd>unknown adapter/monitor type
<dt><br>_MDPA
<dd>Monochrome Display/Printer Adapter
<dt><br>_CGA
<dd>Color Graphics Adapter
<dt><br>_HERCULES
<dd>Hercules Monochrome Adapter
<dt><br>_MCGA
<dd>Multi-Color Graphics Array
<dt><br>_EGA
<dd>Enhanced Graphics Adapter
<dt><br>_VGA
<dd>Video Graphics Array
<dt><br>_SVGA
<dd>SuperVGA Adapter
</dl>
<br>The<tt> monitor</tt> field will contain one of the following values:
<dl>
<dt>_MONO
<dd>regular monochrome
<dt><br>_COLOR
<dd>regular color
<dt><br>_ENHANCED
<dd>enhanced color
<dt><br>_ANALOGMONO
<dd>analog monochrome
<dt><br>_ANALOGCOLOR
<dd>analog color
</dl>
<br>The amount of memory reported by<tt> _getvideoconfig</tt> will not always be correct for SuperVGA adapters.&nbsp; Since
 it is not always possible to determine the amount of memory,<tt> _getvideoconfig</tt> will always report 256K, the minimum
 amount.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setvideomode">_setvideomode</a>, <a href="#_setvideomoderows">_setvideomoderows</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer mode</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /videoconfig/ vc</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getvideoconfig( vc )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select( vc.adapter )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _VGA, _SVGA )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _VRES16COLOR</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _MCGA )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES256COLOR</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _EGA )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( vc.monitor .eq. _MONO )then</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESNOCOLOR</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESCOLOR</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _CGA )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES4COLOR</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _HERCULES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _HERCMONO</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case default</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop 'No graphics adapter'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endselect</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _setvideomode( mode ) .ne. 0 )then</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getvideoconfig( vc )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '( i3, '' x '',
 i3, '' x '', i3, a1 )' )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vc.numxpixels,
 vc.numypixels,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vc.numcolors, char(0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getviewcoord"> _getviewcoord, _getviewcoord_w, _getviewcoord_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>record /xycoord/ function _getviewcoord( x, y )</tt>
<br><tt>integer*2 x, y</tt>
<br><br><tt>record /xycoord/ function _getviewcoord_w( x, y )</tt>
<br><tt>double precision x, y</tt>
<br><br><tt>record /xycoord/ function _getviewcoord_wxy( p )</tt>
<br><tt>record /_wxycoord/ p</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getviewcoord</tt> routines translate a point from one coordinate system to viewport coordinates.&nbsp; The<tt> _getviewcoord</tt>
 routine translates the point<tt> (x,y)</tt> from physical coordinates.&nbsp; The<tt> _getviewcoord_w</tt> and<tt> _getviewcoord_wxy</tt>
 routines translate the point from the window coordinate system.
<br>Viewport coordinates are defined by the <tt> _setvieworg</tt> and <tt> _setviewport</tt> routines.&nbsp; Window coordinates
 are defined by the <tt> _setwindow</tt> routine.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getviewcoord</tt> routines return the viewport coordinates, as an<tt> xycoord</tt> structure, of the given point.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getphyscoord">_getphyscoord</a>, <a href="#_setvieworg">_setvieworg</a>, <a href="#_setviewport">_setviewport</a>,
 <a href="#_setwindow">_setwindow</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ pos1, pos2</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer seed</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real urand</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed = 75347</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvieworg(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod( int( urand( seed )*32767 ), 640 ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mod( int( urand( seed )*32767 ), 480 ) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos1 = _getviewcoord( 0, 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos2 = _getviewcoord( 639, 479 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; pos1.xcoord, pos1.ycoord,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; pos2.xcoord, pos2.ycoord )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _getviewcoord - DOS, QNX</tt>
<br><tt>_getviewcoord_w - DOS, QNX</tt>
<br><tt>_getviewcoord_wxy - DOS, QNX</tt>
</dl>
<h2 id="_getvisualpage"> _getvisualpage </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _getvisualpage()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getvisualpage</tt> routine returns the number of the currently selected visual graphics page.
<br>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple pages
 are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
 what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
 can be constructed without affecting the screen by setting the active page to be different than the visual page.
<br><br>The number of available video pages can be determined by using the <tt> _getvideoconfig</tt> routine.&nbsp; The default
 video page is 0.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getvisualpage</tt> routine returns the number of the currently selected visual graphics page.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setvisualpage">_setvisualpage</a>, <a href="#_setactivepage">_setactivepage</a>, <a href="#_getactivepage">_getactivepage</a>,
 <a href="#_getvideoconfig">_getvideoconfig</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_apage, old_vpage</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _HRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_apage = _getactivepage()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw an ellipse on page 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR, 100, 50,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw a rectangle on page 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 50,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150
 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! display page 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( old_apage )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( old_vpage )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_getwindowcoord"> _getwindowcoord </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>record /_wxycoord/ function _getwindowcoord( x, y )</tt>
<br><tt>integer*2 x, y</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _getwindowcoord</tt> routine returns the window coordinates of the position with view coordinates<tt> (x,y).</tt>
&nbsp; Window coordinates are defined by the <tt> _setwindow</tt> routine.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _getwindowcoord</tt> routine returns the window coordinates, as a<tt> _wxycoord</tt> structure, of the given point.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setwindow">_setwindow</a>, <a href="#_getviewcoord">_getviewcoord</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ centre</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /_wxycoord/ pos1, pos2</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _MAXRESMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw a box 50 pixels square</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! in the middle of the screen</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; centre = _getviewcoord_w( 0.5, 0.5 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos1 = _getwindowcoord( centre.xcoord - 25,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; centre.ycoord - 25 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos2 = _getwindowcoord( centre.xcoord + 25,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; centre.ycoord + 25 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle_wxy( _GBORDER, pos1, pos2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_grstatus"> _grstatus </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _grstatus()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _grstatus</tt> routine returns the status of the most recently called graphics library routine.&nbsp; The routine
 can be called after any graphics routine to determine if any errors or warnings occurred.&nbsp; The routine returns 0 if
 the previous routine was successful.&nbsp; Values less than 0 indicate an error occurred; values greater than 0 indicate
 a warning condition.
<br>The following values can be returned:&nbsp; uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2
 uindex=2 
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Constant&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value
&nbsp; Explanation</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GROK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp; no error</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 -1&nbsp;&nbsp;&nbsp; graphics error</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRMODENOTSUPPORTED&nbsp;&nbsp;&nbsp; -2&nbsp;&nbsp;&nbsp; video mode not supported</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRNOTINPROPERMODE&nbsp;&nbsp;&nbsp;&nbsp; -3&nbsp;&nbsp;&nbsp; routine n/a in this mode</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRINVALIDPARAMETER&nbsp;&nbsp;&nbsp; -4&nbsp;&nbsp;&nbsp; invalid parameter(s)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRINSUFFICIENTMEMORY&nbsp; -5&nbsp;&nbsp;&nbsp; out of memory</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRFONTFILENOTFOUND&nbsp;&nbsp;&nbsp; -6&nbsp;&nbsp;&nbsp; can't open font file</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRINVALIDFONTFILE&nbsp;&nbsp;&nbsp;&nbsp; -7&nbsp;&nbsp;&nbsp; font file has invalid format</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRNOOUTPUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;
&nbsp;&nbsp; nothing was done</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _GRCLIPPED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 2&nbsp;&nbsp;&nbsp; output clipped</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _grstatus</tt> routine returns the status of the most recently called graphics library routine.
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer x, y</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real urand</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer seed</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed = 75347</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( _grstatus() .eq. _GROK )do</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = mod( int( urand( seed )*32767 ), 700 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = mod( int( urand( seed )*32767 ), 500 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setpixel( x, y )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endwhile</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_grtext"> _grtext, _grtext_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _grtext( x, y, text )</tt>
<br><tt>integer*2 x, y</tt>
<br><tt>character*(*) text</tt>
<br><br><tt>integer*2 function _grtext_w( x, y, text )</tt>
<br><tt>double precision x, y</tt>
<br><tt>character*(*) text</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _grtext</tt> routines display a character string.&nbsp; The<tt> _grtext</tt> routine uses the view coordinate system.
&nbsp; The<tt> _grtext_w</tt> routine uses the window coordinate system.
<br>The character string<b> text</b> is displayed at the point<tt> (x,y).</tt>&nbsp; The string must be terminated by a null
 character (char(0)).&nbsp; The text is displayed in the current color using the current text settings.
<br><br>The graphics library can display text in three different ways.
<ol>
<li>The <tt> _outtext</tt> and <tt> _outmem</tt> routines can be used in any video mode.&nbsp; However, this variety of text
 can be displayed in only one size.
<li>The <tt> _grtext</tt> routine displays text as a sequence of line segments, and can be drawn in different sizes, with
 different orientations and alignments.
<li>The <tt> _outgtext</tt> routine displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts are
 supported; the size and type of text depends on the fonts that are available.
</ol>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _grtext</tt> routines return a non-zero value when the text was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_outgtext">_outgtext</a>, <a href="#_setcharsize">_setcharsize</a>,
 <a href="#_settextalign">_settextalign</a>, <a href="#_settextpath">_settextpath</a>, <a href="#_settextorient">_settextorient</a>,
 <a href="#_setcharspacing">_setcharspacing</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 100, ' WATCOM'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 200, 'Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_grtxt.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _grtext - DOS, QNX</tt>
<br><tt>_grtext_w - DOS, QNX</tt>
</dl>
<h2 id="_imagesize"> _imagesize, _imagesize_w, _imagesize_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*4 function _imagesize( x1, y1, x2, y2 )</tt>
<br><tt>integer*2 x1, y1</tt>
<br><tt>integer*2 x2, y2</tt>
<br><br><tt>integer*4 function _imagesize_w( x1, y1, x2, y2 )</tt>
<br><tt>double precision x1, y1</tt>
<br><tt>double precision x2, y2</tt>
<br><br><tt>integer*4 function _imagesize_wxy( p1, p2 )</tt>
<br><tt>record /_wxycoord/ p1, p2</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _imagesize</tt> routines compute the number of bytes required to store a screen image.&nbsp; The<tt> _imagesize</tt>
 routine uses the view coordinate system.&nbsp; The<tt> _imagesize_w</tt> and<tt> _imagesize_wxy</tt> routines use the window
 coordinate system.
<br>The screen image is the rectangular area defined by the points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>&nbsp; The storage
 area used by the <tt> _getimage</tt> routines must be at least this large (in bytes).
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _imagesize</tt> routines return the size of a screen image.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getimage">_getimage</a>, <a href="#_putimage">_putimage</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 image(:)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer y, image_size, istat</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 100, 100, 200, 200 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image_size = _imagesize( 100, 100, 201, 201 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate( image(image_size), stat = istat )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( istat .eq. 0 )then</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getimage( 100, 100, 201, 201, image )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 260, 200, image, _GPSET )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, 100, image, _GPSET )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do y = 100, 280, 20</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, y,
 image, _GXOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, y+20,
 image, _GXOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deallocate( image )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _imagesize - DOS, QNX</tt>
<br><tt>_imagesize_w - DOS, QNX</tt>
<br><tt>_imagesize_wxy - DOS, QNX</tt>
</dl>
<h2 id="_lineto"> _lineto, _lineto_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _lineto( x, y )</tt>
<br><tt>integer*2 x, y</tt>
<br><br><tt>integer*2 function _lineto_w( x, y )</tt>
<br><tt>double precision x, y</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _lineto</tt> routines draw straight lines.&nbsp; The<tt> _lineto</tt> routine uses the view coordinate system.&nbsp;
 The<tt> _lineto_w</tt> routine uses the window coordinate system.
<br>The line is drawn from the current position to the point at the coordinates<tt> (x,y).</tt>&nbsp; The point<tt> (x,y)</tt>
 becomes the new current position.&nbsp; The line is drawn with the current plotting action using the current line style and
 the current color.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _lineto</tt> routines return a non-zero value when the line was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_moveto">_moveto</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_setlinestyle">_setlinestyle</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 540, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 320, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_movto.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _lineto - DOS, QNX</tt>
<br><tt>_lineto_w - DOS, QNX</tt>
</dl>
<h2 id="_moveto"> _moveto, _moveto_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>record /xycoord/ function _moveto( x, y )</tt>
<br><tt>integer*2 x, y</tt>
<br><br><tt>record /_wxycoord/ function _moveto_w( x, y )</tt>
<br><tt>double precision x, y</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _moveto</tt> routines set the current output position for graphics.&nbsp; The<tt> _moveto</tt> routine uses the view
 coordinate system.&nbsp; The<tt> _moveto_w</tt> routine uses the window coordinate system.
<br>The current output position is set to be the point at the coordinates<tt> (x,y).</tt>&nbsp; Nothing is drawn by the routine.
&nbsp; The <tt> _lineto</tt> routine uses the current output position as the starting point when a line is drawn.
<br><br>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
 text output can be set by use of the <tt> _settextposition</tt> routine.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _moveto</tt> routines return the previous value of the output position for graphics.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getcurrentposition">_getcurrentposition</a>, <a href="#_lineto">_lineto</a>, <a href="#_settextposition">_settextposition</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 540, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 320, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _moveto - DOS, QNX</tt>
<br><tt>_moveto_w - DOS, QNX</tt>
</dl>
<h2 id="_outgtext"> _outgtext </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _outgtext( text )</tt>
<br><tt>character*(*) text</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _outgtext</tt> routine displays the character string indicated by the argument<b> text</b>.&nbsp; The string must
 be terminated by a null character (char(0)).
<br>The string is displayed starting at the current position (see the <tt> _moveto</tt> routine) in the current color and
 in the currently selected font (see the <tt> _setfont</tt> routine).&nbsp; The current position is updated to follow the
 displayed text.
<br><br>When no font has been previously selected with <tt> _setfont</tt>, a default font will be used.&nbsp; The default
 font is an 8-by-8 bit-mapped font.
<br><br>The graphics library can display text in three different ways.
<ol>
<li>The <tt> _outtext</tt> and <tt> _outmem</tt> routines can be used in any video mode.&nbsp; However, this variety of text
 can be displayed in only one size.
<li>The <tt> _grtext</tt> routine displays text as a sequence of line segments, and can be drawn in different sizes, with
 different orientations and alignments.
<li>The <tt> _outgtext</tt> routine displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts are
 supported; the size and type of text depends on the fonts that are available.
</ol>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_setfont">_setfont</a>,
 <a href="#_getfontinfo">_getfontinfo</a>, <a href="#_getgtextextent">_getgtextextent</a>, <a href="#_setgtextvector">_setgtextvector</a>,
 <a href="#_getgtextvector">_getgtextvector</a>, <a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_grtext">_grtext</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i, n</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*10 buff</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = _registerfonts( '*.fon'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, n - 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''n'', i2.2, a1 )' ) i, char(0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfont( buff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GCLEARSCREEN )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _unregisterfonts()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_outmem"> _outmem </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _outmem( text, length )</tt>
<br><tt>character*(*) text</tt>
<br><tt>integer*2 length</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _outmem</tt> routine displays the character string indicated by the argument<b> text</b>.&nbsp; The argument<b> length</b>
 specifies the number of characters to be displayed.&nbsp; Unlike the <tt> _outtext</tt> routine,<tt> _outmem</tt> will display
 the graphical representation of characters such as ASCII 10 and 0, instead of interpreting them as control characters.
<br>The text is displayed using the current text color (see the <tt> _settextcolor</tt> routine), starting at the current
 text position (see the <tt> _settextposition</tt> routine).&nbsp; The text position is updated to follow the end of the displayed
 text.
<br><br>The graphics library can display text in three different ways.
<ol>
<li>The <tt> _outtext</tt> and <tt> _outmem</tt> routines can be used in any video mode.&nbsp; However, this variety of text
 can be displayed in only one size.
<li>The <tt> _grtext</tt> routine displays text as a sequence of line segments, and can be drawn in different sizes, with
 different orientations and alignments.
<li>The <tt> _outgtext</tt> routine displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts are
 supported; the size and type of text depends on the fonts that are available.
</ol>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextcolor">_settextcolor</a>, <a href="#_settextposition">_settextposition</a>, <a href="#_settextwindow">_settextwindow</a>,
 <a href="#_grtext">_grtext</a>, <a href="#_outtext">_outtext</a>, <a href="#_outgtext">_outgtext</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*20 buf</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GCLEARSCREEN )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, 255</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 1 + mod( i, 16 ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 + 5 * ( i / 16 ) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; buf( 1:1 ) = char( i )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outmem( buf, 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_outtext"> _outtext </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _outtext( text )</tt>
<br><tt>character*(*) text</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _outtext</tt> routine displays the character string indicated by the argument<b> text</b>.&nbsp; The string must be
 terminated by a null character (char(0)).&nbsp; When a line-feed character (char(10)) is encountered in the string, the characters
 following will be displayed on the next row of the screen.
<br>The text is displayed using the current text color (see the <tt> _settextcolor</tt> routine), starting at the current
 text position (see the <tt> _settextposition</tt> routine).&nbsp; The text position is updated to follow the end of the displayed
 text.
<br><br>The graphics library can display text in three different ways.
<ol>
<li>The <tt> _outtext</tt> and <tt> _outmem</tt> routines can be used in any video mode.&nbsp; However, this variety of text
 can be displayed in only one size.
<li>The <tt> _grtext</tt> routine displays text as a sequence of line segments, and can be drawn in different sizes, with
 different orientations and alignments.
<li>The <tt> _outgtext</tt> routine displays text in the currently selected font.&nbsp; Both bit-mapped and vector fonts are
 supported; the size and type of text depends on the fonts that are available.
</ol>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextcolor">_settextcolor</a>, <a href="#_settextposition">_settextposition</a>, <a href="#_settextwindow">_settextwindow</a>,
 <a href="#_grtext">_grtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_outgtext">_outgtext</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 10, 30 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( 'WATCOM Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_analyzechart"> _pg_analyzechart, _pg_analyzechartms </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_analyzechart( env, cat, values, n )</tt>
<br><tt>record /chartenv/ env</tt>
<br><tt>integer*4 cat(*)</tt>
<br><tt>real values(*)</tt>
<br><tt>integer*2 n</tt>
<br><br><tt>integer*2 function _pg_analyzechartms( env, cat, values,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nseries,
 n,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dim, labels
 )</tt>
<br><tt>record /chartenv/ env</tt>
<br><tt>integer*4 cat(*)</tt>
<br><tt>real values(*)</tt>
<br><tt>integer*2 nseries, n, dim</tt>
<br><tt>integer*4 labels(*)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_analyzechart</tt> routines analyze either a single-series or a multi-series bar, column or line chart.&nbsp; These
 routines calculate default values for chart elements without actually displaying the chart.
<br>The<tt> _pg_analyzechart</tt> routine analyzes a single-series bar, column or line chart.&nbsp; The chart environment
 structure<b> env</b> is filled with default values based on the type of chart and the values of the<b> cat</b> and<b> values</b>
 arguments.&nbsp; The arguments are the same as for the <tt> _pg_chart</tt> routine.
<br><br>The<tt> _pg_analyzechartms</tt> routine analyzes a multi-series bar, column or line chart.&nbsp; The chart environment
 structure<b> env</b> is filled with default values based on the type of chart and the values of the<b> cat</b>,<b> values</b>
 and<b> labels</b> arguments.&nbsp; The arguments are the same as for the <tt> _pg_chartms</tt> routine.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_analyzechart</tt> routines return zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_analyzepie">_pg_analyzepie</a>,
 <a href="#_pg_analyzescatter">_pg_analyzescatter</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_analyzechart( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; values, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use manual scaling</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.autoscale = 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.scalemin = 0.0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.scalemax = 100.0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.ticinterval = 25.0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _pg_analyzechart - DOS, QNX</tt>
<br><tt>_pg_analyzechartms - DOS, QNX</tt>
</dl>
<h2 id="_pg_analyzepie"> _pg_analyzepie </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_analyzepie( env, cat, values,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; explode, n )</tt>
<br><tt>record /chartenv/ env</tt>
<br><tt>integer*4 cat(*)</tt>
<br><tt>real values(*)</tt>
<br><tt>integer*2 explode(*), n</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_analyzepie</tt> routine analyzes a pie chart.&nbsp; This routine calculates default values for chart elements
 without actually displaying the chart.
<br>The chart environment structure<b> env</b> is filled with default values based on the values of the<b> cat</b>,<b> values</b>
 and<b> explode</b> arguments.&nbsp; The arguments are the same as for the <tt> _pg_chartpie</tt> routine.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_analyzepie</tt> routine returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_analyzechart">_pg_analyzechart</a>,
 <a href="#_pg_analyzescatter">_pg_analyzescatter</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 explode( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 1, 0, 0,
 0 /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_PIECHART, _PG_NOPERCENT )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Pie Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.legend.place = _PG_BOTTOM</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_analyzepie( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, explode, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! make legend window same width as data window</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.legend.autosize = 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.legend.legendwindow.x1 = env.datawindow.x1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.legend.legendwindow.x2 = env.datawindow.x2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chartpie( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, explode, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_analyzescatter"> _pg_analyzescatter, _pg_analyzescatterms </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_analyzescatter( env, x, y, n )</tt>
<br><tt>record /chartenv/ env</tt>
<br><tt>real x(*), y(*)</tt>
<br><tt>integer*2 n</tt>
<br><br><tt>integer*2 function _pg_analyzescatterms( env, x, y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 nseries, n,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 dim, labels )</tt>
<br><tt>record /chartenv/ env</tt>
<br><tt>real x(*), y(*)</tt>
<br><tt>integer*2 nseries, n, dim</tt>
<br><tt>integer*4 labels(*)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_analyzescatter</tt> routines analyze either a single-series or a multi-series scatter chart.&nbsp; These routines
 calculate default values for chart elements without actually displaying the chart.
<br>The<tt> _pg_analyzescatter</tt> routine analyzes a single-series scatter chart.&nbsp; The chart environment structure<b>
 env</b> is filled with default values based on the values of the<b> x</b> and<b> y</b> arguments.&nbsp; The arguments are
 the same as for the <tt> _pg_chartscatter</tt> routine.
<br><br>The<tt> _pg_analyzescatterms</tt> routine analyzes a multi-series scatter chart.&nbsp; The chart environment structure<b>
 env</b> is filled with default values based on the values of the<b> x</b>,<b> y</b> and<b> labels</b> arguments.&nbsp; The
 arguments are the same as for the <tt> _pg_chartscatterms</tt> routine.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_analyzescatter</tt> routines return zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_analyzechart">_pg_analyzechart</a>,
 <a href="#_pg_analyzepie">_pg_analyzepie</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_SERIES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_SERIES=2)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 labels( NUM_SERIES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real x( NUM_SERIES, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 5, 15,
 30, 40, 10, 20, 30, 45 /</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real y( NUM_SERIES, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 10, 15,
 30, 45, 40, 30, 15, 5 /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labels( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labels( 2 ) = loc( 'Feb'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 _PG_SCATTERCHART, _PG_POINTANDLINE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Scatter Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_analyzescatterms( env, x, y, NUM_SERIES,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; NUM_VALUES, NUM_VALUES, labels )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! display x-axis labels with 2 decimal places</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.xaxis.autoscale = 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.xaxis.ticdecimals = 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chartscatterms( env, x, y, NUM_SERIES,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; NUM_VALUES, NUM_VALUES, labels )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _pg_analyzescatter - DOS, QNX</tt>
<br><tt>_pg_analyzescatterms - DOS, QNX</tt>
</dl>
<h2 id="_pg_chart"> _pg_chart, _pg_chartms </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_chart( env, cat, values, n )</tt>
<br><tt>record /chartenv/ env</tt>
<br><tt>integer*4 cat(*)</tt>
<br><tt>real values(*)</tt>
<br><tt>integer*2 n</tt>
<br><br><tt>integer*2 function _pg_chartms( env, cat, values, nseries,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n, dim, labels )</tt>
<br><tt>record /chartenv/ env</tt>
<br><tt>integer*4 cat(*)</tt>
<br><tt>real values(*)</tt>
<br><tt>integer*2 nseries, n, dim</tt>
<br><tt>integer*4 labels(*)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_chart</tt> routines display either a single-series or a multi-series bar, column or line chart.&nbsp; The type
 of chart displayed and other chart options are contained in the<b> env</b> argument.&nbsp; The argument<b> cat</b> is an
 array of addresses of strings.&nbsp; These strings describe the categories against which the data in the<b> values</b> array
 is charted.
<br>The<tt> _pg_chart</tt> routine displays a bar, column or line chart from the single series of data contained in the<b>
 values</b> array.&nbsp; The argument<b> n</b> specifies the number of values to chart.
<br><br>The<tt> _pg_chartms</tt> routine displays a multi-series bar, column or line chart.&nbsp; The argument<b> nseries</b>
 specifies the number of series of data to chart.&nbsp; The argument<b> values</b> is assumed to be a two-dimensional array
 defined as follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; real values( nseries, dim )</tt>
<br><br>The number of values used from each series is given by the argument<b> n</b>, where<b> n</b> is less than or equal
 to<b> dim</b>.&nbsp; The argument<b> labels</b> is an array of addresses of strings.&nbsp; These strings describe each of
 the series and are used in the chart legend.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_chart</tt> routines return zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chartpie">_pg_chartpie</a>,
 <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_analyzechart">_pg_analyzechart</a>, <a href="#_pg_analyzepie">_pg_analyzepie</a>,
 <a href="#_pg_analyzescatter">_pg_analyzescatter</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_pgc.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _pg_chart - DOS, QNX</tt>
<br><tt>_pg_chartms - DOS, QNX</tt>
</dl>
<h2 id="_pg_chartpie"> _pg_chartpie </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_chartpie( env, cat, values, explode, n )</tt>
<br><tt>record /chartenv/ env</tt>
<br><tt>integer*4 cat(*)</tt>
<br><tt>real values(*)</tt>
<br><tt>integer*2 explode(*), n</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_chartpie</tt> routine displays a pie chart.&nbsp; The chart is displayed using the options specified in the<b>
 env</b> argument.
<br>The pie chart is created from the data contained in the<b> values</b> array.&nbsp; The argument<b> n</b> specifies the
 number of values to chart.
<br><br>The argument<b> cat</b> is an array of addresses of strings.&nbsp; These strings describe each of the pie slices and
 are used in the chart legend.&nbsp; The argument<b> explode</b> is an array of values corresponding to each of the pie slices.
&nbsp; For each non-zero element in the array, the corresponding pie slice is drawn &quot;exploded&quot;, or slightly offset
 from the rest of the pie.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_chartpie</tt> routine returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_analyzechart">_pg_analyzechart</a>, <a href="#_pg_analyzepie">_pg_analyzepie</a>,
 <a href="#_pg_analyzescatter">_pg_analyzescatter</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 explode( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 1, 0, 0,
 0 /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_PIECHART, _PG_NOPERCENT )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Pie Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chartpie( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, explode, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_pgcp.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_chartscatter"> _pg_chartscatter, _pg_chartscatterms </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_chartscatter( env, x, y, n )</tt>
<br><tt>record /chartenv/ env</tt>
<br><tt>float x(*), y(*)</tt>
<br><tt>integer*2 n</tt>
<br><br><tt>integer*2 function _pg_chartscatterms( env, x, y, nseries,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n, dim,
 labels )</tt>
<br><tt>record /chartenv/ env</tt>
<br><tt>real x(*), y(*)</tt>
<br><tt>integer*2 nseries, n, dim</tt>
<br><tt>integer*4 labels(*)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_chartscatter</tt> routines display either a single-series or a multi-series scatter chart.&nbsp; The chart is
 displayed using the options specified in the<b> env</b> argument.
<br>The<tt> _pg_chartscatter</tt> routine displays a scatter chart from the single series of data contained in the arrays<b>
 x</b> and<b> y</b>.&nbsp; The argument<b> n</b> specifies the number of values to chart.
<br><br>The<tt> _pg_chartscatterms</tt> routine displays a multi-series scatter chart.&nbsp; The argument<b> nseries</b> specifies
 the number of series of data to chart.&nbsp; The arguments<b> x</b> and<b> y</b> are assumed to be two-dimensional arrays
 defined as follows:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; real x( nseries, dim )</tt>
<br><br>The number of values used from each series is given by the argument<b> n</b>, where<b> n</b> is less than or equal
 to<b> dim</b>.&nbsp; The argument<b> labels</b> is an array of addresses of strings.&nbsp; These strings describe each of
 the series and are used in the chart legend.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_chartscatter</tt> routines return zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_analyzechart">_pg_analyzechart</a>, <a href="#_pg_analyzepie">_pg_analyzepie</a>,
 <a href="#_pg_analyzescatter">_pg_analyzescatter</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_SERIES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_SERIES=2)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 labels( NUM_SERIES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real x( NUM_SERIES, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 5, 15,
 30, 40, 10, 20, 30, 45 /</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real y( NUM_SERIES, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 10, 15,
 30, 45, 40, 30, 15, 5 /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labels( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; labels( 2 ) = loc( 'Feb'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 _PG_SCATTERCHART, _PG_POINTANDLINE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Scatter Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chartscatterms( env, x, y, NUM_SERIES,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; NUM_VALUES, NUM_VALUES, labels )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_pgcs.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _pg_chartscatter - DOS, QNX</tt>
<br><tt>_pg_chartscatterms - DOS, QNX</tt>
</dl>
<h2 id="_pg_defaultchart"> _pg_defaultchart </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_defaultchart( env, type, style )</tt>
<br><tt>record /chartenv/ env</tt>
<br><tt>integer*2 type, style</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_defaultchart</tt> routine initializes the chart structure<b> env</b> to contain default values before a chart
 is drawn.&nbsp; All values in the chart structure are initialized, including blanking of all titles.&nbsp; The chart type
 in the structure is initialized to the value<b> type</b>, and the chart style is initialized to<b> style</b>.
<br>The argument<b> type</b> can have one of the following values:
<dl>
<dt>_PG_BARCHART
<dd>Bar chart (horizontal bars)
<dt><br>_PG_COLUMNCHART
<dd>Column chart (vertical bars)
<dt><br>_PG_LINECHART
<dd>Line chart
<dt><br>_PG_SCATTERCHART
<dd>Scatter chart
<dt><br>_PG_PIECHART
<dd>Pie chart
</dl>
<br>Each type of chart can be drawn in one of two styles.&nbsp; For each chart type the argument<b> style</b> can have one
 of the following values:&nbsp; uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Style 1&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Style 2</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Bar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_PLAINBARS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_STACKEDBARS</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Column&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_PLAINBARS&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_STACKEDBARS</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Line&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTANDLINE&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTONLY</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Scatter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTANDLINE&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; _PG_POINTONLY</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Pie&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_PERCENT&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _PG_NOPERCENT</tt>
<br><br>For single-series bar and column charts, the chart style is ignored.&nbsp; The &quot;plain&quot; (clustered) and &quot;stacked&quot;
 styles only apply when there is more than one series of data.&nbsp; The &quot;percent&quot; style for pie charts causes percentages
 to be displayed beside each of the pie slices.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_defaultchart</tt> routine returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>, <a href="#_pg_chartpie">_pg_chartpie</a>,
 <a href="#_pg_chartscatter">_pg_chartscatter</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_getchardef"> _pg_getchardef </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_getchardef( ch, def )</tt>
<br><tt>integer*2 ch</tt>
<br><tt>integer*1 def(8)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_getchardef</tt> routine retrieves the current bit-map definition for the character<b> ch</b>.&nbsp; The bit-map
 is placed in the array<b> def</b>.&nbsp; The current font must be an 8-by-8 bit-mapped font.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_getchardef</tt> routine returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_setchardef">_pg_setchardef</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real x( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 5, 25,
 45, 65 /</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real y( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 5, 45,
 25, 65 /</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 diamond( 8 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / '10'x, '28'x,
 '44'x, '82'x,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '44'x,
 '28'x, '10'x, '00'x /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 old_def( 8 )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 _PG_SCATTERCHART, _PG_POINTANDLINE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Scatter Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! change asterisk character to diamond</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getchardef( ichar( '*' ), old_def )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setchardef( ichar( '*' ), diamond )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chartscatter( env, x, y, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setchardef( ichar( '*' ), old_def )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_getpalette"> _pg_getpalette </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_getpalette( pal )</tt>
<br><tt>record /paletteentry/ pal(*)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_getpalette</tt> routine retrieves the internal palette of the presentation graphics system.&nbsp; The palette
 controls the colors, line styles, fill patterns and plot characters used to display each series of data in a chart.
<br>The argument<b> pal</b> is an array of palette structures that will contain the palette.&nbsp; Each element of the palette
 is a structure containing the following fields:
<dl>
<dt>color
<dd>color used to display series
<dt><br>style
<dd>line style used for line and scatter charts
<dt><br>fill
<dd>fill pattern used to fill interior of bar and pie sections
<dt><br>plotchar
<dd>character plotted on line and scatter charts
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_getpalette</tt> routine returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_setpalette">_pg_setpalette</a>,
 <a href="#_pg_resetpalette">_pg_resetpalette</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 bricks( 8 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 'ff'x,
 '80'x, '80'x, '80'x,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 'ff'x, '08'x, '08'x, '08'x /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /paletteentry/ pal( _PG_PALETTELEN )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get default palette and change 1st entry</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getpalette( pal )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal( 2 ).color = 12</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 8</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal( 2 ).fill( i ) = bricks( i )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use new palette</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setpalette( pal )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! reset palette to default</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_resetpalette()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_getstyleset"> _pg_getstyleset </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _pg_getstyleset( style )</tt>
<br><tt>integer*2 style(*)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_getstyleset</tt> routine retrieves the internal style-set of the presentation graphics system.&nbsp; The style-set
 is a set of line styles used for drawing window borders and grid-lines.&nbsp; The argument<b> style</b> is an array that
 will contain the style-set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_setstyleset">_pg_setstyleset</a>,
 <a href="#_pg_resetstyleset">_pg_resetstyleset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 style( _PG_PALETTELEN )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! turn on yaxis grid, and use style 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.grid = 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.gridstyle = 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get default style-set and change entry 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getstyleset( style )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style( 3 ) = '8888'x</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use new style-set</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setstyleset( style )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! reset style-set to default</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_resetstyleset()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_hlabelchart"> _pg_hlabelchart </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_hlabelchart( env, x, y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color, label )</tt>
<br><tt>record /chartenv/ env</tt>
<br><tt>integer*2 x, y, color</tt>
<br><tt>character*(*) label</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_hlabelchart</tt> routine displays the text string<b> label</b> on the chart described by the<b> env</b> chart
 structure.&nbsp; The string is displayed horizontally starting at the point<tt> (x,y),</tt> relative to the upper left corner
 of the chart.&nbsp; The<b> color</b> specifies the palette color used to display the string.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_hlabelchart</tt> routine returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_vlabelchart">_pg_vlabelchart</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_hlabelchart( env, 64, 32, 1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 'Horizontal label'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_vlabelchart( env, 48, 32, 1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 'Vertical label'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_initchart"> _pg_initchart </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_initchart()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_initchart</tt> routine initializes the presentation graphics system.&nbsp; This includes initializing the internal
 palette and style-set used when drawing charts.&nbsp; This routine must be called before any of the other presentation graphics
 routines.
<br>The initialization of the presentation graphics system requires that a valid graphics mode has been selected.&nbsp; For
 this reason the <tt> _setvideomode</tt> routine must be called before<tt> _pg_initchart</tt> is called.&nbsp; If a font has
 been selected (with the <tt> _setfont</tt> routine), that font will be used when text is displayed in a chart.&nbsp; Font
 selection should also be done before initializing the presentation graphics system.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_initchart</tt> routine returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_chart">_pg_chart</a>, <a href="#_pg_chartpie">_pg_chartpie</a>,
 <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_setvideomode">_setvideomode</a>, <a href="#_setfont">_setfont</a>,
 <a href="#_registerfonts">_registerfonts</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_resetpalette"> _pg_resetpalette </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_resetpalette()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_resetpalette</tt> routine resets the internal palette of the presentation graphics system to default values.&nbsp;
 The palette controls the colors, line styles, fill patterns and plot characters used to display each series of data in a
 chart.&nbsp; The default palette chosen is dependent on the current video mode.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_resetpalette</tt> routine returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_getpalette">_pg_getpalette</a>,
 <a href="#_pg_setpalette">_pg_setpalette</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 bricks( 8 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 'ff'x,
 '80'x, '80'x, '80'x,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 'ff'x, '08'x, '08'x, '08'x /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /paletteentry/ pal( _PG_PALETTELEN )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get default palette and change 1st entry</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getpalette( pal )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal( 2 ).color = 12</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 8</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal( 2 ).fill( i ) = bricks( i )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use new palette</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setpalette( pal )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! reset palette to default</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_resetpalette()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_resetstyleset"> _pg_resetstyleset </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _pg_resetstyleset()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_resetstyleset</tt> routine resets the internal style-set of the presentation graphics system to default values.
&nbsp; The style-set is a set of line styles used for drawing window borders and grid-lines.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_getstyleset">_pg_getstyleset</a>,
 <a href="#_pg_setstyleset">_pg_setstyleset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 style( _PG_PALETTELEN )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! turn on yaxis grid, and use style 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.grid = 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.gridstyle = 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get default style-set and change entry 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getstyleset( style )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style( 3 ) = '8888'x</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use new style-set</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setstyleset( style )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! reset style-set to default</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_resetstyleset()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_setchardef"> _pg_setchardef </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_setchardef( ch, def )</tt>
<br><tt>integer*2 ch</tt>
<br><tt>integer*1 def(8)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_setchardef</tt> routine sets the current bit-map definition for the character<b> ch</b>.&nbsp; The bit-map is
 contained in the array<b> def</b>.&nbsp; The current font must be an 8-by-8 bit-mapped font.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_setchardef</tt> routine returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_getchardef">_pg_getchardef</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real x( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 5, 25,
 45, 65 /</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real y( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 5, 45,
 25, 65 /</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 diamond( 8 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / '10'x, '28'x,
 '44'x, '82'x,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '44'x,
 '28'x, '10'x, '00'x /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 old_def( 8 )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 _PG_SCATTERCHART, _PG_POINTANDLINE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Scatter Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! change asterisk character to diamond</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getchardef( ichar( '*' ), old_def )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setchardef( ichar( '*' ), diamond )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chartscatter( env, x, y, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setchardef( ichar( '*' ), old_def )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_setpalette"> _pg_setpalette </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_setpalette( pal )</tt>
<br><tt>record /paletteentry/ pal(*)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_setpalette</tt> routine sets the internal palette of the presentation graphics system.&nbsp; The palette controls
 the colors, line styles, fill patterns and plot characters used to display each series of data in a chart.
<br>The argument<b> pal</b> is an array of palette structures containing the new palette.&nbsp; Each element of the palette
 is a structure containing the following fields:
<dl>
<dt>color
<dd>color used to display series
<dt><br>style
<dd>line style used for line and scatter charts
<dt><br>fill
<dd>fill pattern used to fill interior of bar and pie sections
<dt><br>plotchar
<dd>character plotted on line and scatter charts
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_setpalette</tt> routine returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_getpalette">_pg_getpalette</a>,
 <a href="#_pg_resetpalette">_pg_resetpalette</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 bricks( 8 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 'ff'x,
 '80'x, '80'x, '80'x,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 'ff'x, '08'x, '08'x, '08'x /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /paletteentry/ pal( _PG_PALETTELEN )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get default palette and change 1st entry</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getpalette( pal )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal( 2 ).color = 12</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 8</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pal( 2 ).fill( i ) = bricks( i )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use new palette</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setpalette( pal )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! reset palette to default</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_resetpalette()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_setstyleset"> _pg_setstyleset </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _pg_setstyleset( style )</tt>
<br><tt>integer*2 style(*)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_setstyleset</tt> routine retrieves the internal style-set of the presentation graphics system.&nbsp; The style-set
 is a set of line styles used for drawing window borders and grid-lines.&nbsp; The argument<b> style</b> is an array containing
 the new style-set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_getstyleset">_pg_getstyleset</a>,
 <a href="#_pg_resetstyleset">_pg_resetstyleset</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 style( _PG_PALETTELEN )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! turn on yaxis grid, and use style 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.grid = 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.yaxis.gridstyle = 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! get default style-set and change entry 2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_getstyleset( style )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; style( 3 ) = '8888'x</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! use new style-set</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_setstyleset( style )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! reset style-set to default</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_resetstyleset()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pg_vlabelchart"> _pg_vlabelchart </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pg_vlabelchart( env, x, y,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; color, label )</tt>
<br><tt>record /chartenv/ env</tt>
<br><tt>integer*2 x, y, color</tt>
<br><tt>character*(*) label</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pg_vlabelchart</tt> routine displays the text string<b> label</b> on the chart described by the<b> env</b> chart
 structure.&nbsp; The string is displayed vertically starting at the point<tt> (x,y),</tt> relative to the upper left corner
 of the chart.&nbsp; The<b> color</b> specifies the palette color used to display the string.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pg_vlabelchart</tt> routine returns zero if successful; otherwise, a non-zero value is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_pg_defaultchart">_pg_defaultchart</a>, <a href="#_pg_initchart">_pg_initchart</a>, <a href="#_pg_chart">_pg_chart</a>,
 <a href="#_pg_chartpie">_pg_chartpie</a>, <a href="#_pg_chartscatter">_pg_chartscatter</a>, <a href="#_pg_hlabelchart">_pg_hlabelchart</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pgapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'pg.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer NUM_VALUES</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (NUM_VALUES=4)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*4 categories( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real values( NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; / 20, 45,
 30, 25 /</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /chartenv/ env</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 1 ) = loc( 'Jan'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 2 ) = loc( 'Feb'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 3 ) = loc( 'Mar'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories( 4 ) = loc( 'Apr'c )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_initchart()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_defaultchart( env,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; _PG_COLUMNCHART, _PG_PLAINBARS )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; env.maintitle.title = 'Column Chart'c</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_chart( env, categories,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; values, NUM_VALUES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_hlabelchart( env, 64, 32, 1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 'Horizontal label'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pg_vlabelchart( env, 48, 32, 1,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; 'Vertical label'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_pie"> _pie, _pie_w, _pie_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _pie( fill, x1, y1, x2, y2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x3, y3, x4, y4 )</tt>
<br><tt>integer*2 fill</tt>
<br><tt>integer*2 x1, y1</tt>
<br><tt>integer*2 x2, y2</tt>
<br><tt>integer*2 x3, y3</tt>
<br><tt>integer*2 x4, y4</tt>
<br><br><tt>integer*2 function _pie_w( fill, x1, y1, x2, y2,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x3, y3, x4, y4 )</tt>
<br><tt>integer*2 fill</tt>
<br><tt>double precision x1, y1</tt>
<br><tt>double precision x2, y2</tt>
<br><tt>double precision x3, y3</tt>
<br><tt>double precision x4, y4</tt>
<br><br><tt>integer*2 function _pie_wxy( fill, p1, p2, p3, p4 )</tt>
<br><tt>integer*2 fill,</tt>
<br><tt>record /_wxycoord/ p1, p2</tt>
<br><tt>record /_wxycoord/ p3, p4</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _pie</tt> routines draw pie-shaped wedges.&nbsp; The<tt> _pie</tt> routine uses the view coordinate system.&nbsp;
 The<tt> _pie_w</tt> and<tt> _pie_wxy</tt> routines use the window coordinate system.
<br>The pie wedges are drawn by drawing an elliptical arc (in the way described for the <tt> _arc</tt> routines) and then
 joining the center of the rectangle that contains the ellipse to the two endpoints of the arc.
<br><br>The elliptical arc is drawn with its center at the center of the rectangle established by the points<tt> (x1,y1)</tt>
 and<tt> (x2,y2).</tt>&nbsp; The arc is a segment of the ellipse drawn within this bounding rectangle.&nbsp; The arc starts
 at the point on this ellipse that intersects the vector from the centre of the ellipse to the point<tt> (x3,y3).</tt>&nbsp;
 The arc ends at the point on this ellipse that intersects the vector from the centre of the ellipse to the point<tt> (x4,y4).</tt>
&nbsp; The arc is drawn in a counter-clockwise direction with the current plot action using the current color and the current
 line style.
<br><br>The following picture illustrates the way in which the bounding rectangle and the vectors specifying the start and
 end points are defined.
<br><br><img src="pic2.bmp" style="vertical-align:middle">
<br>When the coordinates<tt> (x1,y1)</tt> and<tt> (x2,y2)</tt> establish a line or a point (this happens when one or more
 of the x-coordinates or y-coordinates are equal), nothing is drawn.
<br><br>The argument<b> fill</b> determines whether the figure is filled in or has only its outline drawn.&nbsp; The argument
 can have one of two values:
<dl>
<dt>_GFILLINTERIOR
<dd>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<dt><br>_GBORDER
<dd>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
 style
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _pie</tt> routines return a non-zero value when the figure was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_arc">_arc</a>, <a href="#_ellipse">_ellipse</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_setfillmask">_setfillmask</a>,
 <a href="#_setlinestyle">_setlinestyle</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _pie( _GBORDER, 120, 90, 520, 390,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 140, 20, 190, 460 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_pie.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _pie - DOS, QNX</tt>
<br><tt>_pie_w - DOS, QNX</tt>
<br><tt>_pie_wxy - DOS, QNX</tt>
</dl>
<h2 id="_polygon"> _polygon, _polygon_w, _polygon_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _polygon( fill, numpts, points )</tt>
<br><tt>integer*2 fill</tt>
<br><tt>integer*2 numpts</tt>
<br><tt>record /xycoord/ points(*)</tt>
<br><br><tt>integer*2 function _polygon_w( fill, numpts, points )</tt>
<br><tt>integer*2 fill</tt>
<br><tt>integer*2 numpts</tt>
<br><tt>double precision points(*)</tt>
<br><br><tt>integer*2 function _polygon_wxy( fill, numpts, points )</tt>
<br><tt>integer*2 fill</tt>
<br><tt>integer*2 numpts</tt>
<br><tt>record /_wxycoord/ points(*)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _polygon</tt> routines draw polygons.&nbsp; The<tt> _polygon</tt> routine uses the view coordinate system.&nbsp; The<tt>
 _polygon_w</tt> and<tt> _polygon_wxy</tt> routines use the window coordinate system.
<br>The polygon is defined as containing<b> numpts</b> points whose coordinates are given in the array<b> points</b>.
<br><br>The argument<b> fill</b> determines whether the polygon is filled in or has only its outline drawn.&nbsp; The argument
 can have one of two values:
<dl>
<dt>_GFILLINTERIOR
<dd>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<dt><br>_GBORDER
<dd>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
 style
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _polygon</tt> routines return a non-zero value when the polygon was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setcolor">_setcolor</a>, <a href="#_setfillmask">_setfillmask</a>, <a href="#_setlinestyle">_setlinestyle</a>,
 <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ points(5)/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 319, 140, 224, 209, 261, 320,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 378, 320, 415, 209/</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _polygon( _GBORDER, 5, points )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_polyg.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _polygon - DOS, QNX</tt>
<br><tt>_polygon_w - DOS, QNX</tt>
<br><tt>_polygon_wxy - DOS, QNX</tt>
</dl>
<h2 id="_putimage"> _putimage, _putimage_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _putimage( x, y, image, mode )</tt>
<br><tt>integer*2 x, y</tt>
<br><tt>integer*1 image(*)</tt>
<br><tt>integer*2 mode</tt>
<br><br><tt>subroutine _putimage_w( x, y, image, mode )</tt>
<br><tt>double precision x, y</tt>
<br><tt>integer*1 image(*)</tt>
<br><tt>integer*2 mode</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _putimage</tt> routines display the screen image indicated by the argument<b> image</b>.&nbsp; The<tt> _putimage</tt>
 routine uses the view coordinate system.&nbsp; The<tt> _putimage_w</tt> routine uses the window coordinate system.
<br>The image is displayed upon the screen with its top left corner located at the point with coordinates<tt> (x,y).</tt>
&nbsp; The image was previously saved using the <tt> _getimage</tt> routines.&nbsp; The image is displayed in a rectangle
 whose size is the size of the rectangular image saved by the <tt> _getimage</tt> routines.
<br><br>The image can be displayed in a number of ways, depending upon the value of the<b> mode</b> argument.&nbsp; This argument
 can have the following values:
<dl>
<dt>_GPSET
<dd>replace the rectangle on the screen by the saved image
<dt><br>_GPRESET
<dd>replace the rectangle on the screen with the pixel values of the saved image inverted; this produces a negative image
<dt><br>_GAND
<dd>produce a new image on the screen by ANDing together the pixel values from the screen with those from the saved image
<dt><br>_GOR
<dd>produce a new image on the screen by ORing together the pixel values from the screen with those from the saved image
<dt><br>_GXOR
<dd>produce a new image on the screen by exclusive ORing together the pixel values from the screen with those from the saved image;
 the original screen is restored by two successive calls to the<tt> _putimage</tt> routine with this value, providing an efficient
 method to produce animated effects
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getimage">_getimage</a>, <a href="#_imagesize">_imagesize</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 image(:)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer y, image_size, istat</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 100, 100, 200, 200 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; image_size = _imagesize( 100, 100, 201, 201 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allocate( image(image_size), stat = istat )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( istat .eq. 0 )then</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getimage( 100, 100, 201, 201, image )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 260, 200, image, _GPSET )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, 100, image, _GPSET )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do y = 100, 280, 20</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, y,
 image, _GXOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _putimage( 420, y+20,
 image, _GXOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deallocate( image )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _putimage - DOS, QNX</tt>
<br><tt>_putimage_w - DOS, QNX</tt>
</dl>
<h2 id="_rectangle"> _rectangle, _rectangle_w, _rectangle_wxy </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _rectangle( fill, x1, y1, x2, y2 )</tt>
<br><tt>integer*2 fill</tt>
<br><tt>integer*2 x1, y1</tt>
<br><tt>integer*2 x2, y2</tt>
<br><br><tt>integer*2 function _rectangle_w( fill, x1, y1, x2, y2 )</tt>
<br><tt>integer*2 fill</tt>
<br><tt>double precision x1, y1</tt>
<br><tt>double precision x2, y2</tt>
<br><br><tt>integer*2 function _rectangle_wxy( fill, p1, p2 )</tt>
<br><tt>integer*2 fill</tt>
<br><tt>record /_wxycoord/ p1, p2</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _rectangle</tt> routines draw rectangles.&nbsp; The<tt> _rectangle</tt> routine uses the view coordinate system.&nbsp;
 The<tt> _rectangle_w</tt> and<tt> _rectangle_wxy</tt> routines use the window coordinate system.
<br>The rectangle is defined with opposite corners established by the points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>
<br><br>The argument<b> fill</b> determines whether the rectangle is filled in or has only its outline drawn.&nbsp; The argument
 can have one of two values:
<dl>
<dt>_GFILLINTERIOR
<dd>fill the interior by writing pixels with the current plot action using the current color and the current fill mask
<dt><br>_GBORDER
<dd>leave the interior unchanged; draw the outline of the figure with the current plot action using the current color and line
 style
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _rectangle</tt> routines return a non-zero value when the rectangle was successfully drawn; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setcolor">_setcolor</a>, <a href="#_setfillmask">_setfillmask</a>, <a href="#_setlinestyle">_setlinestyle</a>,
 <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100, 540, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_rect.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _rectangle - DOS, QNX</tt>
<br><tt>_rectangle_w - DOS, QNX</tt>
<br><tt>_rectangle_wxy - DOS, QNX</tt>
</dl>
<h2 id="_registerfonts"> _registerfonts </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _registerfonts( path )</tt>
<br><tt>character*(*) path</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _registerfonts</tt> routine initializes the font graphics system.&nbsp; Fonts must be registered, and a font selected,
 before text can be displayed with the <tt> _outgtext</tt> routine.
<br>The argument<b> path</b> specifies the location of the font files.&nbsp; This argument is a file specification, and can
 contain drive and directory components and may contain wildcard characters.&nbsp; The<tt> _registerfonts</tt> routine opens
 each of the font files specified and reads the font information.&nbsp; Memory is allocated to store the characteristics of
 the font.&nbsp; These font characteristics are used by the <tt> _setfont</tt> routine when selecting a font.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _registerfonts</tt> routine returns the number of fonts that were registered if the routine is successful; otherwise,
 a negative number is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_setfont">_setfont</a>, <a href="#_getfontinfo">_getfontinfo</a>,
 <a href="#_outgtext">_outgtext</a>, <a href="#_getgtextextent">_getgtextextent</a>, <a href="#_setgtextvector">_setgtextvector</a>,
 <a href="#_getgtextvector">_getgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i, n</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*10 buff</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = _registerfonts( '*.fon'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, n - 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''n'', i2.2, a1 )' ) i, char(0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfont( buff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GCLEARSCREEN )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _unregisterfonts()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_remapallpalette"> _remapallpalette </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _remapallpalette( colors )</tt>
<br><tt>integer*4 colors(*)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _remapallpalette</tt> routine sets (or remaps) all of the colors in the palette.&nbsp; The color values in the palette
 are replaced by the array of color values given by the argument<b> colors</b>.&nbsp; This routine is supported in all video
 modes, but only works with EGA, MCGA and VGA adapters.
<br>The array<b> colors</b> must contain at least as many elements as there are supported colors.&nbsp; The newly mapped palette
 will cause the complete screen to change color wherever there is a pixel value of a changed color in the palette.
<br><br>The representation of colors depends upon the hardware being used.&nbsp; The number of colors in the palette can be
 determined by using the <tt> _getvideoconfig</tt> routine.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _remapallpalette</tt> routine returns (-1) if the palette is remapped successfully and zero otherwise.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_remappalette">_remappalette</a>, <a href="#_getvideoconfig">_getvideoconfig</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer colors(16)/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BRIGHTWHITE, _YELLOW, _LIGHTMAGENTA,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTRED, _LIGHTCYAN, _LIGHTGREEN,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTBLUE, _GRAY, _WHITE, _BROWN,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _MAGENTA, _RED, _CYAN,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _GREEN, _BLUE, _BLACK/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer x, y</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do y = 0, 3</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do x = 0, 3</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( x + 4 *
 y )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 x * 160, y * 120,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 ( x + 1 ) * 160, ( y + 1 ) * 120 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _remapallpalette( colors )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_remappalette"> _remappalette </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*4 function _remappalette( pixval, color )</tt>
<br><tt>integer*2 pixval</tt>
<br><tt>integer*4 color</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _remappalette</tt> routine sets (or remaps) the palette color<b> pixval</b> to be the color<b> color</b>.&nbsp; This
 routine is supported in all video modes, but only works with EGA, MCGA and VGA adapters.
<br>The argument<b> pixval</b> is an index in the color palette of the current video mode.&nbsp; The argument<b> color</b>
 specifies the actual color displayed on the screen by pixels with pixel value<b> pixval</b>.&nbsp; Color values are selected
 by specifying the red, green and blue intensities that make up the color.&nbsp; Each intensity can be in the range from 0
 to 63, resulting in 262144 possible different colors.&nbsp; A given color value can be conveniently specified as a value
 of type<tt> integer*4.</tt>&nbsp; The color value is of the form<tt> '00bbggrr'x,</tt> where<tt> bb</tt> is the blue intensity,<tt>
 gg</tt> is the green intensity and<tt> rr</tt> is the red intensity of the selected color.&nbsp; The file<tt> graph.fi</tt>
 defines constants containing the color intensities of each of the 16 default colors.
<br><br>The<tt> _remappalette</tt> routine takes effect immediately.&nbsp; All pixels on the complete screen which have a
 pixel value equal to the value of<b> pixval</b> will now have the color indicated by the argument<b> color</b>.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _remappalette</tt> routine returns the previous color for the pixel value if the palette is remapped successfully;
 otherwise, (-1) is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_remapallpalette">_remapallpalette</a>, <a href="#_setvideomode">_setvideomode</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer col</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer colors(16)/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BLACK, _BLUE, _GREEN,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _CYAN, _RED, _MAGENTA,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BROWN, _WHITE, _GRAY, _LIGHTBLUE,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTGREEN, _LIGHTCYAN, _LIGHTRED,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTMAGENTA, _YELLOW, _BRIGHTWHITE/</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do col = 1, 16</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _remappalette( 0, colors(col) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_scrolltextwindow"> _scrolltextwindow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _scrolltextwindow( rows )</tt>
<br><tt>integer*2 rows</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _scrolltextwindow</tt> routine scrolls the lines in the current text window.&nbsp; A text window is defined with the
 <tt> _settextwindow</tt> routine.&nbsp; By default, the text window is the entire screen.
<br>The argument<b> rows</b> specifies the number of rows to scroll.&nbsp; A positive value means to scroll the text window
 up or towards the top of the screen.&nbsp; A negative value means to scroll the text window down or towards the bottom of
 the screen.&nbsp; Specifying a number of rows greater than the height of the text window is equivalent to clearing the text
 window with the <tt> _clearscreen</tt> routine.
<br><br>Two constants are defined that can be used with the<tt> _scrolltextwindow</tt> routine:
<dl>
<dt>_GSCROLLUP
<dd>the contents of the text window are scrolled up (towards the top of the screen) by one row
<dt><br>_GSCROLLDOWN
<dd>the contents of the text window are scrolled down (towards the bottom of the screen) by one row
</dl>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextwindow">_settextwindow</a>, <a href="#_clearscreen">_clearscreen</a>, <a href="#_outtext">_outtext</a>,
 <a href="#_outmem">_outmem</a>, <a href="#_settextposition">_settextposition</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextwindow( 5, 20, 20, 40 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 10</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''Line '', i2, a1, a1 )' )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, char(10), char(0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _scrolltextwindow( _GSCROLLDOWN )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _scrolltextwindow( _GSCROLLUP )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_selectpalette"> _selectpalette </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _selectpalette( palnum )</tt>
<br><tt>integer*2 palnum</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _selectpalette</tt> routine selects the palette indicated by the argument<b> palnum</b> from the color palettes available.
&nbsp; This routine is only supported by the video modes<tt> _MRES4COLOR</tt> and<tt> _MRESNOCOLOR.</tt>
<br>Mode<tt> _MRES4COLOR</tt> supports four palettes of four colors.&nbsp; In each palette, color 0, the background color,
 can be any of the 16 possible colors.&nbsp; The color values associated with the other three pixel values, (1, 2 and 3),
 are determined by the selected palette.
<br><br>The following table outlines the available color palettes:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Palette&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pixel
 Values</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Number&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; green&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; red&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brown</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; cyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; magenta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; white</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; light green&nbsp;&nbsp;&nbsp;&nbsp; light red
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yellow</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; light cyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; light
 magenta&nbsp;&nbsp; bright white</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _selectpalette</tt> routine returns the number of the previously selected palette.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setvideomode">_setvideomode</a>, <a href="#_getvideoconfig">_getvideoconfig</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer x, y, pal</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _MRES4COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do y = 0, 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do x = 0, 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( x + 2 *
 y )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 x * 160, y * 100,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 ( x + 1 ) * 160, ( y + 1 ) * 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do pal = 0, 3</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _selectpalette( pal )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setactivepage"> _setactivepage </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _setactivepage( pagenum )</tt>
<br><tt>integer*2 pagenum</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setactivepage</tt> routine selects the page (in memory) to which graphics output is written.&nbsp; The page to be
 selected is given by the<b> pagenum</b> argument.
<br>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple pages
 are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
 what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
 can be constructed without affecting the screen by setting the active page to be different than the visual page.
<br><br>The number of available video pages can be determined by using the <tt> _getvideoconfig</tt> routine.&nbsp; The default
 video page is 0.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setactivepage</tt> routine returns the number of the previous page when the active page is set successfully; otherwise,
 a negative number is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getactivepage">_getactivepage</a>, <a href="#_setvisualpage">_setvisualpage</a>, <a href="#_getvisualpage">_getvisualpage</a>,
 <a href="#_getvideoconfig">_getvideoconfig</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_apage, old_vpage</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _HRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_apage = _getactivepage()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw an ellipse on page 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR, 100, 50,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw a rectangle on page 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 50,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150
 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! display page 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( old_apage )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( old_vpage )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setbkcolor"> _setbkcolor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*4 function _setbkcolor( color )</tt>
<br><tt>integer*4 color</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setbkcolor</tt> routine sets the current background color to be that of the<b> color</b> argument.&nbsp; In text
 modes, the background color controls the area behind each individual character.&nbsp; In graphics modes, the background refers
 to the entire screen.&nbsp; The default background color is 0.
<br>When the current video mode is a graphics mode, any pixels with a zero pixel value will change to the color of the<b>
 color</b> argument.&nbsp; When the current video mode is a text mode, nothing will immediately change; only subsequent output
 is affected.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setbkcolor</tt> routine returns the previous background color.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getbkcolor">_getbkcolor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer bk, old_bk</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer colors(16)/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BLACK, _BLUE, _GREEN,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _CYAN, _RED, _MAGENTA,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _BROWN, _WHITE, _GRAY, _LIGHTBLUE,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTGREEN, _LIGHTCYAN, _LIGHTRED,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _LIGHTMAGENTA, _YELLOW, _BRIGHTWHITE/</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do bk = 1, 16</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( colors( bk ) )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( old_bk )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setcharsize"> _setcharsize, _setcharsize_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _setcharsize( height, width )</tt>
<br><tt>integer*2 height, width</tt>
<br><br><tt>subroutine _setcharsize_w( height, width )</tt>
<br><tt>double precision height, width</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setcharsize</tt> routines set the character height and width to the values specified by the arguments<b> height</b>
 and<b> width</b>.&nbsp; For the<tt> _setcharsize</tt> routine, the arguments<b> height</b> and<b> width</b> represent a number
 of pixels.&nbsp; For the<tt> _setcharsize_w</tt> routine, the arguments<b> height</b> and<b> width</b> represent lengths
 along the y-axis and x-axis in the window coordinate system.
<br>These sizes are used when displaying text with the <tt> _grtext</tt> routine.&nbsp; The default character sizes are dependent
 on the graphics mode selected, and can be determined by the <tt> _gettextsettings</tt> routine.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_gettextsettings">_gettextsettings</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /textsettings/ ts</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _gettextsettings( ts )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 100, 'WATCOM'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcharsize( 2 * ts.height, 2 * ts.width )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 300, 'Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcharsize( ts.height, ts.width )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_getts.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _setcharsize - DOS, QNX</tt>
<br><tt>_setcharsize_w - DOS, QNX</tt>
</dl>
<h2 id="_setcharspacing"> _setcharspacing, _setcharspacing_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _setcharspacing( space )</tt>
<br><tt>integer*2 space</tt>
<br><br><tt>subroutine _setcharspacing_w( space )</tt>
<br><tt>double precision space</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setcharspacing</tt> routines set the current character spacing to have the value of the argument<b> space</b>.&nbsp;
 For the<tt> _setcharspacing</tt> routine,<b> space</b> represents a number of pixels.&nbsp; For the<tt> _setcharspacing_w</tt>
 routine,<b> space</b> represents a length along the x-axis in the window coordinate system.
<br>The character spacing specifies the additional space to leave between characters when a text string is displayed with
 the <tt> _grtext</tt> routine.&nbsp; A negative value can be specified to cause the characters to be drawn closer together.
&nbsp; The default value of the character spacing is 0.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_gettextsettings">_gettextsettings</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 100, 'WATCOM'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcharspacing( 20 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 100, 300, 'Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_setcs.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _setcharspacing - DOS, QNX</tt>
<br><tt>_setcharspacing_w - DOS, QNX</tt>
</dl>
<h2 id="_setcliprgn"> _setcliprgn </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _setcliprgn( x1, y1, x2, y2 )</tt>
<br><tt>integer*2 x1, y1</tt>
<br><tt>integer*2 x2, y2</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setcliprgn</tt> routine restricts the display of graphics output to the clipping region.&nbsp; This region is a rectangle
 whose opposite corners are established by the physical points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>
<br>The<tt> _setcliprgn</tt> routine does not affect text output using the <tt> _outtext</tt> and <tt> _outmem</tt> routines.
&nbsp; To control the location of text output, see the <tt> _settextwindow</tt> routine.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_settextwindow">_settextwindow</a>, <a href="#_setvieworg">_setvieworg</a>, <a href="#_setviewport">_setviewport</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 x1, y1, x2, y2</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getcliprgn( x1, y1, x2, y2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcliprgn( 130, 100, 510, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GBORDER, 120, 90, 520, 390 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcliprgn( x1, y1, x2, y2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setcolor"> _setcolor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _setcolor( pixval )</tt>
<br><tt>integer*2 pixval</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setcolor</tt> routine sets the pixel value for the current color to be that indicated by the<b> pixval</b> argument.
&nbsp; The current color is only used by the routines that produce graphics output; text output with <tt> _outtext</tt> uses
 the current text color (see the <tt> _settextcolor</tt> routine).&nbsp; The default color value is one less than the maximum
 number of colors in the current video mode.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setcolor</tt> routine returns the previous value of the current color.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getcolor">_getcolor</a>, <a href="#_settextcolor">_settextcolor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer col, old_col</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_col = _getcolor()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do col = 0, 15</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( col )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 100, 100, 540, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( old_col )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setfillmask"> _setfillmask </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _setfillmask( mask )</tt>
<br><tt>integer*1 mask(8)</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setfillmask</tt> routine sets the current fill mask to the value of the argument<b> mask</b>.
<br>The fill mask is an eight-byte array which is interpreted as a square pattern (8 by 8) of 64 bits.&nbsp; Each bit in the
 mask corresponds to a pixel.&nbsp; When a region is filled, each point in the region is mapped onto the fill mask.&nbsp;
 When a bit from the mask is one, the pixel value of the corresponding point is set using the current plotting action with
 the current color; when the bit is zero, the pixel value of that point is not affected.
<br><br>When the fill mask is not set, a fill operation will set all points in the fill region to have a pixel value of the
 current color.&nbsp; By default, no fill mask is set.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getfillmask">_getfillmask</a>, <a href="#_ellipse">_ellipse</a>, <a href="#_floodfill">_floodfill</a>, <a href="#_rectangle">_rectangle</a>,
 <a href="#_polygon">_polygon</a>, <a href="#_pie">_pie</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 old_mask(8)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*1 new_mask(8)/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 '81'x, '42'x, '24'x, '18'x,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 '18'x, '24'x, '42'x, '81'x/</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getfillmask( old_mask )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfillmask( new_mask )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 100, 100, 540, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfillmask( old_mask )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_getfm.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setfont"> _setfont </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _setfont( opt )</tt>
<br><tt>character*(*) opt</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setfont</tt> routine selects a font from the list of registered fonts (see the <tt> _registerfonts</tt> routine).
&nbsp; The font selected becomes the current font and is used whenever text is displayed with the <tt> _outgtext</tt> routine.
&nbsp; The routine will fail if no fonts have been registered, or if a font cannot be found that matches the given characteristics.
<br>The argument<b> opt</b> is a string of characters specifying the characteristics of the desired font.&nbsp; These characteristics
 determine which font is selected.&nbsp; The options may be separated by blanks and are not case-sensitive.&nbsp; Any number
 of options may be specified and in any order.&nbsp; The available options are:
<dl>
<dt>hX
<dd>character height X (in pixels)
<dt><br>wX
<dd>character width X (in pixels)
<dt><br>f
<dd>choose a fixed-width font
<dt><br>p
<dd>choose a proportional-width font
<dt><br>r
<dd>choose a raster (bit-mapped) font
<dt><br>v
<dd>choose a vector font
<dt><br>b
<dd>choose the font that best matches the options
<dt><br>nX
<dd>choose font number X (the number of fonts is returned by the <tt> _registerfonts</tt> routine)
<dt><br>t'facename'
<dd>choose a font with specified facename
</dl>
<br>The facename option is specified as a &quot;t&quot; followed by a facename enclosed in single quotes.&nbsp; The available
 facenames are:
<dl>
<dt>Courier
<dd>fixed-width raster font with serifs
<dt><br>Helv
<dd>proportional-width raster font without serifs
<dt><br>Tms Rmn
<dd>proportional-width raster font with serifs
<dt><br>Script
<dd>proportional-width vector font that appears similar to hand-writing
<dt><br>Modern
<dd>proportional-width vector font without serifs
<dt><br>Roman
<dd>proportional-width vector font with serifs
</dl>
<br>When &quot;nX&quot; is specified to select a particular font, the other options are ignored.
<br><br>If the best fit option (&quot;b&quot;) is specified,<tt> _setfont</tt> will always be able to select a font.&nbsp;
 The font chosen will be the one that best matches the options specified.&nbsp; The following precedence is given to the options
 when selecting a font:
<ol>
<li>Pixel height (higher precedence is given to heights less than the specified height)
<li>Facename
<li>Pixel width
<li>Font type (fixed or proportional)
</ol>
<br>When a pixel height or width does not match exactly and a vector font has been selected, the font will be stretched appropriately
 to match the given size.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setfont</tt> routine returns zero if successful; otherwise, (-1) is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_getfontinfo">_getfontinfo</a>,
 <a href="#_outgtext">_outgtext</a>, <a href="#_getgtextextent">_getgtextextent</a>, <a href="#_setgtextvector">_setgtextvector</a>,
 <a href="#_getgtextvector">_getgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i, n</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*10 buff</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = _registerfonts( '*.fon'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, n - 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''n'', i2.2, a1 )' ) i, char(0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfont( buff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GCLEARSCREEN )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _unregisterfonts()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setgtextvector"> _setgtextvector </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>record /xycoord/ function _setgtextvector( x, y )</tt>
<br><tt>integer*2 x, y</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setgtextvector</tt> routine sets the orientation for text output used by the <tt> _outgtext</tt> routine to the vector
 specified by the arguments<tt> (x,y).</tt>&nbsp; Each of the arguments can have a value of -1, 0 or 1, allowing for text
 to be displayed at any multiple of a 45-degree angle.&nbsp; The default text orientation, for normal left-to-right text,
 is the vector<tt> (1,0).</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setgtextvector</tt> routine returns, as an<tt> xycoord</tt> structure, the previous value of the text orientation
 vector.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_unregisterfonts">_unregisterfonts</a>, <a href="#_setfont">_setfont</a>,
 <a href="#_getfontinfo">_getfontinfo</a>, <a href="#_outgtext">_outgtext</a>, <a href="#_getgtextextent">_getgtextextent</a>,
 <a href="#_getgtextvector">_getgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /xycoord/ old_vec</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_vec = _getgtextvector()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setgtextvector( 0, -1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setgtextvector( old_vec.xcoord, old_vec.ycoord )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setlinestyle"> _setlinestyle </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _setlinestyle( style )</tt>
<br><tt>integer*2 style</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setlinestyle</tt> routine sets the current line-style mask to the value of the<b> style</b> argument.
<br>The line-style mask determines the style by which lines and arcs are drawn.&nbsp; The mask is treated as an array of 16
 bits.&nbsp; As a line is drawn, a pixel at a time, the bits in this array are cyclically tested.&nbsp; When a bit in the
 array is 1, the pixel value for the current point is set using the current color according to the current plotting action;
 otherwise, the pixel value for the point is left unchanged.&nbsp; A solid line would result from a value of<tt> 'FFFF'x</tt>
 and a dashed line would result from a value of<tt> 'F0F0'x.</tt>
<br><br>The default line style mask is<tt> 'FFFF'x.</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getlinestyle">_getlinestyle</a>, <a href="#_lineto">_lineto</a>, <a href="#_rectangle">_rectangle</a>, <a href="#_polygon">_polygon</a>,
 <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer DASHED</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (DASHED='f0f0'x)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_style</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_style = _getlinestyle()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setlinestyle( DASHED )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100, 540, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setlinestyle( old_style )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_getls.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setpixel"> _setpixel, _setpixel_w </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _setpixel( x, y )</tt>
<br><tt>integer*2 x, y</tt>
<br><br><tt>integer*2 function _setpixel_w( x, y )</tt>
<br><tt>double precision x, y</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setpixel</tt> routine sets the pixel value of the point<tt> (x,y)</tt> using the current plotting action with the
 current color.&nbsp; The<tt> _setpixel</tt> routine uses the view coordinate system.&nbsp; The<tt> _setpixel_w</tt> routine
 uses the window coordinate system.
<br>A pixel value is associated with each point.&nbsp; The values range from 0 to the number of colors (less one) that can
 be represented in the palette for the current video mode.&nbsp; The color displayed at the point is the color in the palette
 corresponding to the pixel number.&nbsp; For example, a pixel value of 3 causes the fourth color in the palette to be displayed
 at the point in question.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setpixel</tt> routines return the previous value of the indicated pixel if the pixel value can be set; otherwise,
 (-1) is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getpixel">_getpixel</a>, <a href="#_setcolor">_setcolor</a>, <a href="#_setplotaction">_setplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer x, y, i</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; real urand</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer seed</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed = 75347</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GBORDER, 100, 100, 540, 380 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, 60000</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = 101 + mod( int( urand( seed )*32767 ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 439 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = 101 + mod( int( urand( seed )*32767 ),</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 279 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setcolor( _getpixel( x, y ) + 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setpixel( x, y )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd><tt> _setpixel - DOS, QNX</tt>
<br><tt>_setpixel_w - DOS, QNX</tt>
</dl>
<h2 id="_setplotaction"> _setplotaction </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _setplotaction( action )</tt>
<br><tt>integer*2 action</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setplotaction</tt> routine sets the current plotting action to the value of the<b> action</b> argument.
<br>The drawing routines cause pixels to be set with a pixel value.&nbsp; By default, the value to be set is obtained by replacing
 the original pixel value with the supplied pixel value.&nbsp; Alternatively, the replaced value may be computed as a function
 of the original and the supplied pixel values.
<br><br>The plotting action can have one of the following values:
<dl>
<dt>_GPSET
<dd>replace the original screen pixel value with the supplied pixel value
<dt><br>_GAND
<dd>replace the original screen pixel value with the<b> bitwise and</b> of the original pixel value and the supplied pixel value
<dt><br>_GOR
<dd>replace the original screen pixel value with the<b> bitwise or</b> of the original pixel value and the supplied pixel value
<dt><br>_GXOR
<dd>replace the original screen pixel value with the<b> bitwise exclusive-or</b> of the original pixel value and the supplied
 pixel value.&nbsp; Performing this operation twice will restore the original screen contents, providing an efficient method
 to produce animated effects.
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The previous value of the plotting action is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getplotaction">_getplotaction</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_act</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_act = _getplotaction()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setplotaction( _GPSET )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 100,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 380
 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setplotaction( _GXOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 100,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 380
 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setplotaction( old_act )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextalign"> _settextalign </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _settextalign( horiz, vert )</tt>
<br><tt>integer*2 horiz, vert</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextalign</tt> routine sets the current text alignment to the values specified by the arguments<b> horiz</b> and<b>
 vert</b>.&nbsp; When text is displayed with the <tt> _grtext</tt> routine, it is aligned (justified) horizontally and vertically
 about the given point according to the current text alignment settings.
<br>The horizontal component of the alignment can have one of the following values:
<dl>
<dt>_NORMAL
<dd>use the default horizontal alignment for the current setting of the text path
<dt><br>_LEFT
<dd>the text string is left justified at the given point
<dt><br>_CENTER
<dd>the text string is centred horizontally about the given point
<dt><br>_RIGHT
<dd>the text string is right justified at the given point
</dl>
<br>The vertical component of the alignment can have one of the following values:
<dl>
<dt>_NORMAL
<dd>use the default vertical alignment for the current setting of the text path
<dt><br>_TOP
<dd>the top of the text string is aligned at the given point
<dt><br>_CAP
<dd>the cap line of the text string is aligned at the given point
<dt><br>_HALF
<dd>the text string is centred vertically about the given point
<dt><br>_BASE
<dd>the base line of the text string is aligned at the given point
<dt><br>_BOTTOM
<dd>the bottom of the text string is aligned at the given point
</dl>
<br>The default is to use<tt> _LEFT</tt> alignment for the horizontal component unless the text path is<tt> _PATH_LEFT,</tt>
 in which case<tt> _RIGHT</tt> alignment is used.&nbsp; The default value for the vertical component is<tt> _TOP</tt> unless
 the text path is<tt> _PATH_UP,</tt> in which case<tt> _BOTTOM</tt> alignment is used.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_gettextsettings">_gettextsettings</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 100, 'WATCOM'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setpixel( 200, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextalign( _CENTER, _HALF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 200, 'Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setpixel( 200, 200 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_setta.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextcolor"> _settextcolor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _settextcolor( pixval )</tt>
<br><tt>integer*2 pixval</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextcolor</tt> routine sets the current text color to be the color indicated by the pixel value of the<b> pixval</b>
 argument.&nbsp; This is the color value used for displaying text with the <tt> _outtext</tt> and <tt> _outmem</tt> routines.
&nbsp; Use the <tt> _setcolor</tt> routine to change the color of graphics output.&nbsp; The default text color value is set
 to 7 whenever a new video mode is selected.
<br>The pixel value<b> pixval</b> is a number in the range 0-31.&nbsp; Colors in the range 0-15 are displayed normally.&nbsp;
 In text modes, blinking colors are specified by adding 16 to the normal color values.&nbsp; The following table specifies
 the default colors in color text modes.
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Pixel&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pixel
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; value</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Black&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gray</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Blue&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Blue</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Green&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Green</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cyan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Cyan</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Red&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Red</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Magenta&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Light Magenta</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Brown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Yellow</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; White&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bright White</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _settextcolor</tt> routine returns the pixel value of the previous text color.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_gettextcolor">_gettextcolor</a>, <a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_setcolor">_setcolor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_col</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_bk</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_col = _gettextcolor()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_bk = _getbkcolor()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcolor( 7 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( _BLUE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( ' WATCOM '//char(10)//</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; 'Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcolor( old_col )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setbkcolor( old_bk )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextcursor"> _settextcursor </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _settextcursor( cursor )</tt>
<br><tt>integer*2 cursor</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextcursor</tt> routine sets the attribute, or shape, of the cursor in text modes.&nbsp; The argument<b> cursor</b>
 specifies the new cursor shape.&nbsp; The cursor shape is selected by specifying the top and bottom rows in the character
 matrix.&nbsp; The high byte of<b> cursor</b> specifies the top row of the cursor; the low byte specifies the bottom row.
<br>Some typical values for<b> cursor</b> are:
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Cursor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Shape</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; '0607'x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normal underline cursor</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; '0007'x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; full block cursor</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; '0407'x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; half-height block cursor</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; '2000'x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no cursor</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _settextcursor</tt> routine returns the previous cursor shape when the shape is set successfully; otherwise, (-1)
 is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_gettextcursor">_gettextcursor</a>, <a href="#_displaycursor">_displaycursor</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 old_shape</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_shape = _gettextcursor()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcursor( '0007'x )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(10)//'Block cursor'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcursor( '0407'x )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(10)//'Half height cursor'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextcursor( '2000'x )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext(</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; char(10)//'No cursor'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextorient"> _settextorient </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _settextorient( vecx, vecy )</tt>
<br><tt>integer*2 vecx, vecy</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextorient</tt> routine sets the current text orientation to the vector specified by the arguments<tt> (vecx,vecy).</tt>
&nbsp; The text orientation specifies the direction of the base-line vector when a text string is displayed with the <tt>
 _grtext</tt> routine.&nbsp; The default text orientation, for normal left-to-right text, is the vector<tt> (1,0).</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_gettextsettings">_gettextsettings</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 100, 'WATCOM'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextorient( 1, 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 200, 'Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_setto.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextpath"> _settextpath </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _settextpath( path )</tt>
<br><tt>integer*2 path</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextpath</tt> routine sets the current text path to have the value of the<b> path</b> argument.&nbsp; The text
 path specifies the writing direction of the text displayed by the <tt> _grtext</tt> routine.&nbsp; The argument can have
 one of the following values:
<dl>
<dt>_PATH_RIGHT
<dd>subsequent characters are drawn to the right of the previous character
<dt><br>_PATH_LEFT
<dd>subsequent characters are drawn to the left of the previous character
<dt><br>_PATH_UP
<dd>subsequent characters are drawn above the previous character
<dt><br>_PATH_DOWN
<dd>subsequent characters are drawn below the previous character
</dl>
<br>The default value of the text path is<tt> _PATH_RIGHT.</tt>
</dl>
<dl>
<dt>See Also:
<dd><a href="#_grtext">_grtext</a>, <a href="#_gettextsettings">_gettextsettings</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 100, 'WATCOM'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextpath( _PATH_DOWN )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _grtext( 200, 200, 'Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br>produces the following:
<br><br><img src="eg_settx.bmp" style="vertical-align:middle">
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextposition"> _settextposition </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>record /rccoord/ function _settextposition( row, col )</tt>
<br><tt>integer*2 row, col</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextposition</tt> routine sets the current output position for text to be<tt> (row,col)</tt> where this position
 is in terms of characters, not pixels.
<br>The text position is relative to the current text window.&nbsp; It defaults to the top left corner of the screen,<tt>
 (1,1),</tt> when a new video mode is selected, or when a new text window is set.&nbsp; The position is updated as text is
 drawn with the <tt> _outtext</tt> and <tt> _outmem</tt> routines.
<br><br>Note that the output position for graphics output differs from that for text output.&nbsp; The output position for
 graphics output can be set by use of the <tt> _moveto</tt> routine.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _settextposition</tt> routine returns, as an<tt> rccoord</tt> structure, the previous output position for text.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_gettextposition">_gettextposition</a>, <a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_settextwindow">_settextwindow</a>,
 <a href="#_moveto">_moveto</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /rccoord/ old_pos</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_pos = _gettextposition()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 10, 40 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( 'WATCOM Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( old_pos.row, old_pos.col )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextrows"> _settextrows </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _settextrows( rows )</tt>
<br><tt>integer*2 rows</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextrows</tt> routine selects the number of rows of text displayed on the screen.&nbsp; The number of rows is
 specified by the argument<b> rows</b>.&nbsp; Computers equipped with EGA, MCGA and VGA adapters can support different numbers
 of text rows.&nbsp; The number of rows that can be selected depends on the current video mode and the type of monitor attached.
<br>If the argument<b> rows</b> has the value<b> _MAXTEXTROWS</b>, the maximum number of text rows will be selected for the
 current video mode and hardware configuration.&nbsp; In text modes the maximum number of rows is 43 for EGA adapters, and
 50 for MCGA and VGA adapters.&nbsp; Some graphics modes will support 43 rows for EGA adapters and 60 rows for MCGA and VGA
 adapters.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _settextrows</tt> routine returns the number of screen rows when the number of rows is set successfully; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getvideoconfig">_getvideoconfig</a>, <a href="#_setvideomode">_setvideomode</a>, <a href="#_setvideomoderows">_setvideomoderows</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer valid_rows(8)/</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14, 25, 28, 30,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 34, 43, 50, 60/</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i, j, rows</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, 7</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = valid_rows( i )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _settextrows( rows ) .eq. rows )then</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do j = 1, rows</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 write( buff, '(''Line '', i2, a1 )' )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j, char(0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 call _settextposition( j, 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 call _outtext( buff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_settextwindow"> _settextwindow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _settextwindow( row1, col1, row2, col2 )</tt>
<br><tt>integer*2 row1, col1</tt>
<br><tt>integer*2 row2, col2</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _settextwindow</tt> routine sets the text window to be the rectangle with a top left corner at<tt> (row1,col1)</tt>
 and a bottom right corner at<tt> (row2,col2).</tt>&nbsp; These coordinates are in terms of characters not pixels.
<br>The initial text output position is<tt> (1,1).</tt>&nbsp; Subsequent text positions are reported (by the <tt> _gettextposition</tt>
 routine) and set (by the <tt> _outtext</tt>, <tt> _outmem</tt> and <tt> _settextposition</tt> routines) relative to this
 rectangle.
<br><br>Text is displayed from the current output position for text proceeding along the current row and then downwards.&nbsp;
 When the window is full, the lines scroll upwards one line and then text is displayed on the last line of the window.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_gettextposition">_gettextposition</a>, <a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_settextposition">_settextposition</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer*2 r1, c1, r2, c2</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _gettextwindow( r1, c1, r2, c2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextwindow( 5, 20, 20, 40 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 20</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''Line '', i2, a1, a1 )' )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, char(10), char(0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextwindow( r1, c1, r2, c2 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setvideomode"> _setvideomode </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _setvideomode( mode )</tt>
<br><tt>integer*2 mode</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setvideomode</tt> routine sets the video mode according to the value of the<b> mode</b> argument.&nbsp; The value
 of<b> mode</b> can be one of the following:&nbsp; uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2
 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2 uindex=2
 uindex=2 uindex=2 uindex=2 
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; Mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp; Size
&nbsp;&nbsp;&nbsp; Colors&nbsp;&nbsp;&nbsp; Adapter</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _MAXRESMODE&nbsp;&nbsp; (graphics mode with highest resolution)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _MAXCOLORMODE (graphics mode with most colors)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _DEFAULTMODE&nbsp; (restores screen to original mode)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTBW40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,T&nbsp;&nbsp;&nbsp; 40 x 25&nbsp;&nbsp;&nbsp; 16
&nbsp;&nbsp; MDPA,HGC,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTC40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C,T&nbsp;&nbsp;&nbsp; 40 x 25&nbsp;&nbsp;&nbsp;
 16&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTBW80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,T&nbsp;&nbsp;&nbsp; 80 x 25&nbsp;&nbsp;&nbsp; 16
&nbsp;&nbsp; MDPA,HGC,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTC80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C,T&nbsp;&nbsp;&nbsp; 80 x 25&nbsp;&nbsp;&nbsp;
 16&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _MRES4COLOR&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _MRESNOCOLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _HRESBW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 200&nbsp;&nbsp;&nbsp;
 2&nbsp;&nbsp; CGA,EGA,MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _TEXTMONO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,T&nbsp;&nbsp;&nbsp; 80 x 25&nbsp;&nbsp;&nbsp; 16
&nbsp;&nbsp; MDPA,HGC,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _HERCMONO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; M,G&nbsp;&nbsp; 720 x 350&nbsp;&nbsp;&nbsp; 2&nbsp;
&nbsp; HGC</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _MRES16COLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp;&nbsp; 16&nbsp;&nbsp; EGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _HRES16COLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 200&nbsp;&nbsp; 16&nbsp;&nbsp; EGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _ERESNOCOLOR&nbsp;&nbsp; M,G&nbsp;&nbsp; 640 x 350&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp; EGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _ERESCOLOR&nbsp;&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 350&nbsp; 4/16&nbsp; EGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _VRES2COLOR&nbsp;&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 480&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp; MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _VRES16COLOR&nbsp;&nbsp; C,G&nbsp;&nbsp; 640 x 480&nbsp;&nbsp; 16&nbsp;&nbsp; VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _MRES256COLOR&nbsp; C,G&nbsp;&nbsp; 320 x 200&nbsp; 256&nbsp;&nbsp; MCGA,VGA,SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _URES256COLOR&nbsp; C,G&nbsp;&nbsp; 640 x 400&nbsp; 256&nbsp;&nbsp; SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _VRES256COLOR&nbsp; C,G&nbsp;&nbsp; 640 x 480&nbsp; 256&nbsp;&nbsp; SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _SVRES16COLOR&nbsp; C,G&nbsp;&nbsp; 800 x 600&nbsp;&nbsp; 16&nbsp;&nbsp; SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _SVRES256COLOR C,G&nbsp;&nbsp; 800 x 600&nbsp; 256&nbsp;&nbsp; SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _XRES16COLOR&nbsp;&nbsp; C,G&nbsp; 1024 x 768&nbsp;&nbsp; 16&nbsp;&nbsp; SVGA</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; _XRES256COLOR&nbsp; C,G&nbsp; 1024 x 768&nbsp; 256&nbsp;&nbsp; SVGA</tt>
<br><br>In the preceding table, the Type column contains the following letters:
<dl>
<dt>M
<dd>indicates monochrome; multiple colors are shades of grey
<dt><br>C
<dd>indicates color
<dt><br>G
<dd>indicates graphics mode; size is in pixels
<dt><br>T
<dd>indicates text mode; size is in columns and rows of characters
</dl>
<br>The Adapter column contains the following codes:
<dl>
<dt>MDPA
<dd>IBM Monochrome Display/Printer Adapter
<dt><br>CGA
<dd>IBM Color Graphics Adapter
<dt><br>EGA
<dd>IBM Enhanced Graphics Adapter
<dt><br>VGA
<dd>IBM Video Graphics Array
<dt><br>MCGA
<dd>IBM Multi-Color Graphics Array
<dt><br>HGC
<dd>Hercules Graphics Adapter
<dt><br>SVGA
<dd>SuperVGA adapters
</dl>
<br>The modes<tt> _MAXRESMODE</tt> and<tt> _MAXCOLORMODE</tt> will select from among the video modes supported by the current
 graphics adapter the one that has the highest resolution or the greatest number of colors.&nbsp; The video mode will be selected
 from the standard modes, not including the SuperVGA modes.
<br><br>Selecting a new video mode resets the current output positions for graphics and text to be the top left corner of
 the screen.&nbsp; The background color is reset to black and the default color value is set to be one less than the number
 of colors in the selected mode.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setvideomode</tt> routine returns the number of text rows when the new mode is successfully selected; otherwise,
 zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getvideoconfig">_getvideoconfig</a>, <a href="#_settextrows">_settextrows</a>, <a href="#_setvideomoderows">_setvideomoderows</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer mode</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record /videoconfig/ vc</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getvideoconfig( vc )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select( vc.adapter )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _VGA, _SVGA )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _VRES16COLOR</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _MCGA )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES256COLOR</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _EGA )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( vc.monitor .eq. _MONO )then</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESNOCOLOR</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _ERESCOLOR</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _CGA )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _MRES4COLOR</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case( _HERCULES )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mode = _HERCMONO</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case default</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop 'No graphics adapter'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endselect</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( _setvideomode( mode ) .ne. 0 )then</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _getvideoconfig( vc )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '( i3, '' x '',
 i3, '' x '', i3, a1 )' )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vc.numxpixels,
 vc.numypixels,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vc.numcolors, char(0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setvideomoderows"> _setvideomoderows </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _setvideomoderows( mode, rows )</tt>
<br><tt>integer*2 mode</tt>
<br><tt>integer*2 rows</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setvideomoderows</tt> routine selects a video mode and the number of rows of text displayed on the screen.&nbsp;
 The video mode is specified by the argument<b> mode</b> and is selected with the <tt> _setvideomode</tt> routine.&nbsp; The
 number of rows is specified by the argument<b> rows</b> and is selected with the <tt> _settextrows</tt> routine.
<br>Computers equipped with EGA, MCGA and VGA adapters can support different numbers of text rows.&nbsp; The number of rows
 that can be selected depends on the video mode and the type of monitor attached.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setvideomoderows</tt> routine returns the number of screen rows when the mode and number of rows are set successfully;
 otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getvideoconfig">_getvideoconfig</a>, <a href="#_setvideomode">_setvideomode</a>, <a href="#_settextrows">_settextrows</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer rows</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 buff</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows = _setvideomoderows( _TEXTC80, _MAXTEXTROWS )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( rows .ne. 0 )then</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '(''Number of rows
 is '', i2, a1 )' )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rows, char(0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; endif</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setvieworg"> _setvieworg </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>record /xycoord/ function _setvieworg( x, y )</tt>
<br><tt>integer*2 x, y</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setvieworg</tt> routine sets the origin of the view coordinate system,<tt> (0,0),</tt> to be located at the physical
 point<tt> (x,y).</tt>&nbsp; This causes subsequently drawn images to be translated by the amount<tt> (x,y).</tt>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setvieworg</tt> routine returns, as an<tt> xycoord</tt> structure, the physical coordinates of the previous origin.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getviewcoord">_getviewcoord</a>, <a href="#_getphyscoord">_getphyscoord</a>, <a href="#_setcliprgn">_setcliprgn</a>,
 <a href="#_setviewport">_setviewport</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvieworg( 320, 240 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GBORDER, -200, -150, 200, 150 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setviewport"> _setviewport </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _setviewport( x1, y1, x2, y2 )</tt>
<br><tt>integer*2 x1, y1</tt>
<br><tt>integer*2 x2, y2</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setviewport</tt> routine restricts the display of graphics output to the clipping region and then sets the origin
 of the view coordinate system to be the top left corner of the region.&nbsp; This region is a rectangle whose opposite corners
 are established by the physical points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>
<br>The<tt> _setviewport</tt> routine does not affect text output using the <tt> _outtext</tt> and <tt> _outmem</tt> routines.
&nbsp; To control the location of text output, see the <tt> _settextwindow</tt> routine.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setcliprgn">_setcliprgn</a>, <a href="#_setvieworg">_setvieworg</a>, <a href="#_settextwindow">_settextwindow</a>,
 <a href="#_setwindow">_setwindow</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer XSIZE, YSIZE</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (XSIZE=380)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parameter (YSIZE=280)</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setviewport( 130, 100,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 130 + XSIZE, 100 + YSIZE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GBORDER, 0, 0, XSIZE, YSIZE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setvisualpage"> _setvisualpage </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _setvisualpage( pagenum )</tt>
<br><tt>integer*2 pagenum</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setvisualpage</tt> routine selects the page (in memory) from which graphics output is displayed.&nbsp; The page to
 be selected is given by the<b> pagenum</b> argument.
<br>Only some combinations of video modes and hardware allow multiple pages of graphics to exist.&nbsp; When multiple pages
 are supported, the active page may differ from the visual page.&nbsp; The graphics information in the visual page determines
 what is displayed upon the screen.&nbsp; Animation may be accomplished by alternating the visual page.&nbsp; A graphics page
 can be constructed without affecting the screen by setting the active page to be different than the visual page.
<br><br>The number of available video pages can be determined by using the <tt> _getvideoconfig</tt> routine.&nbsp; The default
 video page is 0.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setvisualpage</tt> routine returns the number of the previous page when the visual page is set successfully; otherwise,
 a negative number is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_getvisualpage">_getvisualpage</a>, <a href="#_setactivepage">_setactivepage</a>, <a href="#_getactivepage">_getactivepage</a>,
 <a href="#_getvideoconfig">_getvideoconfig</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer old_apage, old_vpage</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _HRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_apage = _getactivepage()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; old_vpage = _getvisualpage()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw an ellipse on page 0</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _ellipse( _GFILLINTERIOR, 100, 50,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! draw a rectangle on page 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle( _GFILLINTERIOR, 100, 50,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 540, 150
 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ! display page 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setactivepage( old_apage )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvisualpage( old_vpage )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_setwindow"> _setwindow </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _setwindow( invert, x1, y1, x2, y2 )</tt>
<br><tt>logical invert</tt>
<br><tt>double precision x1, y1</tt>
<br><tt>double precision x2, y2</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _setwindow</tt> routine defines a window for the window coordinate system.&nbsp; Window coordinates are specified
 as a user-defined range of values.&nbsp; This allows for consistent pictures regardless of the video mode.
<br>The window is defined as the region with opposite corners established by the points<tt> (x1,y1)</tt> and<tt> (x2,y2).</tt>
&nbsp; The argument<b> invert</b> specifies the direction of the y-axis.&nbsp; If the value is<tt> .TRUE.,</tt> the y values
 increase from the bottom of the screen to the top, otherwise, the y values increase as you move down the screen.
<br><br>The window defined by the<tt> _setwindow</tt> routine is displayed in the current viewport.&nbsp; A viewport is defined
 by the <tt> _setviewport</tt> routine.
<br><br>By default, the window coordinate system is defined with the point<tt> (0.0,0.0)</tt> located at the lower left corner
 of the screen, and the point<tt> (1.0,1.0)</tt> at the upper right corner.
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _setwindow</tt> routine returns a non-zero value when the window is set successfully; otherwise, zero is returned.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_setviewport">_setviewport</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _MAXRESMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call draw_house( 'Default window'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setwindow( .TRUE., -0.5, -0.5, 1.5, 1.5 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call draw_house( 'Larger window'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setwindow( .TRUE., 0.0, 0.0, 0.5, 1.0 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call draw_house( 'Left side'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subroutine draw_house( msg )</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*80 msg</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GCLEARSCREEN )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( msg )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle_w( _GBORDER, 0.2, 0.1, 0.8, 0.6 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto_w( 0.1, 0.5 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto_w( 0.5, 0.9 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _lineto_w( 0.9, 0.5 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _arc_w( 0.4, 0.5, 0.6, 0.3,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.6,
 0.4, 0.4, 0.4 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _rectangle_w( _GBORDER, 0.4, 0.1, 0.6, 0.4 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_unregisterfonts"> _unregisterfonts </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>subroutine _unregisterfonts()</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _unregisterfonts</tt> routine frees the memory previously allocated by the <tt> _registerfonts</tt> routine.&nbsp;
 The currently selected font is also unloaded.
<br>Attempting to use the <tt> _setfont</tt> routine after calling<tt> _unregisterfonts</tt> will result in an error.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_registerfonts">_registerfonts</a>, <a href="#_setfont">_setfont</a>, <a href="#_getfontinfo">_getfontinfo</a>,
 <a href="#_outgtext">_outgtext</a>, <a href="#_getgtextextent">_getgtextextent</a>, <a href="#_setgtextvector">_setgtextvector</a>,
 <a href="#_getgtextvector">_getgtextvector</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i, n</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character*10 buff</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _VRES16COLOR )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = _registerfonts( '*.fon'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 0, n - 1</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff, '(''n'', i2.2, a1 )' ) i, char(0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setfont( buff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _moveto( 100, 100 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outgtext( 'WATCOM Graphics'c )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _clearscreen( _GCLEARSCREEN )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _unregisterfonts()</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
<h2 id="_wrapon"> _wrapon </h2>
<dl>
<dt>Synopsis:
<dd>
<br><tt>integer*2 function _wrapon( wrap )</tt>
<br><tt>integer*2 wrap</tt>
</dl>
<dl>
<dt>Description:
<dd>The<tt> _wrapon</tt> routine is used to control the display of text when the text output reaches the right side of the text
 window.&nbsp; This is text displayed with the <tt> _outtext</tt> and <tt> _outmem</tt> routines.&nbsp; The<b> wrap</b> argument
 can take one of the following values:
<dl>
<dt>_GWRAPON
<dd>causes lines to wrap at the window border
<dt><br>_GWRAPOFF
<dd>causes lines to be truncated at the window border
</dl>
</dl>
<dl>
<dt>Returns:
<dd>The<tt> _wrapon</tt> routine returns the previous setting for wrapping.
</dl>
<dl>
<dt>See Also:
<dd><a href="#_outtext">_outtext</a>, <a href="#_outmem">_outmem</a>, <a href="#_settextwindow">_settextwindow</a>
</dl>
<dl>
<dt>Example:
<dd>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graphapi.fi'</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; include 'graph.fi'</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer i</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; character buff*80</tt>
<br><br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _TEXTC80 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextwindow( 5, 20, 20, 30 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _wrapon( _GWRAPOFF )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 1, 3</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 2 * i, 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '(''Very very long
 line '', i2, a1)' )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, char(0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _wrapon( _GWRAPON )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do i = 4, 6</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _settextposition( 2 * i, 1 )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write( buff,</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '(''Very very long
 line '', i2, a1)' )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, char(0)</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _outtext( buff )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enddo</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pause</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call _setvideomode( _DEFAULTMODE )</tt>
<br><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end</tt>
</dl>
<dl>
<dt>Classification:
<dd>PC Graphics
</dl>
<dl>
<dt>Systems:
<dd>DOS, QNX
</dl>
</body>
